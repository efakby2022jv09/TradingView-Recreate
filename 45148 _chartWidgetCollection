"use strict";
(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
	[45148, 91859], {
		203308: (e, t, i) => {
			i.d(t, {
				default: () => s
			});
			var r = i(128177),
				n = i(383527);
			const s = function(e) {
				return "number" == typeof e || (0, n.default)(e) && "[object Number]" == (0, r.default)(e)
			}
		},
		210542: (e, t, i) => {
			i.r(t), i.d(t, {
				lineToolEntityInfo: () => a,
				studyEntityInfo: () => o,
				seriesEntityInfo: () => l,
				entityForDataSource: () => c
			});
			var r = i(140662),
				n = i(741511),
				s = i(540968);

			function a(e) {
				return {
					id: e.id(),
					name: (t = e.toolname, Object.keys(n.supportedLineTools).find((e => n.supportedLineTools[e].name === t)) || null)
				};
				var t
			}

			function o(e) {
				return {
					id: e.id(),
					name: e.metaInfo().description
				}
			}

			function l(e) {
				return {
					id: e.id(),
					name: "Main Series"
				}
			}

			function c(e, t) {
				return t === e.mainSeries() ? l(e.mainSeries()) : (0, r.isStudy)(t) ? o(t) : (0, s.isLineTool)(t) ? a(t) : null
			}
		},
		178323: (e, t, i) => {
			i.r(t), i.d(t, {
				isLineToolRiskReward: () => o,
				LineDataSourceApi: () => c
			});
			var r = i(588537),
				n = i(270617);
			const s = new Map([
				["LineToolRiskRewardLong", 2],
				["LineToolRiskRewardShort", 2],
				["LineToolBezierQuadro", 3],
				["LineToolBezierCubic", 4]
			]);

			function a(e) {
				const t = s.get(e.toolname);
				if (void 0 !== t) return t;
				const i = e.pointsCount();
				return -1 === i ? e.points().length : i
			}

			function o(e) {
				return "LineToolRiskRewardLong" === e || "LineToolRiskRewardShort" === e
			}
			const l = ["alwaysShowStats", "entryPrice", "inputs.first bar time", "inputs.last bar time", "interval", "linesWidths", "points", "snapTo45Degrees", "stopPrice", "symbol", "symbolStateVersion", "currencyId", "unitId", "targetPrice", "zOrderVersion"];
			class c {
				constructor(e, t, i) {
					this._source = e, this._undoModel = t, this._model = t.model(), this._pointsConverter = i
				}
				isSelectionEnabled() {
					return this._source.isSelectionEnabled()
				}
				setSelectionEnabled(e) {
					this._source.setSelectionEnabled(e)
				}
				isSavingEnabled() {
					return this._source.isSavedInChart()
				}
				setSavingEnabled(e) {
					this._source.setSavingInChartEnabled(e)
				}
				isShowInObjectsTreeEnabled() {
					return this._source.showInObjectTree()
				}
				setShowInObjectsTreeEnabled(e) {
					this._source.setShowInObjectsTreeEnabled(e)
				}
				isUserEditEnabled() {
					return this._source.userEditEnabled()
				}
				setUserEditEnabled(e) {
					this._source.setUserEditEnabled(e)
				}
				bringToFront() {
					this._model.bringToFront([this._source])
				}
				sendToBack() {
					this._model.sendToBack([this._source])
				}
				getProperties() {
					return this._source.properties().state(l, !0)
				}
				setProperties(e) {
					this._setProps(this._source.properties(), e, "")
				}
				getPoints() {
					let e = this._source.points();
					const t = a(this._source);
					return e.length > t && ((0, r.assert)(o(this._source.toolname)), e = e.slice(0, t)), this._pointsConverter.dataSourcePointsToPriced(e)
				}
				setPoints(e) {
					if (this._source.isFixed()) return;
					const t = a(this._source);
					if (t !== e.length) throw new Error(`Wrong points count. Required: ${t}, provided: ${e.length}`);
					const i = this._pointsConverter.apiPointsToDataSource(e);
					this._model.startChangingLinetool(this._source), this._model.changeLinePoints(this._source, i), this._model.endChangingLinetool(!0), this._source.createServerPoints()
				}
				ownerSourceId() {
					return (0, r.ensureNotNull)(this._source.ownerSource()).id()
				}
				changePoint(e, t) {
					if (this._source.isFixed()) return;
					const i = this._pointsConverter.apiPointsToDataSource([e])[0];
					this._model.startChangingLinetool(this._source, {
						...i
					}, t), this._model.changeLinePoint({
						...i
					}), this._model.endChangingLinetool(!1), this._source.createServerPoints()
				}
				isHidden() {
					return this._source.isSourceHidden()
				}
				getRawPoints() {
					return this._source.points()
				}
				setRawPoint(e, t) {
					this._model.startChangingLinetool(this._source, {
						...t
					}, e), this._model.changeLinePoint({
						...t
					}), this._model.endChangingLinetool(!1)
				}
				move(e, t) {
					this._model.startMovingSources([this._source], {
						logical: e
					}, null, new Map), this._model.moveSources({
						logical: t
					}, new Map), this._model.endMovingSources(!1)
				}
				dataAndViewsReady() {
					return this._source.dataAndViewsReady()
				}
				zorder() {
					return this._source.zorder()
				}
				symbol() {
					return this._source.properties().symbol.value()
				}
				currency() {
					return this._source.properties().currencyId.value()
				}
				unit() {
					return this._source.properties().unitId.value()
				}
				share(e) {
					this._undoModel.shareLineTools([this._source], e)
				}
				sharingMode() {
					return this._source.sharingMode().value()
				}
				_setProps(e, t, i) {
					for (const r in t) {
						if (!t.hasOwnProperty(r)) continue;
						const s = 0 === i.length ? r : `${i}.${r}`;
						if (e.hasOwnProperty(r)) {
							const i = t[r];
							(0, n.isHashObject)(i) ? this._setProps(e[r], i, s): e[r].setValue(i)
						} else console.warn(`Unknown property "${s}"`)
					}
				}
			}
		},
		210493: (e, t, i) => {
			i.d(t, {
				PaneApi: () => u
			});
			var r = i(588537),
				n = i(228039),
				s = i(210542),
				a = i(270617),
				o = i(575932),
				l = i(277036),
				c = i(72833);
			const h = new l.TranslatedString("change pane height", (0, o.t)("change pane height"));
			class d extends c.UndoCommand {
				constructor(e, t, i) {
					super(h), this._model = e, this._paneIndex = t, this._paneHeight = i, this._prevStretchFactors = this._model.panes().map((e => e.stretchFactor()))
				}
				redo() {
					this._model.changePanesHeight(this._paneIndex, this._paneHeight)
				}
				undo() {
					const e = this._model.panes();
					for (let t = 0; t < e.length; ++t) e[t].setStretchFactor((0, r.ensureDefined)(this._prevStretchFactors[t]));
					this._model.fullUpdate()
				}
			}
			class u {
				constructor(e, t) {
					this._priceScales = new WeakMap, this._pane = e, this._chartWidget = t
				}
				hasMainSeries() {
					return this._pane.containsMainSeries()
				}
				getLeftPriceScales() {
					return this._pane.leftPriceScales().map(this._getPriceScaleApi, this)
				}
				getRightPriceScales() {
					return this._pane.rightPriceScales().map(this._getPriceScaleApi, this)
				}
				getMainSourcePriceScale() {
					const e = this._pane.mainDataSource();
					if (null === e) return null;
					const t = e.priceScale();
					return null === t || this._pane.isOverlay(e) ? null : this._getPriceScaleApi(t)
				}
				setMaximized(e) {
					if (this._pane.maximized().value() !== e)
						for (const e of this._chartWidget.paneWidgets())
							if (e.state() === this._pane) {
								this._chartWidget.toggleMaximizePane(e);
								break
							}
				}
				legendLoaded() {
					const e = this._chartWidget.paneByState(this._pane);
					return Boolean(e && e.statusWidget())
				}
				getAllEntities() {
					const e = this._pane.model();
					return this._pane.sourcesByGroup().allIncludingHidden().map((t => (0, s.entityForDataSource)(e, t))).filter(a.notNull).filter((e => null !== e.name))
				}
				getHeight() {
					return this._pane.height()
				}
				setHeight(e) {
					const t = this._chartWidget.model().model(),
						i = t.panes();
					(0, r.assert)(i.length > 1, "Unable to change pane's height if there is only one pane");
					const n = i.indexOf(this._pane);
					(0, r.assert)(-1 !== n, "Invalid pane index");
					const s = new d(t, n, e);
					this._chartWidget.model().undoHistory().pushUndoCommand(s)
				}
				moveTo(e) {
					const t = this.paneIndex();
					t !== e && ((0, r.assert)(e >= 0 && e < this._chartWidget.paneWidgets().length, "Invalid pane index"), this._chartWidget.model().movePane(t, e))
				}
				paneIndex() {
					return this._chartWidget.model().model().panes().indexOf(this._pane)
				}
				_getPriceScaleApi(e) {
					let t = this._priceScales.get(e);
					return void 0 === t && (t = new n.PriceScaleApi(this._chartWidget.model(), e), this._priceScales.set(e, t)), t
				}
			}
		},
		228039: (e, t, i) => {
			i.d(t, {
				PriceScaleApi: () => r
			});
			class r {
				constructor(e, t) {
					this._chartUndoModel = e, this._chartModel = e.model(), this._priceScale = t
				}
				getMode() {
					const e = this._priceScale.properties().childs();
					return e.percentage.value() ? 2 : e.indexedTo100.value() ? 3 : e.log.value() ? 1 : 0
				}
				setMode(e) {
					this._priceScale.setMode({
						percentage: 2 === e,
						log: 1 === e,
						indexedTo100: 3 === e
					})
				}
				isInverted() {
					return this._priceScale.isInverted()
				}
				setInverted(e) {
					this._priceScale.properties().childs().isInverted.setValue(e)
				}
				getVisiblePriceRange() {
					return this._priceScale.priceRangeInPrice()
				}
				setVisiblePriceRange(e) {
					this._priceScale.setPriceRangeInPrice(e), this._chartModel.lightUpdate()
				}
				hasMainSeries() {
					return this._priceScale.hasMainSeries()
				}
				getStudies() {
					return this._priceScale.getStudies().map((e => e.id()))
				}
				currency() {
					const e = this._priceScale.currency(this._chartModel.availableCurrencies());
					return null === e ? null : {
						selectedCurrency: e.selectedCurrency,
						readOnly: e.readOnly
					}
				}
				setCurrency(e) {
					this._chartUndoModel.setPriceScaleCurrency(this._priceScale, e)
				}
				unit() {
					const e = this._priceScale.unit(this._chartModel.availableUnits());
					return null === e ? null : {
						selectedUnit: e.selectedUnit,
						readOnly: 0 === e.availableGroups.size,
						availableGroups: Array.from(e.availableGroups)
					}
				}
				setUnit(e) {
					this._chartUndoModel.setPriceScaleUnit(this._priceScale, e)
				}
				measureUnitId() {
					const e = this._priceScale.measureUnitId(this._chartModel.availableUnits());
					return null === e ? null : {
						selectedMeasureUnitId: e.selectedMeasureUnitId
					}
				}
			}
		},
		66066: (e, t, i) => {
			i.d(t, {
				ReplayApi: () => r
			});
			class r {
				constructor(e) {
					this._replayUIController = e
				}
				isReplayToolbarVisible() {
					return this._replayUIController.isReplayModeEnabled()
				}
				showReplayToolbar() {
					return this._replayUIController.enableReplayMode()
				}
				hideReplayToolbar() {
					return this._replayUIController.requestCloseReplay()
				}
			}
		},
		100148: (e, t, i) => {
			function r(e, t) {
				const i = e.dataSourceForId(t);
				if (null === i) throw new Error(`Chart has no study or shape with id "${t}"`);
				return i
			}
			i.d(t, {
				SelectionApi: () => n
			});
			class n {
				constructor(e) {
					this._model = e
				}
				add(e) {
					Array.isArray(e) ? this._model.selectionMacro((t => {
						e.map(r.bind(null, this._model)).forEach((e => t.addSourceToSelection(e)))
					})) : this.add([e])
				}
				canBeAddedToSelection(e) {
					const t = r(this._model, e);
					return this._model.selection().canBeAddedToSelection(t)
				}
				set(e) {
					Array.isArray(e) ? this._model.selectionMacro((t => {
						t.clearSelection(), e.map(r.bind(null, this._model)).forEach((e => t.addSourceToSelection(e)))
					})) : this.set([e])
				}
				remove(e) {
					Array.isArray(e) ? this._model.selectionMacro((t => {
						e.map(r.bind(null, this._model)).forEach((e => t.removeSourceFromSelection(e)))
					})) : this.remove([e])
				}
				contains(e) {
					const t = r(this._model, e);
					return this._model.selection().isSelected(t)
				}
				allSources() {
					return this._model.selection().dataSources().map((e => e.id()))
				}
				isEmpty() {
					return this._model.selection().isEmpty()
				}
				clear() {
					this._model.selectionMacro((e => {
						e.clearSelection()
					}))
				}
				onChanged() {
					return this._model.onSelectedSourceChanged()
				}
			}
		},
		125853: (e, t, i) => {
			i.d(t, {
				SeriesApi: () => l
			});
			var r = i(588537),
				n = i(284330),
				s = i(167977),
				a = i(38300),
				o = i(228039);
			class l {
				constructor(e, t) {
					this._series = e, this._undoModel = t, this._model = t.model()
				}
				isUserEditEnabled() {
					return this._series.userEditEnabled()
				}
				setUserEditEnabled(e) {
					this._series.setUserEditEnabled(e)
				}
				mergeUp() {
					this._model.isMergeUpAvailableForSource(this._series) && new n.MergeUpUndoCommand(this._model, this._series, null).redo()
				}
				mergeDown() {
					this._model.isMergeDownAvailableForSource(this._series) && new n.MergeDownUndoCommand(this._model, this._series, null).redo()
				}
				unmergeUp() {
					this._model.isUnmergeAvailableForSource(this._series) && new s.UnmergeUpUndoCommand(this._model, this._series, null).redo()
				}
				unmergeDown() {
					this._model.isUnmergeAvailableForSource(this._series) && new s.UnmergeDownUndoCommand(this._model, this._series, null).redo()
				}
				detachToRight() {
					new a.MoveToNewPriceScaleUndoCommand(this._model, this._series, this._pane(), "right", null).redo()
				}
				detachToLeft() {
					new a.MoveToNewPriceScaleUndoCommand(this._model, this._series, this._pane(), "left", null).redo()
				}
				detachNoScale() {
					new a.MoveToNewPriceScaleUndoCommand(this._model, this._series, this._pane(), "overlay", null).redo()
				}
				changePriceScale(e) {
					const t = (0, r.ensureNotNull)(this._model.paneForSource(this._series));
					switch (e) {
						case "new-left":
							new a.MoveToNewPriceScaleUndoCommand(this._model, this._series, t, "left", null).redo();
							break;
						case "new-right":
							new a.MoveToNewPriceScaleUndoCommand(this._model, this._series, t, "right", null).redo();
							break;
						case "no-scale":
							(0, r.assert)(t.actionNoScaleIsEnabled(this._series), "Unable to leave a pane without any non-overlay price scale"), new a.MoveToNewPriceScaleUndoCommand(this._model, this._series, t, "overlay", null).redo();
							break;
						default:
							const i = this._model.dataSourceForId(e);
							if (null === i) throw new Error(`There is no study with entityId='${e}'`);
							const n = this._model.paneForSource(i) === t;
							(0, r.assert)(n, "Study should be on the main pane");
							const s = (0, r.ensureNotNull)(i.priceScale());
							new a.MoveToExistingPriceScaleUndoCommand(this._model, this._series, t, s, null).redo()
					}
				}
				isVisible() {
					return this._series.properties().childs().visible.value()
				}
				setVisible(e) {
					this._series.properties().childs().visible.setValue(e)
				}
				bringToFront() {
					this._model.bringToFront([this._series])
				}
				sendToBack() {
					this._model.sendToBack([this._series])
				}
				entityId() {
					return this._series.id()
				}
				chartStyleProperties(e) {
					return this._series.properties().childs()[c(e)].state(["inputs", "inputsInfo"])
				}
				setChartStyleProperties(e, t) {
					this._series.properties().childs()[c(e)].mergeAndFire(t)
				}
				barsCount() {
					return this._series.bars().size()
				}
				symbolSource() {
					return {
						symbol: this._series.symbol(),
						currencyId: this._series.currency(),
						unitId: this._series.unit()
					}
				}
				isLoading() {
					return this._series.isLoading()
				}
				data() {
					return this._series.data()
				}
				priceScale() {
					return new o.PriceScaleApi(this._undoModel, this._series.priceScale())
				}
				_pane() {
					return (0, r.ensureNotNull)(this._model.paneForSource(this._series))
				}
			}

			function c(e) {
				switch (e) {
					case 0:
						return "barStyle";
					case 1:
						return "candleStyle";
					case 2:
						return "lineStyle";
					case 3:
						return "areaStyle";
					case 4:
						return "renkoStyle";
					case 5:
						return "kagiStyle";
					case 6:
						return "pnfStyle";
					case 7:
						return "pbStyle";
					case 8:
						return "haStyle";
					case 9:
						return "hollowCandleStyle";
					case 10:
						return "baselineStyle";
					case 11:
						return "rangeStyle";
					case 12:
						return "hiloStyle";
					case 13:
						return "columnStyle";
					default:
						(0, r.ensureNever)(e)
				}
				throw new Error(`unsupported chart style: ${e}`)
			}
		},
		830384: (e, t, i) => {
			i.d(t, {
				StudyApi: () => y
			});
			var r = i(588537),
				n = i(97639),
				s = i.n(n),
				a = i(270617),
				o = i(594930),
				l = i(999998),
				c = i(795896),
				h = i(167977),
				d = i(284330),
				u = i(38300),
				g = i(500099),
				m = i(705318),
				_ = i(160377),
				p = i(228039),
				S = i(906096),
				v = i(591316),
				b = i(443403);
			class y {
				constructor(e, t) {
					this._onStudyCompleted = new(s()), this._onStudyError = new(s()), this._study = e, this._chartWidget = t, this._undoModel = this._chartWidget.model(), this._model = this._undoModel.model(), this._study.onAboutToBeDestroyed().subscribe(this, (() => {
						this._study.onStatusChanged().unsubscribeAll(this), this._study.onAboutToBeDestroyed().unsubscribeAll(this)
					})), this._study.onStatusChanged().subscribe(this, (e => {
						switch (e.type) {
							case S.StudyStatusType.Completed:
								this._onStudyCompleted.fire();
								break;
							case S.StudyStatusType.Error:
								this._onStudyError.fire()
						}
					}))
				}
				isUserEditEnabled() {
					return this._study.userEditEnabled()
				}
				setUserEditEnabled(e) {
					this._study.setUserEditEnabled(e)
				}
				getInputsInfo() {
					return (0, v.getStudyInputsInfo)(this._study.metaInfo())
				}
				getInputValues() {
					const e = this._study.inputs({
						symbolsForChartApi: !1,
						asObject: !0
					});
					return Object.keys(e).map((t => {
						const i = e[t];
						return {
							id: t,
							value: (0, a.isObject)(i) ? i.v : i
						}
					}))
				}
				getStyleInfo() {
					return (0, b.getStudyStylesInfo)(this._study.metaInfo())
				}
				getStyleValues() {
					const {
						plots: e,
						styles: t,
						bands: i,
						filledAreas: r,
						palettes: n,
						graphics: s,
						ohlcPlots: a,
						filledAreasStyle: o
					} = this._study.properties().state();
					return {
						plots: e,
						styles: t,
						bands: i,
						filledAreas: r,
						palettes: n,
						graphics: s,
						ohlcPlots: a,
						filledAreasStyle: o
					}
				}
				setInputValues(e) {
					const t = this.getInputValues();
					for (const i of e) {
						void 0 !== t.find((e => e.id === i.id)) ? this._study.properties().childs().inputs.childs()[i.id].setValue(i.value) : console.warn(`There is no such input: "${i.id}"`)
					}
				}
				mergeUp() {
					this._model.isMergeUpAvailableForSource(this._study) && new d.MergeUpUndoCommand(this._model, this._study, null).redo()
				}
				mergeDown() {
					this._model.isMergeDownAvailableForSource(this._study) && new d.MergeDownUndoCommand(this._model, this._study, null).redo()
				}
				unmergeUp() {
					this._model.isUnmergeAvailableForSource(this._study) && new h.UnmergeUpUndoCommand(this._model, this._study, null).redo()
				}
				unmergeDown() {
					this._model.isUnmergeAvailableForSource(this._study) && new h.UnmergeDownUndoCommand(this._model, this._study, null).redo()
				}
				onDataLoaded() {
					return this._onStudyCompleted
				}
				onStudyError() {
					return this._onStudyError
				}
				mergeUpWithUndo() {
					this._model.isMergeUpAvailableForSource(this._study) && this._undoModel.mergeSourceUp(this._study)
				}
				mergeDownWithUndo() {
					this._model.isMergeDownAvailableForSource(this._study) && this._undoModel.mergeSourceDown(this._study)
				}
				unmergeUpWithUndo() {
					this._model.isUnmergeAvailableForSource(this._study) && this._undoModel.unmergeSourceUp(this._study)
				}
				unmergeDownWithUndo() {
					this._model.isUnmergeAvailableForSource(this._study) && this._undoModel.unmergeSourceDown(this._study)
				}
				priceScale() {
					return new p.PriceScaleApi(this._undoModel, (0, r.ensureNotNull)(this._study.priceScale()))
				}
				symbolSource() {
					const e = (0, r.ensureNotNull)(this._study.symbolSource());
					return {
						symbol: e.symbol(),
						currencyId: e.currency(),
						unitId: e.unit()
					}
				}
				currency() {
					return this._study.currency()
				}
				changePriceScale(e) {
					const t = (0, r.ensureNotNull)(this._model.paneForSource(this._model.mainSeries())),
						i = (0, r.ensureNotNull)(this._model.paneForSource(this._study));
					switch (e) {
						case "no-scale":
							(0, r.assert)(i.actionNoScaleIsEnabled(this._study), "Unable to leave a pane without any non-overlay price scale"), new u.MoveToNewPriceScaleUndoCommand(this._model, this._study, i, "overlay", null).redo();
							break;
						case "as-series":
							(0, r.assert)(i === t, "Study should be on the main pane"), new u.MoveToExistingPriceScaleUndoCommand(this._model, this._study, i, this._model.mainSeries().priceScale(), null).redo();
							break;
						case "new-left":
							new u.MoveToNewPriceScaleUndoCommand(this._model, this._study, i, "left", null).redo();
							break;
						case "new-right":
							new u.MoveToNewPriceScaleUndoCommand(this._model, this._study, i, "right", null).redo();
							break;
						default:
							const n = this._model.dataSourceForId(e);
							if (null === n) throw new Error(`There is no study with entityId='${e}'`);
							const s = i === this._model.paneForSource(n);
							(0, r.assert)(s, "Both studies should be on the same pane");
							const a = (0, r.ensureNotNull)(n.priceScale()),
								o = (0, c.sourceNewCurrencyOnPinningToPriceScale)(this._study, a, this._model),
								h = (0, m.sourceNewUnitOnPinningToPriceScale)(this._study, a, this._model);
							new u.MoveToExistingPriceScaleUndoCommand(this._model, this._study, i, a, null).redo(), null !== o && new l.SetPriceScaleCurrencyUndoCommand(a, o, this._undoModel.chartWidget(), null).redo(), null !== h && new _.SetPriceScaleUnitUndoCommand(a, h, this._undoModel.chartWidget(), null).redo()
					}
				}
				isVisible() {
					return this._study.properties().childs().visible.value()
				}
				setVisible(e) {
					this._study.properties().childs().visible.setValue(e)
				}
				bringToFront() {
					this._model.bringToFront([this._study])
				}
				sendToBack() {
					this._model.sendToBack([this._study])
				}
				applyOverrides(e) {
					(0, o.applyOverridesToStudy)(this._study, e)
				}
				dataLength() {
					return this._study.status().type !== S.StudyStatusType.Completed ? 0 : this._study.metaInfo().plots.length > 0 ? this._study.data().size() : this._model.mainSeries().bars().size()
				}
				isLoading() {
					return this._study.isLoading()
				}
				properties() {
					return this._study.properties()
				}
				async applyToEntireLayout() {
					const e = new g.ActionsProvider(this._chartWidget),
						t = (await e.contextMenuActionsForSources([this._study])).find((e => "applyStudyToEntireLayout" === e.id));
					t && t.execute()
				}
			}
		},
		591316: (e, t, i) => {
			i.d(t, {
				getStudyInputsInfo: () => n
			});
			var r = i(575932);

			function n(e) {
				return void 0 === e.inputs ? [] : e.inputs.map((e => ({
					...e,
					id: e.id,
					localizedName: void 0 !== e.name ? (0, r.t)(e.name, {
						context: "input"
					}) : ""
				})))
			}
		},
		443403: (e, t, i) => {
			i.d(t, {
				getStudyStylesInfo: () => s
			});
			var r, n = i(822914);

			function s(e) {
				const t = {};
				if (e.defaults) {
					const i = (0, n.default)(e.defaults);
					t.defaults = i
				}
				return void 0 !== e.plots && (t.plots = (0, n.default)(e.plots)), void 0 !== e.styles && (t.styles = (0, n.default)(e.styles)), void 0 !== e.bands && (t.bands = (0, n.default)(e.bands)), void 0 !== e.filledAreas && (t.filledAreas = (0, n.default)(e.filledAreas)), void 0 !== e.palettes && (t.palettes = (0, n.default)(e.palettes)), t
			}! function(e) {
				e.LeftToRight = "left_to_right", e.RightToLeft = "right_to_left"
			}(r || (r = {}))
		},
		147731: (e, t, i) => {
			i.d(t, {
				backend: () => k
			});
			var r = {};
			i.r(r), i.d(r, {
				getCharts: () => g,
				getChartsCount: () => m,
				getDrawingTemplates: () => D,
				getStandardStudyTemplateContentById: () => I,
				getStudyTemplateContent: () => C,
				getStudyTemplateContentById: () => T,
				getStudyTemplatesList: () => b,
				invalidateStudyTemplatesList: () => y,
				loadChart: () => _,
				loadDrawingTemplate: () => E,
				removeChart: () => S,
				removeDrawingTemplate: () => M,
				removeStudyTemplate: () => w,
				removeStudyTemplateById: () => A,
				renameStudyTemplate: () => W,
				replaceStudyTemplate: () => P,
				saveChart: () => p,
				saveDrawingTemplate: () => L,
				saveStudyTemplate: () => f
			});
			i(823127);
			var n = i(656130),
				s = i(87772);
			const a = (0, i(911905).getLogger)("Lib.AsyncGzip"),
				o = [];
			var l = i(86674);

			function c(e) {
				if (e.ok) return e.json();
				throw new Error("not ok")
			}

			function h(e) {
				if (e.ok) return e.json();
				throw new Error("not ok")
			}
			var d = i(314802),
				u = i(823127);

			function g(e) {
				return new Promise(((t, i) => {
					u.getJSON("/my-charts/", {
						limit: e
					}, t).fail(i)
				}))
			}

			function m(e, t) {
				u.getJSON("/api/v1/charts/count/", void 0, e).fail(t)
			}

			function _(e) {
				const t = (0, n.generateChartUrl)({
						chartId: e.url
					}),
					i = document.createElement("a");
				i.href = t, !(0, d.isOnMobileAppPage)("new") && /^\/chart(\/|$)/.test(location.pathname) && (i.target = "_blank", i.rel = "noopener"), i.click()
			}

			function p(e, t, r, n, l) {
				return function(e) {
					let t;
					const r = new Promise(((r, n) => {
						let a = setTimeout(n, 5e3, new Error("Loading timed out"));
						t = o.pop() || new s.Worker(new URL(i.p + i.u(31482), i.b), {
							name: "Async gzip worker"
						}), t.onerror = n, t.onmessageerror = n, t.onmessage = e => {
							clearTimeout(a), "done" === e.data.type ? r(e.data.payload) : a = setTimeout(n, 3e4, new Error("Processing timed out"))
						}, t.postMessage({
							type: "do",
							payload: e
						})
					}));
					return r.then((() => {
						o.length < 1 ? (delete t.onerror, delete t.onmessage, delete t.onmessageerror, o.push(t)) : t.terminate()
					}), (e => {
						a.logError(`Worker request failed: ${e.message}`), t.terminate()
					})), r
				}(n.content).catch((() => null)).then((e => {
					const t = new FormData;
					for (const i in n) "content" === i && e ? t.append(i, new Blob([e], {
						type: "application/gzip"
					}), "blob.gz") : t.append(i, String(n[i]));
					return fetch("/savechart/", {
						method: "POST",
						credentials: "same-origin",
						body: t
					})
				})).then((e => {
					if (!e.ok) throw e;
					return e.text()
				}))
			}

			function S(e) {
				return new Promise(((t, i) => {
					u.post("/deletechart/", {
						uid: [e]
					}, (e => {
						e.error ? i(e.error) : t()
					}))
				}))
			}
			let v = null;

			function b() {
				return null === v && (v = (0, l.fetch)("/api/v1/study-templates", {
					credentials: "same-origin"
				}).then(c).then((e => {
					const t = new Set((e.standard || []).map((e => e.name))),
						i = (e.custom || []).map((e => ({
							...e,
							is_default: !1
						})));
					for (const e of i) t.delete(e.name);
					const r = (e.standard || []).filter((e => t.has(e.name))).map((e => ({
						...e,
						is_default: !0
					})));
					return [...i, ...r]
				}))), v
			}

			function y() {
				v = null
			}

			function f(e) {
				return t = {
					name: e.name,
					content: e.content,
					meta_info: e.meta_info || {
						indicators: []
					}
				}, (0, l.fetch)("/api/v1/study-templates", {
					credentials: "same-origin",
					method: "POST",
					headers: {
						"Content-Type": "application/json"
					},
					body: JSON.stringify(t)
				}).then((e => {
					if (e.ok) return e.json().then((e => ({
						result: e
					})));
					switch (e.status) {
						case 403:
							return e.json().then((e => ({
								error: e.code
							})));
						case 422:
							return e.json().then((e => ({
								error: e.code,
								id: e.id
							})));
						default:
							throw new Error("not ok")
					}
				}));
				var t
			}
			async function C(e) {
				throw new Error("Not implemented")
			}
			async function w(e) {
				throw new Error("Not implemented")
			}

			function T(e, t) {
				(function(e) {
					return (0, l.fetch)(`/api/v1/study-templates/${e}`, {
						credentials: "same-origin"
					}).then(c)
				})(e).then(t)
			}

			function I(e, t) {
				(function(e) {
					return (0, l.fetch)(`/api/v1/study-templates/standard/${e}`, {
						credentials: "same-origin"
					}).then(c)
				})(e).then(t)
			}

			function A(e, t) {
				(function(e) {
					return (0, l.fetch)(`/api/v1/study-templates/${e}`, {
						credentials: "same-origin",
						method: "DELETE"
					}).then((e => {
						if (!e.ok) throw new Error("not ok")
					}))
				})(e).then(t)
			}

			function W(e, t, i) {
				(function(e, t) {
					return (0, l.fetch)(`/api/v1/study-templates/${e}/rename/`, {
						credentials: "same-origin",
						method: "POST",
						headers: {
							"Content-Type": "application/json"
						},
						body: JSON.stringify(t)
					}).then(c)
				})(e, {
					name: t
				}).then(i)
			}

			function P(e, t, i) {
				(function(e, t) {
					return (0, l.fetch)(`/api/v1/study-templates/${e}`, {
						credentials: "same-origin",
						method: "PUT",
						headers: {
							"Content-Type": "application/json"
						},
						body: JSON.stringify(t)
					}).then(c)
				})(e, {
					name: t.name,
					content: t.content,
					meta_info: t.meta_info || {
						indicators: []
					}
				}).then(i)
			}

			function D(e) {
				return function(e) {
					return (0, l.fetch)(`/drawing-templates/${e}/`, {
						credentials: "same-origin"
					}).then(h)
				}(e)
			}

			function L(e, t, i) {
				return function(e, t, i) {
					const r = new FormData;
					return r.append("name", t), r.append("tool", e), r.append("content", i), (0, l.fetch)("/save-drawing-template/", {
						method: "POST",
						credentials: "same-origin",
						body: r
					}).then(h)
				}(e, t, i)
			}

			function E(e, t) {
				return async function(e, t) {
					const i = await (0, l.fetch)(`/drawing-template/${e}/?templateName=${encodeURIComponent(t)}`, {
							credentials: "same-origin"
						}),
						r = await h(i);
					return JSON.parse(r.content)
				}(e, t)
			}

			function M(e, t) {
				return function(e, t) {
					const i = new FormData;
					return i.append("name", t), i.append("tool", e), (0, l.fetch)("/remove-drawing-template/", {
						method: "POST",
						credentials: "same-origin",
						body: i
					}).then(h)
				}(e, t)
			}
			const k = r
		},
		263983: (e, t, i) => {
			i.d(t, {
				INTERVALS: () => n
			});
			var r = i(575932);
			const n = [{
				name: "",
				label: (0, r.t)("minutes", {
					context: "interval"
				})
			}, {
				name: "H",
				label: (0, r.t)("hours", {
					context: "interval"
				})
			}, {
				name: "D",
				label: (0, r.t)("days", {
					context: "interval"
				})
			}, {
				name: "W",
				label: (0, r.t)("weeks", {
					context: "interval"
				})
			}, {
				name: "M",
				label: (0, r.t)("months", {
					context: "interval"
				})
			}];
			n.push({
				name: "R",
				label: (0, r.t)("range", {
					context: "interval"
				})
			})
		},
		901285: (e, t, i) => {
			i.r(t), i.d(t, {
				openMobileChartPickerCommand: () => r,
				closeMobileChartPickerCommand: () => n
			});
			const r = "OPEN_MOBILE_CHART_PICKER_COMMAND",
				n = "CLOSE_MOBILE_CHART_PICKER_COMMAND"
		},
		767824: (e, t, i) => {
			i.d(t, {
				CustomIntervalsService: () => d,
				customIntervalsServiceInstance: () => u
			});
			var r = i(62802),
				n = i(226722),
				s = i(405117),
				a = i(833813),
				o = i(552279),
				l = i(713917),
				c = i(364019),
				h = i(977809);
			class d extends l.AbstractJsonStoreService {
				constructor(e, t, i = []) {
					super(e, t, "CUSTOM_INTERVALS_CHANGED", "IntervalWidget.intervals", i)
				}
				set(e, t) {
					(0, s.trackGoProFeature)("customIntervals"), e.length < this.get().length ? super.set(e, t) : (0, o.runOrGoPro)((() => super.set(e, t)), a.ProductFeatures.CUSTOM_INTERVALS, {
						feature: "customIntervals"
					})
				}
				_serialize(e) {
					return (0, h.uniq)(e.map(c.normalizeIntervalString))
				}
				_deserialize(e) {
					return (0, h.uniq)((0, c.convertResolutionsFromSettings)(e).filter(c.isResolutionMultiplierValid).map(c.normalizeIntervalString))
				}
			}
			const u = new d(n.TVXWindowEvents, r)
		},
		84123: (e, t, i) => {
			i.d(t, {
				IntervalsService: () => c
			});
			var r = i(583912),
				n = i(97639),
				s = i.n(n),
				a = i(767824),
				o = i(263983),
				l = i(364019);
			class c {
				constructor(e) {
					this._customIntervalsService = a.customIntervalsServiceInstance, this._supportedIntervalsMayChange = new(s()), this._fireSupportedIntervalsMayChange = () => {
						this._supportedIntervalsMayChange.fire()
					}, this._chartApiInstance = e, r.linking.supportedResolutions.subscribe(this._fireSupportedIntervalsMayChange), r.linking.range.subscribe(this._fireSupportedIntervalsMayChange), r.linking.seconds.subscribe(this._fireSupportedIntervalsMayChange), r.linking.ticks.subscribe(this._fireSupportedIntervalsMayChange), r.linking.intraday.subscribe(this._fireSupportedIntervalsMayChange)
				}
				destroy() {
					r.linking.supportedResolutions.unsubscribe(this._fireSupportedIntervalsMayChange), r.linking.range.unsubscribe(this._fireSupportedIntervalsMayChange), r.linking.seconds.unsubscribe(this._fireSupportedIntervalsMayChange), r.linking.ticks.unsubscribe(this._fireSupportedIntervalsMayChange), r.linking.intraday.unsubscribe(this._fireSupportedIntervalsMayChange)
				}
				getDefaultIntervals() {
					return null === this._chartApiInstance ? [] : this._chartApiInstance.defaultResolutions().map(l.normalizeIntervalString)
				}
				getCustomIntervals() {
					return this._customIntervalsService.get()
				}
				add(e, t, i) {
					if (!window.user.is_pro && i) return i(), null;
					if (!this.isValidInterval(e, t)) return null;
					const r = (0, l.normalizeIntervalString)(`${e}${t}`),
						n = this.getCustomIntervals();
					return this._isIntervalDefault(r) || n.includes(r) ? null : (this._customIntervalsService.set((0, l.sortResolutions)([...n, r])), r)
				}
				remove(e) {
					this._customIntervalsService.set(this.getCustomIntervals().filter((t => t !== e)))
				}
				isValidInterval(e, t) {
					return (0, l.isResolutionMultiplierValid)(`${e}${t}`)
				}
				isSupportedInterval(e) {
					return (0, l.isAvailable)(e)
				}
				supportedIntervalsMayChange() {
					return this._supportedIntervalsMayChange
				}
				getOnChange() {
					return this._customIntervalsService.getOnChange()
				}
				getPossibleIntervals() {
					return o.INTERVALS
				}
				getResolutionUtils() {
					return {
						getMaxResolutionValue: l.getMaxResolutionValue,
						getTranslatedResolutionModel: l.getTranslatedResolutionModel,
						mergeResolutions: l.mergeResolutions,
						sortResolutions: l.sortResolutions
					}
				}
				_isIntervalDefault(e) {
					return this.getDefaultIntervals().includes(e)
				}
			}
		},
		226269: (e, t, i) => {
			i.d(t, {
				RangeBinding: () => o
			});
			var r = i(97639),
				n = i.n(r),
				s = i(611688),
				a = i(195048);
			class o {
				constructor(e) {
					this._state = {
						ranges: []
					}, this._change = new(n()), this._rangeChangedListenerBound = this._onRangeChanged.bind(this);
					const {
						chartWidget: t
					} = this._context = e;
					t.withModel(null, (() => {
						const e = t.model(),
							i = e.mainSeries();
						i.onStatusChanged().subscribe(this, this._updateAvailableRanges), s.enabled("update_timeframes_set_on_symbol_resolve") && i.dataEvents().symbolResolved().subscribe(this, this._updateAvailableRanges), i.priceScale().properties().childs().lockScale.subscribe(this, this._updateAvailableRanges);
						const r = e.model().appliedTimeFrame();
						r.subscribe(this._rangeChangedListenerBound), this._rangeChangedListenerBound(r.value()), this._updateAvailableRanges()
					}))
				}
				state() {
					return this._state
				}
				onChange() {
					return this._change
				}
				selectRange(e) {
					this._setState({
						activeRange: e.value.value
					});
					const {
						chartWidgetCollection: t
					} = this._context, i = {
						val: e.value,
						res: e.targetResolution
					};
					t.setTimeFrame(i)
				}
				destroy() {
					const {
						chartWidget: e
					} = this._context;
					e.withModel(null, (() => {
						const t = e.model(),
							i = t.mainSeries();
						i.onStatusChanged().unsubscribe(this, this._updateAvailableRanges), s.enabled("update_timeframes_set_on_symbol_resolve") && i.dataEvents().symbolResolved().unsubscribe(this, this._updateAvailableRanges), i.priceScale().properties().childs().lockScale.unsubscribe(this, this._updateAvailableRanges), t.model().appliedTimeFrame().unsubscribe(this._rangeChangedListenerBound)
					})), this._change.destroy()
				}
				_setState(e) {
					this._state = Object.assign({}, this._state, e), this._change.fire(this._state)
				}
				_onRangeChanged(e) {
					let t;
					null !== e && "period-back" === e.val.type && (t = e.val.value), this._setState({
						activeRange: t
					})
				}
				_updateAvailableRanges() {
					const {
						availableTimeFrames: e,
						chartWidget: t
					} = this._context;
					if (!t.hasModel()) return;
					const i = t.model().mainSeries(),
						r = i.status();
					if (r === a.STATUS_LOADING || r === a.STATUS_RESOLVING) return;
					const n = e(i.symbolInfo(), i.status());
					0 !== n.length && this._setState({
						ranges: n
					})
				}
			}
		},
		741511: (e, t, i) => {
			i.r(t), i.d(t, {
				supportedLineTools: () => r
			});
			const r = {
				cursor: {
					name: "cursor",
					onlySelectable: !0
				},
				dot: {
					name: "dot",
					onlySelectable: !0
				},
				arrow_cursor: {
					name: "arrow",
					onlySelectable: !0
				},
				eraser: {
					name: "eraser",
					onlySelectable: !0
				},
				measure: {
					name: "measure",
					onlySelectable: !0
				},
				zoom: {
					name: "zoom",
					onlySelectable: !0
				},
				brush: {
					name: "LineToolBrush"
				},
				highlighter: {
					name: "LineToolHighlighter"
				},
				text: {
					name: "LineToolText"
				},
				anchored_text: {
					name: "LineToolTextAbsolute"
				},
				note: {
					name: "LineToolNote"
				},
				anchored_note: {
					name: "LineToolNoteAbsolute"
				},
				signpost: {
					name: "LineToolSignpost"
				},
				callout: {
					name: "LineToolCallout"
				},
				balloon: {
					name: "LineToolBalloon"
				},
				arrow_up: {
					name: "LineToolArrowMarkUp"
				},
				arrow_down: {
					name: "LineToolArrowMarkDown"
				},
				arrow_left: {
					name: "LineToolArrowMarkLeft"
				},
				arrow_right: {
					name: "LineToolArrowMarkRight"
				},
				price_label: {
					name: "LineToolPriceLabel"
				},
				price_note: {
					name: "LineToolPriceNote"
				},
				arrow_marker: {
					name: "LineToolArrowMarker"
				},
				flag: {
					name: "LineToolFlagMark"
				},
				vertical_line: {
					name: "LineToolVertLine"
				},
				horizontal_line: {
					name: "LineToolHorzLine"
				},
				cross_line: {
					name: "LineToolCrossLine"
				},
				horizontal_ray: {
					name: "LineToolHorzRay"
				},
				trend_line: {
					name: "LineToolTrendLine"
				},
				info_line: {
					name: "LineToolInfoLine"
				},
				trend_angle: {
					name: "LineToolTrendAngle"
				},
				arrow: {
					name: "LineToolArrow"
				},
				ray: {
					name: "LineToolRay"
				},
				extended: {
					name: "LineToolExtended"
				},
				parallel_channel: {
					name: "LineToolParallelChannel"
				},
				disjoint_angle: {
					name: "LineToolDisjointAngle"
				},
				flat_bottom: {
					name: "LineToolFlatBottom"
				},
				pitchfork: {
					name: "LineToolPitchfork"
				},
				schiff_pitchfork_modified: {
					name: "LineToolSchiffPitchfork"
				},
				schiff_pitchfork: {
					name: "LineToolSchiffPitchfork2"
				},
				inside_pitchfork: {
					name: "LineToolInsidePitchfork"
				},
				pitchfan: {
					name: "LineToolPitchfan"
				},
				gannbox: {
					name: "LineToolGannSquare"
				},
				gannbox_square: {
					name: "LineToolGannComplex"
				},
				gannbox_fixed: {
					name: "LineToolGannFixed"
				},
				gannbox_fan: {
					name: "LineToolGannFan"
				},
				fib_retracement: {
					name: "LineToolFibRetracement"
				},
				fib_trend_ext: {
					name: "LineToolTrendBasedFibExtension"
				},
				fib_speed_resist_fan: {
					name: "LineToolFibSpeedResistanceFan"
				},
				fib_timezone: {
					name: "LineToolFibTimeZone"
				},
				fib_trend_time: {
					name: "LineToolTrendBasedFibTime"
				},
				fib_circles: {
					name: "LineToolFibCircles"
				},
				fib_spiral: {
					name: "LineToolFibSpiral"
				},
				fib_speed_resist_arcs: {
					name: "LineToolFibSpeedResistanceArcs"
				},
				fib_wedge: {
					name: "LineToolFibWedge"
				},
				fib_channel: {
					name: "LineToolFibChannel"
				},
				xabcd_pattern: {
					name: "LineTool5PointsPattern"
				},
				cypher_pattern: {
					name: "LineToolCypherPattern"
				},
				abcd_pattern: {
					name: "LineToolABCD"
				},
				triangle_pattern: {
					name: "LineToolTrianglePattern"
				},
				"3divers_pattern": {
					name: "LineToolThreeDrivers"
				},
				head_and_shoulders: {
					name: "LineToolHeadAndShoulders"
				},
				elliott_impulse_wave: {
					name: "LineToolElliottImpulse"
				},
				elliott_triangle_wave: {
					name: "LineToolElliottTriangle"
				},
				elliott_triple_combo: {
					name: "LineToolElliottTripleCombo"
				},
				elliott_correction: {
					name: "LineToolElliottCorrection"
				},
				elliott_double_combo: {
					name: "LineToolElliottDoubleCombo"
				},
				cyclic_lines: {
					name: "LineToolCircleLines"
				},
				time_cycles: {
					name: "LineToolTimeCycles"
				},
				sine_line: {
					name: "LineToolSineLine"
				},
				long_position: {
					name: "LineToolRiskRewardLong"
				},
				short_position: {
					name: "LineToolRiskRewardShort"
				},
				forecast: {
					name: "LineToolPrediction"
				},
				date_range: {
					name: "LineToolDateRange"
				},
				price_range: {
					name: "LineToolPriceRange"
				},
				date_and_price_range: {
					name: "LineToolDateAndPriceRange"
				},
				bars_pattern: {
					name: "LineToolBarsPattern"
				},
				ghost_feed: {
					name: "LineToolGhostFeed"
				},
				projection: {
					name: "LineToolProjection"
				},
				rectangle: {
					name: "LineToolRectangle"
				},
				rotated_rectangle: {
					name: "LineToolRotatedRectangle"
				},
				circle: {
					name: "LineToolCircle"
				},
				ellipse: {
					name: "LineToolEllipse"
				},
				triangle: {
					name: "LineToolTriangle"
				},
				polyline: {
					name: "LineToolPolyline"
				},
				path: {
					name: "LineToolPath"
				},
				curve: {
					name: "LineToolBezierQuadro"
				},
				double_curve: {
					name: "LineToolBezierCubic"
				},
				arc: {
					name: "LineToolArc"
				},
				icon: {
					name: "LineToolIcon"
				},
				regression_trend: {
					name: "LineToolRegressionTrend"
				},
				fixed_range_volume_profile: {
					name: "LineToolFixedRangeVolumeProfile"
				}
			}; {
				const e = r;
				e.anchored_vwap = {
					name: "LineToolAnchoredVWAP"
				}, e.tweet = {
					name: "LineToolTweet"
				}, e.idea = {
					name: "LineToolIdea"
				}
			}
		},
		911730: (e, t, i) => {
			i.d(t, {
				changedAll: () => s,
				ChartChangesWatcher: () => a
			});
			var r = i(97639),
				n = i.n(r);
			const s = 3;
			class a {
				constructor(e, t, i) {
					this._undoHistoryHasChanges = !1, this._changesMask = 0, this._handleMetainfoChanged = () => {
							this._changesMask = 1 | this._changesMask
						},
						this._recalculateHaveChanges = () => {
							const e = this._undoHistoryHasChanges ? 1 : 0,
								t = this._lineToolsHaveChanges.value() ? 2 : 0,
								i = this._changesMask;
							this._changesMask = e | t, i !== this._changesMask && this._onValueChanged.fire(0 !== this._changesMask)
						}, this._chartWidgetCollection = e, this._undoHistory = e.undoHistory, this._lineToolsHaveChanges = e.lineToolsSynchronizerHasChanges, this._chartSaver = t, this._globalEvents = i, this._onValueChanged = new(n()), this._subscribe()
				}
				destroy() {
					this._unsubscribe(), this._onValueChanged.destroy()
				}
				changes() {
					return this._changesMask
				}
				hasChanges() {
					return this._changesMask > 0
				}
				getOnChange() {
					return this._onValueChanged
				}
				_subscribe() {
					this._globalEvents.subscribe("chart_loaded", this._handleChartLoaded, this), this._undoHistory.undoStack().onChange().subscribe(this, this._handleUndoHistoryChange), this._chartSaver.chartSaved().subscribe(this, this._handleChartSaved), this._lineToolsHaveChanges.subscribe(this._recalculateHaveChanges);
					this._chartWidgetCollection.metaInfo.name.subscribe(this._handleMetainfoChanged)
				}
				_unsubscribe() {
					this._globalEvents.unsubscribe("chart_loaded", this._handleChartLoaded, this), this._undoHistory.undoStack().onChange().unsubscribe(this, this._handleUndoHistoryChange), this._chartSaver.chartSaved().unsubscribe(this, this._handleChartSaved), this._lineToolsHaveChanges.unsubscribe(this._recalculateHaveChanges);
					this._chartWidgetCollection.metaInfo.name.unsubscribe(this._handleMetainfoChanged)
				}
				_setUndoHistoryHasChanges(e) {
					this._undoHistoryHasChanges = e, this._recalculateHaveChanges()
				}
				_handleChartLoaded() {
					this._setUndoHistoryHasChanges(!1)
				}
				_handleUndoHistoryChange(e) {
					e && !e.customFlag("doesnt_affect_save") && this._setUndoHistoryHasChanges(!0)
				}
				_handleChartSaved(e) {
					e && this._setUndoHistoryHasChanges(!1)
				}
			}
		},
		436940: (e, t, i) => {
			i.d(t, {
				ChartWidgetApiBase: () => A
			});
			var r = i(588537),
				n = i(575932),
				s = i(277036),
				a = i(273044),
				o = i(566190),
				l = i(370062);
			class c {
				constructor(e) {
					this._timeScale = e
				}
				coordinateToTime(e) {
					const t = this._timeScale.coordinateToIndex(e);
					return this._timeScale.indexToTimePoint(t)
				}
				barSpacingChanged() {
					return this._timeScale.barSpacingChanged()
				}
				rightOffsetChanged() {
					return this._timeScale.rightOffsetChanged()
				}
				setRightOffset(e) {
					this._timeScale.setRightOffset(e)
				}
				setBarSpacing(e) {
					this._timeScale.setBarSpacing(e)
				}
				barSpacing() {
					return this._timeScale.barSpacing()
				}
				rightOffset() {
					return this._timeScale.rightOffset()
				}
				width() {
					return this._timeScale.width()
				}
				defaultRightOffset() {
					return this._timeScale.defaultRightOffset()
				}
				isEmpty() {
					return this._timeScale.isEmpty()
				}
			}
			var h = i(97639),
				d = i.n(h),
				u = i(888667);
			const g = new s.TranslatedString("change timezone", (0, n.t)("change timezone"));
			class m {
				constructor(e) {
					this._onTimezoneChanged = new(d()), this._chartWidget = e, this._timezoneProperty = e.properties().childs().timezone, this._timezoneProperty.subscribe(this, (e => {
						this._onTimezoneChanged.fire(e.value())
					})), e.onAboutToBeDestroyed().subscribe(this, (() => {
						this._timezoneProperty.unsubscribeAll(this)
					}), !0)
				}
				availableTimezones() {
					return u.availableTimezones
				}
				getTimezone() {
					const e = this._timezoneProperty.value();
					return (0,
						r.ensureDefined)(u.availableTimezones.find((t => t.id === e)))
				}
				setTimezone(e, t) {
					(0, r.assert)((0, u.timezoneIsAvailable)(e), `Incorrect timezone: ${e}`), (null == t ? void 0 : t.disableUndo) ? this._timezoneProperty.setValue(e): this._chartWidget.model().setProperty(this._timezoneProperty, e, g)
				}
				onTimezoneChanged() {
					return this._onTimezoneChanged
				}
			}
			var _ = i(226269);
			class p {
				constructor(e) {
					this._drawer = null, this._context = e, this._rangeBindings = new _.RangeBinding(e)
				}
				drawer() {
					return Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(30063), i.e(91670), i.e(63280), i.e(21834), i.e(80580), i.e(68074), i.e(52498), i.e(9935), i.e(44155), i.e(50522), i.e(77542), i.e(92617), i.e(97430), i.e(45410), i.e(82290), i.e(59697), i.e(84236), i.e(88314), i.e(75514), i.e(97974), i.e(68985), i.e(18611), i.e(38277), i.e(8866)]).then(i.bind(i, 321675)).then((e => (null === this._drawer && (this._drawer = new e.DateRangeDrawerApi(this._context)), this._drawer)))
				}
				state() {
					return this._rangeBindings.state()
				}
				onChange() {
					return this._rangeBindings.onChange()
				}
				selectRange(e) {
					this._rangeBindings.selectRange(e)
				}
				goToTime(e) {
					const t = this._context.chartWidget.model().model();
					t.gotoTime(e).then((e => {
						const i = t.mainSeries();
						void 0 === e ? i.clearGotoDateResult() : i.setGotoDateResult(e)
					}))
				}
			}
			var S = i(126974),
				v = i(210542),
				b = i(587314),
				y = i(467659);

			function f(e, t) {
				const i = () => {
						e.completed().unsubscribe(null, r), t(!1)
					},
					r = () => {
						e.error().unsubscribe(null, i), t(!0)
					};
				e.completed().subscribe(null, i, !0), e.error().subscribe(null, r, !0)
			}
			var C = i(294766);
			const w = new s.TranslatedString("change price to bar ratio", (0, n.t)("change price to bar ratio")),
				T = new s.TranslatedString("toggle lock scale", (0, n.t)("toggle lock scale")),
				I = new s.TranslatedString("change series style", (0, n.t)("change series style"));
			class A {
				constructor(e, t) {
					this._visibleBarsChanged = new(d()), this._crosshairMoved = new(d()), this._ranges = null, this._alignerResolution = a.Interval.parse(""), this._alignerSymbolInfo = null, this._dwmAligner = null, this._chartWidget = e, this._activateChart = t, this._timezoneApi = new m(e), this._chartWidget.withModel(this, (() => {
						this._chartWidget.model().crossHairSource().moved().subscribe(this, this._onCrosshairMoved)
					}))
				}
				getPriceToBarRatio() {
					return this._chartWidget.model().model().mainSeriesScaleRatioProperty().value()
				}
				setPriceToBarRatio(e, t) {
					const i = this._chartWidget.model(),
						r = i.model(),
						n = r.mainSeriesScaleRatioProperty();
					(null == t ? void 0 : t.disableUndo) ? new y.SetScaleRatioPropertiesCommand(n, e, null, r).redo(): i.setScaleRatioProperty(n, e, w)
				}
				isPriceToBarRatioLocked() {
					return this._chartWidget.model().model().mainSeries().priceScale().isLockScale()
				}
				setPriceToBarRatioLocked(e, t) {
					const i = this._chartWidget.model(),
						r = i.model(),
						n = r.mainSeries().priceScale();
					(null == t ? void 0 : t.disableUndo) ? new b.SetPriceScaleModeCommand({
						lockScale: e
					}, n, null, r).redo(): i.setPriceScaleMode({
						lockScale: e
					}, n, T)
				}
				onDataLoaded() {
					return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().dataEvents().completed())
				}
				onSymbolChanged() {
					return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().dataEvents().symbolResolved())
				}
				onIntervalChanged() {
					return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().onIntervalChanged())
				}
				onVisibleRangeChanged() {
					return this._makeSubscriptionFromDelegate(this._visibleBarsChanged)
				}
				onChartTypeChanged() {
					return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().onStyleChanged())
				}
				onSeriesTimeframe() {
					return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().dataEvents().seriesTimeFrame())
				}
				whenChartReady(e) {
					this._chartWidget.withModel(this, e)
				}
				crossHairMoved() {
					return this._makeSubscriptionFromDelegate(this._crosshairMoved)
				}
				setSymbol(e, t) {
					if (e === this.symbol()) return void(null == t || t());
					const i = e => {
							!e && t && t()
						},
						r = this._chartWidget.model().mainSeries().dataEvents();
					t && f(r, i), this._activateChart(), this._chartWidget.setSymbol(e)
				}
				setResolution(e, t) {
					const i = a.Interval.normalize(e);
					if (null === i || i === this.resolution()) return void(null == t || t());
					const r = e => {
							!e && t && t()
						},
						n = this._chartWidget.model().mainSeries().dataEvents();
					t && f(n, r), this._activateChart(), this._chartWidget.setResolution(i)
				}
				setChartType(e, t) {
					const i = this._chartWidget.model().mainSeries().properties().childs().style;
					if (i.value() === e) return void(null == t || t());
					const r = e => {
							!e && t && t()
						},
						n = this._chartWidget.model().mainSeries().dataEvents();
					t && f(n, r), this._chartWidget.model().setChartStyleProperty(i, e, I)
				}
				getAllStudies() {
					return this._chartWidget.model().model().allStudies(!0).map(v.studyEntityInfo)
				}
				getAllPanesHeight() {
					const e = this._chartWidget.model().model().panes();
					if (this._chartWidget.isMaximizedPane()) {
						let t = 0,
							i = 0;
						e.forEach((e => {
							t += e.height(), i += e.stretchFactor()
						}));
						const r = i / t;
						return e.map((e => Math.round(e.stretchFactor() / r * 100) / 100))
					}
					return e.map((e => e.height()))
				}
				setAllPanesHeight(e) {
					const t = this._chartWidget.model().model(),
						i = t.panes();
					(0, r.assert)(i.length === e.length, "There`s a mismatch between the number of heights you provided and the number of panes.");
					const n = i.reduce(((e, t) => e + t.stretchFactor()), 0) / e.reduce(((e, t) => e + t));
					e.forEach(((e, t) => {
						const r = e * n;
						i[t].setStretchFactor(r)
					})), t.fullUpdate()
				}
				maximizeChart() {
					this._chartWidget.getResizerDetacher().requestFullscreen()
				}
				restoreChart() {
					this._chartWidget.getResizerDetacher().exitFullscreen()
				}
				sessions() {
					return this._chartWidget.model().model().sessions()
				}
				getTimeScaleLogicalRange() {
					return this._chartWidget.model().timeScale().logicalRange()
				}
				getTimezoneApi() {
					return this._timezoneApi
				}
				exportData(e) {
					const t = {
						...e
					};
					return void 0 !== t.from && (t.from = this._convertTimeFromPublic(t.from)), void 0 !== t.to && (t.to = this._convertTimeFromPublic(t.to)), Promise.reject("Data export is not supported")
				}
				isSelectBarRequested() {
					return 0 !== this._chartWidget.selectPointMode().value()
				}
				barTimeToEndOfPeriod(e) {
					const t = this._prepareEndOfPeriodArgs();
					return function(e, t, i) {
						if (i.isDays()) return t;
						if (e.moveTo(1e3 * t), i.isIntraday()) {
							const i = e.indexOfBar(1e3 * t);
							if (i < 0) throw new Error(`${t} is out of the instrument session `);
							return e.endOfBar(i) / 1e3
						}
						return e.startOfBar(l.SessionStage.LASTBAR_SESSION) / 1e3
					}(t.barBuilder, e, t.intervalObj)
				}
				endOfPeriodToBarTime(e) {
					const t = this._prepareEndOfPeriodArgs();
					return function(e, t, i) {
						if (i.isDays()) return t;
						const r = 1e3 * t - 1;
						if (e.moveTo(r), i.isIntraday()) {
							const i = e.indexOfBar(r);
							if (i < 0) throw new Error(`${t} is out of the instrument session `);
							return e.startOfBar(i) / 1e3
						}
						return e.startOfBar(0) / 1e3
					}(t.barBuilder, e, t.intervalObj)
				}
				properties() {
					return this._chartWidget.properties()
				}
				setBarSpacing(e) {
					this._chartWidget.model().timeScale().setBarSpacing(e)
				}
				scrollChartByBar(e) {
					this._chartWidget.model().scrollChartByBar(e)
				}
				mergeAllScales(e) {
					this._chartWidget.model().mergeAllScales(e)
				}
				chartPainted() {
					return this._chartWidget.chartPainted()
				}
				axesSizeReady() {
					for (const e of this._chartWidget.paneWidgets()) {
						for (const t of e.leftPriceAxisesContainer().axes())
							if (!t.sizeReady()) return !1;
						for (const t of e.rightPriceAxisesContainer().axes())
							if (!t.sizeReady()) return !1
					}
					return !0
				}
				applyOverrides(e) {
					this._chartWidget.applyOverrides(e)
				}
				addOverlayStudy(e, t, i) {
					return this._chartWidget.addOverlayStudy(e, t, i)
				}
				lineToolsSynchronizer() {
					return this._chartWidget.lineToolsSynchronizer()
				}
				ranges() {
					return null === this._ranges && (this._ranges = new p({
						chartWidget: this._chartWidget,
						chartWidgetCollection: this._chartWidget.chartWidgetCollection(),
						availableTimeFrames: S.availableTimeFrames
					})), this._ranges
				}
				getTimeScale() {
					return new c(this._chartWidget.model().timeScale())
				}
				_destroy() {
					this._chartWidget.hasModel() && this._chartWidget.model().crossHairSource().moved().unsubscribeAll(this)
				}
				_createStudy(e) {
					return new Promise(((t, i) => {
						this._chartWidget.insertStudy(e).then((e => {
							null === e ? i("Failed to create study") : t(e.id())
						}))
					}))
				}
				_convertTimeToPublic(e) {
					const t = this._getSeriesAligner();
					return null !== t ? t.timeToExchangeTradingDay(1e3 * e) / 1e3 : e
				}
				_convertIndexToPublicTime(e) {
					const t = this._chartWidget.model(),
						i = t.timeScale();
					if (i.isEmpty()) return null;
					const n = i.points(),
						s = (0, r.ensureNotNull)(n.firstIndex()),
						a = (0, r.ensureNotNull)(n.lastIndex());
					let o = null;
					if (s <= e && e <= a) o = n.valueAt(e);
					else if (e > a) {
						const n = t.mainSeries().syncModel();
						if (null !== n) {
							const t = (0, r.ensureNotNull)(i.indexToTimePoint(a));
							o = n.projectTime(t, e - a)
						}
					}
					return null !== o && (o = this._convertTimeToPublic(o)), o
				}
				_getDefaultCreateMultipointShapeOptions() {
					return {
						filled: !0
					}
				}
				_convertTimeFromPublic(e) {
					const t = this._getSeriesAligner();
					return null !== t ? t.timeToSessionStart(1e3 * e) / 1e3 : e
				}
				_getSeriesAligner() {
					const e = this._chartWidget.model().mainSeries(),
						t = e.interval(),
						i = a.Interval.parse(t),
						r = e.symbolInfo();
					return this._alignerResolution.isEqualTo(i) && this._alignerSymbolInfo === r || (this._dwmAligner = null === r ? null : (0, C.createDwmAligner)(t, r), this._alignerResolution = i, this._alignerSymbolInfo = r), this._dwmAligner
				}
				_onCrosshairMoved(e) {
					const t = this._convertIndexToPublicTime(e.index);
					null !== t && this._crosshairMoved.fire({
						price: e.price,
						time: t
					})
				}
				_makeSubscriptionFromDelegate(e) {
					return {
						subscribe: e.subscribe.bind(e),
						unsubscribe: e.unsubscribe.bind(e),
						unsubscribeAll: e.unsubscribeAll.bind(e)
					}
				}
				_prepareEndOfPeriodArgs() {
					const e = this._chartWidget.model().model(),
						t = e.timezone(),
						i = (0, r.ensureNotNull)(e.mainSeries().symbolInfo()),
						n = e.mainSeries().interval(),
						s = new o.SessionInfo(t, i.session, i.session_holidays, i.corrections);
					return {
						barBuilder: (0, o.newBarBuilder)(n, s, s),
						intervalObj: a.Interval.parse(n)
					}
				}
			}
		},
		982405: (e, t, i) => {
			var r = i(588537).ensureNotNull,
				n = i(776734).getTracker,
				s = i(178323),
				a = s.LineDataSourceApi,
				o = s.isLineToolRiskReward,
				l = i(830384).StudyApi,
				c = i(125853).SeriesApi,
				h = i(100148).SelectionApi,
				d = i(210493).PaneApi,
				u = i(294766).createDwmAligner,
				g = i(273044).Interval,
				m = i(741511).supportedLineTools,
				_ = i(451902).showTooManyStudiesNotice,
				p = i(270617),
				S = p.isNumber,
				v = p.deepEquals,
				b = i(540968).createLineToolProperties,
				y = i(540968).prepareLineToolPropertiesByOwnerSource,
				f = i(210542).lineToolEntityInfo,
				C = i(914554).LineToolsGroupControllerApi,
				w = i(69318).RemoveSourcesCommand;
			const {
				isLineDrawnWithPressedButton: T,
				isLineToolFinishRequiredWhenCreatedByApi: I
			} = i(29084), A = i(443527).EnvironmentState;
			var W = i(436940).ChartWidgetApiBase,
				P = i(308170);
			const D = i(345848).trackEvent;

			function L(e, t) {
				return t.map((function(t) {
					return e.dataSourceForId(t)
				}))
			}
			e.exports = class extends W {
				constructor(e, t) {
					super(e, t), this._panes = new WeakMap, this._studies = new WeakMap, this._lineDataSources = new WeakMap, this._selectionApi = null, this._prevVisibleRange = null, this._chartWidget.onAboutToBeDestroyed().subscribe(this, this._destroy, !0), this._chartWidget.withModel(this, (function() {
						this._chartWidget.model().timeScale().logicalRangeChanged().subscribe(this, this._onLogicalRangeChanged)
					}))
				}
				id() {
					return this._chartWidget.id()
				}
				_getPaneApi(e) {
					var t = this._panes.get(e);
					return void 0 === t && (t = new d(e, this._chartWidget), this._panes.set(e, t)), t
				}
				_getStudyApi(e) {
					var t = this._studies.get(e);
					return void 0 === t && (t = new l(e, this._chartWidget), this._studies.set(e, t)), t
				}
				_getLineDataSourceApi(e) {
					var t = this._lineDataSources.get(e);
					return void 0 === t && (t = new a(e, this._chartWidget.model(), {
						apiPointsToDataSource: this._convertUserPointsToDataSource.bind(this),
						dataSourcePointsToPriced: e => {
							var t = this._chartWidget.model().mainSeries().syncModel(),
								i = this._chartWidget.model().timeScale();
							return e.map((e => {
								var r = i.normalizeBarIndex(e.index);
								return {
									price: e.price,
									time: this._convertTimeToPublic(t.projectTime(r.time_t, r.offset))
								}
							}))
						}
					}), this._lineDataSources.set(e, t)), t
				}
				executeActionById(e) {
					this._chartWidget.executeActionById(e)
				}
				getCheckableActionState(e) {
					return this._chartWidget.getCheckableActionState(e)
				}
				setZoomEnabled(e) {
					this._chartWidget.model().model().setZoomEnabled(e)
				}
				setScrollEnabled(e) {
					this._chartWidget.model().model().setScrollEnabled(e)
				}
				refreshMarks() {
					this._chartWidget.refreshMarks()
				}
				clearMarks() {
					this._chartWidget.clearMarks()
				}
				symbol() {
					return this._chartWidget.getSymbol()
				}
				symbolExt() {
					var e = this._chartWidget.model().mainSeries().symbolInfo();
					return e ? {
						symbol: e.name,
						full_name: e.full_name,
						exchange: e.exchange,
						description: e.description,
						type: e.type,
						pro_name: e.pro_name,
						typespecs: e.typespecs
					} : null
				}
				resolution() {
					return this._chartWidget.model().mainSeries().properties().interval.value()
				}
				resetData() {
					this._chartWidget.model().mainSeries().rerequestData()
				}
				setEntityVisibility(e, t) {
					console.warn("`setEntityVisibility` is deprecated. Use shape/study API instead");
					var i = this._chartWidget.model().model().dataSourceForId(e);
					if (i) {
						var r = i.properties();
						r && r.visible && r.visible.setValue(t)
					}
				}
				availableZOrderOperations(e) {
					var t = L(this._chartWidget.model().model(), e);
					return this._chartWidget.model().availableZOrderOperations(t)
				}
				sendToBack(e) {
					var t = L(this._chartWidget.model().model(), e);
					this._chartWidget.model().sendToBack(t)
				}
				bringToFront(e) {
					var t = L(this._chartWidget.model().model(), e);
					this._chartWidget.model().bringToFront(t)
				}
				insertAfter(e, t) {
					var i = this._chartWidget.model().model(),
						r = L(i, e),
						n = i.dataSourceForId(t);
					this._chartWidget.model().insertAfter(r, n)
				}
				insertBefore(e, t) {
					var i = this._chartWidget.model().model(),
						r = L(i, e),
						n = i.dataSourceForId(t);
					this._chartWidget.model().insertBefore(r, n)
				}
				bringForward(e) {
					var t = L(this._chartWidget.model().model(), e);
					this._chartWidget.model().bringForward(t)
				}
				sendBackward(e) {
					var t = L(this._chartWidget.model().model(), e);
					this._chartWidget.model().sendBackward(t)
				}
				showPropertiesDialog(e) {
					var t = this._chartWidget.model().model().dataSourceForId(e);
					if (null === t) throw new Error("Study or shape " + e + " does not exist");
					this._chartWidget.showChartPropertiesForSource(t)
				}
				getAllShapes() {
					return this._chartWidget.model().model().allLineTools().map(f).filter((function(e) {
						return null !== e.name
					}))
				}
				removeAllShapes() {
					this._chartWidget.removeAllDrawingTools()
				}
				removeAllStudies() {
					this._chartWidget.removeAllStudies()
				}
				removeEntity(e, t) {
					var i = this._chartWidget.model().chartModel().dataSourceForId(e);
					i ? t && t.disableUndo ? new w(this._chartWidget.model().chartModel(), [i], "").redo() : this._chartWidget.model().removeSource(i, !0, !0) : console.warn("Can't find a source with id: " + e)
				}
				removeEntityWithUndo(e) {
					var t = this._chartWidget.model().chartModel().dataSourceForId(e);
					this._chartWidget.model().removeSource(t, !1)
				}
				selection() {
					return null === this._selectionApi && (this._selectionApi = new h(this._chartWidget.model().model())), this._selectionApi
				}
				createStudyTemplate(e) {
					return this._chartWidget.model().model().studyTemplate(e.saveSymbol, e.saveInterval)
				}
				drawOnAllCharts(e) {
					P.drawOnAllCharts.setValue(e)
				}
				applyStudyTemplate(e) {
					this._chartWidget.model().applyStudyTemplate(e, "" + 1e3 * Math.random())
				}
				setVisibleRange(e, t) {
					throw new Error("Not implemented")
				}
				getVisibleRange() {
					var e = {
							from: 0,
							to: 0
						},
						t = this._chartWidget.model().timeScale();
					if (t.isEmpty()) return e;
					var i = t.coordinateToVisibleIndex(0),
						r = t.coordinateToVisibleIndex(t.width() - 1),
						n = this._convertIndexToPublicTime(r);
					return null === n || (e.from = this._convertIndexToPublicTime(Math.max(t.points().firstIndex(), i)), e.to = n), e
				}
				getVisiblePriceRange() {
					return console.warn("`getVisiblePriceRange` is deprecated. Use Price Scale API instead"), this._chartWidget.model().mainSeries() ? this._chartWidget.model().mainSeries().priceScale().priceRangeInPrice() : null
				}
				scrollPosition() {
					return console.warn("`scrollPosition` is deprecated. Use rightOffset from Time Scale API instead"), this._chartWidget.model().timeScale().rightOffset()
				}
				defaultScrollPosition() {
					return console.warn("`defaultScrollPosition` is deprecated. Use defaultRightOffset from Time Scale API instead"), this._chartWidget.model().timeScale().defaultRightOffset().value()
				}
				_createTradingPrimitive(e, t) {
					var i, n = this._chartWidget.model(),
						s = n.model(),
						a = s.paneForSource(s.mainSeries());

					function o() {
						var e = TradingView.CLOSE_PLOT,
							t = r(n.mainSeries().bars().last());
						return {
							index: t.index,
							price: t.value[e]
						}
					}
					return (i = t ? s.createLineTool(a, o(), e) : n.createLineTool({
						pane: a,
						point: o(),
						linetool: e
					})) ? i._adapter : void 0
				}
				createOrderLine(e) {
					e = e || {};
					return this._createTradingPrimitive("LineToolOrder", e.disableUndo)
				}
				createPositionLine(e) {
					e = e || {};
					return this._createTradingPrimitive("LineToolPosition", e.disableUndo)
				}
				createExecutionShape(e) {
					e = e || {};
					return this._createTradingPrimitive("LineToolExecution", e.disableUndo)
				}
				createShape(e, t) {
					return this.createMultipointShape([e], t)
				}
				_alignPoints(e) {
					var t = this._chartWidget.model().model(),
						i = t.mainSeries(),
						r = i.interval();
					if (t.timeScale().isEmpty() || !g.isDWM(r)) return e;
					var n = u(r, i.symbolInfo());
					return null === n ? e : e.map((function(e) {
						return n.timeToSessionStart(1e3 * e) / 1e3
					}))
				}
				_convertUserPointsToDataSource(e) {
					var t = this._chartWidget.model().model(),
						i = t.mainSeries(),
						r = t.timeScale().points(),
						n = i.data();
					if (t.timeScale().isEmpty()) return null;
					var s = e.map((function(e) {
							return e.time || 0
						})),
						a = this._alignPoints(s);

					function o(e, t, s) {
						var a = r.closestIndexLeft(e) || 0,
							o = {
								index: a
							},
							l = r.valueAt(a);
						if (e > l && a === r.lastIndex())(c = i.syncModel().distance(l, e)).success && (o.index = o.index + c.result);
						else if (e < l && a === r.firstIndex()) {
							var c;
							(c = i.syncModel().distance(e, l)).success && (o.index = o.index - c.result)
						}
						if (S(t)) o.price = t;
						else {
							var h = s ? ["open", "high", "low", "close"].indexOf(s) + 1 : 1;
							h <= 0 && (h = 1), o.price = n.valueAt(a)[h]
						}
						return o
					}
					for (var l = [], c = 0; c < e.length; c++) {
						var h = e[c];
						l.push(o(a[c], h.price, h.channel))
					}
					return l
				}
				createMultipointShape(e, t) {
					const i = Object.assign({}, this._getDefaultCreateMultipointShapeOptions(), t);
					var r = m[i.shape] || m.flag;
					D("API", "CreateDrawing", r.name), n().then((e => {
						null !== e && e.trackChartApiDrawingCreation(r.name)
					}));
					var s = this._chartWidget.model().model(),
						a = s.mainSeries();
					if (!s.timeScale().isEmpty()) {
						var l = s.dataSourceForId(i.ownerStudyId) || a,
							c = s.paneForSource(l),
							h = this._convertUserPointsToDataSource(e);
						if (r.onlySelectable) throw new Error('Cannot create "' + i.shape + '" shape');
						if ("LineToolIcon" === r.name) {
							if (i.icon = i.icon || i.overrides && i.overrides.icon, !i.hasOwnProperty("icon")) throw new Error("icon must be specified in options");
							i.overrides = i.overrides || {}, i.overrides.icon = i.icon
						}
						var d, u, g = b(r.name, void 0, this._chartWidget.model().model());
						if (y(g, l), i.overrides)
							for (var _ in i.overrides) g[_] ? g[_].mergeAndFire(i.overrides[_]) : o(r.name) && -1 !== ["profitLevel", "stopLevel"].indexOf(_) && g.addProperty(_, i.overrides[_]);
						if (void 0 !== g.text && i.text && g.text.setValue(i.text), g.hasChild("filled") && i.filled && g.filled.setValue(!0), null !== (u = i.disableUndo ? (d = this._chartWidget.model().model()).createLineTool(c, h[0], r.name, g, void 0, l) : (d = this._chartWidget.model()).createLineTool({
								pane: c,
								point: h[0],
								linetool: r.name,
								properties: g,
								ownerSource: l
							}))) {
							if (o(r.name)) {
								if (h.length > 2) throw new Error("Wrong points count for " + i.shape + ". Required 1 or 2");
								2 === h.length && (u.startChanging(1, h[1]), u.setPoint(1, h[1]), u.endChanging())
							} else {
								var p = u.pointsCount();
								if (p !== h.length && -1 !== p) throw new Error("Wrong points count for " + i.shape + ". Required " + p);
								for (var S = new A(void 0, !0), v = T(r.name), f = 1; f < h.length && this._chartWidget.model().lineBeingCreated(); f++) u.setLastPoint(h[f]), d.continueCreatingLine(h[f], S, f < h.length - 1 || v);
								I(r.name) && (u.finish(), d.finishLineTool(u), d.continueCreatingLine(h[h.length - 1], S, !1))
							}
							if (i.lock && u.setUserEditEnabled(!1), i.disableSelection && u.setSelectionEnabled(!1), i.disableSave && (u.customization.disableSave = !0), i.hasOwnProperty("showInObjectsTree") && (u.customization.showInObjectsTree = i.showInObjectsTree), i.zOrder) {
								var C = this._chartWidget.model().availableZOrderOperations([u]);
								"top" === i.zOrder && C.bringToFrontEnabled ? d.bringToFront([u]) : "bottom" === i.zOrder && C.sendToBackEnabled && d.sendToBack([u])
							}
							return u.id()
						}
					}
				}
				getShapeById(e) {
					var t = this._chartWidget.model().model().getLineToolById(e);
					if (null === t) throw new Error("There is no such shape");
					return this._getLineDataSourceApi(t)
				}
				createStudy(e, t, i, r, n, s) {
					if ("function" == typeof n) return console.warn('"createStudy" does not take "callback" parameter anymore'), Promise.resolve(null);
					if (s = s || {}, "string" != typeof e) return this._createStudy(e);
					if (s.checkLimit && !this._chartWidget.model().canCreateStudy()) return _(), Promise.resolve(null);
					e = e.toLowerCase();
					var a = s.disableUndo ? this._chartWidget.model().model() : this._chartWidget.model(),
						o = undefined.findStudyMetaInfoByDescription(a.studiesMetaData(), e),
						l = a.createStudyInserter({
							type: "java",
							studyId: o.id
						});
					if (l.setForceOverlay(t), s.priceScale && l.setPreferredPriceScale(function(e) {
							switch (e) {
								case "no-scale":
									return "overlay";
								case "as-series":
									return "as-series";
								case "new-left":
									return "left";
								case "new-right":
									return "right";
								default:
									throw new Error('The pricescale "' + e + '" is invalid, the only valid options are "no-scale", "as-series", "new-left" and "new-right".')
							}
						}(s.priceScale)), s.allowChangeCurrency && l.setAllowChangeCurrency(!0), s.allowChangeUnit && l.setAllowChangeUnit(!0), Array.isArray(r)) {
						console.warn("Passing study inputs as an ordered array is now deprecated. Please use an object where keys correspond to the inputs of your study instead.");
						for (var c = {}, h = 0; h < o.inputs.length; ++h) c[o.inputs[h].id] = r[h];
						r = c
					}
					return l.insert((function() {
						return Promise.resolve({
							inputs: r || {}
						})
					})).then((function(e) {
						return n && undefined(e, n), i && e.setUserEditEnabled(!1), e.id()
					}))
				}
				getStudyById(e) {
					var t = this._chartWidget.model().model().getStudyById(e);
					if (null === t) throw new Error("There is no such study");
					return this._getStudyApi(t)
				}
				getSeries() {
					var e = this._chartWidget.model(),
						t = e.mainSeries();
					return new c(t, e)
				}
				chartType() {
					return this._chartWidget.model().mainSeries().properties().style.value()
				}
				priceFormatter() {
					return this._chartWidget.model().mainSeries().priceScale().formatter()
				}
				dataReady(e) {
					var t = !this._chartWidget.hasModel() || !this._chartWidget.model().mainSeries() || this._chartWidget.model().mainSeries().data().isEmpty();
					return e && (t ? this.onDataLoaded().subscribe(null, e, !0) : e()), !t
				}
				_onLogicalRangeChanged() {
					var e = this._chartWidget.model().mainSeries(),
						t = e.data().isEmpty();
					if (null !== this._chartWidget.model().timeScale().visibleBarsStrictRange() && t) e.dataEvents().completed().subscribe(this, this._onLogicalRangeChanged, !0);
					else {
						var i = this.getVisibleRange();
						null !== this._prevVisibleRange && v(this._prevVisibleRange, i)[0] || (this._prevVisibleRange = i, this._visibleBarsChanged.fire(i))
					}
				}
				_destroy() {
					super._destroy(), this._chartWidget.hasModel() && this._chartWidget.model().timeScale().logicalRangeChanged().unsubscribe(this, this._onLogicalRangeChanged)
				}
				setTimezone(e) {
					this._chartWidget.setTimezone(e)
				}
				getTimezone() {
					return this._chartWidget.getTimezone()
				}
				getPanes() {
					return this._chartWidget.model().chartModel().panes().map((function(e) {
						return this._getPaneApi(e)
					}), this)
				}
				canZoomOut() {
					return !this._chartWidget.model().zoomStack().isEmpty()
				}
				zoomOut() {
					this.canZoomOut() && this._chartWidget.model().zoomFromViewport()
				}
				shapesGroupController() {
					return new C(this._chartWidget.model().lineToolsGroupController(), this._chartWidget.model())
				}
				requestSelectBar() {
					if (this.isSelectBarRequested()) return Promise.reject("already requested");
					var e = this;
					return new Promise((function(t, i) {
						e._chartWidget.requestSelectPoint({
							pointType: "time"
						}).then((function(i) {
							t(e._convertTimeToPublic(i.point.time))
						})).catch((function() {
							i("cancelled")
						}))
					}))
				}
				cancelSelectBar() {
					this.isSelectBarRequested() && this._chartWidget.cancelRequestSelectPoint()
				}
			}
		},
		914554: (e, t, i) => {
			i.d(t, {
				LineToolsGroupControllerApi: () => a
			});
			var r = i(534953),
				n = i(588537),
				s = i(540968);
			class a {
				constructor(e, t) {
					this._controller = e, this._model = t
				}
				createGroupFromSelection() {
					return this._controller.createGroupFromSelection().id
				}
				removeGroup(e) {
					const t = (0, n.ensureDefined)(this._groupById(e));
					this._controller.removeGroup(t)
				}
				groups() {
					return this._controller.groups().map((e => e.id))
				}
				shapesInGroup(e) {
					const t = (0, n.ensureDefined)(this._groupById(e));
					return (0, r.sortSources)(t.lineTools()).map((e => e.id()))
				}
				excludeShapeFromGroup(e, t) {
					const i = (0, n.ensureDefined)(this._groupById(e)),
						r = (0, n.ensureNotNull)(this._model.dataSourceForId(t));
					(0, n.assert)((0, s.isLineTool)(r), "Passed shapeId is not a line tool"), this._controller.excludeLineToolFromGroup(i, r)
				}
				addShapeToGroup(e, t) {
					const i = (0, n.ensureDefined)(this._groupById(e)),
						r = (0, n.ensureNotNull)(this._model.dataSourceForId(t));
					(0, n.assert)((0, s.isLineTool)(r), "Passed shapeId is not a line tool"), this._controller.addLineToolToGroup(i, r)
				}
				availableZOrderOperations(e) {
					const t = (0, n.ensureDefined)(this._groupById(e));
					return this._controller.availableZOrderOperations(t)
				}
				bringToFront(e) {
					const t = (0, n.ensureDefined)(this._groupById(e));
					this._controller.bringToFront(t)
				}
				bringForward(e) {
					const t = (0, n.ensureDefined)(this._groupById(e));
					this._controller.bringForward(t)
				}
				sendBackward(e) {
					const t = (0, n.ensureDefined)(this._groupById(e));
					this._controller.sendBackward(t)
				}
				sendToBack(e) {
					const t = (0,
						n.ensureDefined)(this._groupById(e));
					this._controller.sendToBack(t)
				}
				insertAfter(e, t) {
					const i = (0, n.ensureDefined)(this._groupById(e)),
						r = (0, n.ensureNotNull)(this._groupById(t) || this._model.dataSourceForId(t));
					this._controller.insertAfter(i, r)
				}
				insertBefore(e, t) {
					const i = (0, n.ensureDefined)(this._groupById(e)),
						r = (0, n.ensureNotNull)(this._groupById(t) || this._model.dataSourceForId(t));
					this._controller.insertBefore(i, r)
				}
				groupVisibility(e) {
					return (0, n.ensureDefined)(this._groupById(e)).visibility()
				}
				setGroupVisibility(e, t) {
					const i = (0, n.ensureDefined)(this._groupById(e));
					this._controller.setGroupVisibility(i, t)
				}
				groupLock(e) {
					return (0, n.ensureDefined)(this._groupById(e)).locked()
				}
				setGroupLock(e, t) {
					const i = (0, n.ensureDefined)(this._groupById(e));
					this._controller.setGroupLock(i, t)
				}
				getGroupName(e) {
					return (0, n.ensureDefined)(this._groupById(e)).name()
				}
				setGroupName(e, t) {
					const i = (0, n.ensureDefined)(this._groupById(e));
					this._controller.setGroupName(i, t)
				}
				canBeGroupped(e) {
					const t = e.map((e => (0, n.ensureNotNull)(this._model.dataSourceForId(e))));
					return !t.some((e => !(0, s.isLineTool)(e))) && this._controller.canBeGroupped(t)
				}
				_groupById(e) {
					return this._controller.groups().find((t => t.id === e))
				}
			}
		},
		713917: (e, t, i) => {
			i.d(t, {
				AbstractJsonStoreService: () => s,
				CommonJsonStoreService: () => a
			});
			var r = i(97639),
				n = i.n(r);
			class s {
				constructor(e, t, i, r, s) {
					this._onChange = new(n()), this._handleChange = () => {
						this._onChange.fire(this.get())
					}, this._crossTabEvents = e, this._jsonKeyValueStore = t, this.CROSSTAB_EVENT_NAME = i, this.JSON_STORE_KEY = r, this.defaultStoreValue = this._serialize(s), this._subscribe()
				}
				get() {
					const e = this._jsonKeyValueStore.getJSON(this.JSON_STORE_KEY, this.defaultStoreValue);
					return this._deserialize(e)
				}
				set(e, t) {
					const i = this._serialize(e);
					this._jsonKeyValueStore.setJSON(this.JSON_STORE_KEY, i, t), this._crossTabEvents.emit(this.CROSSTAB_EVENT_NAME), this._onChange.fire(e)
				}
				getOnChange() {
					return this._onChange
				}
				destroy() {
					this._unsubscribe(), this._onChange.destroy(), delete this._onChange
				}
				_subscribe() {
					this._crossTabEvents.on(this.CROSSTAB_EVENT_NAME, this._handleChange), this._jsonKeyValueStore.onSync.subscribe(this, this._handleChange)
				}
				_unsubscribe() {
					this._crossTabEvents.off(this.CROSSTAB_EVENT_NAME, this._handleChange), this._jsonKeyValueStore.onSync.unsubscribe(this, this._handleChange)
				}
			}
			class a extends s {
				_serialize(e) {
					return e
				}
				_deserialize(e) {
					return e
				}
			}
		},
		231780: (e, t, i) => {
			var r = i(828336),
				n = i(810468);

			function s(e) {
				this._chartApiInstance = e
			}
			s.prototype.searchSymbols = function(e, t, i, r, n, s) {
					this._chartApiInstance.searchSymbols(e, t, i, r, n, !1, void 0, !1, null, function(e) {
						e.forEach((function(e) {
							e.flag = this.getFlagIdBySymbolExt(e)
						}), this), s(e)
					}.bind(this))
				}, s.prototype.displayedExchanges = function() {
					var e = r.displayedExchangesFilter(this.supportedExchanges());
					return r.sortExchangesListByFlagIfNeeded(e)
				}, s.prototype.supportedExchanges = function() {
					return this._chartApiInstance.supportedExchangesList()
				}, s.prototype.supportedSymbolsTypes = function() {
					return this._chartApiInstance.supportedSymbolsTypes()
				}, s.prototype.getFlagIdBySymbolExt = function(e) {
					return n.getFlagIdBySymbolInfo(e)
				},
				s.prototype.getFlagIdByExchangeInfo = function(e) {
					return e ? n.getFlagIdByName(e.flag) : ""
				}, e.exports = s
		},
		828336: (e, t, i) => {
			var r, n = i(611688),
				s = i(810468);
			r = function(e, t) {
				var i = new RegExp("country-([a-z*_]+)", "i"),
					r = s.supportedFlags().filter((function(e) {
						return "forex" !== e && "bitcoin" !== e && "crypto" !== e
					})).sort(),
					n = ["forex", "country-usa", "country-canada", "country-ae", "country-uk", "country-europe", "country-germany", "country-ireland", "country-italy", "country-luxembourg", "country-austria", "country-norway", "country-spain", "country-poland", "country-sweden", "country-switzerland", "country-turkey", "country-israel", "country-argentina", "country-australia", "country-brasil", "country-mexico", "country-peru", "country-chile", "country-colombia", "country-new_zealand", "country-brasil", "country-india", "country-japan", "country-china", "country-hong_kong", "country-singapore", "country-taiwan", "country-russia", "country-malaysia", "country-bahrain", "country-egypt", "country-saudi_arabia", "country-serbia", "country-*", "bitcoin", "crypto"];
				t && t.order && (n = t.order);
				var a = {};
				s.supportedFlags().forEach((function(e) {
					a[e] = []
				}));
				var o = [];

				function l(e) {
					var t = a[e];
					t && (o = o.concat(t.sort((function(e, t) {
						return e.name.localeCompare(t.name)
					}))), delete a[e])
				}
				return e.forEach((function(e) {
					e.flag && a[e.flag].push(e), e.value || o.push(e)
				})), n.forEach((function(e) {
					if ("forex" === e || "bitcoin" === e || "crypto" === e) l(e);
					else {
						var t = i.exec(e),
							n = t && t[1];
						"*" === n ? r.forEach((function(e) {
							l(e)
						})) : l(n)
					}
				})), Object.keys(a).forEach((function(e) {
					l(e)
				})), o
			}, e.exports.displayedExchangesFilter = function(e) {
				return n.enabled("symbol_search_limited_exchanges") && (e = e.filter((function(e) {
					return !("bitcoin" === e.flag || "crypto" === e.flag || e.hideInSymbolSearch)
				}))), e
			}, e.exports.sortExchangesListByFlagIfNeeded = function(e) {
				return n.enabled("symbol_search_flags") && (e = r(e)), e
			}
		},
		810468: (e, t, i) => {
			var r = i(519073).hasCryptoTypespec,
				n = {
					ae: "flag-ae",
					argentina: "flag-ar",
					canada: "flag-ca",
					colombia: "flag-co",
					bitcoin: "flag-btc",
					brasil: "flag-br",
					uk: "flag-uk",
					gb: "flag-uk",
					usa: "flag-us",
					egypt: "flag-eg",
					europe: "flag-eu",
					russia: "flag-ru",
					japan: "flag-jp",
					indonesia: "flag-id",
					india: "flag-in",
					forex: "flag-fx",
					luxembourg: "flag-lu",
					mexico: "flag-mx",
					germany: "flag-de",
					ireland: "flag-ie",
					italy: "flag-it",
					qatar: "flag-qa",
					peru: "flag-pe",
					spain: "flag-es",
					saudi_arabia: "flag-sa",
					serbia: "flag-rs",
					south_africa: "flag-za",
					sweden: "flag-se",
					switzerland: "flag-ch",
					turkey: "flag-tr",
					norway: "flag-no",
					austria: "flag-at",
					australia: "flag-au",
					new_zealand: "flag-nz",
					hong_kong: "flag-hk",
					taiwan: "flag-tw",
					thailand: "flag-th",
					singapore: "flag-sg",
					south_korea: "flag-kr",
					poland: "flag-pl",
					israel: "flag-il",
					chile: "flag-cl",
					china: "flag-cn",
					malaysia: "flag-my",
					bahrain: "flag-bh",
					nigeria: "flag-ng",
					finland: "flag-fi",
					iceland: "flag-is",
					denmark: "flag-dk",
					lithuania: "flag-lt",
					estonia: "flag-ee",
					latvia: "flag-lv",
					vietnam: "flag-vn",
					netherlands: "flag-nl",
					belgium: "flag-be",
					portugal: "flag-pt",
					france: "flag-fr",
					greece: "flag-gr",
					korea: "flag-kr",
					philippines: "flag-ph"
				},
				s = {
					gb: "flag-uk"
				},
				a = {
					FXCM: !0,
					OANDA: !0,
					FOREXCOM: !0,
					"FOREX.com": !0,
					FX_IDC: !0,
					FX: !0,
					IDC: !0
				};

			function o(e) {
				return e ? s[e] || "flag-" + e : ""
			}
			e.exports.supportedFlags = function() {
				return Object.keys(n)
			}, e.exports.getFlagIdByName = function(e) {
				return e && n[e] ? n[e] : ""
			}, e.exports.getFlagIdBySymbolInfo = function(e) {
				if (!e) return "";
				var t = "";
				if (e.country) t = o(e.country && e.country.toLowerCase());
				else if (e.rootItem) {
					t = o(e.rootItem.country && e.rootItem.country.toLowerCase())
				} else "forex" === e.type || !0 === a[e.exchange] ? t = "flag-fx" : r(e.type, e.typespecs || []) && (t = "flag-btc");
				return t
			}
		},
		210081: (e, t, i) => {
			i.d(t, {
				TradingViewApiBase: () => f
			});
			i(588537);
			var r = i(583912),
				n = i(611688),
				s = i(333126),
				a = i(84123),
				o = i(981033),
				l = i(103669),
				c = i(988534),
				h = i(388482),
				d = i(290382),
				u = i(345848),
				g = i(440135),
				m = i(909740),
				_ = i(97639),
				p = i.n(_);
			class S {
				constructor(e) {
					this._toolbarThemeChanged = new(p()), this._onWatchedThemeChanged = e => {
						this._toolbarThemeChanged.fire(e)
					}, this._opts = e, m.watchedTheme.subscribe(this._onWatchedThemeChanged)
				}
				destroy() {
					m.watchedTheme.unsubscribe(this._onWatchedThemeChanged)
				}
				isStdTheme() {
					const e = this._opts.chartWidgetCollection.getAll().every((e => (0, g.isStdTheme)((0, g.extractThemeFromModel)(e.model()))));
					return Promise.resolve(e)
				}
				async setStdTheme(e, t = !0, i) {
					await (0, g.loadTheme)(this._opts.chartWidgetCollection, {
						themeName: e,
						standardTheme: !0,
						syncState: t,
						noUndo: i
					})
				}
				setStdThemeForLayout(e, t = !0) {
					(0, m.setTheme)(e), t && (0, g.syncTheme)()
				}
				getCurrentThemeName() {
					return (0, g.getCurrentTheme)().name
				}
				toolbarThemeChanged() {
					return this._toolbarThemeChanged
				}
			}
			var v = i(741511),
				b = i(308170);

			function y() {
				throw new Error("not implemented")
			}
			class f {
				constructor(e) {
					this._studyTemplatesDrawer = null, this._fontIconsSettingsDrawer = null, this._favoriteDrawingsToolbar = null, this._themesApi = null, this._newsApiDeferredPromise = null, this._newsApiRejectionReason = null, this._watchlistApiDeferredPromise = null, this._watchlistApiRejectionReason = null, this._widgetbarApiDeferredPromise = null, this._widgetbarApiRejectionReason = null, this._isDestroyed = !1, this._widgebarApi = null;
					const {
						chartApiInstance: t,
						chartWidgetCollection: i,
						studyMarket: n,
						financialsDialog: s,
						saveChartService: c,
						loadChartService: h,
						sharingChartService: d = null
					} = e;
					this._chartWidgetCollection = i, this._studyMarket = n, this._financialsDialog = s, this._saveChartService = c, this._sharingChartService = d, this._loadChartLayoutDialog = h, this._intervalsService = new a.IntervalsService(t), this._alertsWidgetDialog = new o.AlertsWidgetDialog((() => i.activeChartWidget.value())), this._detailsDialogController = l.DetailsDialogController.getInstance(), this._supportedChartStylesSpawn = r.linking.supportedChartStyles.spawn(), this._chartWidgetCollection.onAboutToBeDestroyed.subscribe(null, (() => this.destroy()), !0)
				}
				destroy() {
					var e, t, i;
					this._supportedChartStylesSpawn.destroy(), null === (e = this._intervalsService) || void 0 === e || e.destroy(), null === (t = this._themesApi) || void 0 === t || t.destroy(), null === (i = this._widgebarApi) || void 0 === i || i.destroy(), this._widgetbarApiRejectionReason = "This ITradingViewApi instance has been destroyed", this._isDestroyed = !0
				}
				themes() {
					return null === this._themesApi && (this._themesApi = new S({
						chartWidgetCollection: this._chartWidgetCollection
					})), this._themesApi
				}
				dialogs() {
					var e, t, i, r, n, a;
					return {
						Indicators: this._studyMarket,
						Financials: this._financialsDialog,
						Compare: this._chartWidgetCollection.getCompareDialogRenderer(),
						ObjectsTree: s.ObjectTreeDialogController.getInstance(),
						ChartProperties: this._chartWidgetCollection.getChartPropertiesDialogRenderer(),
						ChartLayoutSaveAs: null !== (t = null === (e = this._saveChartService) || void 0 === e ? void 0 : e.getSaveAsController()) && void 0 !== t ? t : null,
						ChartLayoutRename: null !== (r = null === (i = this._saveChartService) || void 0 === i ? void 0 : i.getRenameController()) && void 0 !== r ? r : null,
						ChartLayoutCreate: null !== (a = null === (n = this._saveChartService) || void 0 === n ? void 0 : n.getCreateController()) && void 0 !== a ? a : null,
						ChartLayoutLoad: this._loadChartLayoutDialog,
						Alerts: this._alertsWidgetDialog,
						Details: this._detailsDialogController,
						FinancialsCharts: c.FinancialsDialogController.getInstance()
					}
				}
				studyTemplatesDrawerApi() {
					return Promise.all([i.e(90519), i.e(37135), i.e(5979), i.e(21834), i.e(95468), i.e(29331), i.e(74733), i.e(11812), i.e(73327), i.e(44177), i.e(32256), i.e(55893), i.e(75514), i.e(17170)]).then(i.bind(i, 916838)).then((e => (this._studyTemplatesDrawer || (this._studyTemplatesDrawer = new e.ToolWidgetTemplatesDrawerMenuRenderer(this._chartWidgetCollection)), this._studyTemplatesDrawer)))
				}
				fontIconsSettingsDrawer() {
					return Promise.all([i.e(90519), i.e(21834), i.e(29331), i.e(22647), i.e(86292), i.e(75514), i.e(64558)]).then(i.bind(i, 997116)).then((e => (this._fontIconsSettingsDrawer || (this._fontIconsSettingsDrawer = new e.IconsSettingsDrawerApi), this._fontIconsSettingsDrawer)))
				}
				intervalsService() {
					return this._intervalsService
				}
				supportedChartTypes() {
					return this._supportedChartStylesSpawn
				}
				setBrokerName(e) {
					this._chartWidgetCollection.setBroker(e)
				}
				drawOnAllChartsMode(e) {
					(0, b.drawOnAllChartsMode)().setValue(e)
				}
				disableTrackingEvents() {
					(0, u.disableTrackingEvents)()
				}
				getSaveChartService() {
					return this._saveChartService
				}
				setSymbolSearchUI(e) {
					d.SymbolSearchUI.setProvider({
						getSymbol: () => e.getSymbol()
					})
				}
				setLayout(e, t) {
					(null == t ? void 0 : t.withUndo) ? this._chartWidgetCollection.setChartLayoutWithUndo(e): this._chartWidgetCollection.setLayout(e)
				}
				selectLineTool(e, t) {
					if (!v.supportedLineTools[e]) return;
					const i = v.supportedLineTools[e].name;
					if ("icon" === e) {
						const e = null == t ? void 0 : t.icon;
						void 0 !== e && b.iconTool.setValue(e)
					}
					b.tool.setValue(i)
				}
				favoriteDrawingsToolbar() {
					return Promise.all([i.e(94349), i.e(65551)]).then(i.bind(i, 726481)).then((e => (this._favoriteDrawingsToolbar || (this._favoriteDrawingsToolbar = new e.FavoriteDrawingsApi), this._favoriteDrawingsToolbar)))
				}
				sharingChart() {
					return this._sharingChartService
				}
				watchlist() {
					y()
				}
				setWatchlistApiPromise(e) {
					y()
				}
				news() {
					y()
				}
				setNewsApiPromise(e) {
					y()
				}
				widgetbar() {
					y()
				}
				setWidgetbarApiPromise(e) {
					y()
				}
				getChartStorage() {
					return (0, h.getChartStorage)()
				}
				setDebugMode(e) {
					n.setEnabled("charting_library_debug_mode", e)
				}
			}
		},
		108494: (e, t, i) => {
			var r = i(97639),
				n = i(262325),
				s = i(583912).linking,
				a = (i(579917).createDeferredPromise,
					i(982405)),
				o = i(467608).layouts,
				l = i(251954),
				c = i(1891).ContextMenuManager,
				h = i(308170),
				d = i(364019),
				u = i(147731).backend,
				g = i(911905),
				m = i(779923).showWarning,
				_ = i(779923).showConfirm,
				p = i(741511),
				S = i(332450).CLOSE_POPUPS_AND_DIALOGS_COMMAND,
				v = i(273044).Interval,
				b = i(346090).saveDefaultProperties,
				y = i(911730).ChartChangesWatcher,
				f = i(210081).TradingViewApiBase,
				C = (i(970028).StudyMetaInfo, i(591316).getStudyInputsInfo, i(443403).getStudyStylesInfo, i(63208).CollectionViewMode),
				w = i(231780),
				T = i(501867),
				I = i(246433).ConnectionStatus,
				A = i(110933),
				W = A.tradingService,
				P = A.waitTradingService,
				D = i(360025).publishChart,
				L = i(360025).setPublishChartOptions,
				E = i(619101).showSupportDialog,
				M = i(901285),
				k = M.openMobileChartPickerCommand,
				R = M.closeMobileChartPickerCommand,
				F = i(915150).AlertService,
				O = i(66066).ReplayApi,
				x = i(629588),
				V = x.createGoProDialog,
				U = x.onGoProDialog;
			e.exports = class extends f {
				constructor(e) {
					const {
						chartWidgetCollection: t,
						saveChartService: i,
						loadChartService: n,
						sharingChartService: a,
						alertsDispatcher: o,
						supportTicketData: l,
						favoriteServices: c,
						chartApiInstance: h = null,
						studyMarket: d = null,
						financialsDialog: u = null
					} = e;
					super({
						chartApiInstance: h,
						chartWidgetCollection: t,
						studyMarket: d,
						financialsDialog: u,
						saveChartService: i,
						loadChartService: n,
						sharingChartService: a
					}), this._chartApiInstance = h, this._loadChartService = n, this._alertsDispatcher = o, this._supportTicketData = l, this._favoriteServices = c, this._proxyWatchListChangedDelegate = null, this._lockDrawingsWatchedValue = null, this._hideDrawingsWatchedValue = null, this._hideIndicatorsWatchedValue = null, this._magnetEnabledWatchedValue = null, this._magnetModeWatchedValue = null, this._replayApi = null, this._chartChangesWatcher = null, this._hasChartChangesWatchedValue = null, this._getDataSourceHub = function() {
						return t.activeChartWidget.value().model().model()
					}, this._chartWidgetCollection.getResizerDetacher = function() {
						return t.activeChartWidget.value().getResizerDetacher()
					}, this._alertService = this._alertsDispatcher ? new F(this._alertsDispatcher, this._getDataSourceHub) : null, this._activeChangedChangedDelegate = new r, this._chartWidgetCollection.activeChartWidget.subscribe(function() {
						this._activeChangedChangedDelegate.fire()
					}.bind(this)), this._chartWidgets = new WeakMap, this._activateChart = function(e) {
						t.activeChartWidget.setValue(e)
					}, this.linking = s
				}
				subscribe(e, t) {
					l.subscribe(e, t)
				}
				unsubscribe(e, t) {
					l.unsubscribe(e, t)
				}
				onContextMenu(e) {
					l.subscribe("onContextMenu", (function(t) {
						t.callback(e(t.unixtime, t.price))
					}))
				}
				onGrayedObjectClicked(e) {
					l.subscribe("onGrayedObjectClicked", e)
				}
				activeChart() {
					return this._getChartWidgetApi(this._chartWidgetCollection.activeChartWidget.value())
				}
				_getChartWidgetApi(e) {
					var t = this._chartWidgets.get(e);
					return void 0 === t && (t = new a(e, this._activateChart.bind(null, e)), this._chartWidgets.set(e, t)), t
				}
				onActiveChartChanged() {
					return this._activeChangedChangedDelegate
				}
				changeSymbol(e, t, i) {
					s.interval.setValue(v.normalize(t)), s.symbol.setValue(e), i && this.activeChart().onDataLoaded().subscribe(null, i, !0)
				}
				layout() {
					return this._chartWidgetCollection.layout.value()
				}
				layoutName() {
					return this._chartWidgetCollection.metaInfo.name.value()
				}
				layoutNameWatchedValue() {
					return this._chartWidgetCollection.metaInfo.name.readonly()
				}
				layoutSettingsDrawer() {
					return Promise.all([i.e(21834), i.e(29331), i.e(24817), i.e(86193), i.e(91488), i.e(85775), i.e(8800), i.e(75514), i.e(45289)]).then(i.bind(i, 126582)).then(function(e) {
						return this._layoutSettingsDrawer || (this._layoutSettingsDrawer = new e.LayoutSettingsDrawerApi(this._chartWidgetCollection)), this._layoutSettingsDrawer
					}.bind(this))
				}
				chartsCount() {
					return o[this.layout()].count
				}
				viewMode() {
					return this._chartWidgetCollection.viewMode.readonly().value()
				}
				viewModeWatchedValue() {
					return this._chartWidgetCollection.viewMode.readonly()
				}
				setForceFullscreenMode() {
					this._chartWidgetCollection.setViewMode(C.ForceFullscreen), this._chartWidgetCollection.getResizerDetacher().requestFullscreen()
				}
				setMultichartMode() {
					this._chartWidgetCollection.setViewMode(C.Multichart), this._chartWidgetCollection.getResizerDetacher().exitFullscreen()
				}
				setActiveChart(e) {
					if (e >= 0 && e < this.chartsCount()) {
						var t = this._chartWidgetCollection.getAll()[e];
						t && (this._chartWidgetCollection.getResizerDetacher().fullscreen.value() ? t.requestFullscreen() : this._chartWidgetCollection.activeChartWidget.setValue(t))
					}
				}
				chart(e) {
					if (void 0 === e && (e = 0), e < 0 || e >= this.chartsCount()) throw Error("Incorrect index: " + e);
					return this._getChartWidgetApi(this._chartWidgetCollection.getAll()[e])
				}
				getSymbolInterval(e) {
					var t = {
						symbol: s.symbol.value(),
						interval: s.interval.value()
					};
					return e && e(t), t
				}
				saveChart(e) {
					if (this._saveChartService) {
						var t = this;
						this._saveChartService.whenReadyToSave((function() {
							var i = t._saveChartService.saveToJSON();
							return e && e(JSON.parse(i.content))
						}))
					}
				}
				loadChart(e) {
					throw new Error("Not implemented")
				}
				getStudiesList() {
					throw new Error("Not implemented")
				}
				getStudyInputs(e) {
					throw new Error("Not implemented")
				}
				getStudyStyles(e) {
					throw new Error("Not implemented")
				}
				getSavedCharts(e) {
					u.getCharts().then(e)
				}
				loadChartFromServer(e) {
					u.loadChart(e)
				}
				saveChartToServer(e, t, i) {
					this._saveChartService && this._saveChartService.saveChartSilently(e, t, i)
				}
				setAutosave(e) {
					this._saveChartService && this._saveChartService.autoSaveEnabled().setValue(e)
				}
				removeChartFromServer(e, t) {
					u.removeChart(e).then(t)
				}
				getIntervals() {
					var e = [],
						t = d.getCustomResolutions();
					return null !== this._chartApiInstance && (e = this._chartApiInstance.defaultResolutions()), d.mergeResolutions(e, t)
				}
				closePopupsAndDialogs() {
					c.hideAll(), l.emit(S)
				}
				selectedLineTool() {
					for (var e = Object.keys(p.supportedLineTools), t = h.tool.value(), i = 0; i < e.length; ++i)
						if (p.supportedLineTools[e[i]].name === t) return e[i];
					return ""
				}
				lockAllDrawingTools() {
					return null === this._lockDrawingsWatchedValue && (this._lockDrawingsWatchedValue = new n(h.lockDrawings().value()), this._lockDrawingsWatchedValue.subscribe((function(e) {
						h.lockDrawings().setValue(e)
					})), h.lockDrawings().subscribe(this, (function() {
						this._lockDrawingsWatchedValue.setValue(h.lockDrawings().value())
					}))), this._lockDrawingsWatchedValue
				}
				hideAllDrawingTools() {
					return null === this._hideDrawingsWatchedValue && (this._hideDrawingsWatchedValue = new n(h.hideAllDrawings().value()), this._hideDrawingsWatchedValue.subscribe((function(e) {
						h.hideAllDrawings().setValue(e)
					})), h.hideAllDrawings().subscribe(this, (function() {
						this._hideDrawingsWatchedValue.setValue(h.hideAllDrawings().value())
					}))), this._hideDrawingsWatchedValue
				}
				hideAllIndicators() {
					return null === this._hideIndicatorsWatchedValue && (this._hideIndicatorsWatchedValue = new n(h.hideAllIndicators().value()), this._hideIndicatorsWatchedValue.subscribe((function(e) {
						h.hideAllIndicators().setValue(e)
					})), h.hideAllIndicators().subscribe(this, (function() {
						this._hideIndicatorsWatchedValue.setValue(h.hideAllIndicators().value())
					}))), this._hideIndicatorsWatchedValue
				}
				magnetEnabled() {
					return null === this._magnetEnabledWatchedValue && (this._magnetEnabledWatchedValue = new n(h.properties().magnet.value()), this._magnetEnabledWatchedValue.subscribe((function(e) {
						b(!0), h.properties().magnet.setValue(e), b(!1)
					})), h.properties().magnet.subscribe(this, (function() {
						this._magnetEnabledWatchedValue.setValue(h.properties().magnet.value())
					}))), this._magnetEnabledWatchedValue
				}
				magnetMode() {
					return null === this._magnetModeWatchedValue && (this._magnetModeWatchedValue = new n(h.properties().magnetMode.value()), this._magnetModeWatchedValue.subscribe((function(e) {
						b(!0), h.properties().magnetMode.setValue(e), b(!1)
					})), h.properties().magnetMode.subscribe(this, (function() {
						this._magnetModeWatchedValue.setValue(h.properties().magnetMode.value())
					}))), this._magnetModeWatchedValue
				}
				mainSeriesPriceFormatter() {
					return this._chartWidgetCollection.activeChartWidget.value().model().mainSeries().priceScale().formatter()
				}
				showNoticeDialog(e) {
					m({
						title: (e = e || {}).title,
						text: e.body || "",
						onClose: e.callback
					})
				}
				showConfirmDialog(e) {
					if (!(e = e || {}).callback) throw Error("callback must be exist");
					var t = e.callback;

					function i(e) {
						t && (t(e), t = null)
					}
					_({
						title: e.title,
						text: e.body || "",
						onClose: function() {
							i(!1)
						},
						onConfirm: function(e) {
							i(!0), e.dialogClose()
						}
					})
				}
				logs() {
					return {
						getLogHistory: g.getLogHistory,
						enable: g.loggingOn,
						disable: g.loggingOff
					}
				}
				showLoadChartDialog() {
					var e = this._loadChartService;
					e && e.showLoadDialog()
				}
				showSaveAsChartDialog() {
					var e = this._saveChartService;
					e && window.runOrSignIn((function() {
						e.saveChartAs()
					}), {
						source: "Save as chart dialogue"
					})
				}
				drawOnAllCharts(e) {
					return h.drawOnAllCharts().setValue(e)
				}
				undoRedoState() {
					return this._chartWidgetCollection.undoHistory.state()
				}
				clearUndoHistory() {
					return this._chartWidgetCollection.undoHistory.clearStack()
				}
				undo() {
					return this._chartWidgetCollection.undoHistory.undo()
				}
				redo() {
					return this._chartWidgetCollection.undoHistory.redo()
				}
				trading() {
					return W()
				}
				waitTrading() {
					return P()
				}
				symbolSearch() {
					return this._chartApiInstance ? new w(this._chartApiInstance) : null
				}
				saveChartOrShowTitleDialog(e, t, i) {
					var r = this._saveChartService;
					r && r.saveChartOrShowTitleDialog(e, t, i)
				}
				showRenameChartDialog() {
					var e = this._saveChartService;
					e && e.renameChart()
				}
				setUserInfo(e) {
					e && (!1 === e.profile_data_filled && delete e.profile_data_filled, window.loginUser(e))
				}
				connect() {
					this._chartApiInstance.connected() || this._chartApiInstance.connect(), T.forceConnect()
				}
				disconnect() {
					this._chartApiInstance.connected() && this._chartApiInstance.disconnect(), T.isConnected() && T.disconnect()
				}
				loginRequired() {
					return window.loginRequiredDelegate
				}
				onConnectionStatusChanged(e) {
					T.onStatus(e)
				}
				isConnected() {
					return T.status() === I.Open
				}
				showCreateAlertDialog() {
					this._alertsDispatcher && this._alertsDispatcher.openCreateDialog({
						dataSourceHub: this._getDataSourceHub(),
						actionSource: "tv_api"
					})
				}
				alertService() {
					return this._alertService
				}
				publishChart(e) {
					return D(e, !1)
				}
				setPublishChartOptions(e) {
					L(e)
				}
				showSupportDialog() {
					E()
				}
				openMobileChartPicker() {
					l.emit(k)
				}
				closeMobileChartPicker() {
					l.emit(R)
				}
				replayApi() {
					return null === this._chartApiInstance ? Promise.reject(new Error("replay api isn't available")) : null !== this._replayApi ? Promise.resolve(this._replayApi) : Promise.all([i.e(90519), i.e(8348), i.e(37135), i.e(21834), i.e(95468), i.e(82739), i.e(12580), i.e(54792), i.e(81750), i.e(29754), i.e(69184), i.e(55646), i.e(75514), i.e(1462), i.e(80075), i.e(14135), i.e(6932)]).then(i.bind(i, 849740)).then(function(e) {
						return null === this._replayApi && (this._replayApi = new O(new e.ReplayUIController(this._chartWidgetCollection, this._chartApiInstance))), this._replayApi
					}.bind(this))
				}
				takeScreenshot() {
					return this._chartWidgetCollection.takeScreenshot()
				}
				setIntervalLinkingEnabled(e) {
					this._chartWidgetCollection.lock.interval.setValue(e)
				}
				setTimeFrame(e) {
					this._chartWidgetCollection.setTimeFrame(e)
				}
				symbolSync() {
					return this._chartWidgetCollection.lock.symbol
				}
				intervalSync() {
					return this._chartWidgetCollection.lock.interval
				}
				dateRangeSync() {
					return this._chartWidgetCollection.lock.dateRange
				}
				crosshairSync() {
					return this._chartWidgetCollection.lock.crosshair
				}
				timeSync() {
					return this._chartWidgetCollection.lock.trackTime
				}
				startFullscreen() {
					return this._chartWidgetCollection.startFullscreen()
				}
				exitFullscreen() {
					return this._chartWidgetCollection.exitFullscreen()
				}
				takeClientScreenshot(e) {
					return this._chartWidgetCollection.clientSnapshot(e)
				}
				getFavoriteIntervalsService() {
					if (this._favoriteServices) return this._favoriteServices.favoriteIntervalsService;
					throw new Error("not implemented")
				}
				getFavoriteChartStylesService() {
					if (this._favoriteServices) return this._favoriteServices.favoriteChartStylesService;
					throw new Error("not implemented")
				}
				getLinetoolsFavoritesStore() {
					if (this._favoriteServices) return this._favoriteServices.lineToolsFavoritesService;
					throw new Error("not implemented")
				}
				supportTicketData() {
					return this._supportTicketData
				}
				hasChartChanges() {
					return null === this._chartChangesWatcher && null === this._hasChartChangesWatchedValue && (this._chartChangesWatcher = new y(this._chartWidgetCollection, window.saver, l), this._hasChartChangesWatchedValue = new n(this._chartChangesWatcher.hasChanges()), this._chartChangesWatcher.getOnChange().subscribe(this, (function() {
						this._hasChartChangesWatchedValue.setValue(this._chartChangesWatcher.hasChanges())
					}))), this._hasChartChangesWatchedValue
				}
				createGoProDialog(e) {
					V(e)
				}
				onGoProDialog(e, t) {
					U(e, t)
				}
			}
		},
		915150: (e, t, i) => {
			i.d(t, {
				AlertService: () => s
			});
			var r = i(696329);
			const n = "alert_service";
			class s {
				constructor(e, t) {
					this.ALERT_DIALOG_CREATE_INVOCATION_ID = r.ALERT_DIALOG_CREATE_INVOCATION_ID, this._alertsDispatcher = e, this._getDataSourceHub = t
				}
				showCreateAlertDialog() {
					return new Promise(((e, t) => {
						this._alertsDispatcher.openCreateDialog({
							actionSource: n,
							dataSourceHub: this._getDataSourceHub(),
							onDialogOpened: e,
							onAborted: t
						})
					}))
				}
				getAlertDialogInvocations() {
					return this._alertsDispatcher.getAlertDialogInvocations()
				}
				showEditAlertDialog(e) {
					return new Promise(((t, i) => {
						this._alertsDispatcher.openEditDialog(e, {
							actionSource: n,
							onDialogOpened: t,
							onAborted: i
						})
					}))
				}
				restartAlert(e) {
					return new Promise(((t, i) => {
						this._alertsDispatcher.restartAlert(e, {
							actionSource: n,
							success: t,
							error: i
						})
					}))
				}
				cloneAlert(e) {
					return new Promise(((t, i) => {
						this._alertsDispatcher.requestAlert(e, {
							error: i,
							success: e => {
								this._alertsDispatcher.cloneAlert(e, {
									actionSource: n,
									success: t,
									error: i
								})
							}
						})
					}))
				}
				subscribe(e) {
					this._alertsDispatcher.subscribeToPushStream(e)
				}
				unsubscribe(e) {
					this._alertsDispatcher.unsubscribeFromPushStream(e)
				}
			}
		},
		981033: (e, t, i) => {
			i.d(t, {
				AlertsWidgetDialog: () => c
			});
			var r = i(62802),
				n = i.n(r),
				s = i(262325),
				a = i.n(s),
				o = i(920358),
				l = i(539390);
			class c {
				constructor(e) {
					this._isVisible = new(a())(!1), this._activeTab = new(a())(function() {
						const e = n().getValue("alerts.widget_dialog.active_tab");
						return !e || "list" !== e && "log" !== e ? "list" : e
					}()), this._willShow = !1, this._dialogImpl = null, this._getChartWidget = e, this._activeTab.subscribe((e => {
						n().setValue("alerts.widget_dialog.active_tab", e)
					}))
				}
				setTab(e) {
					this._activeTab.setValue(e)
				}
				show() {
					this._willShow || (this._willShow = !0, Promise.all([Promise.all([i.e(10146), i.e(90519), i.e(90926), i.e(8834), i.e(30063), i.e(21834), i.e(80580), i.e(68074), i.e(52498), i.e(82739), i.e(28111), i.e(50522), i.e(91965), i.e(1689), i.e(45410), i.e(2304), i.e(82290), i.e(41134), i.e(34663), i.e(74930), i.e(45152), i.e(12615), i.e(86967), i.e(28812), i.e(56856), i.e(75514), i.e(69397), i.e(82943), i.e(92697), i.e(93827), i.e(84263), i.e(61491)]).then(i.bind(i, 916142)), (0, o.getPriceAlertsDispatcher)(), (0, l.getGlobalAlertFocusedIdTracker)(), Promise.all([i.e(49680), i.e(81579), i.e(46670)]).then(i.bind(i, 181579))]).then((([{
						AlertsWidgetDialogImpl: e
					}, t, i, {
						getUnreadFiresBuffer: r
					}]) => {
						this._willShow && (this._dialogImpl = new e({
							alertsDispatcher: t,
							globalFocusedTracker: i,
							unreadFiresBuffer: r(),
							onClose: () => this.hide(),
							activeTab: this._activeTab,
							getChartWidget: this._getChartWidget
						}), this._isVisible.setValue(!0))
					})))
				}
				hide() {
					this._dialogImpl && (this._dialogImpl.destroy(), this._dialogImpl = null), this._willShow = !1, this._isVisible.setValue(!1)
				}
				visible() {
					return this._isVisible
				}
			}
		},
		539390: (e, t, i) => {
			i.d(t, {
				getGlobalAlertFocusedIdTracker: () => n
			});
			var r = i(920358);
			const n = function(e) {
				let t;
				return () => (t || (t = Promise.all([(0, r.getPriceAlertsDispatcher)(), i.e(68553).then(i.bind(i, 848524))]).then((([t, {
					AlertInteractionStateIdTracker: i
				}]) => new i(t.alerts, e)))), t)
			}("selected")
		},
		364251: (e, t, i) => {
			var r;
			i.d(t, {
					PublishIntroDialogContent: () => r
				}),
				function(e) {
					e.Idea = "ideaPublishing", e.Script = "scriptPublishing", e.Stream = "startStreaming", e.VideoIdea = "videoIdeaPublishing"
				}(r || (r = {}))
		},
		360025: (e, t, i) => {
			i.r(t), i.d(t, {
				publishChart: () => g,
				publishChartWidget: () => m,
				setPublishChartOptions: () => _
			});
			i(823127);
			var r = i(973286),
				n = i(364251),
				s = i(125226),
				a = i(62802),
				o = i(823127);
			const l = "publish.showIntroText";
			let c, h = 0;

			function d() {
				clearTimeout(h),
					o(".publish-chart-button").removeClass("process")
			}
			async function u(e, t) {
				if (!(0, s.isFeatureEnabled)("show_checkbox_of_house_rules_to_idea_and_script")) {
					if (!0 === t || !a.getBool(l, !0)) return window.saver.publishChart(e);
					const {
						createWarningPopup: r
					} = await i.e(63746).then(i.bind(i, 317400)), s = await r({
						type: n.PublishIntroDialogContent.Idea,
						dataDialogName: "publish-intro-dialog"
					});
					a.setValue(l, !s)
				}
				return window.saver.publishChart(e)
			}

			function g(e, t) {
				const i = {
					...e,
					...c
				};
				return new Promise((e => {
					window.runOrSignIn((() => {
						(0, s.isFeatureEnabled)("disable_phone_verification_sms") ? e(u(i, t)): (! function() {
							const e = o(".publish-chart-button");
							0 !== e.length && (e.addClass("process"), h = setTimeout(d, 3e4))
						}(), (0, r.whenVerified)({
							showDialog: !0,
							source: "Publish chart",
							silentPhoneVerification: null == i ? void 0 : i.silentPhoneVerification
						}).done((() => {
							e(u(i, t))
						})).fail((e => (null == i ? void 0 : i.onPublishError) && i.onPublishError(e))).always(d))
					}), {
						source: "Publish chart",
						sourceMeta: "Chart"
					})
				}))
			}

			function m(e) {
				g(e, !0)
			}

			function _(e) {
				c = e
			}
		},
		126974: (e, t, i) => {
			i.d(t, {
				availableTimeFrames: () => a
			});
			var r = i(195048),
				n = i(659192);
			const s = {
				[r.STATUS_DELAYED]: [n.timeFrames.ytd, n.timeFrames["12m"], n.timeFrames["60m"], n.timeFrames.all],
				[r.STATUS_READY]: [n.timeFrames["1d"], n.timeFrames["5d"], n.timeFrames["1m"], n.timeFrames["3m"], n.timeFrames["6m"], n.timeFrames.ytd, n.timeFrames["12m"], n.timeFrames["60m"], n.timeFrames.all]
			};

			function a(e, t) {
				return t === r.STATUS_DELAYED_STREAMING && (t = r.STATUS_READY), t === r.STATUS_EOD && (t = r.STATUS_DELAYED), s[t] || []
			}
		},
		656130: (e, t, i) => {
			i.d(t, {
				generateChartUrl: () => n
			});
			var r = i(314802);

			function n(e) {
				const t = e.chartId ? `/chart/${e.chartId}/` : "/chart/",
					i = new URL(t, location.href);
				return e.symbol && i.searchParams.append("symbol", e.symbol), e.interval && i.searchParams.append("interval", e.interval), e.style && i.searchParams.append("style", e.style), (0, r.urlWithMobileAppParams)(i.href)
			}
		},
		332450: (e, t, i) => {
			i.d(t, {
				CLOSE_POPUPS_AND_DIALOGS_COMMAND: () => r,
				breakpointList: () => n
			});
			const r = "CLOSE_POPUPS_AND_DIALOGS_COMMAND",
				n = [1920, 1440, 1280, 1024, 768, 480, 0]
		},
		290382: (e, t, i) => {
			i.d(t, {
				SymbolSearchUI: () => a
			});
			var r = i(588537),
				n = i(187545),
				s = i(583912);
			class a {
				async show(e) {
					if (null !== a._provider) {
						const e = await a._provider.getSymbol();
						return s.linking.symbol.setValue(e.symbol), e
					}
					if (a._currentShowingInstance) throw new DOMException("SymbolSearchUI is already shown", "InvalidStateError");
					try {
						a._currentShowingInstance = this, a.preload();
						const t = await a._implementation;
						return (0, r.assert)(null !== t), new Promise((i => {
							t.showDefaultSearchDialog({
								...e,
								onSearchComplete: e => {
									i({
										symbol: e
									})
								}
							})
						}))
					} finally {
						a._currentShowingInstance = null
					}
				}
				static setProvider(e) {
					this._provider = e
				}
				static preload() {
					null === this._provider && null === this._implementation && (this._implementation = (0, n.loadNewSymbolSearch)())
				}
			}
			a._currentShowingInstance = null, a._provider = null, a._implementation = null
		}
	}
]);