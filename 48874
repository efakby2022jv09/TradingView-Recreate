"use strict";
(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
	[48874], {
		990997: (e, t, i) => {
			function s(e, t, i) {
				const s = e.get(t);
				return void 0 !== s ? s : (e.set(t, i), i)
			}

			function r(e, t, i) {
				const s = e.get(t);
				if (void 0 !== s) return s;
				const r = i();
				return e.set(t, r), r
			}

			function n(e, t, i, r) {
				const n = s(e, t, new Map);
				return s(n, i, r)
			}

			function o(e, t, i, n) {
				return r(s(e, t, new Map), i, n)
			}

			function a(e, t, i, r, n) {
				const o = s(e, t, new Map),
					a = s(o, i, new Map);
				return s(a, r, n)
			}
			i.d(t, {
				getDefault2: () => n,
				getDefault2Lazy: () => o,
				getDefault3: () => a,
				AbstractMapContainer: () => l
			});
			class l {
				constructor() {
					this._map = new Map, this._size = 0
				}
				size() {
					return this._size
				}
				clear() {
					this._map.clear(), this._size = 0
				}
			}
		},
		945455: (e, t, i) => {
			i.d(t, {
				TextImageCachesContainer: () => a
			});
			var s = i(588537),
				r = i(990997),
				n = i(208214),
				o = i(267151);
			class a extends r.AbstractMapContainer {
				constructor(e) {
					super(), this._maxSize = e, this._keysQueue = []
				}
				get(e) {
					const {
						fontSize: t,
						text: i,
						align: s,
						font: a,
						lineSpacing: l = 0
					} = e;
					if (!i || !t || !s) return null;
					const h = (0, n.makeFont)(t, a),
						d = (0, r.getDefault3)(this._map, l, s, h, new Map);
					let u = d.get(i);
					return void 0 !== u || (this._size >= this._maxSize ? this._deleteFirstKey() : ++this._size, this._keysQueue.push([h, s, l, i]), u = new o.TextImageCache(i, e.bold, e.italic, a, t, s, l), d.set(i, u)), u
				}
				_deleteFirstKey() {
					const e = this._keysQueue.shift(),
						[t, i, r, n] = e,
						o = (0, s.ensureDefined)(this._map.get(r)),
						a = (0, s.ensureDefined)(o.get(i)),
						l = (0, s.ensureDefined)(a.get(t));
					l.delete(n), 0 === l.size && a.delete(t), 0 === a.size && o.delete(i), 0 === o.size && this._map.delete(r)
				}
			}
		},
		267151: (e, t, i) => {
			i.d(t, {
				HorizontalAlign: () => s,
				VerticalAlign: () => r,
				TextImageCache: () => h
			});
			var s, r, n = i(588537),
				o = i(208214),
				a = i(824112);
			! function(e) {
				e.Left = "left", e.Right = "right", e.Center = "center"
			}(s || (s = {})),
			function(e) {
				e.Top = "top", e.Bottom = "bottom", e.Middle = "middle"
			}(r || (r = {}));
			const l = (0, a.createDisconnectedCanvas)(document, new a.Size(0, 0), 1);
			class h {
				constructor(e, t, i, s, r, a = "center", h = 0) {
					this._lines = e.split(/[^\S\r\n]*(?:\r\n|\r|\n)/), this._font = function(e, t, i, s) {
						return (0, o.makeFont)(s, i, `${e?"bold ":""}${t?"italic ":""}`)
					}(t, i, s, r), this._fontSize = r, this._verticalPadding = ~~(r / 6), this._textAlign = a, this._lineSpacing = h;
					const d = (0, n.ensureNotNull)(l.getContext("2d"));
					d.font = this._font, d.textBaseline = "top";
					let u = 0;
					for (let e = 0; e < this._lines.length; ++e) {
						const t = this._lines[e],
							i = d.measureText(t).width;
						u = Math.max(u, i)
					}
					this.textImageWidth = u + 1, this.textImageHeight = this._lines.length * r + (this._lines.length - 1) * this._lineSpacing + this._verticalPadding
				}
				paintTo(e, t, i) {
					e.save();
					const s = t.pixelRatio,
						r = i.location;
					e.translate(Math.round(function(e, t, i) {
						let s = e;
						switch (t) {
							case "left":
								break;
							case "right":
								s -= i;
								break;
							case "center":
								s -= i / 2
						}
						return Math.round(s)
					}(r.x, r.horzAlign, this.textImageWidth) * s), Math.round(function(e, t, i) {
						let s = e;
						switch (t) {
							case "top":
								break;
							case "bottom":
								s -= i;
								break;
							case "middle":
								s -= i / 2
						}
						return Math.round(s)
					}(r.y, r.vertAlign, this.textImageHeight) * s));
					const n = i.style;
					let o;
					switch (e.textBaseline = "top", e.font = this._font, e.lineJoin = "round", e.fillStyle = n.fillStyle, n.strokeStyle && (e.strokeStyle = n.strokeStyle), n.lineWidth && (e.lineWidth = n.lineWidth), this._textAlign) {
						case "left":
							o = 0, e.textAlign = "left";
							break;
						case "right":
							o = this.textImageWidth - 1, e.textAlign = "right";
							break;
						default:
							o = this.textImageWidth / 2, e.textAlign = "center"
					}
					let l = this._verticalPadding;
					(0, a.drawScaled)(e, s, (() => {
						for (const t of this._lines) n.strokeStyle && e.strokeText(t, o, l), e.fillText(t, o, l), l += this._fontSize, l += this._lineSpacing
					})), e.restore()
				}
			}
		},
		289627: (e, t, i) => {
			var s = i(752280).PlotRowSearchMode,
				r = i(418458).STUDYPLOTDISPLAYTARGET,
				n = i(721386).rgbaFromInteger;

			function o() {
				this.backColorers = []
			}

			function a(e) {
				o.call(this), this._series = e
			}

			function l(e, t) {
				o.call(this), this._study = e, this._plotIndex = t
			}
			o.prototype.barStyle = function(e, t, i) {
					for (var s = {}, r = this.backColorers.length - 1; r >= 0; r--) this.backColorers[r].applyBarStyle(e, t, s, i);
					return this.applyBarStyle(e, t, s, i), s
				}, o.prototype.pushBackBarColorer = function(e) {
					this.backColorers.push(e)
				}, o.prototype.applyBarStyle = function(e, t, i) {
					throw new Error("This function is supposed to be reimplemented in a subclass")
				}, inherit(a, o), a.upColor = function(e, t) {
					var i = e.style.value();
					switch (i) {
						case TradingView.Series.STYLE_LINE:
							return e.lineStyle.color.value();
						case TradingView.Series.STYLE_AREA:
							return e.areaStyle.linecolor.value();
						case TradingView.Series.STYLE_BARS:
							return e.barStyle.upColor.value();
						case TradingView.Series.STYLE_CANDLES:
							return e.candleStyle.upColor.value();
						case TradingView.Series.STYLE_HOLLOW_CANDLES:
							return e.hollowCandleStyle.upColor.value();
						case TradingView.Series.STYLE_HEIKEN_ASHI:
							return e.haStyle.upColor.value();
						case TradingView.Series.STYLE_BASELINE:
							return e.baselineStyle.topLineColor.value();
						case TradingView.Series.STYLE_HILO:
							return e.hiloStyle.color.value();
						case TradingView.Series.STYLE_COLUMNS:
							return e.columnStyle.upColor.value()
					}
					switch (i) {
						case TradingView.Series.STYLE_RENKO:
							return t ? e.renkoStyle.upColorProjection.value() : e.renkoStyle.upColor.value();
						case TradingView.Series.STYLE_PB:
							return t ? e.pbStyle.upColorProjection.value() : e.pbStyle.upColor.value();
						case TradingView.Series.STYLE_KAGI:
							return t ? e.kagiStyle.upColorProjection.value() : e.kagiStyle.upColor.value();
						case TradingView.Series.STYLE_PNF:
							return t ? e.pnfStyle.upColorProjection.value() : e.pnfStyle.upColor.value()
					}
					if (TradingView.Series.STYLE_RANGE === i) return t ? e.rangeStyle.upColorProjection.value() : e.rangeStyle.upColor.value();
					throw new Error("Unknown series style")
				}, a.downColor = function(e, t) {
					var i = e.style.value();
					switch (i) {
						case TradingView.Series.STYLE_LINE:
							return e.lineStyle.color.value();
						case TradingView.Series.STYLE_AREA:
							return e.areaStyle.linecolor.value();
						case TradingView.Series.STYLE_BARS:
							return e.barStyle.downColor.value();
						case TradingView.Series.STYLE_CANDLES:
							return e.candleStyle.downColor.value();
						case TradingView.Series.STYLE_HOLLOW_CANDLES:
							return e.hollowCandleStyle.downColor.value();
						case TradingView.Series.STYLE_HEIKEN_ASHI:
							return e.haStyle.downColor.value();
						case TradingView.Series.STYLE_BASELINE:
							return e.baselineStyle.bottomLineColor.value();
						case TradingView.Series.STYLE_HILO:
							return e.hiloStyle.color.value();
						case TradingView.Series.STYLE_COLUMNS:
							return e.columnStyle.downColor.value()
					}
					switch (i) {
						case TradingView.Series.STYLE_RENKO:
							return t ? e.renkoStyle.downColorProjection.value() : e.renkoStyle.downColor.value();
						case TradingView.Series.STYLE_PB:
							return t ? e.pbStyle.downColorProjection.value() : e.pbStyle.downColor.value();
						case TradingView.Series.STYLE_KAGI:
							return t ? e.kagiStyle.downColorProjection.value() : e.kagiStyle.downColor.value();
						case TradingView.Series.STYLE_PNF:
							return t ? e.pnfStyle.downColorProjection.value() : e.pnfStyle.downColor.value()
					}
					if (TradingView.Series.STYLE_RANGE === i) return t ? e.rangeStyle.downColorProjection.value() : e.rangeStyle.downColor.value();
					throw new Error("Unknown series style")
				}, a.prototype._applyLineStyle = function(e, t, i, s, r) {
					i.barColor = a.upColor(r)
				}, a.prototype._applyAreaStyle = function(e, t, i, s, r) {
					i.barColor = a.upColor(r)
				}, a.prototype._applyBarStyle = function(e, t, i, s, r) {
					var n = a.upColor(r),
						o = a.downColor(r),
						l = this.findBar(e, !1, s);
					if (r.barStyle.barColorsOnPrevClose.value()) {
						var h = this.findPrevBar(e, !1, s);
						i.barColor = h[TradingView.CLOSE_PLOT] <= l[TradingView.CLOSE_PLOT] ? n : o, i.barBorderColor = h[TradingView.CLOSE_PLOT] <= l[TradingView.CLOSE_PLOT] ? n : o
					} else i.barColor = l[TradingView.OPEN_PLOT] <= l[TradingView.CLOSE_PLOT] ? n : o, i.barBorderColor = l[TradingView.OPEN_PLOT] <= l[TradingView.CLOSE_PLOT] ? n : o
				}, a.prototype._applyRangeStyle = function(e, t, i, s, r) {
					var n = a.upColor(r, t),
						o = a.downColor(r, t),
						l = this.findBar(e, !1, s);
					i.barColor = l[TradingView.OPEN_PLOT] <= l[TradingView.CLOSE_PLOT] ? n : o, i.barBorderColor = i.barColor
				}, a.prototype._applyCandleStyle = function(e, t, i, s, r) {
					var n, o = a.upColor(r, t),
						l = a.downColor(r, t),
						h = r.candleStyle.borderUpColor ? r.candleStyle.borderUpColor.value() : r.candleStyle.borderColor.value(),
						d = r.candleStyle.borderDownColor ? r.candleStyle.borderDownColor.value() : r.candleStyle.borderColor.value(),
						u = r.candleStyle.wickUpColor ? r.candleStyle.wickUpColor.value() : r.candleStyle.wickColor.value(),
						c = r.candleStyle.wickDownColor ? r.candleStyle.wickDownColor.value() : r.candleStyle.wickColor.value(),
						p = this.findBar(e, !1, s);
					r.candleStyle.barColorsOnPrevClose.value() && this._series.data().first().index !== e ? n = this.findPrevBar(e, !1, s)[TradingView.CLOSE_PLOT] <= p[TradingView.CLOSE_PLOT] : n = p[TradingView.OPEN_PLOT] <= p[TradingView.CLOSE_PLOT];
					i.barColor = n ? o : l, i.barBorderColor = n ? h : d, i.barWickColor = n ? u : c
				}, a.prototype._applyHollowCandleStyle = function(e, t, i, s, r) {
					var n, o = a.upColor(r, t),
						l = a.downColor(r, t),
						h = r.hollowCandleStyle.borderUpColor ? r.hollowCandleStyle.borderUpColor.value() : r.hollowCandleStyle.borderColor.value(),
						d = r.hollowCandleStyle.borderDownColor ? r.hollowCandleStyle.borderDownColor.value() : r.hollowCandleStyle.borderColor.value(),
						u = r.hollowCandleStyle.wickUpColor ? r.hollowCandleStyle.wickUpColor.value() : r.hollowCandleStyle.wickColor.value(),
						c = r.hollowCandleStyle.wickDownColor ? r.hollowCandleStyle.wickDownColor.value() : r.hollowCandleStyle.wickColor.value(),
						p = this.findBar(e, !1, s),
						_ = this.findPrevBar(e, !1, s);
					n = this._series.data().first().index !== e ? _[TradingView.CLOSE_PLOT] <= p[TradingView.CLOSE_PLOT] : p[TradingView.OPEN_PLOT] <= p[TradingView.CLOSE_PLOT], i.barColor = n ? o : l, i.barBorderColor = n ? h : d, i.barWickColor = n ? u : c,
						i.isBarHollow = p[TradingView.OPEN_PLOT] <= p[TradingView.CLOSE_PLOT]
				}, a.prototype._applyHAStyle = function(e, t, i, s, r) {
					var n, o = a.upColor(r, t),
						l = a.downColor(r, t),
						h = r.haStyle.borderUpColor.value(),
						d = r.haStyle.borderDownColor.value(),
						u = r.haStyle.wickUpColor.value(),
						c = r.haStyle.wickDownColor.value(),
						p = this.findBar(e, t, s);
					r.haStyle.barColorsOnPrevClose.value() ? n = this.findPrevBar(e, t, s)[TradingView.CLOSE_PLOT] <= p[TradingView.CLOSE_PLOT] : n = p[TradingView.OPEN_PLOT] <= p[TradingView.CLOSE_PLOT];
					i.barColor = n ? o : l, i.barBorderColor = n ? h : d, i.barWickColor = n ? u : c
				}, a.prototype._applyRenkoStyle = function(e, t, i, s, r) {
					var n = this.findBar(e, t, s),
						o = n[TradingView.OPEN_PLOT] <= n[TradingView.CLOSE_PLOT],
						l = a.upColor(r, t),
						h = a.downColor(r, t),
						d = t ? r.renkoStyle.borderUpColorProjection.value() : r.renkoStyle.borderUpColor.value(),
						u = t ? r.renkoStyle.borderDownColorProjection.value() : r.renkoStyle.borderDownColor.value(),
						c = r.renkoStyle.wickUpColor.value(),
						p = r.renkoStyle.wickDownColor.value();
					i.barColor = o ? l : h, i.barBorderColor = o ? d : u, i.barWickColor = o ? c : p, i.isBarUp = o
				}, a.prototype._applyPBStyle = function(e, t, i, s, r) {
					i.barColor = a.upColor(r);
					var n = this.findBar(e, t, s),
						o = n[TradingView.OPEN_PLOT] <= n[TradingView.CLOSE_PLOT],
						l = a.upColor(r, t),
						h = a.downColor(r, t),
						d = t ? r.pbStyle.borderUpColorProjection.value() : r.pbStyle.borderUpColor.value(),
						u = t ? r.pbStyle.borderDownColorProjection.value() : r.pbStyle.borderDownColor.value();
					i.barColor = o ? l : h, i.barBorderColor = o ? d : u, i.isBarUp = o
				}, a.prototype._applyKagiStyle = function(e, t, i, s, r) {
					i.upColor = a.upColor(r, t), i.downColor = a.downColor(r, t);
					var n = null,
						o = this.findBar(e, t, s);
					o[TradingView.LOW_PLOT] < o[TradingView.ADT_PLOT] && o[TradingView.ADT_PLOT] < o[TradingView.HIGH_PLOT] ? (n = o[TradingView.OPEN_PLOT] <= o[TradingView.CLOSE_PLOT], i.isTwoColorBar = !0) : (n = o[TradingView.OPEN_PLOT] <= o[TradingView.CLOSE_PLOT] ? o[TradingView.OPEN_PLOT] === o[TradingView.ADT_PLOT] : o[TradingView.OPEN_PLOT] !== o[TradingView.ADT_PLOT], i.isTwoColorBar = !1), i.barColor = n ? i.upColor : i.downColor, i.isBarUp = o[TradingView.OPEN_PLOT] <= o[TradingView.CLOSE_PLOT]
				}, a.prototype._applyPnfStyle = function(e, t, i, s, r) {
					var n = this.findBar(e, t, s)[TradingView.ADT_PLOT],
						o = n > 0,
						l = a.upColor(r, t),
						h = a.downColor(r, t);
					i.isBarUp = o, i.isMergedBar = 2 === Math.abs(n), i.upColor = l, i.downColor = h, i.barColor = o ? l : h
				}, a.prototype._applyBaseLineStyle = function(e, t, i, s, r) {
					var n = this.findBar(e, t, s),
						o = r.baselineStyle,
						l = this._series.priceScale(),
						h = Math.round(l.height() * (Math.abs(100 - o.baseLevelPercentage.value()) / 100)),
						d = this._series.firstValue(),
						u = l.coordinateToPrice(h, d);
					n[TradingView.CLOSE_PLOT] > u ? i.barColor = a.upColor(r, t) : i.barColor = a.downColor(r, t)
				}, a.prototype._applyHiLoStyle = function(e, t, i, s, r) {
					i.barColor = a.upColor(r, t), i.barBorderColor = r.hiloStyle.borderColor.value()
				}, a.prototype._applyColumnStyle = function(e, t, i, s, r) {
					var n = a.upColor(r),
						o = a.downColor(r),
						l = this.findBar(e, !1, s);
					if (r.columnStyle.barColorsOnPrevClose.value()) {
						var h = this.findPrevBar(e, !1, s);
						i.color = h[TradingView.CLOSE_PLOT] <= l[TradingView.CLOSE_PLOT] ? n : o
					} else i.color = l[TradingView.OPEN_PLOT] <= l[TradingView.CLOSE_PLOT] ? n : o;
					i.barColor = i.color
				},
				a.prototype.applyBarStyle = function(e, t, i, s) {
					i || (i = {}), i.barColor = null, i.barBorderColor = null, i.barWickColor = null, i.isBarHollow = null, i.isBarUp = null, i.upColor = null, i.downColor = null, i.isTwoColorBar = null, i.isMergedBar = null;
					var r = this._series.properties(),
						n = r.style.value();
					switch (n) {
						case TradingView.Series.STYLE_LINE:
							this._applyLineStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_AREA:
							this._applyAreaStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_BARS:
							this._applyBarStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_CANDLES:
							this._applyCandleStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_HOLLOW_CANDLES:
							this._applyHollowCandleStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_HEIKEN_ASHI:
							this._applyHAStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_BASELINE:
							this._applyBaseLineStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_HILO:
							this._applyHiLoStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_COLUMNS:
							this._applyColumnStyle(e, t, i, s, r)
					}
					switch (n) {
						case TradingView.Series.STYLE_RENKO:
							this._applyRenkoStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_PB:
							this._applyPBStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_KAGI:
							this._applyKagiStyle(e, t, i, s, r);
							break;
						case TradingView.Series.STYLE_PNF:
							this._applyPnfStyle(e, t, i, s, r)
					}
					return TradingView.Series.STYLE_RANGE === n && this._applyRangeStyle(e, t, i, s, r), i
				}, a.prototype.getSeriesBars = function(e) {
					return e ? this._series.nsBars() : this._series.bars()
				}, a.prototype._findBarFieldValue = function(e, t, i) {
					var s = this.getSeriesBars(i).valueAt(e);
					if (null !== s) return s[t]
				}, a.prototype.findBar = function(e, t, i) {
					return i ? i.value : this.getSeriesBars(t).valueAt(e) || []
				}, a.prototype.findPrevBar = function(e, t, i) {
					if (i && i.previousValue) return i.previousValue;
					var r = this._series.bars().search(e - 1, s.NearestLeft, TradingView.CLOSE_PLOT);
					return null !== r ? r.value : []
				}, inherit(l, o), l.prototype.getBars = function() {
					return this._study.series().bars()
				}, l.prototype.firstColoredBar = function(e) {
					for (var t = e, i = 0; i < this.backColorers.length; i++) t = Math.min(t, this.backColorers[i].firstColoredBar(e));
					var s = this.getOffset(this._plotIndex);
					t = Math.min(t, e + s);
					var r = this.getBars().firstIndex();
					return Math.max(t, r)
				}, l.prototype.getOffset = function() {
					var e = this._study.metaInfo().plots[this._plotIndex];
					return this._study.offset(e.id)
				}, l.prototype.applyBarStyle = function(e, t, i) {
					if (i || (i = {}), t) return i;
					var s = this._study.properties();
					if (!s.visible.value()) return i;
					var o = this._study.metaInfo(),
						a = this._study.data();
					if (!a || 0 === a.size()) return i;
					var l = o.plots[this._plotIndex],
						h = this.getOffset();
					if (this._study.getMinFirstBarIndexForPlot(l.id) > e + h) return i;
					if (s.styles[l.id].display.value() === r.None) return i;
					var d = a.valueAt(e - h);
					if (null === d) return i;
					var u = d[this._plotIndex + 1];
					if (null == u) return i;
					if (u = Math.round(u), o.isRGB) i.barColor = n(u), i.upColor = i.barColor, i.downColor = i.barColor;
					else {
						var c = o.plots[this._plotIndex].palette,
							p = s.palettes[c],
							_ = o.palettes[c].valToIndex ? o.palettes[c].valToIndex[u] : u,
							f = p.colors[_].color.value();
						i.barColor = f, i.upColor = f.color, i.downColor = f.color
					}
					return i
				}, t.SeriesBarColorer = a, t.StudyBarColorer = l
		},
		612826: (e, t, i) => {
			i.d(t, {
				BarsRange: () => r
			});
			var s = i(588537);
			class r {
				constructor(e, t) {
					(0, s.assert)(e <= t, "The last bar in the bars range should be greater than or equal to the first bar"), this._firstBar = e, this._lastBar = t
				}
				firstBar() {
					return this._firstBar
				}
				lastBar() {
					return this._lastBar
				}
				count() {
					return this._lastBar - this._firstBar + 1
				}
				contains(e) {
					return this._firstBar <= e && e <= this._lastBar
				}
				equals(e) {
					return this._firstBar === e.firstBar() && this._lastBar === e.lastBar()
				}
				static compare(e, t) {
					return null === e || null === t ? e === t : e.equals(t)
				}
			}
		},
		38627: (e, t, i) => {
			i.d(t, {
				currencyUnitVisibilityProperty: () => o,
				currencyUnitVisibilityOptions: () => a,
				migrateShowCurrencyAndShowUnitProperties: () => h
			});
			var s = i(611239),
				r = i(62802),
				n = i.n(r);
			const {
				property: o,
				availableValues: a
			} = (0, s.createVisibilityController)("PriceAxisCurrencyAndUnit.visibility");
			let l = !1;

			function h(e, t) {
				l || (l = !0, void 0 === n().getValue("PriceAxisCurrencyAndUnit.visibility") && o().setValue(e || t ? "alwaysOn" : "alwaysOff"))
			}
		},
		734906: (e, t, i) => {
			i.d(t, {
				DataWindowItem: () => s,
				DataWindowView: () => r
			});
			class s {
				constructor(e, t, i, s = !1) {
					this._visible = !0, this._id = e, this._title = t, this._value = i, this._unimportant = s
				}
				id() {
					return this._id
				}
				title() {
					return this._title
				}
				setTitle(e) {
					this._title = e
				}
				text() {
					return this._value
				}
				value() {
					return this._value
				}
				setValue(e) {
					this._value = e
				}
				visible() {
					return this._visible
				}
				setVisible(e) {
					this._visible = e
				}
				color() {
					return this._color
				}
				setColor(e) {
					this._color = e
				}
				unimportant() {
					return this._unimportant
				}
			}
			class r {
				constructor() {
					this._items = [], this._header = "", this._title = ""
				}
				header() {
					return this._header
				}
				title() {
					return this._title
				}
				items() {
					return this._items
				}
				update() {}
			}
		},
		362145: (e, t, i) => {
			i.d(t, {
				FormattersSerializer: () => h
			});
			var s = i(588537),
				r = i(689765),
				n = i(591419),
				o = i(965513),
				a = i(776263);
			const l = {
				price: r.PriceFormatter,
				volume: n.VolumeFormatter,
				percentage: o.PercentageFormatter,
				quoteSessionPrice: a.QuoteSessionPriceFormatter
			};
			var h;
			! function(e) {
				e.serialize = function(e) {
					const t = (0, s.ensureDefined)(l[e.type]);
					return {
						type: e.type,
						state: t.serialize(e)
					}
				}, e.deserialize = function(e) {
					return (0, s.ensureDefined)(l[e.type]).deserialize(e.state)
				}
			}(h || (h = {}))
		},
		776263: (e, t, i) => {
			i.d(t, {
				QuoteSessionPriceFormatter: () => r
			});
			var s = i(689765);
			class r {
				constructor(e) {
					this.type = "quoteSessionPrice", this.reset(e)
				}
				state() {
					return this._priceFormatter.state()
				}
				reset(e) {
					this._priceFormatter = e || new s.PriceFormatter(100, 1, !1)
				}
				update(e, t) {
					const i = null != t.pricescale || null != t.minmov || null != t.fractional || null != t.minmove2,
						r = null != e.pricescale && null != e.minmov && null != e.fractional && null != e.minmove2;
					i && r && (this._priceFormatter = new s.PriceFormatter(e.pricescale, e.minmov, e.fractional || !1, e.minmove2))
				}
				format(e, t, i) {
					return this._priceFormatter.format(e, t, i)
				}
				hasForexAdditionalPrecision() {
					return this._priceFormatter.hasForexAdditionalPrecision()
				}
				static serialize(e) {
					return e.state()
				}
				static deserialize(e) {
					const t = new s.PriceFormatter(e.priceScale, e.minMove, e.fractional, e.minMove2);
					return new r(t)
				}
			}
		},
		676809: (e, t, i) => {
			i.d(t, {
				shouldBeFormattedAsPercent: () => n,
				shouldBeFormattedAsIndexedTo100: () => o,
				getPriceValueFormatterForSource: () => a
			});
			var s = i(749473),
				r = i(992179);

			function n(e) {
				const t = e.priceScale();
				return !(null === t || !t.isPercentage()) && (!(0, r.isSymbolSource)(e) || (0, s.isPriceSourceStyle)(e.style()))
			}

			function o(e) {
				const t = e.priceScale();
				return !(null === t || !t.isIndexedTo100()) && (!(0, r.isSymbolSource)(e) || (0, s.isPriceSourceStyle)(e.style()))
			}

			function a(e) {
				const t = e.priceScale();
				if (o(e) && null !== t) return i => {
					var s;
					return t.formatPriceIndexedTo100(i, null !== (s = e.firstValue()) && void 0 !== s ? s : 100)
				};
				if (n(e) && null !== t) return i => {
					var s;
					return t.formatPricePercentage(i, null !== (s = e.firstValue()) && void 0 !== s ? s : 100)
				};
				const i = e.formatter();
				return i.format.bind(i)
			}
		},
		350985: (e, t, i) => {
			i.d(t, {
				HorizontalLinePaneView: () => n
			});
			var s = i(37689),
				r = i(345185);
			class n {
				constructor() {
					this._lineRendererData = {
						y: 0,
						color: "rgba(0, 0, 0, 0)",
						linewidth: 1,
						linestyle: r.LINESTYLE_SOLID,
						visible: !1
					}, this._lineRenderer = new s.HorizontalLineRenderer, this._invalidated = !0, this._lineRenderer.setData(this._lineRendererData)
				}
				update(e) {
					this._invalidated = !0
				}
				renderer() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._lineRenderer
				}
			}
		},
		992179: (e, t, i) => {
			function s(e) {
				return e.symbolSource && e.symbolSource() === e
			}
			i.d(t, {
				isSymbolSource: () => s
			})
		},
		613648: (e, t, i) => {
			i.d(t, {
				PanePriceAxisView: () => n
			});
			var s = i(405222);
			class r {
				constructor(e) {
					this._priceAxisViewRenderer = null, this._rendererOptions = null, this._align = "right", this._width = 0, this._height = 0, this._textWidthCache = e
				}
				setParams(e, t, i, s, r) {
					this._priceAxisViewRenderer = e, this._rendererOptions = t, this._width = i, this._height = s, this._align = r
				}
				draw(e, t) {
					null !== this._rendererOptions && null !== this._priceAxisViewRenderer && this._priceAxisViewRenderer.draw(e, this._rendererOptions, this._textWidthCache, this._width, this._height, this._align, t.pixelRatio)
				}
				hitTest(e) {
					var t, i;
					return void 0 === (null === (t = this._priceAxisViewRenderer) || void 0 === t ? void 0 : t.hitTest) ? null : null === (i = this._priceAxisViewRenderer) || void 0 === i ? void 0 : i.hitTest(e, this._width, this._align)
				}
			}
			class n {
				constructor(e, t, i) {
					this._renderer = null, this._invalidated = !0, this._priceAxisView = e, this._textWidthCache = new s.TextWidthCache(100), this._dataSource = t, this._chartModel = i, this._fontSize = -1, this._panePriceAxisViewRenderer = new r(this._textWidthCache)
				}
				update(e) {
					this._invalidated = !0
				}
				renderer(e, t) {
					return this._invalidated && this._updateImpl(e, t), this._renderer
				}
				_updateImpl(e, t) {
					this._renderer = null;
					const i = this._chartModel.crossHairSource(),
						s = this._dataSource === i ? i.pane : this._chartModel.paneForSource(this._dataSource);
					if (null === s) return;
					const r = this._priceScale();
					if (null === r) return;
					let n = s.priceScalePosition(r);
					if ("overlay" === n && (n = s.priceScalePosition(s.defaultPriceScale())), "overlay" === n) return;
					const o = this._chartModel.priceAxisRendererOptions();
					o.fontSize !== this._fontSize && (this._fontSize = o.fontSize, this._textWidthCache.reset()), this._panePriceAxisViewRenderer.setParams(this._priceAxisView.paneRenderer(), o, t, e, n), this._renderer = this._panePriceAxisViewRenderer, this._invalidated = !1
				}
				_priceScale() {
					return this._dataSource.priceScale()
				}
			}
		},
		896949: (e, t, i) => {
			i.d(t, {
				PaneRendererArea: () => a
			});
			var s = i(588537),
				r = i(729828),
				n = i(72461),
				o = i(601132);
			class a extends r.PaneRendererLine {
				constructor(e) {
					e.forceLineColor = !1, super(e)
				}
				draw(e, t) {
					var i, r, a, l, h;
					const d = this._data;
					if (0 === d.items.length) return;
					let u = null !== (r = null === (i = this._data.visibleItemsRange) || void 0 === i ? void 0 : i.startItemIndex) && void 0 !== r ? r : 0,
						c = (null !== (l = null === (a = this._data.visibleItemsRange) || void 0 === a ? void 0 : a.endItemIndex) && void 0 !== l ? l : this._data.items.length) - 1;
					for (; u < c && !(0, o.coordinateIsValid)(d.items[u].y);) u++;
					for (; c >= 0 && !(0, o.coordinateIsValid)(d.items[c].y);) c--;
					if (u > c) return;
					e.save(), e.scale(t.pixelRatio, t.pixelRatio), e.lineCap = "butt", e.strokeStyle = d.lineColor, e.lineWidth = d.lineWidth, (0, n.setLineStyle)(e, d.lineStyle), e.lineWidth = 1;
					const p = {},
						_ = d.items;
					for (let e = u; e <= c; e++) {
						const t = _[e];
						let i;
						if (i = t.style ? t.style.color : d.lineColor, e < c && _[e + 1].style) {
							const r = (0, s.ensureDefined)(_[e + 1].style).color;
							if (i !== r) {
								const e = p[r] || [];
								e.push(t), p[r] = e
							}
						}
						const r = p[i] || [];
						r.push(t), p[i] = r
					}
					for (const t of Object.keys(p)) {
						const i = p[t];
						e.beginPath();
						let s = 0;
						for (let r = 0; r < i.length; r++) i[r].style && (null === (h = i[r].style) || void 0 === h ? void 0 : h.color) !== t && (e.moveTo(Math.round(i[s].x), d.bottom), this._walkLine(e, i.slice(s, r), !0, d.bottom, !0), s = r);
						if (e.moveTo(Math.round(i[s].x), d.bottom), this._walkLine(e, i.slice(s, i.length), !0, d.bottom, !0), e.closePath(), d.isSeries) {
							const t = e.createLinearGradient(0, 0, 0, d.bottom);
							t.addColorStop(0, d.color1), t.addColorStop(1, d.color2), e.fillStyle = t, d.simpleMode = !0
						} else e.fillStyle = t;
						e.fill()
					}
					e.lineWidth = d.lineWidth, e.restore(), super.draw(e, t)
				}
			}
		},
		717611: (e, t, i) => {
			i.d(t, {
				CompositeRenderer: () => s
			});
			class s {
				constructor() {
					this._renderers = [], this._globalAlpha = 1
				}
				setGlobalAlpha(e) {
					this._globalAlpha = e
				}
				append(e) {
					this._renderers.push(e)
				}
				insert(e, t) {
					this._renderers.splice(t, 0, e)
				}
				clear() {
					this._renderers.length = 0
				}
				isEmpty() {
					return 0 === this._renderers.length
				}
				draw(e, t) {
					for (let i = 0; i < this._renderers.length; i++) e.save(), e.globalAlpha = this._globalAlpha, this._renderers[i].draw(e, t), e.restore()
				}
				drawBackground(e, t) {
					e.save(), e.globalAlpha = this._globalAlpha;
					for (let i = 0; i < this._renderers.length; i++) {
						const s = this._renderers[i];
						s.drawBackground && s.drawBackground(e, t)
					}
					e.restore()
				}
				hitTest(e, t) {
					let i = null;
					for (let s = this._renderers.length - 1; s >= 0; s--) {
						const r = this._renderers[s].hitTest(e, t);
						null !== r && (null === i || r.result() > i.result()) && (i = r)
					}
					return i
				}
				doesIntersectWithBox(e) {
					return this._renderers.some((t => !!t.doesIntersectWithBox && t.doesIntersectWithBox(e)))
				}
			}
		},
		37689: (e, t, i) => {
			i.d(t, {
				HorizontalLineRenderer: () => l
			});
			var s = i(218718),
				r = i(72461),
				n = i(164149),
				o = i(601132),
				a = i(824112);
			class l {
				constructor() {
					this._data = null, this._hitTest = new s.HitTestResult(s.HitTestResult.REGULAR)
				}
				setData(e) {
					this._data = e
				}
				setHitTest(e) {
					this._hitTest = e
				}
				hitTest(e) {
					if (null === this._data || !1 === this._data.visible || null === this._hitTest) return null;
					const t = (0, o.interactionTolerance)().line,
						i = Math.abs(e.y - this._data.y) <= t + this._data.linewidth / 2,
						s = void 0 === this._data.left || this._data.left - e.x <= t,
						r = void 0 === this._data.right || e.x - this._data.right <= t;
					return i && s && r ? this._hitTest : null
				}
				draw(e, t) {
					if (null === this._data) return;
					if (!1 === this._data.visible) return;
					if (this._data.y < -this._data.linewidth / 2 || this._data.y > t.cssHeight + this._data.linewidth / 2) return;
					const i = t.pixelRatio;
					e.lineCap = "butt", e.strokeStyle = this._data.color, e.lineWidth = Math.max(1, Math.floor(this._data.linewidth * i)), void 0 !== this._data.linestyle && (0, r.setLineStyle)(e, this._data.linestyle);
					const s = void 0 !== this._data.left ? Math.max(this._data.left, 0) : 0,
						o = void 0 !== this._data.right ? Math.min(this._data.right, t.cssWidth) : t.cssWidth,
						l = Math.round(this._data.y * i),
						h = Math.floor(s * i),
						d = Math.ceil(o * i),
						u = this._data.excludeBoundaries;
					void 0 !== u && (e.save(), (0, a.addExclusionArea)(e, t, u)), (0, n.drawHorizontalLine)(e, l, h, d), void 0 !== this._data.excludeBoundaries && e.restore()
				}
			}
		},
		729828: (e, t, i) => {
			i.d(t, {
				PaneRendererLine: () => l
			});
			var s = i(86441),
				r = i(204652),
				n = i(218718),
				o = i(72461),
				a = i(601132);
			class l {
				constructor(e) {
					this._data = e
				}
				hitTest(e, t) {
					var i, o, l, h;
					const d = (0, a.interactionTolerance)().series + this._data.lineWidth / 2;
					let u = null !== (o = null === (i = this._data.visibleItemsRange) || void 0 === i ? void 0 : i.startItemIndex) && void 0 !== o ? o : 0,
						c = (null !== (h = null === (l = this._data.visibleItemsRange) || void 0 === l ? void 0 : l.endItemIndex) && void 0 !== h ? h : this._data.items.length) - 1;
					for (; c - u > 2;) {
						const t = Math.round((c + u) / 2);
						this._data.items[t].x <= e.x ? u = t : c = t
					}
					u = Math.max(1, u - 1), c = Math.min(this._data.items.length - 1, c + 1);
					for (let t = u; t <= c; ++t) {
						const i = this._data.items[t - 1],
							o = this._data.items[t],
							a = i.x,
							l = o.x;
						if ((0, r.distanceToSegment)(new s.Point(a, i.y), new s.Point(l, o.y), new s.Point(e.x, e.y)).distance <= d) return this._data.hittest ? this._data.hittest : new n.HitTestResult(n.HitTestResult.REGULAR)
					}
					return null
				}
				draw(e, t) {
					e.save(), e.scale(t.pixelRatio, t.pixelRatio), e.lineCap = "square", e.lineJoin = "round", e.strokeStyle = this._data.lineColor, e.fillStyle = this._data.lineColor, e.lineWidth = this._data.lineWidth, (0, o.setLineStyle)(e, this._data.lineStyle), (0, a.setValidLineStyle)(e, this._data.lineStyle), this._data.simpleMode ? this._drawSimpleMode(e, t.pixelRatio) : this._drawLines(e), e.restore()
				}
				_drawSimpleMode(e, t) {
					var i, s, r, n;
					if (e.beginPath(), this._walkLine(e, this._data.items, !1, NaN), e.stroke(), this._data.withMarkers) {
						e.save(), e.scale(1 / t, 1 / t);
						const o = Math.max(1, Math.floor(t)) % 2 / 2,
							a = (this._data.lineWidth + 2) * t + o,
							l = 2 * Math.PI;
						e.beginPath();
						const h = null !== (s = null === (i = this._data.visibleItemsRange) || void 0 === i ? void 0 : i.startItemIndex) && void 0 !== s ? s : 0;
						for (let i = (null !== (n = null === (r = this._data.visibleItemsRange) || void 0 === r ? void 0 : r.endItemIndex) && void 0 !== n ? n : this._data.items.length) - 1 + 1; i-- >= h;) {
							const s = this._data.items[i];
							if (s) {
								const i = Math.round(s.x * t) + o,
									r = s.y * t;
								e.moveTo(i, r), e.arc(i, r, a, 0, l)
							}
						}
						e.fill(), e.restore()
					}
				}
				_walkLine(e, t, i, s, r) {
					var n, o, l, h;
					if (!t) return;
					const d = .25 * this._data.barSpacing;
					let u, c, p, _, f;
					const m = a.coordinateIsValid,
						y = r ? 0 : null !== (o = null === (n = this._data.visibleItemsRange) || void 0 === n ? void 0 : n.startItemIndex) && void 0 !== o ? o : 0,
						v = r ? t.length - 1 : Math.min((null !== (h = null === (l = this._data.visibleItemsRange) || void 0 === l ? void 0 : l.endItemIndex) && void 0 !== h ? h : t.length) - 1, t.length - 1);
					for (let e = y; e <= v; e++) {
						const i = t[e];
						if (m(i.y)) {
							c = i, u = e;
							break
						}
					}
					if (void 0 !== u && void 0 !== c)
						for (let r = u; r <= v; r++) {
							_ = t[r], f = t[r + 1] || {};
							const n = Math.round(_.x);
							if (m(_.y))
								if (p && m(p.y)) e.lineTo(n, _.y), i && !m(f.y) && e.lineTo(n, s);
								else if (f && m(f.y)) i ? (r !== u && e.lineTo(n, s), e.lineTo(n, _.y)) : e.moveTo(n, _.y);
							else if (i) {
								if (0 === r) continue;
								r !== u && e.lineTo(n - d, s), e.lineTo(n - d, _.y), e.lineTo(n + d, _.y), e.lineTo(n + d, s)
							} else e.moveTo(n - d, _.y), e.lineTo(n + d, _.y);
							p = _
						}
				}
				_drawLines(e) {
					var t, i, s, r;
					if (!this._data.items.length) return;
					let n, o, l;
					const h = .25 * this._data.barSpacing,
						d = a.coordinateIsValid;
					e.beginPath();
					const u = null !== (i = null === (t = this._data.visibleItemsRange) || void 0 === t ? void 0 : t.startItemIndex) && void 0 !== i ? i : 0,
						c = (null !== (r = null === (s = this._data.visibleItemsRange) || void 0 === s ? void 0 : s.endItemIndex) && void 0 !== r ? r : this._data.items.length) - 1,
						p = this._data.items[u];
					p && e.moveTo(p.x, p.y);
					let _, f = e.strokeStyle,
						m = e.lineWidth;
					for (let t = u + 1; t <= c; ++t) {
						let i, s, r;
						n = this._data.items[t - 1], o = this._data.items[t], l = this._data.items[t + 1], o.style && !this._data.forceLineColor ? (i = o.style.color, s = o.style.width, r = o.style.style) : (i = this._data.lineColor, s = this._data.lineWidth, r = this._data.lineStyle), this._data.ignorePaletteLineWidth && (s = this._data.lineWidth);
						(i !== f || s !== m || r !== _) && (f = i, m = s, _ = r, e.stroke(), e.beginPath(), e.strokeStyle = i, e.lineWidth = s, (0, a.setValidLineStyle)(e, r), e.moveTo(n.x, n.y)), y = n, g = l, d((v = o).y) && (d(y.y) ? e.lineTo(v.x, v.y) : g && d(g.y) ? e.moveTo(v.x, v.y) : (e.moveTo(v.x - h, v.y), e.lineTo(v.x + h, v.y)))
					}
					var y, v, g;
					e.stroke()
				}
			}
		},
		380047: (e, t, i) => {
			i.d(t, {
				ScaledPaneRenderer: () => s,
				ScaledPaneRendererWrapper: () => r
			});
			class s {
				draw(e, t) {
					e.save(), e.scale(t.pixelRatio, t.pixelRatio), e.translate(.5, .5), this._drawImpl(e, {
						...t,
						pixelRatio: 1
					}), e.restore()
				}
				drawBackground(e, t) {
					e.save(), e.scale(t.pixelRatio, t.pixelRatio), e.translate(.5, .5), this._drawBackgroundImpl(e, {
						...t,
						pixelRatio: 1
					}), e.restore()
				}
				_drawBackgroundImpl(e, t) {}
			}
			class r {
				constructor(e) {
					this._base = e
				}
				hitTest(e, t) {
					return this._base.hitTest(e, t)
				}
				draw(e, t) {
					e.save(), e.scale(t.pixelRatio, t.pixelRatio), e.translate(.5, .5), this._base.draw(e, {
						...t,
						pixelRatio: 1
					}), e.restore()
				}
				drawBackground(e, t) {
					e.save(), e.scale(t.pixelRatio, t.pixelRatio), e.translate(.5, .5), this._base.drawBackground && this._base.drawBackground(e, {
						...t,
						pixelRatio: 1
					}), e.restore()
				}
			}
		},
		68226: (e, t, i) => {
			i.d(t, {
				StepLineDecoration: () => s,
				PaneRendererStepLine: () => m
			});
			var s, r = i(204652),
				n = i(218718),
				o = i(86441),
				a = i(72461),
				l = i(377884),
				h = i(601132),
				d = i(164149),
				u = i(721386);
			! function(e) {
				e[e.None = 0] = "None", e[e.Diamonds = 1] = "Diamonds"
			}(s || (s = {}));
			class c {
				initialize(e, t, i, s) {
					var r, n, o, l;
					const h = e.lineStyle;
					t.lineCap = "butt", t.lineJoin = "round";
					const d = Math.max(Math.floor(null !== (n = null === (r = s.style) || void 0 === r ? void 0 : r.width) && void 0 !== n ? n : e.lineWidth * i.pixelRatio));
					void 0 !== h && (0, a.setLineStyle)(t, h);
					const u = d % 2 ? .5 : 0;
					t.moveTo(Math.round(s.x * i.pixelRatio) + u, Math.round(s.y * i.pixelRatio) + u), t.strokeStyle = null !== (l = null === (o = s.style) || void 0 === o ? void 0 : o.color) && void 0 !== l ? l : e.lineColor, t.lineWidth = d
				}
				finishFragment(e) {
					e.stroke()
				}
				hitTest(e, t, i, s, r) {
					return c.hitTest(e, t, i, s, r)
				}
				applyColor(e, t) {
					e.strokeStyle = t
				}
				applyLineWidth(e, t) {
					e.lineWidth = t
				}
				drawItem(e, t, i, s) {
					e.lineTo(i.x, i.y), void 0 !== s && (e.lineTo(s.x, i.y),
						e.lineTo(s.x, s.y))
				}
				static hitTest(e, t, i, s, n) {
					var a, l;
					const d = Math.round((i.x + s.x) / 2),
						u = new o.Point(d, i.y),
						c = new o.Point(d, s.y),
						p = null !== (l = null === (a = i.style) || void 0 === a ? void 0 : a.width) && void 0 !== l ? l : e.lineWidth,
						_ = (0, h.interactionTolerance)().series + p / 2;
					return Math.min((0, r.distanceToSegment)(i, u, n).distance, (0, r.distanceToSegment)(u, c, n).distance, (0, r.distanceToSegment)(c, s, n).distance) <= _
				}
			}
			class p {
				constructor() {
					this._lineWidth = 1
				}
				initialize(e, t, i, s) {
					var r, n, o, a;
					this.applyColor(t, null !== (n = null === (r = s.style) || void 0 === r ? void 0 : r.color) && void 0 !== n ? n : e.lineColor), this._lineWidth = Math.max(Math.floor(null !== (a = null === (o = s.style) || void 0 === o ? void 0 : o.width) && void 0 !== a ? a : e.lineWidth * i.pixelRatio))
				}
				finishFragment(e) {
					e.fill()
				}
				drawItem(e, t, i, s, r) {
					if (r && void 0 !== s && !Number.isNaN(s.y)) {
						e.save(), e.translate(s.x, s.y), e.rotate(Math.PI / 4);
						const i = this._scaleByLineWidth(this._lineWidth);
						e.scale(i, i), this._drawItemRotatedAndTranslated(e, t), e.restore()
					}
				}
				applyLineWidth(e, t) {
					this._lineWidth = t
				}
				hitTest(e, t, i, s, r) {
					var n, a;
					if (!s.valIsNotSameAsPrev) return !1;
					const l = Math.round((i.x + s.x) / 2),
						h = new o.Point(l, s.y),
						d = r.subtract(h),
						u = Math.max(Math.floor(null !== (a = null === (n = i.style) || void 0 === n ? void 0 : n.width) && void 0 !== a ? a : e.lineWidth * t.pixelRatio));
					return this._hitTestTranslated(d, u)
				}
				_scaleByLineWidth(e) {
					return Math.sqrt(e)
				}
			}
			class _ extends p {
				applyColor(e, t) {
					e.fillStyle = t
				}
				_hitTestTranslated(e, t) {
					return Math.abs(e.x) + Math.abs(e.y) < 8 * this._scaleByLineWidth(t) / 2
				}
				_drawItemRotatedAndTranslated(e, t) {
					(0, d.drawRoundRect)(e, -4, -4, 8, 8, 2, !0)
				}
			}
			class f extends p {
				applyColor(e, t) {
					e.fillStyle = (0, u.applyTransparency)(t, 85)
				}
				_hitTestTranslated(e, t) {
					return Math.abs(e.x) + Math.abs(e.y) < 21 * this._scaleByLineWidth(t) / 2
				}
				_drawItemRotatedAndTranslated(e, t) {
					(0, d.drawRoundRect)(e, -10.5, -10.5, 21, 21, 5, !0)
				}
			}
			class m {
				constructor(e, t) {
					this._data = null, this._data = null != e ? e : null, this._extendLineToLastConfirmedBar = Boolean(t)
				}
				setData(e) {
					this._data = e
				}
				hitTest(e, t) {
					var i;
					const r = this._data;
					if (null === r || 0 === r.items.length) return null;
					const a = r.items,
						h = (0, l.lowerbound)(a, e, ((e, t) => e.x <= t.x)),
						d = Math.max(0, h - 1),
						u = Math.min(a.length, h + 1),
						p = (null === (i = this._data) || void 0 === i ? void 0 : i.decoration) === s.Diamonds ? [new c, new f] : [new c];
					for (let i = d; i < u; i++) {
						const s = a[i],
							l = a[i + 1];
						if (l) {
							if (p.some((i => i.hitTest(r, t, s, l, e)))) return new n.HitTestResult(n.HitTestResult.REGULAR)
						} else if (this._extendLineToLastConfirmedBar && void 0 !== r.lastConfirmedSeriesBarCoordinate && u === a.length && s.x < t.cssWidth && s.x < r.lastConfirmedSeriesBarCoordinate) {
							const i = (0, o.point)(r.lastConfirmedSeriesBarCoordinate, s.y);
							if (c.hitTest(r, t, s, i, e)) return new n.HitTestResult(n.HitTestResult.REGULAR)
						}
					}
					return null
				}
				draw(e, t) {
					if (null === this._data || 0 === this._data.items.length) return;
					e.save();
					(this._data.decoration === s.Diamonds ? [new c, new _, new f] : [new c]).forEach((i => this._drawImpl(e, t, i))), e.restore()
				}
				_drawImpl(e, t, i) {
					var s, r, n, a, l, h, d, u, c, p, _, f, m, y, v, g;
					if (null === this._data || 0 === this._data.items.length) return;
					const {
						lineWidth: S,
						lineColor: b,
						items: w
					} = this._data, P = t.pixelRatio;
					let C = Math.max(Math.floor(null !== (r = null === (s = w[0].style) || void 0 === s ? void 0 : s.width) && void 0 !== r ? r : S * P)),
						x = C % 2 ? .5 : 0;
					i.initialize(this._data, e, t, w[0]);
					const I = null !== (a = null === (n = this._data.visibleItemsRange) || void 0 === n ? void 0 : n.startItemIndex) && void 0 !== a ? a : 0,
						T = null !== (h = null === (l = this._data.visibleItemsRange) || void 0 === l ? void 0 : l.endItemIndex) && void 0 !== h ? h : w.length,
						V = this._data.barSpacing;
					if (!(T <= I)) {
						e.beginPath(), i.applyColor(e, null !== (u = null === (d = w[I].style) || void 0 === d ? void 0 : d.color) && void 0 !== u ? u : b);
						for (let s = I; s < T; s++) {
							const r = w[s],
								n = s === T - 1 ? null : w[s + 1],
								a = Math.round(r.x * P) + x,
								l = Math.round(r.y * P) + x;
							if (!n) {
								if (i.drawItem(e, t, (0, o.point)(a, l)), this._extendLineToLastConfirmedBar && void 0 !== this._data.lastConfirmedSeriesBarCoordinate && a < t.physicalWidth && r.x < this._data.lastConfirmedSeriesBarCoordinate) {
									const s = Math.round(this._data.lastConfirmedSeriesBarCoordinate * P) + x;
									a < s && i.drawItem(e, t, (0, o.point)(Math.min(t.physicalWidth, s), l), void 0, !0)
								}
								continue
							}
							const h = Math.round((n.x - V / 2) * P) + x,
								d = Math.round(n.y * P) + x;
							i.drawItem(e, t, (0, o.point)(a, l), (0, o.point)(h, d), n.valIsNotSameAsPrev);
							const u = null !== (p = null === (c = r.style) || void 0 === c ? void 0 : c.color) && void 0 !== p ? p : b,
								I = null !== (f = null === (_ = r.style) || void 0 === _ ? void 0 : _.width) && void 0 !== f ? f : S,
								M = null !== (y = null === (m = n.style) || void 0 === m ? void 0 : m.color) && void 0 !== y ? y : b,
								R = null !== (g = null === (v = n.style) || void 0 === v ? void 0 : v.width) && void 0 !== g ? g : S,
								A = u !== M,
								B = I !== R;
							(A || B) && (i.finishFragment(e), A && i.applyColor(e, M), B && (C = Math.max(1, Math.floor(R * P)), x = C % 2 ? .5 : 0, i.applyLineWidth(e, C)), e.beginPath(), e.moveTo(h, d))
						}
						i.finishFragment(e)
					}
				}
			}
		},
		902899: (e, t, i) => {
			i.d(t, {
				isPriceDataSource: () => a,
				PriceDataSource: () => l
			});
			var s = i(62949),
				r = i(97639),
				n = i.n(r),
				o = i(992179);

			function a(e) {
				return e instanceof l
			}
			class l extends s.DataSource {
				constructor(e, t) {
					super(t), this._formatterChanged = new(n()), this._priceStepChanged = new(n()), this._currencyChanged = new(n()), this._unitChanged = new(n()), this._priceRangeReadyChanged = new(n()), this._priceStep = null, this._priceRangeReady = !0, this._model = e
				}
				base() {
					return 0
				}
				model() {
					return this._model
				}
				currencyChanged() {
					return this._currencyChanged
				}
				isCurrencySource() {
					return !0
				}
				isDisplayedInLegend() {
					return !0
				}
				unitChanged() {
					return this._unitChanged
				}
				isUnitSource() {
					return !0
				}
				priceRange(e, t) {
					return null
				}
				isDraggable() {
					return !0
				}
				priceLineColor(e) {
					return e
				}
				formatterChanged() {
					return this._formatterChanged
				}
				priceStep(e) {
					return this._priceStep
				}
				priceStepChanged() {
					return this._priceStepChanged
				}
				isIncludedInAutoScale() {
					return !0
				}
				correctScaleMargins(e) {
					return e
				}
				priceRangeReady() {
					return this._priceRangeReady
				}
				priceRangeReadyChanged() {
					return this._priceRangeReadyChanged
				}
				disablePriceRangeReady() {
					const e = this.priceScale();
					null === e || e.isAutoScale() || e.mainSource() !== this || (this._priceRangeReady = !1, e.recalculatePriceRangeOnce()), this._priceRangeReadyChanged.fire(!1)
				}
				statusView() {
					return null
				}
				legendView() {
					return null
				}
				marketStatusModel() {
					return null
				}
				dataUpdatedModeModel() {
					return null
				}
				dataProblemModel() {
					return null
				}
				_enablePriceRangeReady() {
					this._priceRangeReady = !0, this._priceRangeReadyChanged.fire(!0)
				}
				_onSourceCurrencyChanged() {
					(0, o.isSymbolSource)(this) || this._currencyChanged.fire()
				}
				_onSourceUnitChanged() {
					(0, o.isSymbolSource)(this) || this._unitChanged.fire()
				}
				_onSourcePriceRangeReadyChanged(e) {
					(0, o.isSymbolSource)(this) || e || this.disablePriceRangeReady()
				}
			}
		},
		342141: (e, t, i) => {
			i.d(t, {
				PriceLineAxisRenderer: () => a
			});
			var s = i(588537),
				r = i(72461),
				n = i(345185),
				o = i(164149);
			class a {
				constructor(e, t) {
					this.setData(e, t)
				}
				setData(e, t) {
					this._data = e, this._commonData = t
				}
				draw(e, t, i, a, l, h, d) {
					var u;
					if (!this._data.visible) return;
					const c = null !== (u = this._commonData.fixedCoordinate) && void 0 !== u ? u : this._commonData.coordinate;
					e.lineWidth = Math.max(1, Math.floor((0, s.ensureDefined)(this._data.linewidth) * d)), e.lineCap = "butt", (0, r.setLineStyle)(e, void 0 === this._data.linestyle ? n.LINESTYLE_DOTTED : this._data.linestyle), e.strokeStyle = this._commonData.textColor, (0, o.drawHorizontalLine)(e, Math.round(c * d), 0, Math.ceil(a * d))
				}
				height(e) {
					return 0
				}
			}
		},
		267850: (e, t, i) => {
			i.d(t, {
				PriceLineAxisView: () => o,
				SeriesPriceLineAxisView: () => a,
				StudyPriceLineAxisView: () => l
			});
			var s = i(498424),
				r = i(342141),
				n = i(345185);
			class o extends s.PriceAxisView {
				constructor(e) {
					super(e || r.PriceLineAxisRenderer)
				}
				ignoreAlignment() {
					return !0
				}
				_updateRendererData(e, t, i) {
					if (t.visible = !1, e.visible = !1, !this._isVisible()) return;
					const s = this._value();
					s.noData || (i.background = "", i.textColor = this._priceLineColor(s.color), i.coordinate = s.coordinate, i.floatCoordinate = s.floatCoordinate, e.linewidth = this._lineWidth(), e.linestyle = this._lineStyle(), e.backgroundAreaVisible = this._backgroundAreaVisible(), e.backgroundAreaColor = this._backgroundAreaColor(), e.backgroundAreaHeight = this._backgroundAreaHeight(), e.visible = !0)
				}
				_lineStyle() {
					return n.LINESTYLE_DOTTED
				}
				_backgroundAreaVisible() {
					return !1
				}
				_backgroundAreaColor() {
					return ""
				}
				_backgroundAreaHeight() {
					return 0
				}
			}
			class a extends o {
				constructor(e) {
					super(), this._series = e
				}
				_value() {
					return this._series.lastValueData(void 0, !0)
				}
				_priceLineColor(e) {
					return this._series.priceLineColor(e)
				}
				_lineWidth() {
					return this._series.properties().childs().priceLineWidth.value()
				}
				_isVisible() {
					const e = this._series.model().properties().childs().scalesProperties.childs().showSeriesLastValue.value();
					return this._series.properties().childs().showPriceLine.value() && e
				}
			}
			class l extends o {
				constructor(e, t) {
					super(), this._study = e, this._plotname = t
				}
				_value() {
					return this._study.lastValueData(this._plotname, !0)
				}
				_lineWidth() {
					return this._study.properties().childs().styles.childs()[this._plotname].childs().linewidth.value()
				}
				_lineStyle() {
					return n.LINESTYLE_DOTTED
				}
				_priceLineColor(e) {
					return e
				}
				_isVisible() {
					const e = this._study.model().properties().childs().scalesProperties.childs().showStudyLastValue.value(),
						t = this._study.isPlotVisibleAt(this._plotname, 1);
					return this._study.properties().childs().styles.childs()[this._plotname].childs().trackPrice.value() && e && t
				}
			}
		},
		346037: (e, t, i) => {
			i.d(t, {
				SelectionIndexes: () => r
			});
			var s = i(588537);
			class r {
				constructor(e) {
					this._baseIndex = null, this._offsetInBar = null, this._offsetInTime = null, this._barsBetweenPoints = null, this._timescale = e
				}
				indexes() {
					const e = this._timescale.visibleBarsStrictRange();
					if (null === e) return [];
					const t = e.firstBar(),
						i = e.lastBar();
					if (null === this._offsetInTime || null === this._barsBetweenPoints) {
						const e = this._timescale.barSpacing();
						this._barsBetweenPoints = Math.floor(120 / e), this._offsetInBar = i % this._barsBetweenPoints, this._offsetInTime = this._timescale.indexToTimePoint(this._offsetInBar), this._baseIndex = this._timescale.baseIndex()
					}
					const r = this._timescale.baseIndex();
					this._baseIndex !== r && (this._baseIndex = r, this._offsetInBar = (0, s.ensureNotNull)(this._timescale.timePointToIndex(this._offsetInTime)));
					const n = (0, s.ensureNotNull)(this._offsetInBar),
						o = [];
					let a = Math.floor((t - n) / this._barsBetweenPoints);
					const l = Math.floor((i - n) / this._barsBetweenPoints);
					for (; a <= l; a++) o.push(n + a * this._barsBetweenPoints);
					return o
				}
				clear() {
					this._offsetInBar = null, this._offsetInTime = null, this._baseIndex = null, this._barsBetweenPoints = null
				}
			}
		},
		859447: (e, t, i) => {
			i.d(t, {
				SelectionRenderer: () => l
			});
			var s = i(934026),
				r = i(679520),
				n = i(218718),
				o = i(87511);
			const a = r.colorsPalette["color-tv-blue-600"];
			class l {
				constructor(e) {
					this._data = e || null
				}
				setData(e) {
					this._data = e
				}
				draw(e, t) {
					if (null === this._data || !this._data.visible) return;
					const i = t.pixelRatio;
					e.strokeStyle = void 0 !== this._data.color ? this._data.color : a, e.lineCap = "butt";
					const s = Math.max(1, Math.floor(i));
					e.lineWidth = s;
					const r = this._data.vertOffset || 0;
					for (let t = 0; t < this._data.points.length; ++t) {
						const o = this._data.points[t];
						(n = o, Number.isFinite(n.x) && Number.isFinite(n.y)) && (e.fillStyle = this._data.bgColors[t], this._drawMarker(e, o, r, s, i))
					}
					var n
				}
				hitTest(e) {
					if (!this._data || !this._data.visible) return null;
					for (let t = 0; t < this._data.points.length; t++) {
						const i = this._data.points[t];
						if (i.subtract(e).length() <= 5.5) {
							const e = void 0 !== this._data.pointsCursorType ? this._data.pointsCursorType[t] : o.PaneCursorType.Default;
							return new n.HitTestResult(this._data.hittestResult, {
								pointIndex: i.data,
								cursorType: e
							})
						}
					}
					return null
				}
				doesIntersectWithBox(e) {
					return !!this._data && this._data.points.some((t => (0, s.pointInBox)(t, e)))
				}
				_drawMarker(e, t, i, s, r) {
					let n = Math.round(3.5 * r * 2);
					n % 2 != s % 2 && (n += 1);
					let o = Math.round(n + 2 * (.5 * s + .75 * r));
					o % 2 != s % 2 && (o += 1);
					const a = Math.round(t.x * r),
						l = Math.round((t.y + i) * r),
						h = s % 2 / 2;
					e.beginPath(), e.arc(a + h, l + h, o / 2, 0, 2 * Math.PI, !0), e.closePath(), e.fill(), e.beginPath(), e.arc(a + h, l + h, n / 2, 0, 2 * Math.PI, !0), e.closePath(), e.stroke()
				}
			}
		},
		207152: (e, t, i) => {
			i.d(t, {
				PaneRendererBars: () => n
			});
			var s = i(601132),
				r = i(544077);
			class n extends r.PaneRendererSeriesBase {
				constructor(e) {
					super(), this._bars = e.bars, this._barSpacing = e.barSpacing, this._dontDrawOpen = e.dontDrawOpen, this._thinBars = e.thinBars
				}
				draw(e, t) {
					e.save();
					const i = t.pixelRatio;
					if (this._barWidth = this._calcBarWidth(i), this._barWidth >= 2) {
						Math.max(1, Math.floor(i)) % 2 != this._barWidth % 2 && this._barWidth--
					}
					this._barLineWidth = this._thinBars ? Math.min(this._barWidth, Math.floor(i)) : this._barWidth;
					let s = null;
					const r = this._barLineWidth <= this._barWidth && this._barSpacing >= Math.floor(1.5 * t.pixelRatio);
					for (const t of this._bars) {
						s !== t.color && (e.fillStyle = t.color, s = t.color);
						const n = Math.floor(.5 * this._barLineWidth),
							o = Math.round(t.time * i),
							a = o - n,
							l = this._barLineWidth,
							h = a + l - 1,
							d = Math.min(t.high, t.low),
							u = Math.max(t.high, t.low),
							c = Math.round(d * i) - n,
							p = Math.round(u * i) + n,
							_ = Math.max(p - c, this._barLineWidth);
						e.fillRect(a, c, l, _);
						const f = Math.ceil(1.5 * this._barWidth);
						if (r) {
							const s = o - f,
								r = o + f,
								d = Math.min(a - s, r - h);
							if (!this._dontDrawOpen) {
								let r = Math.max(c, Math.round(t.open * i) - n),
									o = r + l - 1;
								o > c + _ - 1 && (o = c + _ - 1, r = o - l + 1), e.fillRect(s, r, d, o - r + 1)
							}
							let u = Math.max(c, Math.round(t.close * i) - n),
								p = u + l - 1;
							p > c + _ - 1 && (p = c + _ - 1, u = p - l + 1), e.fillRect(h + 1, u, d, p - u + 1)
						}
					}
					e.restore()
				}
				_getTolerance() {
					const e = this._calcBarWidth(1),
						t = this._thinBars ? Math.min(e, 1) : e;
					return (0, s.interactionTolerance)().series + t / 2
				}
				_getBarSpacing() {
					return this._barSpacing
				}
				_calcBarWidth(e) {
					const t = Math.floor(e);
					return Math.max(t, Math.floor((0, s.optimalBarWidth)(this._barSpacing, e)))
				}
			}
		},
		544077: (e, t, i) => {
			i.d(t, {
				PaneRendererSeriesBase: () => r
			});
			var s = i(218718);
			class r {
				constructor() {
					this._bars = []
				}
				hitTest(e) {
					const t = this._bars,
						i = this._getBarSpacing(),
						s = i / 2;
					if (0 === t.length) return null;
					const r = this._getTolerance(),
						n = t[0],
						o = t[t.length - 1];
					if (e.x < n.time - s - r) return null;
					if (e.x > o.time + s + r) return null;
					let a = 0,
						l = t.length - 1,
						h = -1;
					for (; a <= l;) {
						const i = Math.floor((a + l) / 2),
							d = t[i];
						let u = s;
						if (d !== n && d !== o || (u += r), Math.abs(d.time - e.x) <= u) {
							h = i;
							break
						}
						e.x - d.time > s ? a = i + 1 : l = i - 1
					}
					if (-1 !== h) {
						const n = Math.ceil(r / i);
						if (0 !== n) {
							const i = Math.max(0, h - n),
								o = Math.min(t.length - 1, h + n);
							for (let n = i; n <= o; n++)
								if (Math.abs(e.x - t[n].time) <= s + r && this._isPointAtBar(t[n], e.y, r)) return this._getHitTest()
						} else if (this._isPointAtBar(t[h], e.y, r)) return this._getHitTest()
					}
					return null
				}
				_getHitTest() {
					return new s.HitTestResult(s.HitTestResult.REGULAR)
				}
				_isPointAtBar(e, t, i) {
					const s = Math.min(e.high, e.low),
						r = Math.max(e.high, e.low);
					return s - i <= t && t <= r + i
				}
			}
		},
		280446: (e, t, i) => {
			i.d(t, {
				PaneRendererCandles: () => l
			});
			var s = i(588537),
				r = i(218718),
				n = i(164149),
				o = i(601132),
				a = i(544077);
			class l extends a.PaneRendererSeriesBase {
				constructor(e) {
					super(), this._barSpacing = 1, this._barWidth = 1, this._borderVisible = !1, this._barBorderWidth = 1, this._wickVisible = !1, this._bodyVisible = !0, this._borderColor = void 0, this._wickColor = void 0, this._hittest = void 0, this._isPriceScaleInverted = !1, e && this.setData(e)
				}
				setData(e) {
					this._bars = e.bars, this._barSpacing = e.barSpacing, this._borderVisible = e.borderVisible, this._bodyVisible = e.bodyVisible, this._wickVisible = e.wickVisible, this._borderColor = e.borderColor, this._wickColor = e.wickColor, this._hittest = e.hittest, this._isPriceScaleInverted = e.isPriceScaleInverted
				}
				hitTest(e) {
					return this._wickVisible || this._borderVisible || this._bodyVisible ? super.hitTest(e) : null
				}
				draw(e, t) {
					if (0 === this._bars.length) return;
					const i = t.pixelRatio;
					if (this._barWidth = (0, o.optimalCandlestickWidth)(this._barSpacing, i), this._barWidth >= 2) {
						Math.floor(i) % 2 != this._barWidth % 2 && this._barWidth--
					}
					this._wickVisible && this._drawWicks(e, i), this._borderVisible && this._drawBorder(e, i), this._bodyVisible && this._drawCandles(e, i)
				}
				_getTolerance() {
					return (0, o.interactionTolerance)().series + this._barBorderWidth / 2
				}
				_getBarSpacing() {
					return this._barSpacing
				}
				_getHitTest() {
					return this._hittest || new r.HitTestResult(r.HitTestResult.REGULAR)
				}
				_isPointAtBar(e, t, i) {
					const s = this._bodyVisible || this._borderVisible,
						r = this._wickVisible;
					if (!s && !r) return !1;
					if (s) {
						const s = r ? Math.min(e.high, e.low) : Math.min(e.open, e.close),
							n = r ? Math.max(e.high, e.low) : Math.max(e.open, e.close);
						return s - i <= t && t <= n + i
					} {
						const s = Math.min(e.open, e.close),
							r = Math.max(e.open, e.close);
						return e.high - i <= t && t <= s + i || r - i <= t && t <= e.low + i
					}
				}
				_drawWicks(e, t) {
					const i = this._bars;
					let r = "",
						n = Math.min(Math.floor(t), Math.floor(this._barSpacing * t));
					n = Math.max(Math.floor(t), Math.min(n, this._barWidth));
					const o = Math.floor(.5 * n);
					let a = null;
					for (const l of i) {
						const i = l.wickColor ? l.wickColor : (0, s.ensureDefined)(this._wickColor);
						i !== r && (e.fillStyle = i, r = i);
						let h = Math.round(Math.min(l.open, l.close) * t),
							d = Math.round(Math.max(l.open, l.close) * t);
						this._isPriceScaleInverted && ([d, h] = [h, d]);
						const u = Math.round(l.high * t),
							c = Math.round(l.low * t);
						let p = Math.round(t * l.time) - o;
						const _ = p + n - 1;
						null !== a && (p = Math.max(a + 1, p), p = Math.min(p, _));
						const f = _ - p + 1;
						e.fillRect(p, u, f, h - u), e.fillRect(p, d + 1, f, c - d - 1), a = _
					}
				}
				_calculateBorderWidth(e) {
					let t = Math.floor(1 * e);
					this._barWidth <= 2 * t && (t = Math.floor(.5 * (this._barWidth - 1)));
					const i = Math.max(Math.floor(e), t);
					return this._barWidth <= 2 * i ? Math.max(Math.floor(e), Math.floor(1 * e)) : i
				}
				_drawBorder(e, t) {
					let i = "";
					const r = this._calculateBorderWidth(t);
					let o = null;
					for (const a of this._bars) {
						if (a.borderColor !== i && (e.fillStyle = a.borderColor ? a.borderColor : (0, s.ensureDefined)(this._borderColor), i = a.borderColor), this._bodyVisible && a.hollow) continue;
						let l = Math.round(a.time * t) - Math.floor(.5 * this._barWidth);
						const h = l + this._barWidth - 1,
							d = Math.round(Math.min(a.open, a.close) * t),
							u = Math.round(Math.max(a.open, a.close) * t);
						if (null !== o && (l = Math.max(o + 1, l), l = Math.min(l, h)), this._barSpacing * t > 2 * r)(0, n.fillRectInnerBorder)(e, l, d, h - l + 1, u - d + 1, r);
						else {
							const t = h - l + 1;
							e.fillRect(l, d, t, u - d + 1)
						}
						o = h
					}
				}
				_drawCandles(e, t) {
					let i = "";
					const s = this._calculateBorderWidth(t);
					for (const r of this._bars) {
						if (this._borderVisible && this._barWidth <= 2 * s && !r.hollow) continue;
						let o = Math.round(Math.min(r.open, r.close) * t),
							a = Math.round(Math.max(r.open, r.close) * t),
							l = Math.round(r.time * t) - Math.floor(.5 * this._barWidth),
							h = l + this._barWidth - 1;
						if (r.color !== i) {
							const t = r.color;
							e.fillStyle = t, i = t
						}
						if (r.hollow) e.fillStyle = r.color, (0, n.fillRectInnerBorder)(e, l, o, h - l + 1, a - o + 1, s);
						else {
							if (this._borderVisible && (l += s, o += s, h -= s, a -= s), o > a) continue;
							e.fillRect(l, o, h - l + 1, a - o + 1)
						}
					}
				}
			}
		},
		5073: (e, t, i) => {
			i.d(t, {
				StatusProviderBase: () => s
			});
			class s {
				constructor(e) {
					this._colorProperty = e
				}
				size() {
					return "13px"
				}
				bold() {
					return !1
				}
				color() {
					return this._colorProperty.value()
				}
			}
		},
		892139: (e, t, i) => {
			i.d(t, {
				StatusView: () => s
			});
			class s {
				constructor(e) {
					this._text = "", this._color = "", this._size = "13px", this._bold = !1, this._statusProvider = e
				}
				text() {
					return this._text
				}
				getSplitTitle() {
					return [this._text]
				}
				color() {
					return this._statusProvider.color()
				}
				bold() {
					return this._bold
				}
				size() {
					return this._size
				}
			}
		},
		408484: (e, t, i) => {
			i.d(t, {
				AbstractFilledAreaPaneView: () => v
			});
			var s = i(588537),
				r = i(721386),
				n = i(466915);
			class o {
				constructor() {
					this._items = [], this._actualLength = 0, this._invalidations = 0
				}
				push(e) {
					this._items.length === this._actualLength ? this._items.push(e) : this._items[this._actualLength] !== e && (this._items[this._actualLength] = e), this._actualLength += 1
				}
				newItem() {
					const e = this._items.length > this._actualLength ? this._items[this._actualLength] : null;
					return null !== e && Boolean(e.invalidateCache) && e.invalidateCache(), e
				}
				invalidateCache() {
					this._invalidations += 1, 3e3 === this._invalidations && (this._items.splice(this._actualLength), this._invalidations = 0), this._actualLength = 0
				}
				at(e) {
					return this._items[e]
				}
				data() {
					return this._items
				}
				length() {
					return this._actualLength
				}
			}
			class a extends o {
				constructor(e) {
					super(), this.color = e
				}
			}
			class l {
				constructor() {
					this._map = new Map, this._usedKeys = new Set, this._invalidations = 0
				}
				invalidateCache() {
					this._invalidations += 1, 50 === this._invalidations && (this._deleteUnused(), this._invalidations = 0), this._usedKeys.clear(), this._map.forEach(((e, t) => e.invalidateCache()))
				}
				get(e) {
					const t = this._map.get(e);
					return void 0 !== t && this._usedKeys.add(e), t
				}
				set(e, t) {
					this._usedKeys.add(e), this._map.set(e, t)
				}
				forEach(e) {
					this._map.forEach(((t, i) => {
						this._usedKeys.has(i) && e(t, i)
					}))
				}
				delete(e) {
					const t = this._map.get(e);
					void 0 !== t && t.invalidateCache(), this._usedKeys.delete(e)
				}
				_deleteUnused() {
					const e = [];
					this._map.forEach(((t, i) => {
						this._usedKeys.has(i) || e.push(i)
					}));
					for (const t of e) this._map.delete(t)
				}
			}
			class h extends o {
				constructor() {
					super(), this.points1 = new o, this.points2 = new o, this.push(this.points1), this.push(this.points2)
				}
				addPoints1Point(e, t) {
					let i = this.points1.newItem();
					null !== i ? (i.x = e, i.y = t) : i = {
						x: e,
						y: t
					}, this.points1.push(i)
				}
				addPoints2Point(e, t) {
					let i = this.points2.newItem();
					null !== i ? (i.x = e, i.y = t) : i = {
						x: e,
						y: t
					}, this.points2.push(i)
				}
				invalidateCache() {
					this.points1.invalidateCache(), this.points2.invalidateCache()
				}
			}
			class d {
				constructor() {
					this._data = null
				}
				setData(e) {
					this._data = e
				}
				hitTest(e, t) {
					return null
				}
				draw(e, t) {
					if (null === this._data) return;
					const i = t.pixelRatio,
						s = .25 * this._data.barSpacing;
					this._data.colorAreas.forEach((t => {
						var r, n;
						e.beginPath();
						for (let r = 0; r < t.length(); r++) {
							const n = t.at(r);
							if (0 === n.points1.length() || 0 === n.points2.length()) continue;
							const o = n.points1.at(0).x,
								a = n.points1.at(0).y;
							if (e.moveTo(Math.round(o * i), a * i), 1 !== n.points1.length() && 1 !== n.points2.length()) {
								for (let t = 1; t < n.points1.length(); t++) e.lineTo(Math.round(n.points1.at(t).x * i), n.points1.at(t).y * i);
								for (let t = n.points2.length() - 1; t >= 0; t--) e.lineTo(Math.round(n.points2.at(t).x * i), n.points2.at(t).y * i)
							} else {
								const t = n.points2.at(0).x,
									r = n.points2.at(0).y;
								e.lineTo(Math.round((o + s) * i), a * i), e.lineTo(Math.round((t + s) * i), r * i), e.lineTo(Math.round((t - s) * i), r * i), e.lineTo(Math.round((o - s) * i), a * i)
							}
						}
						if (e.closePath(), 0 === t.color.type) e.fillStyle = t.color.color;
						else {
							const s = e.createLinearGradient(0, t.color.value1 * i, 0, t.color.value2 * i);
							s.addColorStop(0, null !== (r = t.color.color1) && void 0 !== r ? r : "transparent"), s.addColorStop(1, null !== (n = t.color.color2) && void 0 !== n ? n : "transparent"), e.fillStyle = s
						}
						e.fill()
					}))
				}
			}
			var u = i(752280),
				c = i(601132),
				p = i(612826);

			function _(e) {
				return 0 === e.type ? `${e.color}` : `${e.color1}:${e.color2}:${e.value1}:${e.value2}`
			}
			class f extends o {
				constructor() {
					super(...arguments),
						this._startIndex = 0
				}
				setStartIndex(e) {
					this._startIndex = e
				}
				at(e) {
					const t = e - this._startIndex;
					for (; t >= this._actualLength;) this._items.length <= t ? this._items.push(this._newObject()) : this._clearObject(this._items[this._actualLength]), this._actualLength += 1;
					return this._items[t]
				}
			}
			class m extends f {
				_newObject() {
					return {
						plot1Value: void 0,
						plot2Value: void 0,
						colorValue: void 0
					}
				}
				_clearObject(e) {
					e.plot1Value = void 0, e.plot2Value = void 0, e.colorValue = void 0
				}
			}
			class y extends f {
				_newObject() {
					return {
						type: void 0,
						colorIndexOrRgba: void 0,
						colorIndexOrRgba1: void 0,
						colorIndexOrRgba2: void 0,
						value1: void 0,
						value2: void 0
					}
				}
				_clearObject(e) {
					const t = e;
					t.type = void 0, t.colorIndexOrRgba = void 0, t.colorIndexOrRgba1 = void 0, t.colorIndexOrRgba2 = void 0, t.value1 = void 0, t.value2 = void 0
				}
			}
			class v {
				constructor(e, t, i = !1) {
					this._isHlineFill = !1, this._bandAKey = null, this._bandBKey = null, this._colorPlotIndex = null, this._colors = new o, this._areaRenderer = new d, this._invalidated = !0, this._plIndex1 = null, this._plIndex2 = null, this._level1 = 0, this._level2 = 0, this._studyValuesCache = new m, this._colorValuesCache = new y, this._points1 = new o, this._points2 = new o, this._timePoints = new o, this._colorAreas = new l, this._source = e, this._model = t, this._fillGaps = i
				}
				update() {
					this._invalidated = !0
				}
				renderer(e, t) {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._areaRenderer
				}
				_correctVisibleRange(e) {
					const t = this._source.data(),
						i = t.search(e.firstBar(), u.PlotRowSearchMode.NearestLeft, this._plotIndex1()),
						s = t.search(e.firstBar(), u.PlotRowSearchMode.NearestLeft, this._plotIndex2()),
						r = t.search(e.lastBar(), u.PlotRowSearchMode.NearestRight, this._plotIndex1()),
						n = t.search(e.lastBar(), u.PlotRowSearchMode.NearestRight, this._plotIndex2()),
						o = null !== i ? i.index : e.firstBar(),
						a = null !== s ? s.index : e.firstBar(),
						l = null !== r ? r.index : e.lastBar(),
						h = null !== n ? n.index : e.lastBar();
					return [Math.min(o, a), Math.max(l, h)]
				}
				_plotNames() {
					return this._source.metaInfo().plots.map((e => e.id))
				}
				_plotIndex1() {
					return null === this._plIndex1 && (this._plIndex1 = this._plotNames().indexOf(this._plotAId()) + 1), this._plIndex1
				}
				_plotIndex2() {
					return null === this._plIndex2 && (this._plIndex2 = this._plotNames().indexOf(this._plotBId()) + 1), this._plIndex2
				}
				_updateImpl() {
					var e, t;
					if (this._areaRenderer.setData(null), !this._visible()) return;
					const i = this._source.priceScale(),
						o = this._model,
						a = o.timeScale();
					if (!i || i.isEmpty() || a.isEmpty()) return;
					if (o.mainSeries().bars().isEmpty()) return;
					const l = this._source.firstValue();
					if (null === l) return;
					if (this._isHlineFill) {
						const e = this._source.properties().bands[(0, s.ensureNotNull)(this._bandAKey)],
							t = this._source.properties().bands[(0, s.ensureNotNull)(this._bandBKey)];
						this._level1 = i.priceToCoordinate(e.value.value(), l), this._level2 = i.priceToCoordinate(t.value.value(), l)
					}
					const h = a.visibleBarsStrictRange();
					if (null === h) return;
					const d = new Map,
						u = e => {
							let t = d.get(e);
							return void 0 === t && (t = i.priceToCoordinate(e, l), d.set(e, t)), t
						},
						c = (0, n.clamp)(this._transparency(), 0, 100),
						_ = new Map,
						f = e => {
							let t = _.get(e);
							return void 0 === t && (t = (0, r.generateColor)(e, c), _.set(e, t)), t
						};
					this._timePoints.invalidateCache(), this._points1.invalidateCache(),
						this._points2.invalidateCache(), this._colors.invalidateCache(), this._colorAreas.invalidateCache();
					const [m, y] = this._correctVisibleRange(h), v = null !== this._colorPlotIndex ? this._colors : null, g = this._source.offset(this._plotAId()), S = this._source.offset(this._plotBId()), b = Math.min(g, S), w = Math.max(g, S), P = this._plotIndex1(), C = this._plotIndex2(), x = this._source.data();
					if (x.isEmpty()) return;
					let I, T;
					const V = (0, s.ensureNotNull)(x.firstIndex()),
						M = (0, s.ensureNotNull)(x.lastIndex()),
						R = V - Math.max(0, -b),
						A = M + Math.max(0, w),
						B = Math.max(m - 1, R),
						L = Math.min(y + 1, A),
						O = this._studyValuesCache,
						D = this._colorValuesCache;
					O.invalidateCache(), D.invalidateCache();
					const k = B - w,
						N = x.rangeIterator(k, L - b),
						E = Math.max(h.firstBar() - 1, Math.min(k - w - 1, k - 1 + b));
					O.setStartIndex(E), D.setStartIndex(E);
					const F = new p.BarsRange(h.firstBar() - 1, h.lastBar() + 1);
					for (; N.hasNext();) {
						const e = N.next(),
							t = e.index,
							i = e.value,
							r = i[P],
							n = i[C],
							o = t + g,
							a = t + S;
						if (o === a && F.contains(o)) {
							const e = O.at(o);
							e.plot1Value = r, e.plot2Value = n
						} else {
							if (F.contains(o)) {
								O.at(o).plot1Value = r
							}
							if (F.contains(a)) {
								O.at(a).plot2Value = n
							}
						}
						if (null !== v) {
							const e = t - 1 + b;
							if (h.contains(e)) {
								const t = O.at(e),
									r = (0, s.ensureNotNull)(this._colorPlotIndex);
								if (0 === r.type) {
									const s = D.at(e);
									t.colorValue = s, s.type = 0, s.colorIndexOrRgba = i[r.colorIndexOrRgba + 1]
								} else {
									const s = D.at(e);
									t.colorValue = s, s.colorIndexOrRgba1 = void 0 === r.colorIndexOrRgba1 ? void 0 : i[r.colorIndexOrRgba1 + 1], s.colorIndexOrRgba2 = void 0 === r.colorIndexOrRgba2 ? void 0 : i[r.colorIndexOrRgba2 + 1], s.value1 = void 0 === r.valueIndex1 ? void 0 : i[r.valueIndex1 + 1], s.value2 = void 0 === r.valueIndex2 ? void 0 : i[r.valueIndex2 + 1]
								}
							}
						}
					}
					const W = this._timePoints,
						H = this._points1,
						U = this._points2;
					let z = null;
					const G = E + O.length();
					for (let i = E; i <= G; i++) {
						if (!this._fillGaps && (null === I || null === T)) {
							const e = i - 1;
							W.push(e), H.push(NaN), U.push(NaN), null == v || v.push(null)
						}
						const s = O.at(i);
						if (null !== this._colorPlotIndex) {
							const e = s.colorValue;
							void 0 === e || 0 === e.type && null == e.colorIndexOrRgba || 1 === e.type && (void 0 !== this._colorPlotIndex.valueIndex1 && null == e.value1 || void 0 !== this._colorPlotIndex.valueIndex2 && null == e.value2) ? z = null : (z = this._getColorByPlotValue(e), null !== z && (1 === z.type ? (z.value1 = u(z.value1), z.value2 = u(z.value2), z.color1 = z.color1 && f(z.color1), z.color2 = z.color2 && f(z.color2)) : z.color = f(z.color)))
						}
						if (this._isHlineFill) {
							W.push(i), null !== v && v.push(z);
							continue
						}
						const r = null !== (e = s.plot1Value) && void 0 !== e ? e : null,
							n = null !== (t = s.plot2Value) && void 0 !== t ? t : null;
						(null !== r || null !== n || Number.isFinite(I) || Number.isFinite(T)) && (I = r, T = n, H.push(r), U.push(n), W.push(i), null !== v && v.push(z))
					}
					i.pricesArrayToCoordinates(H.data(), l, H.length()), i.pricesArrayToCoordinates(U.data(), l, U.length()), a.indexesToCoordinates(W.data(), W.length());
					const Y = {
						barSpacing: this._model.timeScale().barSpacing(),
						colorAreas: this._getFilledAreas(W, H, U, v, u, f)
					};
					this._areaRenderer.setData(Y)
				}
				_getFilledAreas(e, t, i, s, r, n) {
					var o, d;
					const u = this._isHlineFill;
					if (!u && (0 === t.length() || 0 === i.length())) return new l;
					const p = this._colorAreas;
					let f = null,
						m = null;
					const y = {
							type: 0,
							color: ""
						},
						v = this._commonColor();
					1 === v.type ? (v.value1 = r(v.value1), v.value2 = r(v.value2),
						v.color1 = v.color1 && n(v.color1), v.color2 = v.color2 && n(v.color2)) : v.color = n(v.color);
					for (let r = 0; r < e.length(); r++) {
						const n = u ? this._level1 : t.at(r),
							l = u ? this._level2 : i.at(r),
							g = e.at(r),
							S = (0, c.coordinateIsValid)(n),
							b = (0, c.coordinateIsValid)(l);
						if (this._fillGaps ? S || b : S && b) {
							const e = s ? s.at(r) || y : v;
							if (m !== e || null === f) {
								m = e, null !== f && (S && f.addPoints1Point(g, n), b && f.addPoints2Point(g, l));
								const t = _(e),
									i = null !== (o = p.get(t)) && void 0 !== o ? o : new a(e);
								f = null !== (d = i.newItem()) && void 0 !== d ? d : new h, i.push(f), p.set(t, i)
							}
							S && f.addPoints1Point(g, n), b && f.addPoints2Point(g, l)
						} else this._fillGaps || (m = null, f = null)
					}
					return p.delete(_(y)), p
				}
			}
		},
		51975: (e, t, i) => {
			i.d(t, {
				AreaBackgroundPaneView: () => n
			});
			var s = i(466915),
				r = i(408484);
			class n extends r.AbstractFilledAreaPaneView {
				constructor(e, t) {
					super(e, t)
				}
				_plotAId() {
					return this._source.properties().area[0].name.value()
				}
				_plotBId() {
					return this._source.properties().area[1].name.value()
				}
				_commonColor() {
					return {
						type: 0,
						color: this._source.properties().areaBackground.backgroundColor.value()
					}
				}
				_transparency() {
					const e = this._source.properties().areaBackground.transparency.value();
					return (0, s.clamp)(e, 0, 100)
				}
				_visible() {
					return this._source.properties().areaBackground.fillBackground.value()
				}
				_getColorByPlotValue(e) {
					return this._commonColor()
				}
			}
		},
		34088: (e, t, i) => {
			i.d(t, {
				DwgExtend: () => s,
				isExtendInSameDirection: () => o,
				convertPointsToScreenDimension: () => a,
				doesItemAffectVisibleRange: () => l
			});
			var s, r = i(588537);

			function n(e, t) {
				return e === s.None ? t : t === s.None ? e : e === s.Both || t === s.Both ? s.Both : e === t ? t : s.Both
			}

			function o(e, t) {
				return e === s.Both || e === t
			}

			function a(e, t, i, o, a, l, h, d, u, c) {
				let p, _;
				if (null === e && null === i) {
					if (a !== s.Right && a !== s.Both) return null;
					a = s.Both, p = 0, _ = d
				} else null === e ? (p = h.indexToCoordinate((0, r.ensureNotNull)(i) - 1), a = n(a, s.Left)) : p = h.indexToCoordinate(e), null === i ? (_ = h.indexToCoordinate((0, r.ensureNotNull)(e) - 1), a = n(a, s.Right)) : _ = h.indexToCoordinate(i);
				const f = p,
					m = l.priceToCoordinate(t, u),
					y = _,
					v = l.priceToCoordinate(o, u);
				return void 0 !== c ? (c.x1 = f, c.y1 = m, c.x2 = y, c.y2 = v, c.extend = a, c) : {
					x1: f,
					y1: m,
					x2: y,
					y2: v,
					extend: a
				}
			}

			function l(e, t, i, r, n) {
				let o = !1;
				switch (i) {
					case s.Both:
						o = !0;
						break;
					case s.Right:
						o = null === t || null === e || e <= n;
						break;
					case s.Left:
						o = null === t || t >= r;
						break;
					default:
						null !== e && null !== t ? o = (e >= r || t >= r) && (e <= n || t <= n) : null !== e && null === t ? o = e <= n : null === e && null !== t && (o = t >= r)
				}
				return o
			}! function(e) {
				e.None = "n", e.Left = "l", e.Right = "r", e.Both = "b"
			}(s || (s = {}))
		},
		752256: (e, t, i) => {
			i.d(t, {
				DwgLabelPaneViewConstants: () => s,
				calculateLabelHeight: () => o,
				calculateDwgLabelsMargins: () => a
			});
			var s, r = i(418458),
				n = i(656164);

			function o(e, t, i) {
				let s = i;
				switch (t) {
					case r.PlotSymbolSize.Tiny:
						s = .6 * e;
						break;
					case r.PlotSymbolSize.Small:
						s = .8 * e;
						break;
					case r.PlotSymbolSize.Normal:
						s = e;
						break;
					case r.PlotSymbolSize.Large:
						s = 1.5 * e;
						break;
					case r.PlotSymbolSize.Huge:
						s = 2 * e
				}
				return s
			}

			function a(e, t, i) {
				const r = e.model().timeScale().barSpacing(),
					a = Math.round(r * s.AUTO_SIZE_MULT),
					l = o(s.NORMAL_SIZE, t.size, a) * s.SHAPE_HEIGHT_MULT;
				switch (t.style) {
					case n.DwgLabelStyle.LabelUp:
					case n.DwgLabelStyle.LabelLeftUp:
					case n.DwgLabelStyle.LabelRightUp:
						return {
							bottomPixelMargin: l, topPixelMargin: 0
						};
					case n.DwgLabelStyle.LabelDown:
					case n.DwgLabelStyle.LabelLeftDown:
					case n.DwgLabelStyle.LabelRightDown:
						return {
							bottomPixelMargin: 0, topPixelMargin: l
						};
					case n.DwgLabelStyle.LabelLeft:
					case n.DwgLabelStyle.LabelRight:
					case n.DwgLabelStyle.LabelCenter:
						return {
							bottomPixelMargin: .5 * l, topPixelMargin: .5 * l
						}
				}
				return {
					bottomPixelMargin: 0,
					topPixelMargin: 0
				}
			}! function(e) {
				e.NORMAL_SIZE = 50, e.AUTO_SIZE_MULT = 1, e.SHAPE_HEIGHT_MULT = .5, e.SHAPE_WIDTH_MULT = .6, e.FONT_SIZE_MULT = .24
			}(s || (s = {}))
		},
		721925: (e, t, i) => {
			i.d(t, {
				LiveStudyGraphics: () => o.LiveStudyGraphics,
				createGraphicsPaneViews: () => c,
				createGraphicsPriceAxisViews: () => _,
				emptyStudyGraphics: () => n.emptyStudyGraphics,
				isStudyGraphicsEmpty: () => r.isStudyGraphicsEmpty,
				loadStudyGraphics: () => n.loadStudyGraphics,
				saveStudyGraphics: () => n.saveStudyGraphics
			});
			var s = i(911905),
				r = i(965716),
				n = i(476043),
				o = i(211014),
				a = i(498424);
			class l extends a.PriceAxisView {
				constructor(e, t) {
					super(), this._source = e, this._data = t
				}
				_updateRendererData(e, t, i) {
					var s, r;
					e.visible = !1;
					const n = this._source.priceScale(),
						o = this._source.properties().childs(),
						a = o.visible.value();
					if (!n || n.isEmpty() || !a) return;
					const l = null === (r = null === (s = o.graphics.childs()[this._data.lineType]) || void 0 === s ? void 0 : s.childs()[this._data.styleId]) || void 0 === r ? void 0 : r.childs();
					if (!(void 0 !== l && l.visible && l.visible.value() && l.showPrice && l.showPrice.value() && this._isLabelVisibleAccordinglyToProperties())) return;
					const h = this._source.firstValue();
					if (null === h) return;
					const d = this._data.line.level,
						u = l.color.value();
					i.background = u, i.textColor = this.generateTextColor(u), i.coordinate = n.priceToCoordinate(d, h), e.text = n.formatPrice(d, h, !0), e.visible = !0
				}
				_isLabelVisibleAccordinglyToProperties() {
					const e = this._source.model().properties().childs().scalesProperties.childs();
					return (e.showStudyLastValue.value() || e.showFundamentalLastValue.value()) && this._source.properties().childs().showLabelsOnPriceScale.value()
				}
			}
			const h = (0, s.getLogger)("Chart.StudyGraphics"),
				d = new Set(["dwgtablecells"]);
			async function u(e, t, s, r) {
				switch (e) {
					case "backgrounds":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 720090))).BackgroundPaneView)(t, s, r);
					case "hlines":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 555551))).LevelPaneView)(t, s, r);
					case "lines":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 448837))).LinePaneView)(t, s, r);
					case "shapemarks":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 361005))).ShapeMarkPaneView)(t, s, r);
					case "textmarks":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 341218))).TextMarkPaneView)(t, s, r);
					case "trendchannels":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 480662))).TrendChannelPaneView)(t, s, r);
					case "dwglabels":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 829178))).DwgLabelPaneView)(t, s, r);
					case "dwglines":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 780983))).DwgLinePaneView)(t, s, r);
					case "dwgboxes":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 736922))).DwgBoxPaneView)(t, s, r);
					case "dwgtables":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 722827))).DwgTablePaneView)(t, s, r);
					case "dwglinefills":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 702548))).DwgLineFillPaneView)(t, s, r)
				}
				switch (e) {
					case "hhists":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 811486))).HHistPaneView)(t, s, r);
					case "horizlines":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 92787))).HorizLinePaneView)(t, s, r);
					case "vertlines":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 474160))).VertLinePaneView)(t, s, r);
					case "polygons":
						return new((await Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 256571))).PolygonPaneView)(t, s, r)
				}
				return null
			}
			async function c(e, t, i) {
				const s = [],
					r = Object.keys(e.graphicsInfo());
				r.sort(((e, t) => p(e) - p(t)));
				for (const n of r) {
					const r = await u(n, e, t, i);
					null !== r ? s.push(r) : d.has(n) || h.logWarn(`${n} is not supported by this build of graphics subsystem, skipping`)
				}
				return s
			}

			function p(e) {
				var t;
				return null !== (t = r.primitivesZOrders.get(e)) && void 0 !== t ? t : 0
			}

			function _(e) {
				const t = Object.keys(e.graphicsInfo()),
					i = [];
				for (const s of t) switch (s) {
					case "hlines":
						e.graphics().hlines().forEach(((t, r) => {
							t.forEach((t => {
								void 0 !== t.level && i.push(new l(e, {
									line: {
										level: t.level
									},
									styleId: r,
									lineType: s
								}))
							}))
						}));
						break;
					case "horizlines":
						e.graphics().horizlines().forEach(((t, r) => {
							t.forEach((t => {
								void 0 !== t.level && i.push(new l(e, {
									line: {
										level: t.level
									},
									styleId: r,
									lineType: s
								}))
							}))
						}))
				}
				return i
			}
		},
		906156: (e, t, i) => {
			i.d(t, {
				HHistBasedValuesProvider: () => p
			});
			var s = i(793751),
				r = i(588537),
				n = i(638456),
				o = i(752280),
				a = i(308170),
				l = i(591419),
				h = i(59192),
				d = i(29084);

			function u(e, t = "", i = "") {
				return {
					id: t,
					index: e,
					title: i,
					value: "",
					visible: !1
				}
			}
			const c = n.CheckMobile.any();
			class p {
				constructor(e, t) {
					this._emptyValues = [], this._study = e, this._model = t, void 0 !== this._study.metaInfo().graphics.hhists && this._emptyValues.push(u(0), u(1), u(2))
				}
				getItems() {
					return this._emptyValues
				}
				getValues(e) {
					var t, i;
					const n = this._emptyValues.map((e => ({
						...e
					})));
					n.forEach((e => {
						e.visible = this._study.isVisible(), e.value = "âˆ…"
					}));
					const a = this._study.properties().childs().inputs.childs().volume.value();
					switch (a) {
						case h.HHistVolumeMode.UpDown:
							n[0].title = "Up", n[1].title = "Down", n[2].title = "Total";
							break;
						case h.HHistVolumeMode.Total:
							n[0].title = "Total", n[1].visible = !1, n[2].visible = !1;
							break;
						case h.HHistVolumeMode.Delta:
							n[0].title = "Delta", n[1].title = "Max(Up, Down)", n[2].title = "Total"
					}
					const d = this._study.priceScale(),
						u = this._model.timeScale();
					if (null === d || d.isEmpty() || u.isEmpty() || this._hideValues()) return n;
					if (null === e || !isFinite(e)) {
						const t = this._study.data().last();
						if (null === t) return n;
						e = t.index
					}
					const c = this._model.crossHairSource(),
						p = c.price;
					if (!isFinite(c.y) && (e = function(e, t) {
							var i;
							const s = null === (i = e.visibleBarsStrictRange()) || void 0 === i ? void 0 : i.lastBar();
							if (!s) return null;
							const r = t.data().search(s, o.PlotRowSearchMode.NearestLeft);
							return r ? r.index : null
						}(this._model.timeScale(), this._model.mainSeries()), null === e)) return n;
					const _ = function(e, t, i, s) {
						if (0 === e.size) return null;
						if (!i) {
							const e = (0,
								r.ensureNotNull)(s.data().valueAt(t));
							i = s.barFunction()(e)
						}
						const n = function(e, t) {
							let i = null;
							return e.forEach(((e, s) => {
								s <= t && (null === i || s > i) && (i = s)
							})), i
						}(e, t);
						if (null === n) return null;
						const o = e.get(n);
						if (!o || 0 === o.size) return null;
						return function(e, t) {
							let i = null;
							return e.forEach((e => {
								e.priceLow <= t && t < e.priceHigh && (i = e)
							})), i
						}(o, i)
					}(this._study.graphics().hhistsByTimePointIndex(), e, p, this._model.mainSeries());
					if (null === _) return n.forEach((e => {
						e.value = "0"
					})), n;
					const f = this._study.metaInfo().graphics.hhists;
					if (void 0 === f) return n;
					if (void 0 === f[_.styleId]) return n;
					const m = null === (i = null === (t = this._study.properties().childs().graphics.childs().hhists) || void 0 === t ? void 0 : t.childs()[_.styleId]) || void 0 === i ? void 0 : i.childs(),
						y = new l.VolumeFormatter,
						v = e => (0, s.isNumber)(e) ? y.format(e) : "";
					if (a !== h.HHistVolumeMode.Delta) {
						if (_.rate.forEach(((e, t) => {
								n[t].value = v(e), n[t].color = (0, r.ensureDefined)(m).colors[t].value()
							})), a === h.HHistVolumeMode.UpDown) {
							const e = _.rate[0] + _.rate[1];
							n[2].value = v(e), n[2].color = (0, r.ensureDefined)(m).valuesColor.value()
						}
					} else {
						const e = _.rate[0] > _.rate[1] ? 0 : 1,
							t = (0, r.ensureDefined)(m).colors[e].value(),
							i = _.rate[0] + _.rate[1];
						[2 * _.rate[e] - i, _.rate[e], i].forEach(((e, i) => {
							n[i].value = v(e), n[i].color = t
						}))
					}
					return n
				}
				_hideValues() {
					return c && (null === this._model.crossHairSource().pane || (0, d.isLineToolName)(a.tool.value()) || null !== this._model.lineBeingEdited())
				}
			}
		},
		181626: (e, t, i) => {
			function s(e) {
				e.lineWidth = void 0, e.lineStyle = void 0;
				for (let t = 0; t < e.colors.length; t++) e.colors[t] = void 0;
				return e
			}

			function r() {
				return {
					colors: [void 0, void 0, void 0, void 0, void 0, void 0, void 0],
					lineWidth: void 0,
					lineStyle: void 0
				}
			}
			i.d(t, {
				clearStyle: () => s,
				createEmptyStyle: () => r
			})
		},
		737191: (e, t, i) => {
			i.d(t, {
				PaneRendererColumns: () => r
			});
			var s = i(218718);
			class r {
				constructor(e) {
					this._data = null, this._precalculatedCache = [], this.setData(e)
				}
				setData(e) {
					this._data = e, this._precalculatedCache = []
				}
				draw(e, t) {
					var i, s, r, n;
					if (null === this._data || 0 === this._data.items.length) return;
					const o = t.pixelRatio;
					this._precalculatedCache.length || this._fillPrecalculatedCache(o);
					const a = Math.max(1, Math.floor(o)),
						l = Math.round(this._data.histogramBase * o) - Math.floor(a / 2),
						h = l + a,
						d = this._data.lineColor,
						u = null !== (s = null === (i = this._data.visibleItemsRange) || void 0 === i ? void 0 : i.startItemIndex) && void 0 !== s ? s : 0,
						c = (null !== (n = null === (r = this._data.visibleItemsRange) || void 0 === r ? void 0 : r.endItemIndex) && void 0 !== n ? n : this._data.items.length) - 1;
					for (let t = u; t <= c; t++) {
						const i = this._data.items[t],
							s = this._precalculatedCache[t - u],
							r = Math.round(i.y * o),
							n = i.style ? i.style.color : d;
						let c, p;
						e.fillStyle = n, r <= l ? (c = r, p = h) : (c = l, p = r - Math.floor(a / 2) + a), e.fillRect(s.left, c, s.right - s.left + 1, p - c)
					}
				}
				hitTest(e) {
					if (null === this._data) return null;
					const t = .5 * this._data.barSpacing,
						i = e.x - t,
						r = e.x + t;
					for (const t of this._data.items) {
						const n = t.x;
						if (n >= i && n <= r) {
							const i = t.y;
							if (e.y >= Math.min(i, this._data.histogramBase) && e.y <= Math.max(i, this._data.histogramBase)) return new s.HitTestResult(s.HitTestResult.REGULAR)
						}
					}
					return null
				}
				_fillPrecalculatedCache(e) {
					var t, i, s, r;
					if (null === this._data || 0 === this._data.items.length) return void(this._precalculatedCache = []);
					const n = Math.ceil(this._data.barSpacing * e) <= 1 ? 0 : Math.max(1, Math.floor(e)),
						o = Math.round(this._data.barSpacing * e) - n,
						a = null !== (i = null === (t = this._data.visibleItemsRange) || void 0 === t ? void 0 : t.startItemIndex) && void 0 !== i ? i : 0,
						l = (null !== (r = null === (s = this._data.visibleItemsRange) || void 0 === s ? void 0 : s.endItemIndex) && void 0 !== r ? r : this._data.items.length) - 1,
						h = l - a + 1;
					if (h <= 0) return void(this._precalculatedCache = []);
					this._precalculatedCache = new Array(h);
					for (let t = a; t <= l; t++) {
						const i = this._data.items[t],
							s = Math.round(i.x * e);
						let r, n;
						if (o % 2) {
							const e = (o - 1) / 2;
							r = s - e, n = s + e
						} else {
							const e = o / 2;
							r = s - e, n = s + e - 1
						}
						this._precalculatedCache[t - a] = {
							left: r,
							right: n,
							roundedCenter: s,
							center: i.x * e,
							time: i.timePointIndex
						}
					}
					for (let e = a + 1; e <= l; e++) {
						const t = this._precalculatedCache[e - a],
							i = this._precalculatedCache[e - a - 1];
						t.time === i.time + 1 && (t.left - i.right !== n + 1 && (i.roundedCenter > i.center ? i.right = t.left - n - 1 : t.left = i.right + n + 1))
					}
					let d = Math.ceil(this._data.barSpacing * e);
					for (let e = a + 1; e <= l; e++) {
						const t = this._precalculatedCache[e - a];
						t.right < t.left && (t.right = t.left);
						const i = t.right - t.left + 1;
						d = Math.min(i, d)
					}
					if (n > 0 && d < 4)
						for (let e = a + 1; e <= l; e++) {
							const t = this._precalculatedCache[e - a];
							t.right - t.left + 1 > d && (t.roundedCenter > t.center ? t.right -= 1 : t.left += 1)
						}
				}
			}
		},
		951433: (e, t, i) => {
			i.d(t, {
				StudyPlotPaneView: () => k
			});
			var s = i(588537),
				r = i(86441),
				n = i(724377),
				o = i(611688),
				a = i(466915),
				l = i(270617),
				h = i(721386),
				d = i(746511),
				u = i(165035),
				c = i(218718),
				p = i(896949),
				_ = i(717611),
				f = i(729828),
				m = i(68226),
				y = i(346037),
				v = i(859447),
				g = i(181626),
				S = i(573033),
				b = i(601132),
				w = i(638456);
			class P {
				constructor(e) {
					this._data = e
				}
				draw(e, t) {
					var i, s, r, n;
					const o = this._data,
						a = t.pixelRatio,
						h = Math.max(1, Math.floor(a)) % 2 ? .5 : 0,
						d = o.vertOffset || 0,
						u = o.lineColor || o.color,
						c = o.lineWidth || o.height / 2;
					let p = "",
						_ = !1;
					const f = null !== (s = null === (i = o.visibleItemsRange) || void 0 === i ? void 0 : i.startItemIndex) && void 0 !== s ? s : 0,
						m = null !== (n = null === (r = o.visibleItemsRange) || void 0 === r ? void 0 : r.endItemIndex) && void 0 !== n ? n : o.items.length;
					for (let t = f; t < m; t++) {
						const i = o.items[t],
							s = i.x,
							r = i.y + d;
						if ((0, l.isNaN)(s) || (0, l.isNaN)(r)) continue;
						let n, f;
						null != i.style ? (n = i.style.color, f = i.style.width) : (n = u, f = c), (n !== p || w.isSafari) && (p = n, _ && e.fill(), e.beginPath(), e.fillStyle = n);
						const m = Math.round(s * a) + h,
							y = Math.round(r * a) + h,
							v = Math.round(f * a) + h;
						e.moveTo(m + v, y), e.arc(m, y, v, 0, 2 * Math.PI, !1), _ = !0
					}
					_ && e.fill()
				}
				hitTest(e) {
					var t, i, s, n;
					const o = this._data,
						a = o.lineWidth || o.height / 2,
						l = o.vertOffset || 0,
						h = (0, b.interactionTolerance)().series + a,
						d = null !== (i = null === (t = o.visibleItemsRange) || void 0 === t ? void 0 : t.startItemIndex) && void 0 !== i ? i : 0,
						u = null !== (n = null === (s = o.visibleItemsRange) || void 0 === s ? void 0 : s.endItemIndex) && void 0 !== n ? n : o.items.length;
					for (let t = d; t < u; t++) {
						const i = o.items[t];
						if (new r.Point(i.x, i.y + l).subtract(e).length() + a <= h) return new c.HitTestResult(c.HitTestResult.REGULAR)
					}
					return null
				}
			}
			var C = i(737191),
				x = i(204652);
			class I {
				constructor(e) {
					this._data = e
				}
				draw(e, t) {
					var i, s, r, n, o, a, h, d;
					const u = t.pixelRatio;
					let c = "",
						p = !1;
					const _ = null !== (s = null === (i = this._data.visibleItemsRange) || void 0 === i ? void 0 : i.startItemIndex) && void 0 !== s ? s : 0,
						f = (null !== (n = null === (r = this._data.visibleItemsRange) || void 0 === r ? void 0 : r.endItemIndex) && void 0 !== n ? n : this._data.items.length) - 1;
					for (let t = _; t <= f; t++) {
						const i = this._data.items[t];
						if ((0, l.isNaN)(i.x) || (0, l.isNaN)(i.y)) continue;
						const s = null !== (a = null === (o = i.style) || void 0 === o ? void 0 : o.color) && void 0 !== a ? a : this._data.lineColor,
							r = Math.max(1, Math.floor((null !== (d = null === (h = i.style) || void 0 === h ? void 0 : h.width) && void 0 !== d ? d : this._data.lineWidth) * u));
						(s !== c || w.isSafari) && (c = s, p && e.fill(), e.beginPath(), e.fillStyle = s);
						let n = 3 * r;
						n % 2 != r % 2 && (n += 1);
						const _ = Math.round(Math.round(i.x * u) - n / 2),
							f = Math.round(Math.round(i.y * u) - n / 2),
							m = _ + Math.floor(n / 2 - r / 2),
							y = f + Math.floor(n / 2 - r / 2);
						e.rect(_, y, n, r), e.rect(m, f, r, n), p = !0
					}
					p && e.fill()
				}
				hitTest(e) {
					const t = (0, b.interactionTolerance)().series + this._data.lineWidth / 2;
					let i, s, n, o;
					for (let a = 1; a < this._data.items.length; ++a) {
						i = this._data.items[a - 1], s = this._data.items[a], n = i.x, o = s.x;
						if ((0, x.distanceToSegment)(new r.Point(n, i.y), new r.Point(o, s.y), new r.Point(e.x, e.y)).distance <= t) return new c.HitTestResult(c.HitTestResult.REGULAR)
					}
					return null
				}
			}
			class T {
				constructor(e) {
					this._data = e
				}
				draw(e, t) {
					var i, s, r, n;
					if (0 === this._data.items.length) return;
					const o = t.pixelRatio;
					e.fillStyle = this._data.lineColor;
					const a = Math.max(1, Math.floor(this._data.lineWidth * o)),
						l = a / 2,
						h = Math.max(1, Math.floor(o)),
						d = Math.round(this._data.histogramBase * o) - Math.floor(h / 2),
						u = d + h,
						c = null !== (s = null === (i = this._data.visibleItemsRange) || void 0 === i ? void 0 : i.startItemIndex) && void 0 !== s ? s : 0,
						p = (null !== (n = null === (r = this._data.visibleItemsRange) || void 0 === r ? void 0 : r.endItemIndex) && void 0 !== n ? n : this._data.items.length) - 1;
					for (let t = c; t <= p; t++) {
						const i = this._data.items[t];
						let s = a,
							r = l;
						i.style ? (e.fillStyle = i.style.color, s = Math.max(1, Math.floor(i.style.width * o)), r = s / 2) : e.fillStyle = this._data.lineColor;
						const n = s % 2 ? .5 : 0,
							c = Math.round(i.x * o) + n,
							p = Math.round(i.y * o);
						let _, f;
						p <= d ? (_ = p, f = u) : (_ = d, f = p - Math.floor(h / 2) + h), e.fillRect(Math.floor(c - r), _, s, f - _)
					}
				}
				hitTest(e) {
					const t = (0, b.interactionTolerance)().series + this._data.lineWidth / 2,
						i = new Map;
					for (const n of this._data.items) {
						const o = n.x,
							a = n.y;
						let l = t;
						n.style && (i.has(n.style.width) ? l = (0, s.ensureDefined)(i.get(n.style.width)) : i.set(this._data.lineWidth, l));
						if ((0, x.distanceToSegment)(new r.Point(o, a), new r.Point(o, this._data.histogramBase), new r.Point(e.x, e.y)).distance <= l) return new c.HitTestResult(c.HitTestResult.REGULAR)
					}
					return null
				}
			}
			var V = i(418458),
				M = i(362857),
				R = i(377884),
				A = i(752280);
			const B = e => {
					const t = (0, n.rgbToHsl)((0, n.parseRgb)(e)),
						i = t[0] + .05;
					return t[0] = i - Math.floor(i), (0, n.rgbToHexString)((0, n.hslToRgb)(t))
				},
				L = (0, u.memoize)(B);

			function O(e, t) {
				if (null === e) return t;
				const i = e.firstIndex,
					s = t.firstIndex,
					r = e.clearData || t.clearData;
				return {
					firstIndex: r || void 0 === i || void 0 === s ? void 0 : Math.min(i, s),
					clearData: r
				}
			}
			const D = new Set([V.LineStudyPlotStyle.Line, V.LineStudyPlotStyle.Area, V.LineStudyPlotStyle.Circles, V.LineStudyPlotStyle.Cross, V.LineStudyPlotStyle.StepLine, V.LineStudyPlotStyle.StepLineWithDiamonds]);
			class k {
				constructor(e, t, i, s) {
					this._histogramBase = null, this._items = [], this._lastConfirmedSeriesBarCoordinate = NaN, this._selectionData = null, this._lineColor = "", this._lineWidth = 1, this._color1 = "", this._color2 = "", this._dataInvalidated = null, this._viewportInvalidated = !1, this._renderer = new _.CompositeRenderer, this._isMarkersEnabled = o.enabled("source_selection_markers"), this._study = e, this._series = t, this._model = i, this._plotName = s, this._plotIndex = e.metaInfo().plots.findIndex((e => e.id === s)), this._colorProvider = (0, M.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s), this._selectionIndexer = new y.SelectionIndexes(i.timeScale())
				}
				items() {
					return this._items
				}
				update(e) {
					if ("global-change" === e.type) return this._dataInvalidated = O(this._dataInvalidated, {}), void(this._viewportInvalidated = !0);
					if ("data-source-change" !== e.type) this._viewportInvalidated = !0;
					else {
						if (e.dataSourceId === this._study.id()) {
							const t = O(this._dataInvalidated, {
								firstIndex: e.firstUpdatedTimePointIndex,
								clearData: e.clearData
							});
							this._dataInvalidated = t
						}
					}
				}
				renderer() {
					return this._dataInvalidated ? this._updateImplFull(this._viewportInvalidated) && (this._dataInvalidated = null) : this._viewportInvalidated && this._updateImplLight(), this._viewportInvalidated = !1, this._renderer
				}
				_getTranspValue() {
					const e = this._study.properties(),
						t = e.styles[this._plotName];
					let i = 0;
					const s = this._study.metaInfo();
					return "Volume@tv-basicstudies" === s.id && s.version <= 46 && "transparency" in e ? (i = e.transparency.value(), i = (0, l.isNumber)(i) ? i : 0, i) : (t.transparency && (i = t.transparency.value(), i = (0, l.isNumber)(i) ? i : 0), i)
				}
				_updateImplFull(e) {
					var t, i, n, o;
					if (this._renderer.clear(), (null === (t = this._dataInvalidated) || void 0 === t ? void 0 : t.clearData) && (this._items = []), !this._study.isPlotVisibleAt(this._plotName, 1)) return !1;
					if (!this._study.priceScale()) return !1;
					const l = this._study.firstValue();
					if (null === l) return !1;
					const d = this._study.priceScale();
					if (null === d) return !1;
					this._histogramBase = null;
					const u = this._study.data(),
						c = u.size();
					if (0 === c) return !1;
					const p = this._study.offset(this._plotName);
					let _ = null === (i = this._dataInvalidated) || void 0 === i ? void 0 : i.firstIndex;
					const f = this._study.properties().styles[this._plotName],
						m = f.plottype.value(),
						y = D.has(m);
					if (c !== this._items.length) {
						const e = void 0 !== _ ? _ + p : void 0;
						if (void 0 === e || 0 === this._items.length || e < (0, s.ensureDefined)(this._items[0].timePointIndex)) this._items = [], u.each(((e, t) => {
							const i = t[this._plotIndex + 1];
							if (y && null == i || e <= -1e6) return !1;
							const s = new r.Point(NaN, NaN);
							return s.origPrices = new r.Point(NaN, NaN), s.timePointIndex = e + p, this._items.push(s), !1
						})), _ = this._items.length ? (0, s.ensureDefined)(this._items[0].timePointIndex) - p : void 0;
						else {
							const e = this._items[this._items.length - 1].timePointIndex,
								t = (0, s.ensureDefined)(e) - p,
								i = (0, s.ensureNotNull)(u.lastIndex()) + 1,
								n = u.rangeIterator(t + 1, i);
							for (; n.hasNext();) {
								const e = n.next(),
									t = e.value[this._plotIndex + 1],
									i = null == t;
								if (y && i || e.index < -1e6) continue;
								const s = new r.Point(NaN, NaN);
								s.origPrices = new r.Point(NaN, NaN), s.timePointIndex = e.index + p, this._items.push(s)
							}
						}
					}
					let v = NaN,
						S = NaN;
					const b = new Map,
						w = (e, t) => {
							let i = b.get(e);
							void 0 === i && (i = new Map, b.set(e, i));
							let s = i.get(t);
							if (void 0 === s) {
								const r = !this._plotName || "vol" !== this._plotName;
								s = (0, h.generateColor)(e, t, r), i.set(t, s)
							}
							return s
						},
						P = (0, g.createEmptyStyle)(),
						C = (0, a.clamp)(this._getTranspValue(), 0, 100),
						x = this._model.timeScale().visibleBarsStrictRange();
					if (null === x) return !1;
					const {
						startBar: I,
						endBar: T
					} = this._calculateStartEnd(x);
					if (null === I || null === T || 0 === this._items.length) return !1;
					const V = null != _ ? _ : (0, s.ensureNotNull)(u.firstIndex()),
						M = u.rangeIterator(V, (0, s.ensureNotNull)(u.lastIndex()) + 1),
						A = (0, R.lowerbound)(this._items, V + p, ((e, t) => e.timePointIndex < t));
					let B = A;
					for (; M.hasNext();) {
						const e = M.next();
						let t = e.index;
						const i = e.value;
						t += p, t = Math.floor(t);
						let a = i[this._plotIndex + 1];
						const l = null == a;
						if (a = l ? NaN : a, y && l) {
							S = a;
							continue
						}
						const d = new r.Point(t, (0, s.ensure)(a));
						d.timePointIndex = t, d.valIsNotSameAsPrev = a !== S || t - 1 !== v;
						if (this._colorProvider.isColorDefined() && (d.style = {
								color: w(f.color.value(), 100),
								width: f.linewidth.value(),
								style: f.linestyle.value()
							}, null != a)) {
							const e = this._colorProvider.getPlotPointStyle(i, P),
								t = e.colors[0];
							void 0 !== t && (d.style.color = (0, h.isHexColor)(t) ? w(t, C) : t), d.style.width = null !== (n = e.lineWidth) && void 0 !== n ? n : d.style.width, d.style.style = null !== (o = e.lineStyle) && void 0 !== o ? o : d.style.style
						}
						if (!y && !isNaN(v) && v !== t - 1 && B > 0) {
							const e = this._items[B - 1].timePointIndex,
								i = new r.Point(t - 1, NaN);
							i.origPrices = new r.Point(t - 1, NaN), i.timePointIndex = e, B < this._items.length ? this._items[B] = i : this._items.push(i), B++
						}
						v = t, S = a; {
							const e = d;
							e.origPrices = new r.Point(d.x, d.y), B < this._items.length ? this._items[B] = e : this._items.push(e), B++
						}
					}
					if (this._items.length) {
						const t = this._model.mainSeries().data().bars().lastIndex();
						null !== t && (this._lastConfirmedSeriesBarCoordinate = this._model.timeScale().indexToCoordinate(t));
						const i = Math.max(0, (0, R.lowerbound)(this._items, I, ((e, t) => e.timePointIndex < t))),
							s = Math.min(this._items.length, (0, R.upperbound)(this._items, T, ((e, t) => e < t.timePointIndex))),
							r = e ? i : Math.max(i, A),
							n = s;
						for (let e = r; e < n; e++) {
							const t = this._items[e];
							t.x = t.origPrices.x, t.y = t.origPrices.y
						}
						d.pointsArrayToCoordinates(this._items, l, {
							startItemIndex: r,
							endItemIndex: n
						}), this._model.timeScale().timedValuesToCoordinates(this._items, {
							startItemIndex: r,
							endItemIndex: n
						}), f.histogramBase && (this._histogramBase = d.priceToCoordinate(f.histogramBase.value(), l)), this._createSelection(l), this._createRenderer(i, s)
					}
					return !0
				}
				_updateImplLight() {
					const e = this._study.firstValue();
					if (null === e) return this._selectionData = null, void this._createRenderer(0, -1);
					const t = this._study.priceScale();
					if (null === t) return this._selectionData = null, void this._createRenderer(0, -1);
					const i = this._model.timeScale().visibleBarsStrictRange();
					if (null === i) return this._selectionData = null, void this._createRenderer(0, -1);
					const {
						startBar: s,
						endBar: r
					} = this._calculateStartEnd(i);
					if (null === s || null === r || 0 === this._items.length) return this._selectionData = null, void this._createRenderer(0, -1);
					const n = Math.max(0, (0, R.lowerbound)(this._items, s, ((e, t) => e.timePointIndex < t))),
						o = Math.min(this._items.length, (0, R.upperbound)(this._items, r, ((e, t) => e < t.timePointIndex)));
					for (let e = n; e < o; e++) {
						const t = this._items[e];
						t.x = t.origPrices.x, t.y = t.origPrices.y
					}
					t.pointsArrayToCoordinates(this._items, e, {
						startItemIndex: n,
						endItemIndex: o
					}), this._model.timeScale().timedValuesToCoordinates(this._items, {
						startItemIndex: n,
						endItemIndex: o
					});
					const a = this._study.properties().styles[this._plotName];
					a.histogramBase && (this._histogramBase = t.priceToCoordinate(a.histogramBase.value(), e)), this._createSelection(e);
					const l = this._model.mainSeries().data().bars().lastIndex();
					null !== l && (this._lastConfirmedSeriesBarCoordinate = this._model.timeScale().indexToCoordinate(l)), this._createRenderer(n, o)
				}
				_calculateStartEnd(e) {
					const t = this._study.offset(this._plotName);
					let i = e.firstBar() - Math.abs(t) - 1,
						s = e.lastBar() + Math.abs(t) + 1;
					const r = this._study.data(),
						n = r.search(i, A.PlotRowSearchMode.NearestLeft, this._plotIndex + 1),
						o = r.search(s, A.PlotRowSearchMode.NearestRight, this._plotIndex + 1);
					null !== n && (i = n.index), null !== o && (s = o.index);
					const a = this._study.getMinFirstBarIndexForPlot(this._plotName) + t;
					return a > s + 1 ? {
						startBar: null,
						endBar: null
					} : (i = Math.max(a, i), {
						startBar: i,
						endBar: s
					})
				}
				_createRenderer(e, t) {
					var i;
					this._renderer.clear();
					const r = this._study.properties().styles[this._plotName],
						n = (0, a.clamp)(this._getTranspValue(), 0, 100);
					this._lineColor = (0, h.generateColor)(r.color.value(), n), this._lineWidth = r.linewidth.value();
					let o = r.color.value();
					const u = this._colorProvider.getDefaultPlotPointStyle();
					u && (o = u.colors[0], this._lineWidth = null !== (i = u.lineWidth) && void 0 !== i ? i : this._lineWidth, this._lineColor = o ? (0, h.generateColor)(o, n) : this._lineColor), this._color2 = (0, h.generateColor)(o, n);
					const c = this._study.metaInfo(),
						_ = c.isRGB ? B(o) : L(o);
					this._color1 = (0, h.generateColor)(_, n);
					const y = {};
					y.barSpacing = this._model.timeScale().barSpacing(), y.items = this._items, y.histogramBase = this._histogramBase ? this._histogramBase : (0, s.ensureNotNull)(this._study.priceScale()).height(), y.lineIndex = 0, y.lineStyle = r.linestyle.value(), y.lineColor = this._lineColor, y.lineWidth = this._lineWidth, y.lineWidth = (0, l.isNumber)(y.lineWidth) ? y.lineWidth : 1, y.color1 = this._color1, y.color2 = this._color2, y.bottom = y.histogramBase, y.visibleItemsRange = {
						startItemIndex: e,
						endItemIndex: t
					}, y.lastConfirmedSeriesBarCoordinate = this._lastConfirmedSeriesBarCoordinate, y.simpleMode = this._colorProvider.singleColor();
					const g = this._renderer,
						b = !!r.joinPoints && r.joinPoints.value();
					switch (r.plottype.value()) {
						case V.LineStudyPlotStyle.Line:
						case V.LineStudyPlotStyle.LineWithBreaks:
							g.append(new f.PaneRendererLine(y));
							break;
						case V.LineStudyPlotStyle.Area:
						case V.LineStudyPlotStyle.AreaWithBreaks:
							g.append(new p.PaneRendererArea(y));
							break;
						case V.LineStudyPlotStyle.Histogram:
							g.append(new T(y));
							break;
						case V.LineStudyPlotStyle.Columns:
							g.append(new C.PaneRendererColumns(y));
							break;
						case V.LineStudyPlotStyle.Cross:
							if (g.append(new I(y)), b) {
								const e = (0, d.deepCopy)(y);
								e.lineWidth = 1, e.forceLineWidth = !0, g.append(new f.PaneRendererLine(e))
							}
							break;
						case V.LineStudyPlotStyle.Circles:
							if (g.append(new P(y)), b) {
								const e = (0, d.deepCopy)(y);
								e.lineWidth = 1, e.ignorePaletteLineWidth = !0, g.append(new f.PaneRendererLine(e))
							}
							break;
						case V.LineStudyPlotStyle.StepLine:
						case V.LineStudyPlotStyle.StepLineWithDiamonds: {
							y.decoration = r.plottype.value() === V.LineStudyPlotStyle.StepLineWithDiamonds ? m.StepLineDecoration.Diamonds : m.StepLineDecoration.None;
							const e = new m.PaneRendererStepLine(void 0, (0, S.isFundamentalStudyMetaInfo)(c));
							e.setData(y), g.append(e);
							break
						}
						default:
							g.append(new f.PaneRendererLine(y))
					}
					this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData && g.append(new v.SelectionRenderer(this._selectionData))
				}
				_createSelection(e) {
					const t = this._study.priceScale();
					if (null !== t)
						if (this._model.selection().isSelected(this._study)) {
							const i = this._selectionIndexer.indexes();
							this._selectionData = {
								points: [],
								bgColors: [],
								visible: !0,
								hittestResult: c.HitTestResult.REGULAR,
								barSpacing: this._model.timeScale().barSpacing()
							};
							const n = (0, s.ensureNotNull)(this._model.paneForSource(this._study)).height(),
								o = this._study.offset(this._plotName);
							for (let s = 0; s < i.length; s++) {
								let a = i[s];
								const l = this._study.data().valueAt(a);
								if (a += o, null === l) continue;
								const h = l[this._plotIndex + 1];
								if (null == h) continue;
								const d = this._model.timeScale().indexToCoordinate(Math.floor(a)),
									u = t.priceToCoordinate(h, e);
								this._selectionData.points.push(new r.Point(d, u)), this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(u / n))
							}
						} else this._selectionIndexer.clear()
				}
			}
		},
		360511: (e, t, i) => {
			i.d(t, {
				PaneRendererAbstractShape: () => c,
				PaneRendererAbstractStrokeShape: () => p,
				PaneRendererAbstractFillStrokeShape: () => _
			});
			var s = i(588537),
				r = i(86441),
				n = i(934026),
				o = i(218718),
				a = i(945455),
				l = i(267151),
				h = i(588427),
				d = i(824112),
				u = i(638456);
			class c {
				constructor(e, t = {
					skipRenderingOptimizations: !1
				}) {
					this._items = [], this._barSpacing = 0, this._vertOffset = 0, this._textCache = t.textCache || new a.TextImageCachesContainer(5e3), this._drawOperation = t.skipRenderingOptimizations ? this._drawWithoutOptimizations.bind(this) : this._drawWithOptimizations.bind(this), null !== e && this.setData(e)
				}
				draw(e, t) {
					this._preDrawInit(), this._drawOperation(e, t)
				}
				hitTest(e) {
					const t = o.HitTestResult.REGULAR;
					let i = null;
					for (const s of this._items) {
						if (!s) continue;
						const r = this._calcBoundingBox(s);
						if (r && (0, n.pointInBox)(e, r)) {
							const e = {
								tooltip: this._getTooltip(s, r)
							};
							i = new o.HitTestResult(t, e)
						}
					}
					return i
				}
				setData(e) {
					this._height = void 0 !== e.height ? e.height : e.width, this._width = void 0 !== e.width ? e.width : e.height, this._color = e.color, this._borderColor = e.borderColor, this._vertOffset = e.vertOffset || 0, e.text && (this._text = e.text, this._fontSize = e.fontSize, this._lineSpacing = e.lineSpacing, this._textColor = e.textColor, this._textAlign = e.textAlign || "center"), void 0 !== e.items && void 0 !== e.barSpacing && this.setItems(e.items, e.barSpacing)
				}
				setItems(e, t) {
					this._setBaseData(e, t)
				}
				_calcBoundingBox(e) {
					const t = e.vertOffset,
						i = this._getTextCache(e);
					if (!i) return;
					const s = i.textImageWidth,
						n = i.textImageHeight,
						o = s / 2,
						a = e.y + t + e.textVertOffset,
						l = t > 0 ? 0 : -n,
						h = t > 0 ? n : 0,
						d = new r.Point(e.x - o, a + l),
						u = new r.Point(e.x + o, a + h);
					return (0, r.box)(d, u)
				}
				_unionBox(e, t) {
					const i = Math.min(e.min.x, t.min.x),
						s = Math.max(e.max.x, t.max.x),
						n = Math.min(e.min.y, t.min.y),
						o = Math.max(e.max.y, t.max.y),
						a = new r.Point(i, n),
						l = new r.Point(s, o);
					return (0,
						r.box)(a, l)
				}
				_getTooltip(e, t) {
					if (e.tooltip) return {
						content: {
							type: "text",
							data: e.tooltip
						},
						tooltipDelay: 200,
						extendMargin: !0,
						rect: {
							x: t.min.x,
							y: t.min.y,
							w: Math.abs(t.max.x - t.min.x),
							h: Math.abs(t.max.y - t.min.y)
						}
					}
				}
				_setBaseData(e, t) {
					this._items.length = 0, this._barSpacing = t;
					for (const t of e) {
						const e = void 0 === t.width ? (0, s.ensureDefined)(this._width) : t.width,
							i = void 0 === t.height ? (0, s.ensureDefined)(this._height) : t.height,
							r = void 0 === t.vertOffset ? this._vertOffset : t.vertOffset,
							n = r > 0 ? i : -i;
						this._items.push({
							width: e,
							height: i,
							vertOffset: r,
							textVertOffset: n,
							shapeWidth: 0,
							shapeHeight: 0,
							stepX: 0,
							stepY: 0,
							...t
						})
					}
				}
				_drawItemText(e, t, i) {
					const s = this._getTextCache(i);
					if (null === s) return;
					const r = i.x,
						n = i.vertOffset,
						o = i.y + n + i.textVertOffset;
					let a;
					a = i.style && void 0 !== i.style.textColor ? i.style.textColor : this._textColor;
					const h = {
						style: {
							fillStyle: a
						},
						location: {
							x: r,
							y: o,
							horzAlign: l.HorizontalAlign.Center,
							vertAlign: n > 0 ? l.VerticalAlign.Top : l.VerticalAlign.Bottom
						}
					};
					s.paintTo(e, t, h)
				}
				_drawWithOptimizations(e, t) {
					let i, s, r = null,
						n = !1;
					for (const o of this._items) o.style && void 0 !== o.style.color ? (i = o.style.color || "rgba(0, 0, 0, 0)", s = o.style.borderColor || "rgba(0, 0, 0, 0)") : (i = this._color, s = this._borderColor), (r !== i || u.isSafari) && (r = i, n && this._endPath(e), this._startPath(e, t, i, s)), this._drawItemShape(e, t, o), n = !0;
					n && this._endPath(e);
					for (const i of this._items) this._drawItemText(e, t, i)
				}
				_drawWithoutOptimizations(e, t) {
					let i, r;
					for (const n of this._items) {
						const o = (0, s.ensureDefined)(n.style);
						i = o.color || "rgba(0, 0, 0, 0)", r = o.borderColor || "rgba(0, 0, 0, 0)", this._startPath(e, t, i, r), this._drawItemShape(e, t, n), this._endPath(e), this._drawItemText(e, t, n)
					}
				}
				_drawItemShape(e, t, i) {
					(0, d.drawScaled)(e, t.pixelRatio, (() => this._drawItemShapeUsingCSSPixels(e, i)))
				}
				_drawItemShapeUsingCSSPixels(e, t) {}
				_preDrawInit() {}
				_startPath(e, t, i, s) {}
				_endPath(e) {}
				_getTextCache(e) {
					var t, i;
					const s = e.text || this._text,
						r = e.fontSize || this._fontSize,
						n = null !== (t = e.lineSpacing) && void 0 !== t ? t : this._lineSpacing,
						o = e.textAlign || this._textAlign,
						a = null !== (i = e.font) && void 0 !== i ? i : h.CHART_FONT_FAMILY;
					return this._textCache.get({
						text: s,
						bold: !1,
						italic: !1,
						font: a,
						fontSize: r,
						lineSpacing: n,
						align: o
					})
				}
			}
			class p extends c {
				_startPath(e, t, i, s) {
					e.beginPath(), e.lineWidth = this._lineWidth(t), e.lineCap = "butt", e.strokeStyle = i
				}
				_endPath(e) {
					e.stroke()
				}
				_lineWidth(e) {
					return Math.max(1, Math.floor(2 * e.pixelRatio))
				}
			}
			class _ extends c {
				_startPath(e, t, i, s) {
					e.beginPath(), e.lineWidth = this._lineWidth(t), e.lineCap = "butt", e.fillStyle = i, e.strokeStyle = s
				}
				_endPath(e) {
					e.fill(), e.stroke()
				}
				_lineWidth(e) {
					return Math.max(1, Math.floor(e.pixelRatio))
				}
			}
		},
		453864: (e, t, i) => {
			i.d(t, {
				PaneRendererArrowUp: () => a,
				PaneRendererArrowDown: () => l
			});
			var s = i(360511),
				r = i(86441),
				n = i(466915);
			class o extends s.PaneRendererAbstractFillStrokeShape {
				constructor() {
					super(...arguments), this._sign = 0, this._thinArrow = !1, this._thinArrowLineWidth = 0, this._headHeight = 0, this._arrowWidth = 0
				}
				setItems(e, t) {
					this._setBaseData(e, t)
				}
				_drawItemShape(e, t, i) {
					const s = t.pixelRatio,
						r = this._lineWidth(t) % 2 ? .5 : 0,
						o = this._sign,
						a = this._arrowWidth,
						l = this._headHeight,
						h = Math.abs(i.height),
						d = Math.round(i.x * s) + r,
						u = i.vertOffset,
						c = Math.round((i.y + u + o * h / 2) * s) + r,
						p = (0, n.ceiledEven)(a * s),
						_ = p / 2,
						f = Math.round(h * s),
						m = Math.round(l * s);
					e.translate(d, c), this._thinArrow ? (e.moveTo(0, 0), e.lineTo(-_, -_ * o), e.moveTo(0, 0), e.lineTo(_, -_ * o), e.moveTo(0, 0), e.lineTo(0, -f * o), e.moveTo(-_, -f * o), e.lineTo(_, -f * o)) : (e.moveTo(0, 0), f < m ? (e.lineTo(p, -f * o), e.lineTo(-p, -f * o)) : (e.lineTo(p, -m * o), e.lineTo(_, -m * o), e.lineTo(_, -f * o), e.lineTo(-_, -f * o), e.lineTo(-_, -m * o), e.lineTo(-p, -m * o)), e.lineTo(0, 0)), e.translate(-d, -c)
				}
				_preDrawInit() {
					const e = this._calculateWidth();
					this._arrowWidth = e, this._sign = this._isUp() ? -1 : 1, this._thinArrow = e < 4, this._thinArrowLineWidth = Math.max(e / 2, 1), this._headHeight = Math.round(e)
				}
				_startPath(e, t, i, s) {
					e.beginPath(), e.fillStyle = i, e.strokeStyle = s, e.lineWidth = this._lineWidth(t)
				}
				_lineWidth(e) {
					return this._thinArrow ? this._thinArrowLineWidth : super._lineWidth(e)
				}
				_calcBoundingBox(e) {
					const t = e.vertOffset,
						i = this._sign,
						s = this._arrowWidth,
						n = this._headHeight,
						o = Math.abs(e.height),
						a = e.x - s,
						l = a + 2 * s,
						h = e.y + t + i * Math.round(o / 2),
						d = h + (-o - n) * i,
						u = new r.Point(a, h),
						c = new r.Point(l, d);
					let p = (0, r.box)(u, c);
					const _ = super._calcBoundingBox(e);
					return _ && (p = this._unionBox(p, _)), p
				}
				_calculateWidth() {
					return Math.round(this._barSpacing / 4)
				}
			}
			class a extends o {
				_isUp() {
					return !0
				}
			}
			class l extends o {
				_isUp() {
					return !1
				}
			}
		},
		363720: (e, t, i) => {
			i.d(t, {
				PaneRendererCircleShape: () => o
			});
			var s = i(86441),
				r = i(360511);
			const n = 2 * Math.PI;
			class o extends r.PaneRendererAbstractFillStrokeShape {
				_drawItemShapeUsingCSSPixels(e, t) {
					const i = Math.max(t.width, t.height) / 2,
						s = t.x,
						r = t.vertOffset,
						o = t.y + r;
					e.moveTo(s + i, o), e.arc(s, o, i, 0, n, !1)
				}
				_calcBoundingBox(e) {
					const t = Math.max(e.width, e.height) / 2,
						i = e.x,
						r = e.vertOffset,
						n = e.y + r,
						o = i - t,
						a = i + t,
						l = n - t,
						h = n + t,
						d = new s.Point(o, l),
						u = new s.Point(a, h);
					let c = (0, s.box)(d, u);
					const p = super._calcBoundingBox(e);
					return p && (c = this._unionBox(c, p)), c
				}
			}
		},
		78571: (e, t, i) => {
			i.d(t, {
				PaneRendererCrossShape: () => n
			});
			var s = i(360511),
				r = i(86441);
			class n extends s.PaneRendererAbstractStrokeShape {
				_drawItemShape(e, t, i) {
					const s = i.width,
						r = i.height,
						n = i.x - s / 2,
						o = i.vertOffset,
						a = i.y - r / 2 + o,
						l = t.pixelRatio,
						h = this._lineWidth(t),
						d = h % 2 ? .5 : 0,
						u = Math.round(n * l);
					let c = Math.round((n + s) * l);
					(c - u) % 2 != h % 2 && (c += 1);
					const p = Math.floor((u + c) / 2) + d,
						_ = Math.round(a * l);
					let f = Math.round((a + r) * l);
					(f - _) % 2 != h % 2 && (f += 1);
					const m = Math.floor((_ + f) / 2) + d;
					e.moveTo(p, _), e.lineTo(p, f), e.moveTo(u, m), e.lineTo(c, m)
				}
				_calcBoundingBox(e) {
					const t = e.width,
						i = e.height,
						s = e.x - t / 2,
						n = e.vertOffset,
						o = e.y - i / 2 + n,
						a = s,
						l = s + t,
						h = o,
						d = o + i,
						u = new r.Point(a, h),
						c = new r.Point(l, d);
					let p = (0, r.box)(u, c);
					const _ = super._calcBoundingBox(e);
					return _ && (p = this._unionBox(p, _)), p
				}
			}
		},
		771613: (e, t, i) => {
			i.d(t, {
				PaneRendererDiamond: () => n
			});
			var s = i(86441),
				r = i(360511);
			class n extends r.PaneRendererAbstractFillStrokeShape {
				_drawItemShapeUsingCSSPixels(e, t) {
					const i = Math.round(t.height / 2),
						s = t.x,
						r = t.vertOffset,
						n = t.y + r;
					e.moveTo(s, n - i), e.lineTo(s + i, n), e.lineTo(s, n + i), e.lineTo(s - i, n), e.lineTo(s, n - i)
				}
				_calcBoundingBox(e) {
					const t = Math.round(e.height / 2),
						i = e.x,
						r = e.vertOffset,
						n = e.y + r,
						o = i - t,
						a = i + t,
						l = n - t,
						h = n + t,
						d = new s.Point(o, l),
						u = new s.Point(a, h);
					let c = (0, s.box)(d, u);
					const p = super._calcBoundingBox(e);
					return p && (c = this._unionBox(c, p)), c
				}
			}
		},
		808146: (e, t, i) => {
			i.d(t, {
				PaneRendererFlagShape: () => n
			});
			var s = i(86441),
				r = i(360511);
			class n extends r.PaneRendererAbstractFillStrokeShape {
				_drawItemShapeUsingCSSPixels(e, t) {
					const i = t.width,
						s = t.height,
						r = s / 2,
						n = (i - 3) / 3,
						o = t.x - i / 2,
						a = t.vertOffset,
						l = t.y - r + a;
					e.moveTo(o, l), e.lineTo(o + 3, l), e.bezierCurveTo(o + n, l - n, o + 2 * n, l + n, o + i, l), e.lineTo(o + i, l + r), e.bezierCurveTo(o + i - n, l + r + n, o + i - 2 * n, l + r - n, o + 3, l + r), e.lineTo(o + 3, l + s), e.lineTo(o, l + s), e.lineTo(o, l)
				}
				_calcBoundingBox(e) {
					const t = e.width,
						i = e.height,
						r = i / 2,
						n = e.x - t / 2,
						o = e.vertOffset,
						a = e.y - r + o,
						l = n,
						h = n + t,
						d = a,
						u = a + i,
						c = new s.Point(l, d),
						p = new s.Point(h, u);
					let _ = (0, s.box)(c, p);
					const f = super._calcBoundingBox(e);
					return f && (_ = this._unionBox(_, f)), _
				}
			}
		},
		878874: (e, t, i) => {
			i.d(t, {
				PaneRendererLabelBase: () => a,
				CornerVectorsClockwise: () => s
			});
			var s, r = i(588537),
				n = i(360511),
				o = i(267151);
			class a extends n.PaneRendererAbstractFillStrokeShape {
				setItems(e, t) {
					this._setBaseData(e, t);
					for (const e of this._items) {
						const t = e.height;
						e.stepX = Math.round(t / 2 * .65) + .5, e.stepY = e.stepX;
						const i = e.stepX / 2,
							s = this._getTextCache(e);
						if (null === s) {
							e.shapeWidth = 2 * e.stepX, e.shapeHeight = 2.5 * e.stepY, e.vertOffset = this._calcVertOffset(e);
							continue
						}
						const r = s.textImageWidth,
							n = s.textImageHeight;
						e.shapeWidth = r + 2 * e.stepX, e.shapeHeight = n + 2 * i + e.stepY, e.vertOffset = this._calcVertOffset(e), e.textHorizOffset = this._getHorizontalTextOffset(e), e.textVertOffset = this._getVerticalTextOffset(e)
					}
				}
				_calcVertOffset(e) {
					return e.vertOffset
				}
				_drawCorner(e, t, i, s, r) {
					const n = Math.max(1, Math.floor(2 * r));
					e.lineTo(t - n * s.prevPointSignX, i - n * s.prevPointSignY), e.arcTo(t, i, t + n * s.nextPointSignX, i + n * s.nextPointSignY, n)
				}
				_getArrowSize(e) {
					return e.stepX
				}
				_getHorizontalTextOffset(e) {
					return 0
				}
				_getVerticalTextOffset(e) {
					return 0
				}
				_hasText(e) {
					return Boolean(e.text) || Boolean(this._text)
				}
				_drawItemText(e, t, i) {
					var s;
					const n = this._getTextCache(i);
					if (null === n) return;
					const a = i.textHorizOffset || 0,
						l = i.x + a,
						h = i.vertOffset,
						d = i.y + h + i.textVertOffset,
						u = (null === (s = i.style) || void 0 === s ? void 0 : s.textColor) || this._textColor,
						c = {
							style: {
								fillStyle: (0, r.ensureDefined)(u)
							},
							location: {
								x: l,
								y: d,
								horzAlign: o.HorizontalAlign.Center,
								vertAlign: o.VerticalAlign.Middle
							}
						};
					n.paintTo(e, t, c)
				}
			}
			class l {
				constructor(e, t, i, s) {
					this.prevPointSignX = e, this.prevPointSignY = t, this.nextPointSignX = i, this.nextPointSignY = s
				}
			}! function(e) {
				e.rightUp = new l(1, 0, 0, 1), e.rightDown = new l(0, 1, -1, 0), e.leftDown = new l(-1, 0, 0, -1), e.leftUp = new l(0, -1, 1, 0)
			}(s || (s = {}))
		},
		844577: (e, t, i) => {
			i.d(t, {
				PaneRendererLabelUp: () => n,
				PaneRendererLabelDown: () => o,
				PaneRendererLabelLeft: () => a,
				PaneRendererLabelRight: () => l,
				PaneRendererLabelCenter: () => h
			});
			var s = i(86441),
				r = i(878874);
			class n extends r.PaneRendererLabelBase {
				_calcBoundingBox(e) {
					const t = e.x - e.shapeWidth / 2,
						i = e.x + e.shapeWidth / 2,
						r = e.y + e.vertOffset,
						n = e.y + e.shapeHeight + e.vertOffset,
						o = new s.Point(t, r),
						a = new s.Point(i, n);
					return (0, s.box)(o, a)
				}
				_drawItemShape(e, t, i) {
					const s = t.pixelRatio,
						n = this._lineWidth(t) % 2 ? .5 : 0,
						o = Math.max(1, Math.floor(s)) % 2 ? .5 : 0,
						a = this._getArrowSize(i);
					let l = Math.round(a * s);
					(o + l) % 1 != n % 1 && (l += .5);
					let h = Math.round(i.shapeWidth / 2 * s);
					(o + h) % 1 != n % 1 && (h += .5);
					const d = Math.round(i.x * s) + o,
						u = Math.round((i.y + i.vertOffset) * s) + n,
						c = d - l,
						p = Math.round((i.y + i.vertOffset + a) * s) + n,
						_ = d + l,
						f = d + h,
						m = Math.round((i.y + i.vertOffset + i.shapeHeight) * s) + n,
						y = d - h;
					e.moveTo(c, p), e.lineTo(d, u), e.lineTo(_, p), i.shapeWidth <= 2 * a ? (e.lineTo(f, p), this._drawCorner(e, f, m, r.CornerVectorsClockwise.rightDown, s), this._drawCorner(e, y, m, r.CornerVectorsClockwise.leftDown, s), e.lineTo(y, p)) : (this._drawCorner(e, f, p, r.CornerVectorsClockwise.rightUp, s), this._drawCorner(e, f, m, r.CornerVectorsClockwise.rightDown, s), this._drawCorner(e, y, m, r.CornerVectorsClockwise.leftDown, s), this._drawCorner(e, y, p, r.CornerVectorsClockwise.leftUp, s)), e.lineTo(c, p)
				}
				_getVerticalTextOffset(e) {
					return e.shapeHeight / 2 + this._getArrowSize(e) / 2
				}
				_calcVertOffset(e) {
					return Math.sign(e.vertOffset) >= 0 ? e.vertOffset : e.vertOffset - e.shapeHeight
				}
			}
			class o extends r.PaneRendererLabelBase {
				_calcBoundingBox(e) {
					const t = e.x - e.shapeWidth / 2,
						i = e.x + e.shapeWidth / 2,
						r = e.y - e.shapeHeight + e.vertOffset,
						n = e.y + e.vertOffset,
						o = new s.Point(t, r),
						a = new s.Point(i, n);
					return (0, s.box)(o, a)
				}
				_drawItemShape(e, t, i) {
					const s = t.pixelRatio,
						n = this._lineWidth(t) % 2 ? .5 : 0,
						o = Math.max(1, Math.floor(s)) % 2 ? .5 : 0,
						a = this._getArrowSize(i);
					let l = Math.round(a * s);
					(o + l) % 1 != n % 1 && (l += .5);
					let h = Math.round(i.shapeWidth / 2 * s);
					(o + h) % 1 != n % 1 && (h += .5);
					const d = Math.round(i.x * s) + o,
						u = Math.round((i.y + i.vertOffset) * s) + n,
						c = d + l,
						p = Math.round((i.y + i.vertOffset - a) * s) + n,
						_ = d - l,
						f = d + h,
						m = Math.round((i.y + i.vertOffset - i.shapeHeight) * s) + n,
						y = d - h;
					e.moveTo(c, p), e.lineTo(d, u), e.lineTo(_, p), i.shapeWidth <= 2 * a ? (e.lineTo(y, p), this._drawCorner(e, y, m, r.CornerVectorsClockwise.leftUp, s), this._drawCorner(e, f, m, r.CornerVectorsClockwise.rightUp, s), e.lineTo(f, p)) : (this._drawCorner(e, y, p, r.CornerVectorsClockwise.leftDown, s), this._drawCorner(e, y, m, r.CornerVectorsClockwise.leftUp, s), this._drawCorner(e, f, m, r.CornerVectorsClockwise.rightUp, s), this._drawCorner(e, f, p, r.CornerVectorsClockwise.rightDown, s)), e.lineTo(c, p)
				}
				_getVerticalTextOffset(e) {
					return -e.shapeHeight / 2 - this._getArrowSize(e) / 2
				}
				_calcVertOffset(e) {
					return Math.sign(e.vertOffset) <= 0 ? e.vertOffset : e.vertOffset + e.shapeHeight
				}
			}
			class a extends r.PaneRendererLabelBase {
				_calcBoundingBox(e) {
					const t = e.x,
						i = e.x + e.shapeWidth,
						r = e.y - e.shapeHeight / 2 + e.vertOffset,
						n = e.y + e.shapeHeight / 2 + e.vertOffset,
						o = new s.Point(t, r),
						a = new s.Point(i, n);
					return (0, s.box)(o, a)
				}
				_drawItemShape(e, t, i) {
					const s = t.pixelRatio,
						n = this._lineWidth(t) % 2 ? .5 : 0,
						o = this._getArrowSize(i),
						a = this._hasText(i),
						l = a ? i.shapeHeight / 2 : o,
						h = Math.round(i.x * s) + n,
						d = Math.round((i.y + i.vertOffset) * s) + n,
						u = Math.round((i.x + o) * s) + n,
						c = Math.round((i.y + i.vertOffset + o) * s) + n,
						p = Math.round((i.y + i.vertOffset - o) * s) + n,
						_ = Math.round((i.y + i.vertOffset - l) * s) + n,
						f = Math.round((i.x + i.shapeWidth) * s) + n,
						m = Math.round((i.y + i.vertOffset + l) * s) + n;
					e.moveTo(u, c), e.lineTo(h, d), e.lineTo(u, p), a ? this._drawCorner(e, u, _, r.CornerVectorsClockwise.leftUp, s) : e.lineTo(u, _),
						this._drawCorner(e, f, _, r.CornerVectorsClockwise.rightUp, s), this._drawCorner(e, f, m, r.CornerVectorsClockwise.rightDown, s), a ? this._drawCorner(e, u, m, r.CornerVectorsClockwise.leftDown, s) : e.lineTo(u, m), e.lineTo(u, c)
				}
				_getHorizontalTextOffset(e) {
					return e.shapeWidth / 2 + this._getArrowSize(e) / 2
				}
			}
			class l extends r.PaneRendererLabelBase {
				_calcBoundingBox(e) {
					const t = e.x - e.shapeWidth,
						i = e.x,
						r = e.y - e.shapeHeight / 2 + e.vertOffset,
						n = e.y + e.shapeHeight / 2 + e.vertOffset,
						o = new s.Point(t, r),
						a = new s.Point(i, n);
					return (0, s.box)(o, a)
				}
				_drawItemShape(e, t, i) {
					const s = t.pixelRatio,
						n = this._lineWidth(t) % 2 ? .5 : 0,
						o = this._getArrowSize(i),
						a = this._hasText(i),
						l = a ? i.shapeHeight / 2 : o,
						h = Math.round(i.x * s) + n,
						d = Math.round((i.y + i.vertOffset) * s) + n,
						u = Math.round((i.x - o) * s) + n,
						c = Math.round((i.y + i.vertOffset - o) * s) + n,
						p = Math.round((i.y + i.vertOffset + o) * s) + n,
						_ = Math.round((i.y + i.vertOffset - l) * s) + n,
						f = Math.round((i.x - i.shapeWidth) * s) + n,
						m = Math.round((i.y + i.vertOffset + l) * s) + n;
					e.moveTo(u, c), e.lineTo(h, d), e.lineTo(u, p), a ? this._drawCorner(e, u, m, r.CornerVectorsClockwise.rightDown, s) : e.lineTo(u, m), this._drawCorner(e, f, m, r.CornerVectorsClockwise.leftDown, s), this._drawCorner(e, f, _, r.CornerVectorsClockwise.leftUp, s), a ? this._drawCorner(e, u, _, r.CornerVectorsClockwise.rightUp, s) : e.lineTo(u, _), e.lineTo(u, c)
				}
				_getHorizontalTextOffset(e) {
					return -e.shapeWidth / 2 - this._getArrowSize(e) / 2
				}
			}
			class h extends r.PaneRendererLabelBase {
				_calcBoundingBox(e) {
					const t = e.x - e.shapeWidth / 2,
						i = e.x + e.shapeWidth / 2,
						r = e.y - e.shapeHeight / 2 + e.vertOffset,
						n = e.y + e.shapeHeight / 2 + e.vertOffset,
						o = new s.Point(t, r),
						a = new s.Point(i, n);
					return (0, s.box)(o, a)
				}
				_drawItemShape(e, t, i) {
					const s = t.pixelRatio,
						n = this._lineWidth(t) % 2 ? .5 : 0,
						o = i.shapeHeight / 2,
						a = i.shapeWidth / 2,
						l = Math.round(i.x * s) + n,
						h = Math.round((i.x - a) * s) + n,
						d = Math.round((i.x + a) * s) + n,
						u = Math.round((i.y + i.vertOffset - o) * s) + n,
						c = Math.round((i.y + i.vertOffset + o) * s) + n;
					e.moveTo(l, u), this._drawCorner(e, d, u, r.CornerVectorsClockwise.rightUp, s), this._drawCorner(e, d, c, r.CornerVectorsClockwise.rightDown, s), this._drawCorner(e, h, c, r.CornerVectorsClockwise.leftDown, s), this._drawCorner(e, h, u, r.CornerVectorsClockwise.leftUp, s), e.lineTo(l, u)
				}
			}
		},
		805316: (e, t, i) => {
			i.d(t, {
				PaneRendererSquare: () => n
			});
			var s = i(360511),
				r = i(86441);
			class n extends s.PaneRendererAbstractFillStrokeShape {
				_drawItemShape(e, t, i) {
					const s = t.pixelRatio,
						r = Math.max(1, Math.floor(s)) % 2 ? .5 : 0,
						n = this._lineWidth(t) % 2 ? .5 : 0;
					let o = Math.round(i.height / 2 * s);
					(r + o) % 1 != n % 1 && (o += .5);
					const a = Math.round(i.x * s) + r,
						l = Math.round((i.y + i.vertOffset) * s) + r,
						h = a - o,
						d = l - o,
						u = a + o,
						c = l + o;
					e.rect(h, d, u - h, c - d)
				}
				_calcBoundingBox(e) {
					const t = e.height,
						i = Math.round(t / 2),
						s = e.x - i,
						n = e.vertOffset,
						o = e.y + n - i,
						a = s,
						l = s + t,
						h = o,
						d = o + t,
						u = new r.Point(a, h),
						c = new r.Point(l, d);
					let p = (0, r.box)(u, c);
					const _ = super._calcBoundingBox(e);
					return _ && (p = this._unionBox(p, _)), p
				}
			}
		},
		187117: (e, t, i) => {
			i.d(t, {
				PaneRendererTriangleApexUp: () => o,
				PaneRendererTriangleApexDown: () => a
			});
			var s = i(360511),
				r = i(86441);
			class n extends s.PaneRendererAbstractFillStrokeShape {
				_calcBoundingBox(e) {
					const t = e.width,
						i = e.height,
						s = t / 2,
						n = Math.round(i / 3),
						o = e.x,
						a = e.vertOffset - 2 * n,
						l = e.y + a,
						h = o - s,
						d = o + s,
						u = l,
						c = l + i,
						p = new r.Point(h, u),
						_ = new r.Point(d, c);
					let f = (0,
						r.box)(p, _);
					const m = super._calcBoundingBox(e);
					return m && (f = this._unionBox(f, m)), f
				}
			}
			class o extends n {
				_drawItemShape(e, t, i) {
					const s = i.width,
						r = i.height,
						n = Math.round(r / 3),
						o = i.vertOffset - 2 * n,
						a = t.pixelRatio,
						l = this._lineWidth(t) % 2 ? .5 : 0,
						h = Math.max(1, Math.floor(a)),
						d = h % 2 ? .5 : 0;
					let u = Math.round(s * a);
					u % 2 != h % 2 && (u += 1);
					const c = Math.round(i.x * a) + d,
						p = Math.round((i.y + o) * a),
						_ = c + u / 2,
						f = Math.round((i.y + o + r) * a) + l,
						m = c - u / 2;
					e.moveTo(c, p), e.lineTo(_, f), e.lineTo(m, f), e.lineTo(c, p)
				}
			}
			class a extends n {
				_drawItemShape(e, t, i) {
					const s = i.width,
						r = i.height,
						n = Math.round(r / 3),
						o = i.vertOffset - n,
						a = t.pixelRatio,
						l = this._lineWidth(t) % 2 ? .5 : 0,
						h = Math.max(1, Math.floor(a)),
						d = h % 2 ? .5 : 0;
					let u = Math.round(s * a);
					u % 2 != h % 2 && (u += 1);
					const c = Math.round(i.x * a) + d,
						p = Math.round((i.y + o) * a) + l,
						_ = c + u / 2,
						f = Math.round((i.y + o + r) * a),
						m = c - u / 2;
					e.moveTo(m, p), e.lineTo(_, p), e.lineTo(c, f), e.lineTo(m, p)
				}
			}
		},
		97138: (e, t, i) => {
			i.d(t, {
				PaneRendererXCross: () => n
			});
			var s = i(86441),
				r = i(360511);
			class n extends r.PaneRendererAbstractStrokeShape {
				_drawItemShapeUsingCSSPixels(e, t) {
					const i = t.width,
						s = t.height,
						r = t.x - i / 2,
						n = t.vertOffset,
						o = t.y - s / 2 + n;
					e.moveTo(r, o), e.lineTo(r + i, o + s), e.moveTo(r, o + s), e.lineTo(r + i, o)
				}
				_calcBoundingBox(e) {
					const t = e.width,
						i = e.height,
						r = e.x - t / 2,
						n = e.vertOffset,
						o = e.y - i / 2 + n,
						a = r,
						l = r + t,
						h = o,
						d = o + i,
						u = new s.Point(a, h),
						c = new s.Point(l, d);
					let p = (0, s.box)(u, c);
					const _ = super._calcBoundingBox(e);
					return _ && (p = this._unionBox(p, _)), p
				}
			}
		},
		362857: (e, t, i) => {
			i.d(t, {
				createStudyPlotColorProvider: () => p
			});
			var s = i(418458),
				r = i(588537),
				n = i(181626);
			const o = new Map([
				[0, "color"],
				[2, "textColor"],
				[3, "borderColor"],
				[4, "wickColor"],
				[5, "colorup"],
				[6, "colordown"]
			]);
			class a {
				constructor(e) {
					this._plotStyle = e
				}
				getPlotPointStyle(e, t) {
					const i = t ? (0, n.clearStyle)(t) : (0, n.createEmptyStyle)();
					return o.forEach(((e, t) => {
						this._plotStyle[e] && (i.colors[t] = this._plotStyle[e].value())
					})), i.lineWidth = this._plotStyle.linewidth ? this._plotStyle.linewidth.value() : void 0, i.lineStyle = this._plotStyle.linestyle ? this._plotStyle.linestyle.value() : void 0, i
				}
				isColorDefined() {
					return !0
				}
				singleColor() {
					return !0
				}
				getDefaultPlotPointStyle() {
					return null
				}
			}
			const l = [0, 1, 2, 3, 4, 5, 6];
			class h {
				constructor(e, t, i, s) {
					this._palettesColors = new Map, this._defaultPlotColors = new Map, this._indexes = s;
					const n = t.styles[i];
					if (n)
						for (const [e, t] of o) this._defaultPlotColors.set(e, n[t]);
					const a = (0, r.ensureDefined)(e.palettes),
						l = e.plots;
					s.forEach(((e, i) => {
						const s = l[e];
						if (s && "palette" in s) {
							const e = a[s.palette],
								r = t.palettes[s.palette];
							if (e && r) {
								const {
									valToIndex: t
								} = e, {
									colors: s
								} = r, n = {
									...s
								};
								t && Object.keys(t).forEach((e => {
									const i = t[e];
									void 0 !== i && (n[e] = s[i])
								})), this._palettesColors.set(i, n)
							}
						}
					}))
				}
				getPlotPointStyle(e, t) {
					const i = t ? (0, n.clearStyle)(t) : (0, n.createEmptyStyle)();
					return l.forEach((t => {
						var s, n;
						if (this._palettesColors.has(t)) {
							const n = e[(0, r.ensureDefined)(this._indexes.get(t)) + 1];
							if ("number" == typeof n) {
								const e = null === (s = this._palettesColors.get(t)) || void 0 === s ? void 0 : s[n];
								0 === t && e && (i.lineWidth = e.width.value(), i.lineStyle = e.style.value()), i.colors[t] = null == e ? void 0 : e.color.value()
							} else i.colors[t] = "transparent"
						} else i.colors[t] = null === (n = this._defaultPlotColors.get(t)) || void 0 === n ? void 0 : n.value()
					})), i
				}
				getDefaultPlotPointStyle() {
					var e;
					const t = null === (e = this._palettesColors.get(0)) || void 0 === e ? void 0 : e[0];
					if (void 0 !== t) {
						return {
							colors: [t.color.value(), void 0, void 0, void 0, void 0, void 0, void 0],
							lineStyle: void 0,
							lineWidth: t.width.value()
						}
					}
					return null
				}
				isColorDefined() {
					return !!this._palettesColors.size
				}
				singleColor() {
					return !1
				}
			}
			var d = i(721386);
			class u {
				constructor(e) {
					this._indexes = e
				}
				getPlotPointStyle(e, t) {
					const i = t ? (0, n.clearStyle)(t) : (0, n.createEmptyStyle)();
					return this._indexes.forEach(((t, s) => {
						const r = e[t + 1];
						if (null != r) {
							const e = (0, d.rgbaFromInteger)(r);
							i.colors[s] = e
						} else i.colors[s] = "transparent"
					})), i
				}
				isColorDefined() {
					return !0
				}
				singleColor() {
					return !1
				}
				getDefaultPlotPointStyle() {
					return null
				}
			}
			const c = new Map([
				[0, function(e, t) {
					const i = (0, s.isColorerPlot)(t) || (0, s.isOhlcColorerPlot)(t);
					return "target" in t && t.target === e && i
				}],
				[2, function(e, t) {
					const i = (0, s.isTextColorerPlot)(t);
					return "target" in t && t.target === e && i
				}],
				[1, function(e, t) {
					return (0, s.isBgColorerPlot)(t) && t.id === e
				}],
				[3, function(e, t) {
					const i = (0, s.isCandleBorderColorerPlot)(t);
					return "target" in t && t.target === e && i
				}],
				[4, function(e, t) {
					const i = (0, s.isCandleWickColorerPlot)(t);
					return "target" in t && t.target === e && i
				}],
				[5, function(e, t) {
					const i = (0, s.isUpColorerPlot)(t);
					return "target" in t && t.target === e && i
				}],
				[6, function(e, t) {
					const i = (0, s.isDownColorerPlot)(t);
					return "target" in t && t.target === e && i
				}]
			]);

			function p(e, t, i) {
				const {
					colorers: s
				} = function(e, t) {
					const i = e.plots,
						s = i.findIndex((e => e.id === t)),
						r = new Map;
					return i.forEach(((e, i) => {
						c.forEach(((s, n) => {
							s(t, e) && r.set(n, i)
						}))
					})), {
						plotIndex: -1 === s ? null : s,
						colorers: r
					}
				}(e, i);
				if (s.size) return e.isRGB ? new u(s) : new h(e, t, i, s); {
					const e = t.ohlcPlots;
					if (e && e[i]) return new a(e[i]);
					const s = t.styles[i];
					return new a(s)
				}
			}
		},
		226087: (e, t, i) => {
			i.d(t, {
				StudyBaseWindowView: () => r
			});
			var s = i(734906);
			class r extends s.DataWindowView {
				constructor(e, t) {
					super(), this._invalidated = !0, this._study = e, this._model = t, this._valueProvider = this._createValuesProvider(e, t), this._items = this._valueProvider.getItems().map((e => new s.DataWindowItem(e.id, e.title, ""))), this.update()
				}
				update() {
					this._invalidated = !0
				}
				items() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._items
				}
				study() {
					return this._study
				}
				_updateImpl() {
					this._header = this._study.title(!0), this._title = this._study.title();
					const e = this._valueProvider.getValues(this._currentIndex());
					for (let t = 0; t < e.length; ++t) {
						const i = e[t],
							s = this._items[t];
						s.setValue(i.value), s.setVisible(i.visible), s.setColor(i.color), s.setTitle(i.title)
					}
				}
				_currentIndex() {
					const e = this._model.crossHairSource().lockedIndex;
					if (void 0 !== e) return e;
					const t = this._model.crossHairSource().appliedIndex();
					return isNaN(t) ? null : t
				}
			}
		},
		287597: (e, t, i) => {
			i.d(t, {
				StudyDataWindowView: () => a
			});
			var s = i(226087),
				r = i(833485),
				n = i(906156);
			class o {
				constructor(e, t) {
					this._study = e, this._model = t, this._hhistBasedStudy = void 0 !== e.metaInfo().graphics.hhists, this._valuesProvider = this._createValuesProvider(e, t)
				}
				getItems() {
					return this._valuesProvider.getItems()
				}
				getValues(e) {
					const t = this._valuesProvider.getValues(e),
						i = e => !!this._hhistBasedStudy || this._study.isPlotVisibleAt(e, 2);
					for (const e of t) e.visible = e.visible && i(e.id);
					return t
				}
				_createValuesProvider(e, t) {
					return this._hhistBasedStudy ? new n.HHistBasedValuesProvider(e, t) : new r.StudyValuesProvider(e, t)
				}
			}
			class a extends s.StudyBaseWindowView {
				_createValuesProvider(e, t) {
					return new o(e, t)
				}
			}
		},
		624635: (e, t, i) => {
			function s(e) {
				return ["text", "integer", "float", "price", "session", "resolution"].includes(e.type) && e.hasOwnProperty("options")
			}

			function r(e, t, i) {
				for (const s of e)
					if (t[s.id] !== i[s.id]) return !1;
				return !0
			}

			function n(e) {
				return {
					from: Math.round(e.first_visible_bar_time / 1e3),
					to: Math.round(e.last_visible_bar_time / 1e3)
				}
			}

			function o(e) {
				return ("time" === e.type || "price" === e.type) && !0 !== e.isHidden
			}

			function a(e) {
				const t = e.filter(o);
				if (0 === t.length) return [];
				const i = new Map,
					s = [];
				t.forEach((e => {
					var t;
					const {
						group: r,
						inline: n
					} = e;
					if (void 0 === n) return void s.push(e);
					const o = n + (r || "");
					if (i.has(o)) null === (t = i.get(o)) || void 0 === t || t.push(e);
					else {
						const t = [e];
						i.set(o, t), s.push(t)
					}
				}));
				const r = [];
				for (let e = 0; e < s.length; e++) {
					const t = s[e];
					Array.isArray(t) ? 2 === t.length && t[0].type !== t[1].type ? r.push(t) : r.push(...t) : r.push(t)
				}
				return r
			}
			i.d(t, {
				isStudyInputOptionsInfo: () => s,
				areStudyInputsEqual: () => r,
				rangeDependentStudyInputsToTimeRange: () => n,
				isTimeOrPriceNotHiddenInput: () => o,
				editableStudyInputs: () => a
			})
		},
		456525: (e, t, i) => {
			i.d(t, {
				StudyLegendValuesProvider: () => n
			});
			var s = i(833485),
				r = i(906156);
			class n {
				constructor(e, t) {
					this._study = e, this._model = t, this._showStudyValues = t.properties().childs().paneProperties.childs().legendProperties.childs().showStudyValues, this._hhistBasedStudy = void 0 !== e.metaInfo().graphics.hhists, this._valuesProvider = this._createValuesProvider(e, t)
				}
				getItems() {
					return this._valuesProvider.getItems()
				}
				getValues(e) {
					const t = this._valuesProvider.getValues(e),
						i = this._study.properties(),
						s = this._showStudyValues.value() && i.childs().showLegendValues.value(),
						r = e => !!this._hhistBasedStudy || this._study.isPlotVisibleAt(e, 8);
					for (const e of t) e.visible = e.visible && s && r(e.id);
					return t
				}
				_createValuesProvider(e, t) {
					return this._hhistBasedStudy ? new r.HHistBasedValuesProvider(e, t) : new s.StudyValuesProvider(e, t)
				}
			}
		},
		573033: (e, t, i) => {
			i.d(t, {
				fundamentalsPrefix: () => s,
				isFundamentalStudyMetaInfo: () => r,
				studyNameByMetaInfo: () => n
			});
			const s = "study_Internal$STD;Fund_";

			function r(e) {
				return n(e) === s
			}

			function n(e) {
				const t = "study_" + (e.classId || e.shortId);
				return t.startsWith(s) ? s : t
			}
		},
		920937: (e, t, i) => {
			i.d(t, {
				StudyStatusProviderBase: () => a
			});
			var s = i(5073),
				r = i(906096);
			const n = {
					NONE: "Default"
				},
				o = !0;
			class a extends s.StatusProviderBase {
				constructor(e, t) {
					super(t), this._source = e
				}
				getSplitTitle() {
					return this._source.titleInParts(!0, n, void 0, o)
				}
				text() {
					return this._source.isActualInterval() ? this._source.isFailed() ? `${this._source.title(!0,n,void 0,o)}: ${this.sourceStatusText()}` : `${this._source.title(!0,n,void 0,o)} ${this.sourceStatusText()}` : this._source.title(!0, n, void 0, o)
				}
				sourceStatusText() {
					return (0, r.convertStudyStatusToString)(this._source.status(), !0)
				}
				errorStatus() {
					if (!this._source.isActualInterval() || this._source.isSymbolInvalid()) return null;
					const e = this._source.status();
					return e.type === r.StudyStatusType.Error ? {
						error: this.sourceStatusText(),
						solutionId: (0, r.studyStatusSolutionId)(e),
						title: (0, r.studyStatusTitle)(e),
						studyFeature: (0, r.studyStatusFeature)(e)
					} : null
				}
			}
		},
		651620: (e, t, i) => {
			i.d(t, {
				StudyStatusProvider: () => l
			});
			var s = i(575932),
				r = i(906096),
				n = i(971417),
				o = i(920937);
			const a = (0, s.t)("Fundamental studies are no longer available on charts");
			class l extends o.StudyStatusProviderBase {
				constructor(e, t) {
					super(e, t), this._study = e
				}
				color() {
					return this._study.isFailed() || this._study.metaInfo && this._study.metaInfo().isTVScriptStub ? "#ff0000" : super.color()
				}
				sourceStatusText() {
					if (this._study.status().type === r.StudyStatusType.Error) {
						const e = this._study.metaInfo(),
							t = (0, n.extractPineId)(e.fullId);
						if (e.scriptIdPart && (0, n.isEdgrPineId)(e.scriptIdPart) || t && (0, n.isEdgrPineId)(t)) return a
					}
					return super.sourceStatusText()
				}
			}
		},
		234840: (e, t, i) => {
			i.d(t, {
				StudyStatusView: () => r
			});
			var s = i(892139);
			class r extends s.StatusView {
				constructor(e) {
					super(e.statusProvider())
				}
				color() {
					return this._statusProvider.color()
				}
				getSplitTitle() {
					return this._statusProvider.getSplitTitle()
				}
				update() {
					this._text = this._statusProvider.text()
				}
			}
		},
		906096: (e, t, i) => {
			i.d(t, {
				StudyStatusType: () => h,
				convertStudyStatusToString: () => d,
				studyStatusSolutionId: () => u,
				studyStatusTitle: () => c,
				studyStatusFeature: () => p
			});
			var s = i(575932),
				r = i(490901);
			const n = (0, s.t)("No volume data"),
				o = new Map([
					["Pine cannot determine the referencing length of a series. Try using max_bars_back", r.solutionIds.PINE_CANNOT_DETERMINE],
					["Memory limits exceeded", r.solutionIds.MEMORY_LIMITS_EXCEEDED],
					["This script is invite-only", r.solutionIds.PUBLIC_INVITE_ONLY_SCRIPTS]
				]),
				a = new Map([
					["Volume Profile indicator available only on our upgraded plans", "volumeProfile"]
				]),
				l = (0, s.t)("loading...");
			var h;

			function d(e, t) {
				if (e.type === h.Loading) return t ? l : "loading...";
				if (e.type === h.Error) {
					const i = e.errorDescription,
						r = t ? (0, s.t)(i.error) : i.error;
					if (i.ctx) {
						const e = {};
						return Object.entries(i.ctx).forEach((([t, i]) => {
							e[t] = i.toString()
						})), r.format(e)
					}
					return r
				}
				return ""
			}

			function u(e) {
				if (e.type === h.Error) return e.errorDescription.solution_id ? e.errorDescription.solution_id : function(e) {
					for (const t of Array.from(o.keys()))
						if (e.includes(t)) return o.get(t)
				}(e.errorDescription.error)
			}

			function c(e) {
				if (e.type === h.Error) return -1 !== e.errorDescription.error.toLowerCase().indexOf("the data vendor doesn't provide volume data for this symbol.") ? n : void 0
			}

			function p(e) {
				const {
					errorDescription: {
						error: t
					}
				} = e;
				for (const [e, i] of a)
					if (t.startsWith(e)) return i
			}! function(e) {
				e[e.Undefined = 0] = "Undefined", e[e.Loading = 1] = "Loading", e[e.Completed = 2] = "Completed", e[e.Error = 3] = "Error"
			}(h || (h = {}))
		},
		833485: (e, t, i) => {
			i.d(t, {
				StudyValuesProvider: () => m
			});
			var s = i(793751),
				r = i(638456),
				n = i(721386),
				o = i(611688),
				a = i(752280),
				l = i(29084),
				h = i(308170),
				d = i(418458),
				u = i(362857),
				c = i(676809),
				p = i(588537);
			const _ = r.CheckMobile.any(),
				f = o.enabled("hide_last_na_study_output");
			class m {
				constructor(e, t) {
					this._emptyValues = [], this._colorProviders = new Map, this._study = e, this._model = t;
					const i = this._study.metaInfo().plots;
					i && i.forEach(((e, t) => {
						if ((0, d.isPlotWithTechnicalValues)(e)) return;
						const i = e.id;
						this._emptyValues.push(function(e, t = "", i = "") {
							return {
								id: t,
								index: e,
								title: i,
								value: "",
								visible: !1
							}
						}(t, i, this._study.guiPlotName(i)));
						const s = (0, d.isOhlcPlot)(e) ? e.target : i;
						this._colorProviders.set(s, (0, u.createStudyPlotColorProvider)(this._study.metaInfo(), this._study.properties(), s))
					}))
				}
				getItems() {
					return this._emptyValues
				}
				getValues(e) {
					var t, i, r;
					const o = this._emptyValues.map((e => ({
						...e
					})));
					let l = null;
					const h = this._study.data().lastIndex(),
						u = this._study.properties().childs();
					if (null !== h)
						for (const e of o) {
							if (0 === (null === (t = u.styles.childs()[e.id]) || void 0 === t ? void 0 : t.childs().display.value())) continue;
							const i = this._study.nearestIndex(h, a.PlotRowSearchMode.NearestLeft, e.index + 1);
							if (void 0 === i) continue;
							const s = i + this._study.offset(e.id);
							l = null !== l ? Math.max(s, l) : s
						}(null === e || null !== l && e > l) && (e = l);
					const _ = this._hideValues(),
						m = this._study.isVisible() && !_ ? "âˆ…" : "";
					for (const e of o) e.value = m;
					if (_) return o;
					f && o.length && (o[o.length - 1].value = "");
					const y = this._study.priceScale();
					if (!this._study.isVisible() || null === e || null === y || y.isEmpty() || this._model.timeScale().isEmpty()) return o;
					const v = this._study.metaInfo().plots,
						g = (0, c.getPriceValueFormatterForSource)(this._study),
						S = {};
					for (const t of o) {
						let o = t.id;
						const l = (0, p.ensureDefined)(null === (i = u.styles.childs()[o]) || void 0 === i ? void 0 : i.childs()),
							c = l.display.value();
						if (t.visible = 0 !== c, !t.visible) continue;
						const _ = t.index,
							f = e - this._study.offset(o),
							m = null !== h && f > h ? a.PlotRowSearchMode.NearestLeft : a.PlotRowSearchMode.Exact,
							y = this._study.nearestIndex(f, m);
						if (void 0 === y) continue;
						let b = S[o];
						if (void 0 === b && (b = this._study.getMinFirstBarIndexForPlot(o), Number.isFinite(b) && (S[o] = b)), b > y) continue;
						const w = this._study.data().last(),
							P = this._study.data().valueAt(y) || (null !== w ? w.value : null);
						if (null === P) continue;
						const C = P[_ + 1];
						if (!(0, s.isNumber)(C)) continue;
						const x = C > 0;
						let I;
						t.value = g(C);
						const T = v[_];
						(0, d.isOhlcPlot)(T) ? (o = T.target || o, I = (0, p.ensureDefined)(u.ohlcPlots.childs()[o].childs().color).value()) : I = (0, d.isArrowsPlot)(T) ? x ? l.colorup.value() : l.colordown.value() : (0, p.ensureDefined)(null === (r = u.styles.childs()[o]) || void 0 === r ? void 0 : r.child("color")).value();
						let V = I;
						const M = this._colorProviders.get(o),
							R = M && M.getPlotPointStyle(P);
						R && ((0, d.isArrowsPlot)(T) ? (x && void 0 !== R.colors[5] && (V = R.colors[5]), x || void 0 === R.colors[6] || (V = R.colors[6])) : void 0 !== R.colors[0] && (V = R.colors[0])), "transparent" === V && (V = I), V = (0, n.resetTransparency)(V), t.color = V
					}
					return o
				}
				_hideValues() {
					return _ && (null === this._model.crossHairSource().pane || (0, l.isLineToolName)(h.tool.value()) || null !== this._model.lineBeingEdited())
				}
			}
		},
		107555: (e, t, i) => {
			i.d(t, {
				StudyBase: () => It
			});
			var s = i(316230),
				r = i(588537),
				n = i(575932),
				o = i(911905),
				a = i(638456),
				l = i(694755),
				h = i(344265),
				d = i(386189),
				u = i(362145),
				c = i(270369);

			function p(e) {
				const t = e.metaInfo();
				if (!0 === t.historyCalculationMayChange) return c.DataSourceDangerReason.PineRepainting;
				const i = t.inputs.filter((e => "symbol" === e.type)).map((e => e.id));
				for (const t of i) {
					const i = e.properties().childs().inputs.childs()[t].value(),
						s = e.resolvedSymbolInfoBySymbol(i);
					if (s) {
						if ("spread" === s.type) return c.DataSourceDangerReason.Spread;
						if ("CRYPTOCAP" === s.exchange) return c.DataSourceDangerReason.CryptoCap
					}
				}
				const s = e.ownerSource();
				return e.isChildStudy() && s ? p(s) : null
			}
			var _ = i(349692),
				f = i(366156),
				m = i(629588),
				y = i(97639),
				v = i.n(y),
				g = i(695078),
				S = i(902899),
				b = i(559270),
				w = i(752280),
				P = i(970028),
				C = i(721925),
				x = i(831825),
				I = i(226087),
				T = i(456525),
				V = i(418458);
			class M extends I.StudyBaseWindowView {
				constructor(e, t) {
					super(e, t), this._showStudyValues = t.properties().childs().paneProperties.childs().legendProperties.childs().showStudyValues, this._showStudyValues.subscribe(this, this.update);
					const i = this._study.properties();
					i.childs().showLegendValues.subscribe(this, this.update);
					const s = this._study.metaInfo().plots,
						r = new Set;
					s.forEach((e => {
						var t;
						if ((0, V.isOhlcPlot)(e)) {
							const t = e.target;
							if (r.has(t)) return;
							r.add(t), i.childs().ohlcPlots.childs()[t].childs().display.subscribe(this, this.update)
						} else(0, V.isPlotSupportDisplay)(e) && (null === (t = i.childs().styles.childs()[e.id]) || void 0 === t || t.childs().display.subscribe(this, this.update))
					}))
				}
				areValuesVisible() {
					return this._showStudyValues.value()
				}
				additional() {
					return null
				}
				destroy() {
					this._showStudyValues.unsubscribeAll(this);
					const e = this._study.properties();
					e.childs().showLegendValues.unsubscribeAll(this);
					const t = this._study.metaInfo().plots,
						i = new Set;
					t.forEach((t => {
						var s;
						if ((0, V.isOhlcPlot)(t)) {
							const s = t.target;
							if (i.has(s)) return;
							i.add(s), e.childs().ohlcPlots.childs()[s].childs().display.unsubscribe(this, this.update)
						} else(0, V.isPlotSupportDisplay)(t) && (null === (s = e.childs().styles.childs()[t.id]) || void 0 === s || s.childs().display.unsubscribe(this, this.update))
					}))
				}
				_createValuesProvider(e, t) {
					return new T.StudyLegendValuesProvider(e, t)
				}
			}
			var R = i(308170),
				A = i(234840),
				B = i(15693),
				L = i(476543),
				O = i(908803),
				D = i(651620),
				k = i(270617),
				N = i(701336),
				E = i(752256);
			class F {
				constructor(e, t, i = !1) {
					this.price = t, this.index = e, this.useMainSeriesForPriceRange = i
				}
			}
			var W = i(34088);

			function H(e, t, i, s) {
				if (e.y1 === e.y2) return function(e, t, i) {
					return (0, r.assert)(e.y1 === e.y2), (0, W.doesItemAffectVisibleRange)(e.x1, e.x2, e.extend, t, i) ? [new F(t, e.y1, !1), new F(i, e.y2, !1)] : []
				}(e, i, s);
				const n = [];
				return null !== e.x1 && n.push(new F(e.x1, e.y1, !1)), null !== e.x2 && n.push(new F(e.x2, e.y2, !1)), n
			}

			function U(e, t, i, s) {
				return (0, W.doesItemAffectVisibleRange)(e.left, e.right, e.extend, i, s) ? [new F(i, e.top, !1), new F(s, e.bottom, !1)] : []
			}
			var z = i(656164);

			function G(e, t, i, s) {
				let r;
				const n = e.yloc !== z.DwgLabelYloc.Price && e.yloc !== z.DwgLabelYloc.Auto;
				if (n) {
					const i = e.yloc === z.DwgLabelYloc.AboveBar ? 2 : 3,
						s = t.valueAt(e.x);
					null !== s && (r = s[i])
				} else r = e.y;
				return null == r ? null : [new F(e.x, r, n)]
			}

			function Y() {
				return {
					topPixelMargin: 0,
					bottomPixelMargin: 0
				}
			}
			class j {
				constructor(e, t, i, s, n) {
					this._map = e, this._study = t, this._bars = t.series().bars(), this._props = (0, r.ensureDefined)(t.properties().childs().graphics).childs()[i], this._getPoints = s, this._getMargins = n
				}
				groupPriceRange(e, t) {
					let i = null;
					for (const [s, r] of this._map)
						if (this._props[s].visible.value())
							for (const s of r) {
								const r = this._getPoints(s, this._bars, e, t);
								if (null === r) continue;
								let n = 1 / 0,
									o = -1 / 0,
									a = !1,
									l = !1,
									h = !1;
								for (const i of r) {
									const s = i.index <= t,
										r = i.index >= e;
									a = a || s, l = l || r, h = h || s && r;
									let d = i.price,
										u = i.price;
									if (i.useMainSeriesForPriceRange) {
										const e = this._bars.valueAt(i.index);
										if (null === e) continue;
										const t = e[2];
										if (null == t) continue;
										const s = e[3];
										if (null == s) continue;
										d = s, u = t
									}
									d < n && (n = d), u > o && (o = u)
								}
								if (!(h || a && l)) continue;
								const d = new b.PriceRange(n, o);
								i = null === i ? d : i.merge(d)
							}
					return i
				}
				firstValue(e, t) {
					let i = 1 / 0,
						s = 1 / 0,
						r = -1 / 0,
						n = 1 / 0,
						o = 1 / 0,
						a = 1 / 0;
					for (const [l, h] of this._map)
						if (this._props[l].visible.value())
							for (const l of h) {
								const h = this._getPoints(l, this._bars, e, t);
								if (null !== h)
									for (const l of h) {
										const h = l.index;
										h < e && h > r ? (r = h, n = l.price) : h > t && h < o ? (o = h, a = l.price) : h < i && (i = h, s = l.price)
									}
							}
					return {
						firstVisible: i === 1 / 0 ? null : new F(i, s),
						leftClosest: r === -1 / 0 ? null : new F(r, n),
						rightClosest: o === 1 / 0 ? null : new F(o, a)
					}
				}
				groupPixelMargins(e, t) {
					const i = {
						topPixelMargin: 0,
						bottomPixelMargin: 0
					};
					if (null === this._study.priceScale()) return i;
					if (null === this._study.firstValue()) return i;
					for (const [s, r] of this._map)
						if (this._props[s].visible.value())
							for (const s of r) {
								const r = this._getPoints(s, this._bars, e, t);
								if (null === r) continue;
								if (0 === r.filter((i => {
										const s = i.index;
										return s >= e && s <= t
									})).length) continue;
								const n = this._getMargins(s, this._bars);
								i.bottomPixelMargin = Math.max(i.bottomPixelMargin, n.bottomPixelMargin), i.topPixelMargin = Math.max(i.topPixelMargin, n.topPixelMargin)
							}
					return i
				}
			}
			const K = () => ({
				bottomPixelMargin: 0,
				topPixelMargin: 0
			});

			function $(e, t, i) {
				const s = e.graphics(),
					r = s.dwglines();
				let n;
				return [new j(s.dwglabels(), e, "dwglabels", G, E.calculateDwgLabelsMargins.bind(null, e)), new j(r, e, "dwglines", H, K), new j(s.dwgboxes(), e, "dwgboxes", U, K), new j(s.dwglinefills(), e, "dwglinefills", ((e, t, i, s) => {
					if (void 0 === n) {
						n = new Map;
						for (const [, e] of r)
							for (const t of e) n.set(t.id, t)
					}
					return function(e, t, i, s, r) {
						const n = e.get(t.line1),
							o = e.get(t.line2);
						return void 0 !== n && void 0 !== o && ((0, W.doesItemAffectVisibleRange)(n.x1, n.x2, n.extend, s, r) || (0, W.doesItemAffectVisibleRange)(o.x1, o.x2, o.extend, s, r)) ? [new F(s, n.y1, !1), new F(r, n.y2, !1), new F(s, o.y1, !1), new F(r, o.y2, !1)] : []
					}(n, e, 0, i, s)
				}), Y)]
			}

			function q(e, t, i) {
				return null === t ? e : null === e ? t : e.index < t.index ? i ? t : e : i ? e : t
			}
			class X {
				constructor() {
					this.firstVisible = null, this.leftClosest = null, this.rightClosest = null
				}
				improve(e) {
					this.firstVisible = q(this.firstVisible, e.firstVisible, !0), this.leftClosest = q(this.leftClosest, e.leftClosest, !0), this.rightClosest = q(this.rightClosest, e.rightClosest, !1)
				}
				bestPrice() {
					return null !== this.firstVisible ? this.firstVisible.price : null !== this.leftClosest ? this.leftClosest.price : null !== this.rightClosest ? this.rightClosest.price : null
				}
			}
			var J = i(624635),
				Z = i(611688),
				Q = i(86441),
				ee = i(721386),
				te = i(717611);
			class ie {
				constructor(e) {
					this._data = e
				}
				draw(e, t) {}
				drawBackground(e, t) {
					e.save();
					const i = this._data,
						s = t.pixelRatio;
					let r = null;
					const n = Math.round(this._data.w * s);
					for (let t = 0; t < i.items.length; ++t) {
						const o = i.items[t];
						if (null == o.color) {
							r = null;
							continue
						}
						e.fillStyle = o.color;
						const a = Math.round(o.x * s);
						let l = a;
						if (t > 0) {
							i.items[t - 1].index === o.index - 1 && null !== r && (l = r + 1)
						}
						const h = a + n,
							d = h - l + 1;
						e.fillRect(l, Math.round(i.y * s), d, Math.round(i.h * s)), r = h
					}
					e.restore()
				}
				hitTest(e) {
					return null
				}
			}
			var se = i(362857);
			class re {
				constructor(e, t, i, s) {
					this._items = [], this._invalidated = !0, this._isMarkersEnabled = Z.enabled("source_selection_markers"), this._study = e, this._series = t, this._model = i, this._plotName = s;
					const n = this._study.metaInfo().plots;
					for (let e = 0; e < n.length; e++) {
						const t = n[e];
						t.id === this._plotName && (this._plotIndex = e, (0, r.assert)((0, V.isBgColorerPlot)(t), "Plot '" + this._plotName + "' is not a background colorer!"))
					}
					this._colorProvider = (0, se.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s)
				}
				items() {
					return this._items
				}
				update() {
					this._invalidated = !0
				}
				renderer() {
					if (1 != (1 & (0, r.ensureDefined)(this._study.properties().childs().styles.childs()[this._plotName]).childs().display.value())) return null;
					if (!this._scalesReady()) return null;
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const e = {
							items: this._items,
							y: 0,
							h: (0, r.ensureNotNull)(this._study.priceScale()).height(),
							w: this._model.timeScale().barSpacing()
						},
						t = new te.CompositeRenderer;
					return t.append(new ie(e)), t
				}
				_scalesReady() {
					const e = this._model.timeScale(),
						t = this._study.priceScale();
					return e && !e.isEmpty() && null !== t && !t.isEmpty()
				}
				_getTranspValue() {
					const e = (0, r.ensureDefined)(this._study.properties().childs().styles.childs()[this._plotName]).childs();
					let t = 0;
					return e.transparency && (t = e.transparency.value(), t = (0, k.isNumber)(t) ? t : 40), t
				}
				_updateImpl() {
					this._items = [], (0, r.assert)(this._scalesReady(), "Scales must be ready!");
					const e = this._model.timeScale().visibleBarsStrictRange();
					if (null === e) return;
					const t = this._getTranspValue();
					let i = (0, r.ensureDefined)(this._series.nearestIndex(e.firstBar(), w.PlotRowSearchMode.NearestRight)),
						s = (0, r.ensureDefined)(this._series.nearestIndex(e.lastBar(), w.PlotRowSearchMode.NearestLeft));
					const n = this._study.offset(this._plotName);
					n > 0 ? (i -= n, s += n) : (i += n, s -= n);
					const o = this._study.getMinFirstBarIndexForPlot(this._plotName);
					if (o > s) return;
					i = Math.max(o, i);
					const a = this._study.data().rangeIterator(i, s);
					for (; a.hasNext();) {
						const e = a.next();
						let i = e.index;
						const s = e.value;
						i += n;
						const o = new Q.Point(Math.floor(i) - .5, NaN);
						let l = (0, k.isNumber)(t) ? t : 50;
						l = Math.min(l, 100), l = Math.max(l, 0);
						const h = this._colorProvider.getPlotPointStyle(s);
						void 0 !== h.colors[1] && (o.color = (0, ee.generateColor)((0, r.ensureDefined)(h.colors[1]), l)), o.index = i, this._items.push(o)
					}
					this._model.timeScale().timedValuesToCoordinates(this._items)
				}
			}
			var ne = i(859447),
				oe = i(96989),
				ae = i(466915),
				le = i(218718),
				he = i(346037),
				de = i(103653),
				ue = i(181626),
				ce = i(453864),
				pe = i(363720),
				_e = i(78571),
				fe = i(771613),
				me = i(808146),
				ye = i(844577),
				ve = i(805316),
				ge = i(187117),
				Se = i(97138);
			const be = new Map;
			be.set("PaneRendererArrowUp", ce.PaneRendererArrowUp), be.set("PaneRendererArrowDown", ce.PaneRendererArrowDown), be.set("PaneRendererCircleShape", pe.PaneRendererCircleShape), be.set("PaneRendererCrossShape", _e.PaneRendererCrossShape), be.set("PaneRendererDiamond", fe.PaneRendererDiamond), be.set("PaneRendererFlagShape", me.PaneRendererFlagShape), be.set("PaneRendererLabelUp", ye.PaneRendererLabelUp), be.set("PaneRendererLabelDown", ye.PaneRendererLabelDown), be.set("PaneRendererSquare", ve.PaneRendererSquare),
				be.set("PaneRendererTriangleApexUp", ge.PaneRendererTriangleApexUp), be.set("PaneRendererTriangleApexDown", ge.PaneRendererTriangleApexDown), be.set("PaneRendererXCross", Se.PaneRendererXCross);
			class we {
				constructor(e, t, i, s) {
					this._items = [], this._invalidated = !1, this._renderer = null, this._isMarkersEnabled = Z.enabled("source_selection_markers"), this._selectionData = null, this._plotIndex = null, this._topCoord = 0, this._bottomCoord = 0, this._study = e, this._series = t, this._model = i, this._plotName = s;
					const r = e.metaInfo().plots;
					for (let e = 0; e < r.length; e++)
						if (r[e].id === this._plotName) {
							this._plotIndex = e;
							break
						} this._colorProvider = (0, se.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s), this._selectionIndexer = new he.SelectionIndexes(i.timeScale())
				}
				items() {
					return this._items
				}
				update() {
					this._invalidated = !0
				}
				renderer() {
					if (!this._isPlotVisible() || !this._scalesReady()) return null;
					if (this._invalidated) {
						const e = this._study.properties().childs().styles.childs()[this._plotName];
						this._updateRenderer(e), this._invalidated = !1
					}
					return this._renderer
				}
				_isPlotVisible() {
					return this._study.isPlotVisibleAt(this._plotName, 1)
				}
				_scalesReady() {
					const e = this._model.timeScale(),
						t = this._study.priceScale();
					return e && null !== t && !e.isEmpty() && !t.isEmpty()
				}
				_updateImpl() {
					if (this._items = [], !this._scalesReady()) return;
					const e = this._model.timeScale(),
						t = this._study.priceScale(),
						i = e.visibleBarsStrictRange();
					if (null === i || null === t) return;
					let s = this._series.nearestIndex(i.firstBar(), w.PlotRowSearchMode.NearestRight),
						n = this._series.nearestIndex(i.lastBar(), w.PlotRowSearchMode.NearestLeft);
					if (void 0 === s || void 0 === n) return;
					const o = this._study.offset(this._plotName);
					o > 0 ? (s -= o, n += o) : (s += o, n -= o);
					const a = this._study.getMinFirstBarIndexForPlot(this._plotName);
					if (a > n) return;
					s = Math.max(a, s);
					const l = this._study.data(),
						h = this._study.firstValue();
					if (null === h) return;
					const d = l.rangeIterator(s, n),
						u = this._getTranspValue();
					let c = [];
					const p = this._model.selection().isSelected(this._study);
					p ? (c = this._selectionIndexer.indexes(), this._selectionData = {
						points: [],
						hittestResult: le.HitTestResult.REGULAR,
						vertOffset: 0,
						bgColors: [],
						barSpacing: e.barSpacing(),
						visible: !0
					}) : (this._selectionIndexer.clear(), this._selectionData = null);
					const _ = this._series.properties().childs().style.value(),
						f = 2 === _ ? "lineStyle" : 3 === _ ? "areaStyle" : null;
					let m, y;
					f ? (m = this._series.properties().childs()[f].childs().priceSource.value(), y = m) : (m = "high", y = "low");
					const v = t.isInverted(),
						g = t.coordinateToPrice(t.height() * t.topMargin(), h),
						S = t.coordinateToPrice(t.height() * (1 - t.bottomMargin()), h);
					this._topCoord = v ? S : g, this._bottomCoord = v ? g : S;
					const b = (0, r.ensureNotNull)(this._model.paneForSource(this._study)).height(),
						P = this._study.properties().childs().styles.childs()[this._plotName].childs(),
						C = P.color.value(),
						x = P.textColor ? P.textColor.value() : void 0,
						I = C,
						T = C,
						V = void 0 === x ? void 0 : x,
						M = (0, r.ensureNotNull)(this._plotIndex),
						R = (0, ue.createEmptyStyle)();
					for (; d.hasNext();) {
						const e = d.next(),
							t = e.index,
							i = e.value,
							s = Math.floor(t + o),
							r = i[M + 1];
						if (null == r) continue;
						const n = this._createItem(s, r, m, y);
						if (null !== n) {
							if (this._colorProvider.isColorDefined()) {
								n.style = {
									color: I,
									borderColor: T,
									textColor: V
								};
								const e = this._colorProvider.getPlotPointStyle(i, R);
								this._fillItemWithPointStyle(n, e, u)
							}
							p && -1 !== c.indexOf(t) && null !== this._selectionData && (this._selectionData.points.push(n), this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(n.y / b))), this._items.push(n)
						}
					}
					this._convertItemsToCoordinates()
				}
				_fillItemWithPointStyle(e, t, i) {
					const s = (0, r.ensureDefined)(e.style);
					if (void 0 !== t.colors[0]) {
						s.color = (0, ee.generateColor)((0, r.ensureDefined)(t.colors[0]), i);
						const e = i > 9 ? i - 10 : 0;
						s.borderColor = (0, ee.generateColor)(s.color, e)
					}
					void 0 !== t.colors[2] && (s.textColor = (0, ee.generateColor)((0, r.ensureDefined)(t.colors[2]), i))
				}
				_updateRenderer(e) {
					this._updateImpl();
					const t = this._model.timeScale(),
						i = {},
						s = this._getTranspValue(),
						r = t.barSpacing(),
						n = this._calculateShapeHeight(r),
						o = this._study.properties().childs().styles.childs()[this._plotName].childs(),
						a = o.location.value(),
						l = this._calculateVerticalOffset(a, n + n / 2);
					i.barSpacing = r, i.items = this._items, i.color = (0, ee.generateColor)(o.color.value(), s), i.height = n, i.vertOffset = l;
					const h = o.plottype.value(),
						d = oe.plotShapesData[h],
						u = new te.CompositeRenderer;
					d && u.append(this._createRenderer(d.paneRendererClass, i)), this._model.selection().isSelected(this._study) && this._isMarkersEnabled && null !== this._selectionData && (this._selectionData.vertOffset = l, u.append(new ne.SelectionRenderer(this._selectionData))), this._renderer = u
				}
				_createRenderer(e, t) {
					const i = be.get(e);
					return new((0, r.ensureDefined)(i))(t)
				}
				_getSeriesVal(e, t) {
					const i = (0, de.barFunction)(e),
						s = this._series.data().valueAt(t);
					return null === s ? null : i(s)
				}
				_getTranspValue() {
					let e = 0;
					const t = this._study.properties().childs();
					t.transparency && (e = t.transparency.value(), e = (0, k.isNumber)(e) ? e : 50);
					const i = t.styles.childs()[this._plotName].childs();
					return i.transparency && (e = i.transparency.value(), e = (0, k.isNumber)(e) ? e : 50), (0, ae.clamp)(e, 0, 100)
				}
				_createItem(e, t, i, s) {
					const n = this._study.properties().childs().styles.childs()[this._plotName].childs().location.value();
					if ((null === t || 0 === t) && n !== x.MarkLocation.Absolute) return null;
					let o;
					switch (n) {
						case x.MarkLocation.AboveBar:
							const a = this._getSeriesVal(i, e);
							if (null === a) return null;
							o = a;
							break;
						case x.MarkLocation.BelowBar:
							const l = this._getSeriesVal(s, e);
							if (null === l) return null;
							o = l;
							break;
						case x.MarkLocation.Top:
							o = this._topCoord;
							break;
						case x.MarkLocation.Bottom:
							o = this._bottomCoord;
							break;
						case x.MarkLocation.Absolute:
							o = (0, r.ensureNotNull)(t);
							break;
						default:
							throw new Error("Bad value: " + n)
					}
					return new Q.Point(e, o)
				}
				_convertItemsToCoordinates() {
					const e = this._model.timeScale(),
						t = this._study.priceScale();
					e.timedValuesToCoordinates(this._items);
					const i = (0, r.ensureNotNull)(this._study.firstValue());
					(0, r.ensureNotNull)(t).pointsArrayToCoordinates(this._items, i)
				}
				_calculateVerticalOffset(e, t) {
					let i = 0;
					switch (e) {
						case x.MarkLocation.AboveBar:
						case x.MarkLocation.Bottom:
							i = -t;
							break;
						case x.MarkLocation.BelowBar:
						case x.MarkLocation.Top:
							i = t
					}
					return (0, r.ensureNotNull)(this._study.priceScale()).isInverted() && (i *= -1), i
				}
				_calculateShapeHeight(e, t) {
					let i = e;
					switch (t) {
						case V.PlotSymbolSize.Tiny:
							i = .3 * e;
							break;
						case V.PlotSymbolSize.Small:
							i = .6 * e;
							break;
						case V.PlotSymbolSize.Normal:
							i = e;
							break;
						case V.PlotSymbolSize.Large:
							i = 1.5 * e;
							break;
						case V.PlotSymbolSize.Huge:
							i = 2 * e
					}
					return i
				}
			}
			class Pe extends we {
				_updateRenderer(e) {
					const t = e.childs();
					this._updateImpl();
					const i = this._model.timeScale(),
						s = {},
						r = this._getTranspValue(),
						n = i.barSpacing();
					let o;
					if (t.size) {
						const e = t.size.value();
						o = this._calculateShapeHeight(25, e)
					} else o = Math.round(n / 2);
					o = Math.max(o, 1);
					const a = t.location.value(),
						h = (0, ee.generateColor)(t.color.value(), r),
						d = r > 19 ? r - 10 : 0,
						u = this._calculateVerticalOffset(a, Math.round(1.5 * o));
					s.barSpacing = n, s.items = this.items(), s.color = h, s.borderColor = (0, ee.generateColor)(t.color.value(), d), s.height = o, s.vertOffset = u;
					const c = t.plottype.value(),
						p = oe.plotShapesData[c],
						_ = new te.CompositeRenderer,
						f = t.text ? t.text.value() : void 0;
					if (void 0 !== f && "" !== f.trim()) {
						let e = f.trim().replace(/\\n/gm, "\n");
						e = (0, l.cleanButAmpersand)(e, !0), s.text = e, s.fontSize = 12;
						const i = t.textColor ? t.textColor.value() : void 0;
						s.textColor = i ? (0, ee.generateColor)(i, r) : h
					}
					_.append(super._createRenderer(p.paneRendererClass, s)), this._model.selection().isSelected(this._study) && this._isMarkersEnabled && null !== this._selectionData && (this._selectionData.vertOffset = u, _.append(new ne.SelectionRenderer(this._selectionData))), this._renderer = _
				}
			}
			var Ce = i(687795),
				xe = i.n(Ce),
				Ie = i(360511),
				Te = i(601132),
				Ve = i(588427),
				Me = i(267151);
			class Re extends Ie.PaneRendererAbstractShape {
				constructor(e, t) {
					super(null, t), this._fontSizeEnsured = 0, this._ch = "", this._fontFamily = Ve.CHART_FONT_FAMILY, this._charCache = null, null !== e && this.setData(e)
				}
				setData(e) {
					super.setData(e), this._fontSizeEnsured = (0, r.ensureDefined)(this._height);
					const t = e.char.slice(0, 40);
					this._ch = xe()(t)[0] || " ", this._fontFamily = e.fontFamily || Ve.CHART_FONT_FAMILY
				}
				hitTest(e) {
					const t = (0, Te.interactionTolerance)().series + this._fontSizeEnsured / 2;
					for (const i of this._items) {
						if (new Q.Point(i.x, i.y + i.vertOffset).subtract(e).length() <= t) return new le.HitTestResult(le.HitTestResult.REGULAR)
					}
					return null
				}
				_drawItemShape(e, t, i) {
					const s = i.x,
						r = i.vertOffset > 0 ? 1 : -1,
						n = i.y + i.vertOffset - r * Math.round(this._fontSizeEnsured / 2);
					let o;
					o = i.style && void 0 !== i.style.color ? i.style.color : this._color;
					const a = this._textImageCache(),
						l = t.pixelRatio;
					if (this._fontSizeEnsured <= 4 / l) {
						e.save();
						const t = Math.max(1, Math.floor(l));
						let r = Math.max(1, Math.floor(a.textImageWidth * l));
						r % 2 != t % 2 && (r += r > 1 ? -1 : 1);
						const h = Math.round(n * l) + (i.vertOffset >= 0 ? 0 : -r);
						return e.fillStyle = o, e.fillRect(Math.round(s * l) + (l % 2 ? .5 : 0) - r / 2, h, r, r), void e.restore()
					}
					const h = {
						style: {
							fillStyle: o
						},
						location: {
							x: s,
							y: n,
							horzAlign: Me.HorizontalAlign.Center,
							vertAlign: i.vertOffset > 0 ? Me.VerticalAlign.Top : Me.VerticalAlign.Bottom
						}
					};
					a.paintTo(e, t, h)
				}
				_startPath(e, t, i, s) {}
				_endPath(e) {}
				_textImageCache() {
					return null !== this._charCache && this._charCache.fontFamily === this._fontFamily && this._charCache.fontSize === this._fontSizeEnsured || (this._charCache = {
						fontSize: this._fontSizeEnsured,
						fontFamily: this._fontFamily,
						cache: new Me.TextImageCache(this._ch, !1, !1, this._fontFamily, this._fontSizeEnsured, "center", 0)
					}), this._charCache.cache
				}
			}
			class Ae extends we {
				constructor() {
					super(...arguments), this._compositeRenderer = new te.CompositeRenderer, this._charRenderer = new Re(null)
				}
				renderer() {
					return this._isPlotVisible() && this._scalesReady() ? (this._invalidated && (this._updateImpl(), this._invalidated = !1), this._compositeRenderer) : null
				}
				_updateImpl() {
					if (this._compositeRenderer.clear(), super._updateImpl(), 0 === this._items.length) return;
					const e = this._getTranspValue(),
						t = this._model.timeScale().barSpacing();
					let i;
					const s = this._study.properties().childs().styles.childs()[this._plotName].childs();
					if (s.size) {
						const e = s.size.value();
						i = this._calculateShapeHeight(50, e)
					} else i = Math.round(t);
					const r = s.location.value(),
						n = (0, ee.generateColor)(s.color.value(), e),
						o = this._calculateVerticalOffset(r, i),
						a = {
							items: this.items(),
							barSpacing: t,
							char: s.char.value(),
							height: i,
							vertOffset: o,
							color: n
						},
						h = s.text ? s.text.value() : void 0;
					if (void 0 !== h && "" !== h.trim()) {
						let t = h.trim().replace(/\\n/gm, "\n");
						t = (0, l.cleanButAmpersand)(t, !0), a.text = t, a.fontSize = 12;
						const i = s.textColor ? s.textColor.value() : void 0;
						a.textColor = i ? (0, ee.generateColor)(i, e) : n
					}
					this._charRenderer.setData(a), this._compositeRenderer.append(this._charRenderer), this._model.selection().isSelected(this._study) && this._isMarkersEnabled && null !== this._selectionData && (this._selectionData.vertOffset = o, this._compositeRenderer.append(new ne.SelectionRenderer(this._selectionData)))
				}
			}
			var Be = i(724377);
			class Le extends Q.Point {
				constructor(e, t, i, s) {
					super(e, t), this.height = i, this.isUp = s, this.style = {}
				}
			}

			function Oe(e) {
				return Math.round(e / 4)
			}

			function De(e) {
				return Math.round(e / 2)
			}
			class ke {
				constructor(e) {
					this._data = e
				}
				draw(e, t) {
					var i;
					const s = t.pixelRatio,
						r = this._data,
						n = De(r.barSpacing),
						o = Oe(r.barSpacing),
						a = n < 4,
						l = Math.max(n / 2, 1),
						h = (0, ae.ceiledEven)(n * s),
						d = h / 2,
						u = Math.round(n * s);
					e.lineCap = "butt", e.lineWidth = Math.max(1, Math.floor(s));
					const c = e.lineWidth % 2 ? .5 : 0;
					for (const t of r.items) {
						const n = t.isUp ? -1 : 1,
							p = Math.round(Math.abs(t.height) * s),
							_ = Math.round(t.x * s) + c,
							f = Math.round((t.y - n * o) * s) + c;
						e.beginPath(), e.translate(_, f);
						const m = null !== (i = t.style && t.style.color) && void 0 !== i ? i : t.isUp ? r.colorup : r.colordown;
						a ? (e.moveTo(0, 0), e.lineTo(-d, -d * n), e.moveTo(0, 0), e.lineTo(d, -d * n), e.moveTo(0, 0), e.lineTo(0, -p * n), e.moveTo(-d, -p * n), e.lineTo(d, -p * n), e.lineWidth = l, e.strokeStyle = m, e.stroke()) : (e.moveTo(0, 0), p < u ? (e.lineTo(h, -p * n), e.lineTo(-h, -p * n)) : (e.lineTo(h, -u * n), e.lineTo(d, -u * n), e.lineTo(d, -p * n), e.lineTo(-d, -p * n), e.lineTo(-d, -u * n), e.lineTo(-h, -u * n)), e.lineTo(0, 0), e.strokeStyle = t.isUp ? r.colorBorderUp : r.colorBorderDown, e.stroke(), e.fillStyle = m, e.fill()), e.translate(-_, -f)
					}
				}
				hitTest(e) {
					const t = this._data,
						i = De(t.barSpacing),
						s = Math.round(i / 2),
						r = Math.round(i),
						n = Oe(t.barSpacing);
					for (const i of t.items) {
						if (!i) continue;
						if (!Number.isFinite(i.x) || !Number.isFinite(i.y)) continue;
						const t = Math.abs(i.height),
							o = i.isUp ? -1 : 1,
							a = t + r,
							l = i.y - o * n,
							h = l - o * a,
							d = i.x - s,
							u = i.x + s;
						if (d < e.x && e.x < u && (i.isUp ? l < e.y && e.y < h : h < e.y && e.y < l)) return new le.HitTestResult(le.HitTestResult.REGULAR)
					}
					return null
				}
			}
			class Ne extends ne.SelectionRenderer {
				_drawMarker(e, t, i, s, n) {
					const o = (0, r.ensureNotNull)(this._data),
						a = t.isUp ? 1 : -1;
					const l = i + a * Oe(o.barSpacing) + a * De(o.barSpacing);
					let h = Math.round(3.5 * n * 2);
					h % 2 != s % 2 && (h += 1);
					const d = s % 2 / 2,
						u = Math.round(t.x * n) + d,
						c = Math.round((t.y + l) * n) + d;
					e.beginPath(), e.arc(u, c, h / 2, 0, 2 * Math.PI, !0), e.closePath(), e.fill(), e.stroke()
				}
			}
			class Ee extends we {
				constructor() {
					super(...arguments), this._maxAbsValue = 0
				}
				renderer() {
					if (!this._isPlotVisible() || !this._scalesReady()) return null;
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const e = this._study.properties().childs().styles.childs()[this._plotName].childs(),
						t = {},
						i = (0, ae.clamp)(this._getTranspValue(), 0, 100),
						s = this._model.timeScale().barSpacing();
					t.items = this._items, t.barSpacing = s, t.colorup = (0, ee.generateColor)(e.colorup.value(), i), t.colordown = (0, ee.generateColor)(e.colordown.value(), i);
					const r = (0, Be.parseRgba)(t.colorup),
						n = r ? 100 * (1 - r[3]) : 0,
						o = (0, Be.parseRgba)(t.colordown),
						a = o ? 100 * (1 - o[3]) : 0;
					t.colorBorderUp = (0, ee.generateColor)("#000000", n), t.colorBorderDown = (0, ee.generateColor)("#000000", a), t.minHeight = e.minHeight.value(), t.maxHeight = e.maxHeight.value();
					const l = new te.CompositeRenderer;
					if (l.append(new ke(t)), this._model.selection().isSelected(this._study) && null !== this._selectionData) {
						const e = this._selectionData;
						e.barSpacing = s, l.append(new Ne(e))
					}
					return l
				}
				_fillItemWithPointStyle(e, t, i) {
					const s = (0, r.ensureDefined)(e.style);
					e.isUp ? void 0 !== t.colors[5] ? s.color = (0, ee.generateColor)((0, r.ensureDefined)(t.colors[5]), i) : s.color = (0, ee.generateColor)(this._study.properties().childs().styles.childs()[this._plotName].childs().colorup.value(), i) : void 0 !== t.colors[6] ? s.color = (0, ee.generateColor)((0, r.ensureDefined)(t.colors[6]), i) : s.color = (0, ee.generateColor)(this._study.properties().childs().styles.childs()[this._plotName].childs().colordown.value(), i)
				}
				_createItem(e, t, i, s) {
					if (0 === t) return null;
					Math.abs(t) > this._maxAbsValue && (this._maxAbsValue = Math.abs(t));
					const r = t > 0;
					let n;
					if (r) {
						const t = this._getSeriesVal(s, e);
						if (null === t) return null;
						n = t
					} else {
						const t = this._getSeriesVal(i, e);
						if (null === t) return null;
						n = t
					}
					return new Le(e, n, t, r)
				}
				_convertItemsToCoordinates() {
					const e = this._model.timeScale(),
						t = (0, r.ensureNotNull)(this._study.priceScale());
					e.timedValuesToCoordinates(this._items), t.pointsArrayToCoordinates(this._items, (0, r.ensureNotNull)(this._study.firstValue()));
					const i = this._study.properties().childs().styles.childs();
					let s = Math.abs(i[this._plotName].childs().minHeight.value()),
						n = Math.abs(i[this._plotName].childs().maxHeight.value());
					if (s > n) {
						const e = s;
						s = n, n = e
					}
					const o = (n - s) / this._maxAbsValue,
						a = this._items;
					for (let e = 0; e < a.length; e++) {
						const t = a[e],
							i = Math.abs(t.height);
						t.height = i * o + s
					}
				}
			}
			var Fe = i(207152);
			class We {
				constructor(e, t, i, s) {
					this._bars = [], this._invalidated = !1, this._isMarkersEnabled = Z.enabled("source_selection_markers"), this._selectionData = null, this._ohlcPlotIndexes = new Map, this._study = e, this._series = t, this._model = i, this._plotName = s, this._isMarkersEnabled = Z.enabled("source_selection_markers"), this._colorProvider = (0, se.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s), this._selectionIndexer = new he.SelectionIndexes(i.timeScale());
					const r = this._study.metaInfo().plots;
					for (let e = 0; e < r.length; e++) {
						const t = r[e];
						"target" in t && (t.target === this._plotName && ((0, V.isOhlcOpenPlot)(t) && this._ohlcPlotIndexes.set(1, e), (0, V.isOhlcHighPlot)(t) && this._ohlcPlotIndexes.set(2, e), (0, V.isOhlcLowPlot)(t) && this._ohlcPlotIndexes.set(3, e), (0, V.isOhlcClosePlot)(t) && this._ohlcPlotIndexes.set(4, e)))
					}
				}
				update() {
					this._invalidated = !0
				}
				items() {
					return this._bars
				}
				_updateImpl() {
					this._bars.length = 0;
					const e = this._study.priceScale();
					if (this._model.timeScale().isEmpty() || null === e || e.isEmpty()) return;
					const t = this._model.timeScale().visibleBarsStrictRange();
					if (null === t) return;
					let i = this._series.nearestIndex(t.firstBar(), w.PlotRowSearchMode.NearestRight);
					const s = this._series.nearestIndex(t.lastBar(), w.PlotRowSearchMode.NearestLeft);
					if (void 0 === i || void 0 === s) return;
					const n = this._study.getMinFirstBarIndexForPlot(this._plotName);
					if (n > s) return;
					i = Math.max(n, i);
					const o = this._study.data(),
						a = this._study.firstValue();
					if (null === a) return;
					const l = o.rangeIterator(i, s),
						h = (0, r.ensureDefined)(this._study.properties().childs().ohlcPlots).childs()[this._plotName].childs(),
						d = new Map,
						u = (e, t) => {
							const i = e + "@" + t;
							if (!d.has(i)) {
								const s = (0, ee.generateColor)(e, t);
								return d.set(i, s), s
							}
							return d.get(i)
						},
						c = (0, ue.createEmptyStyle)();
					for (; l.hasNext();) {
						const e = l.next();
						let t = e.index;
						const i = e.value;
						t = Math.floor(t);
						let s = !0;
						const n = new Map;
						for (let e = 1; e <= 4; ++e) {
							const t = this._ohlcPlotIndexes.get(e);
							if (void 0 === t) {
								s = !1;
								break
							}
							const r = i[t + 1];
							if (null == r) {
								s = !1;
								break
							}
							n.set(e, r)
						}
						if (!s) continue;
						const o = (0, r.ensureDefined)(n.get(1)),
							a = (0, r.ensureDefined)(n.get(4)),
							d = (0, r.ensureDefined)(n.get(2)),
							p = (0, r.ensureDefined)(n.get(3)),
							_ = Math.max(o, d, p, a),
							f = Math.min(o, d, p, a);
						let m = (0, r.ensureDefined)(u(h.color.value(), 0));
						const y = this._colorProvider.getPlotPointStyle(i, c);
						void 0 !== y.colors[0] && (m = (0, r.ensureDefined)(y.colors[0]));
						const v = {
							time: Math.round(t),
							open: o,
							high: _,
							low: f,
							close: a,
							color: m,
							wickColor: y.colors[4],
							borderColor: y.colors[3],
							hollow: null
						};
						this._bars.push(v)
					}
					if (e.barPricesToCoordinates(this._bars, a), this._model.timeScale().barIndexesToCoordinates(this._bars), this._model.selection().isSelected(this._study)) {
						const t = this._selectionIndexer.indexes();
						this._selectionData = {
							points: [],
							hittestResult: le.HitTestResult.REGULAR,
							bgColors: [],
							visible: !0,
							barSpacing: this._model.timeScale().barSpacing()
						};
						const i = (0, r.ensureNotNull)(this._model.paneForSource(this._study)).height(),
							s = (0, r.ensureDefined)(this._ohlcPlotIndexes.get(4));
						for (let r = 0; r < t.length; r++) {
							const n = t[r],
								o = this._study.data().valueAt(n);
							if (null === o) continue;
							const l = o[s + 1];
							if (null == l) continue;
							const h = this._model.timeScale().indexToCoordinate(Math.floor(n)),
								d = e.priceToCoordinate(l, a);
							this._selectionData.points.push(new Q.Point(h, d)), this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(d / i))
						}
					} else this._selectionIndexer.clear()
				}
				_isOHLCPlotVisible() {
					return this._study.isPlotVisibleAt(this._plotName, 1)
				}
			}
			class He extends We {
				renderer() {
					if (!this._isOHLCPlotVisible()) return null;
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const e = {
							bars: this._bars,
							barSpacing: this._model.timeScale().barSpacing(),
							dontDrawOpen: this._series.properties().childs().barStyle.childs().dontDrawOpen.value(),
							thinBars: this._series.properties().childs().barStyle.childs().thinBars.value()
						},
						t = new te.CompositeRenderer;
					return t.append(new Fe.PaneRendererBars(e)), this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData && t.append(new ne.SelectionRenderer(this._selectionData)), t
				}
			}
			var Ue = i(280446);
			class ze extends We {
				renderer() {
					if (!this._isOHLCPlotVisible()) return null;
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const e = (0, r.ensureDefined)(this._study.properties().childs().ohlcPlots).childs()[this._plotName].childs(),
						t = this._model.timeScale().barSpacing(),
						i = {
							bars: this._bars,
							barSpacing: t,
							wickVisible: e.drawWick.value(),
							bodyVisible: !0,
							borderVisible: e.drawBorder.value(),
							barWidth: (0, Te.optimalBarWidth)(t),
							borderColor: e.borderColor.value(),
							wickColor: e.wickColor.value()
						},
						s = new te.CompositeRenderer;
					return s.append(new Ue.PaneRendererCandles(i)), this._model.selection().isSelected(this._series) && this._isMarkersEnabled && this._selectionData && s.append(new ne.SelectionRenderer(this._selectionData)), s
				}
			}
			var Ge = i(613648),
				Ye = i(951433),
				je = i(350985),
				Ke = i(345185);
			class $e extends je.HorizontalLinePaneView {
				constructor(e, t) {
					super(), this._lineRendererData.linestyle = Ke.LINESTYLE_DOTTED, this._study = e, this._plotName = t
				}
				_updateImpl() {
					this._lineRendererData.visible = !1;
					const e = this._study.properties().childs().styles.childs()[this._plotName].childs();
					if (!e.trackPrice.value() || !this._study.isPlotVisibleAt(this._plotName, 1)) return;
					const t = this._study.lastValueData(this._plotName, !0);
					t.noData || (this._lineRendererData.visible = !0, this._lineRendererData.y = t.coordinate, this._lineRendererData.color = t.color, this._lineRendererData.linewidth = e.linewidth.value())
				}
			}
			var qe = i(51975),
				Xe = i(408484);
			const Je = {
				type: 0,
				color: "transparent"
			};
			class Ze extends Xe.AbstractFilledAreaPaneView {
				constructor(e, t, i, s) {
					var n, o, a;
					super(e, t, !!i.fillgaps), this._palettesInfo = {}, this._gradientPropsStateCache = null;
					const l = this._source.metaInfo();
					this._isRGB = Boolean(l.isRGB), this._isHlineFill = "hline_hline" === i.type, (0, r.assert)(this._isHlineFill || "plot_plot" === i.type, "Wrong filledArea type: " + i.type), this._isHlineFill && this._initBandIndexes(i.objAId, i.objBId), this._fillMetaInfo = i, this._fillStyleProps = s, this._gradientFillType = s.hasChild("fillType") && "gradient" === (null === (n = s.childs().fillType) || void 0 === n ? void 0 : n.value()), this._gradientStaticState = {
						color1: i.topColor,
						color2: i.bottomColor,
						value1: i.topValue,
						value2: i.bottomValue
					}, this._hasAllGradientRequiredProps = this._gradientFillType && (void 0 !== this._gradientStaticState.color1 || s.hasChild("topColor") || void 0 !== this._gradientStaticState.color2 || s.hasChild("bottomColor")) && (void 0 !== this._gradientStaticState.value1 || s.hasChild("topValue")) && (void 0 !== this._gradientStaticState.value2 || s.hasChild("bottomValue"));
					const h = () => {
						var e;
						return this._colorPlotIndex = null !== (e = this._colorPlotIndex) && void 0 !== e ? e : {
							type: 1
						}
					};
					for (let t = 0; t < l.plots.length; ++t) {
						const s = l.plots[t];
						if (((0, V.isColorerPlot)(s) || (0,
								V.isDataPlot)(s)) && s.target === i.id) {
							if ((0, V.isColorerPlot)(s)) {
								let i;
								void 0 !== s.targetField ? "topColor" === s.targetField ? (h().colorIndexOrRgba1 = t, i = "color1") : "bottomColor" === s.targetField && (h().colorIndexOrRgba2 = t, i = "color2") : this._colorPlotIndex = {
									type: 0,
									colorIndexOrRgba: t
								}, (0, V.isPaletteColorerPlot)(s) && (this._palettesInfo[null != i ? i : "color"] = {
									map: (0, r.ensureDefined)(null === (o = (0, r.ensureDefined)(l.palettes)[s.palette]) || void 0 === o ? void 0 : o.valToIndex),
									values: e.properties().palettes[s.palette].colors
								})
							} else(0, V.isDataPlot)(s) && ("topValue" === s.targetField ? h().valueIndex1 = t : "bottomValue" === s.targetField && (h().valueIndex2 = t));
							if (0 === (null === (a = this._colorPlotIndex) || void 0 === a ? void 0 : a.type)) break
						}
					}
				}
				update() {
					super.update(), this._gradientPropsStateCache = null
				}
				_getColorByPlotValue(e) {
					var t, i, s;
					if (0 === e.type) {
						let i;
						if (this._isRGB) {
							if (null == e.colorIndexOrRgba) return null;
							i = (0, ee.rgbaFromInteger)(e.colorIndexOrRgba)
						} else {
							const s = (0, r.ensureDefined)(this._palettesInfo.color),
								n = (0, r.ensureDefined)(s.map[(0, r.ensure)(e.colorIndexOrRgba)]);
							i = null === (t = s.values[n]) || void 0 === t ? void 0 : t.childs().color.value()
						}
						return {
							type: 0,
							color: i
						}
					}
					const n = this._gradientColorPropsState();
					let o, a;
					if (this._isRGB) null != e.colorIndexOrRgba1 && (o = (0, ee.rgbaFromInteger)(e.colorIndexOrRgba1)), null != e.colorIndexOrRgba2 && (a = (0, ee.rgbaFromInteger)(e.colorIndexOrRgba2));
					else {
						if (null != e.colorIndexOrRgba1) {
							const t = (0, r.ensureDefined)(this._palettesInfo.color1);
							o = t.values[(0, r.ensureDefined)(t.map[e.colorIndexOrRgba1])].childs().color.value()
						}
						if (null != e.colorIndexOrRgba2) {
							const t = (0, r.ensureDefined)(this._palettesInfo.color2);
							a = t.values[(0, r.ensureDefined)(t.map[e.colorIndexOrRgba2])].childs().color.value()
						}
					}
					const l = null !== (i = e.value1) && void 0 !== i ? i : n.value1,
						h = null !== (s = e.value2) && void 0 !== s ? s : n.value2;
					return o = null != o ? o : n.color1, a = null != a ? a : n.color2, void 0 === l || void 0 === h || void 0 === o && void 0 === a ? null : {
						type: 1,
						color1: o,
						color2: a,
						value1: l,
						value2: h
					}
				}
				_plotAId() {
					return this._fillMetaInfo.objAId
				}
				_plotBId() {
					return this._fillMetaInfo.objBId
				}
				_commonColor() {
					const e = this._fillStyleProps.childs();
					if (this._gradientFillType) {
						if (!this._hasAllGradientRequiredProps) return Je;
						const e = this._gradientColorPropsState();
						return {
							type: 1,
							color1: e.color1,
							color2: e.color2,
							value1: e.value1,
							value2: e.value2
						}
					}
					return {
						type: 0,
						color: e.color.value()
					}
				}
				_transparency() {
					return this._fillStyleProps.childs().transparency.value()
				}
				_correctVisibleRange(e) {
					const [t, i] = super._correctVisibleRange(e), s = this._source.getMinFirstBarIndexForPlot(this._fillMetaInfo.id);
					return [Math.max(s, t), i]
				}
				_visible() {
					return this._fillStyleProps.childs().visible.value()
				}
				_initBandIndexes(e, t) {
					this._bandAKey = null, this._bandBKey = null;
					const i = this._source.metaInfo().bands;
					if (void 0 !== i)
						for (let s = 0; s < i.length; ++s) {
							const r = i[s];
							null !== this._bandAKey || r.id !== e ? null === this._bandBKey && r.id === t && (this._bandBKey = s) : this._bandAKey = s
						}
				}
				_gradientColorPropsState() {
					var e, t, i, s;
					if (null === this._gradientPropsStateCache) {
						const r = this._fillStyleProps.state();
						this._gradientPropsStateCache = {
							color1: null !== (e = this._gradientStaticState.color1) && void 0 !== e ? e : r.topColor,
							color2: null !== (t = this._gradientStaticState.color2) && void 0 !== t ? t : r.bottomColor,
							value1: null !== (i = this._gradientStaticState.value1) && void 0 !== i ? i : r.topValue,
							value2: null !== (s = this._gradientStaticState.value2) && void 0 !== s ? s : r.bottomValue
						}
					}
					return this._gradientPropsStateCache
				}
			}
			var Qe = i(287597),
				et = i(37689);
			class tt {
				constructor(e, t) {
					this._invalidated = !0, this._lineRenderer = new et.HorizontalLineRenderer, this._source = t, this._points = [new Q.Point(-1, -1)], this._invalidated = !0, this._properties = e
				}
				update() {
					this._invalidated = !0
				}
				renderer() {
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const e = {
						y: this._points[0].y,
						color: this._properties.childs().color.value(),
						linewidth: this._properties.childs().linewidth.value(),
						linestyle: this._properties.childs().linestyle.value()
					};
					return this._lineRenderer.setData(e), this._lineRenderer
				}
				_updateImpl() {
					const e = this._source.priceScale();
					if (!e || e.isEmpty()) return void(this._points[0] = new Q.Point(-1, -1));
					const t = this._properties.childs().value.value(),
						i = this._source.firstValue(),
						s = (0, k.isNumber)(t) && null !== i ? e.priceToCoordinate(t, i) : NaN;
					this._points[0] = new Q.Point(-1, s)
				}
			}
			var it = i(380047);
			class st extends it.ScaledPaneRenderer {
				constructor() {
					super(), this._data = null, this._data = null
				}
				setData(e = null) {
					this._data = e
				}
				hitTest() {
					return null
				}
				_drawImpl(e, t) {
					var i, s;
					if (null === this._data || 0 === this._data.points.length) return;
					const r = t.cssWidth;
					if (this._data.gradient) {
						const t = e.createLinearGradient(0, this._data.coordinate1, 0, this._data.coordinate2);
						t.addColorStop(0, null !== (i = this._data.backColor1) && void 0 !== i ? i : "transparent"), t.addColorStop(1, null !== (s = this._data.backColor2) && void 0 !== s ? s : "transparent"), e.fillStyle = t
					} else e.fillStyle = this._data.backcolor;
					const n = Math.min(this._data.points[0], this._data.points[1]),
						o = Math.max(this._data.points[0], this._data.points[1]);
					e.fillRect(0, n, r, o - n)
				}
			}
			class rt {
				constructor(e) {
					this._bandBgRenderer = new st, this._invalidated = !0, this._source = e
				}
				update() {
					this._invalidated = !0
				}
				renderer() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._bandBgRenderer
				}
				_updateImpl() {
					this._bandBgRenderer.setData(null);
					const e = this._source.properties().childs(),
						t = e.bands;
					if (t.childCount() < 2) return;
					const i = e.bandsBackground;
					if (!(null == i ? void 0 : i.childs().fillBackground.value())) return;
					const s = t[0].childs(),
						n = t[1].childs(),
						o = this._source.priceScale(),
						a = this._source.firstValue();
					if (!o || o.isEmpty() || null === a) return;
					const l = [o.priceToCoordinate(s.value.value(), a), o.priceToCoordinate(n.value.value(), a)],
						h = (0, r.ensureDefined)(e.bandsBackground).childs(),
						d = (0, ae.clamp)(h.transparency.value(), 0, 100);
					this._bandBgRenderer.setData({
						gradient: !1,
						points: l,
						backcolor: (0, ee.generateColor)(h.backgroundColor.value(), d)
					})
				}
			}
			class nt {
				constructor(e, t, i) {
					var s;
					this._bandBgRenderer = new st, this._bandAKey = null, this._bandBKey = null, this._invalidated = !0, this._source = e, (0, r.assert)("hline_hline" === t.type, "Wrong filledArea type: " + t.type), this._initBandIndexes(t.objAId, t.objBId), this._fillStyleProps = i, this._bandBgRenderer = new st,
						this._gradientFillType = i.hasChild("fillType") && "gradient" === (null === (s = i.childs().fillType) || void 0 === s ? void 0 : s.value()), this._gradientStaticState = {
							color1: t.topColor,
							color2: t.bottomColor,
							value1: t.topValue,
							value2: t.bottomValue
						}
				}
				update() {
					this._invalidated = !0
				}
				renderer() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._bandBgRenderer
				}
				_updateImpl() {
					var e, t, i, s, n, o, a, l;
					if (this._bandBgRenderer.setData(null), !this._fillStyleProps.childs().visible.value()) return;
					if (null === this._bandAKey || null === this._bandBKey) return;
					const h = (0, r.ensureDefined)(this._source.properties().childs().bands),
						d = h.childs()[this._bandAKey].childs(),
						u = h.childs()[this._bandBKey].childs(),
						c = this._source.priceScale(),
						p = this._source.firstValue();
					if (!c || c.isEmpty() || null === p) return;
					const _ = [c.priceToCoordinate(d.value.value(), p), c.priceToCoordinate(u.value.value(), p)],
						f = (0, ae.clamp)(this._fillStyleProps.childs().transparency.value(), 0, 100);
					let m;
					const y = this._fillStyleProps.childs();
					if (this._gradientFillType) {
						const r = this._gradientStaticState,
							h = y,
							d = null !== (e = r.value1) && void 0 !== e ? e : null === (t = h.topValue) || void 0 === t ? void 0 : t.value(),
							u = null !== (i = r.value2) && void 0 !== i ? i : null === (s = h.bottomValue) || void 0 === s ? void 0 : s.value();
						if (void 0 === d || void 0 === u) return;
						const v = null !== (n = r.color1) && void 0 !== n ? n : null === (o = h.topColor) || void 0 === o ? void 0 : o.value(),
							g = null !== (a = r.color2) && void 0 !== a ? a : null === (l = h.bottomColor) || void 0 === l ? void 0 : l.value();
						if (void 0 === v && void 0 === g) return;
						m = {
							gradient: !0,
							points: _,
							backColor1: v && (0, ee.generateColor)(v, f),
							backColor2: g && (0, ee.generateColor)(g, f),
							coordinate1: c.priceToCoordinate(d, p),
							coordinate2: c.priceToCoordinate(u, p)
						}
					} else m = {
						gradient: !1,
						points: _,
						backcolor: (0, ee.generateColor)(y.color.value(), f)
					};
					this._bandBgRenderer.setData(m)
				}
				_initBandIndexes(e, t) {
					this._bandAKey = null, this._bandBKey = null;
					(0, r.ensureDefined)(this._source.metaInfo().bands).forEach(((i, s) => {
						null === this._bandAKey && i.id === e && (this._bandAKey = s), null === this._bandBKey && i.id === t && (this._bandBKey = s)
					}))
				}
			}
			var ot = i(906096),
				at = i(669415),
				lt = i(388230),
				ht = i(194459),
				dt = i(262325),
				ut = i.n(dt),
				ct = (i(749473), i(38627)),
				pt = i(285339),
				_t = i(267850),
				ft = i(289627),
				mt = i(251954);
			const yt = (0, o.getLogger)("Chart.Study"),
				vt = (0, n.t)("Invalid Symbol");
			const gt = {
					symbolsForDisplay: !1,
					symbolsForChartApi: !0,
					skipHiddenInputs: !1,
					skipFakeInputs: !1,
					skipBooleanInputs: Z.enabled("dont_show_boolean_study_arguments"),
					asObject: !0,
					skippedGroups: [],
					skippedInputs: [],
					noExchanges: !1,
					noResolution: !1,
					keepOptionalSymbolsEmpty: !1,
					skipColorInputs: !1,
					skipTimeInputs: !1,
					skipOptionalEmptySymbolInputs: !1,
					skipTextareaInputs: !0,
					priceInputsForDisplay: !1
				},
				St = Z.enabled("study_symbol_ticker_description"),
				bt = Z.enabled("hide_main_series_symbol_from_indicator_legend");

			function wt(e, t) {
				const i = e.plots[t];
				if (!i || !(0, V.isOhlcPlot)(i)) return !1;
				const s = i.target,
					r = e.defaults.styles && e.defaults.styles[s],
					n = e.defaults.ohlcPlots && e.defaults.ohlcPlots[s],
					o = e.ohlcPlots && e.ohlcPlots[s];
				return r && (0, V.isOhlcPlotStyleBars)(r) || n && (0, V.isOhlcPlotStyleBars)(n) || !!o && (0, V.isOhlcPlotStyleBars)(o)
			}

			function Pt(e, t) {
				const i = e.plots[t];
				if (!i || !(0, V.isOhlcPlot)(i)) return !1;
				const s = i.target,
					r = e.defaults.styles && e.defaults.styles[s],
					n = e.defaults.ohlcPlots && e.defaults.ohlcPlots[s],
					o = e.ohlcPlots && e.ohlcPlots[s];
				return r && (0, V.isOhlcPlotStyleCandles)(r) || n && (0, V.isOhlcPlotStyleCandles)(n) || !!o && (0, V.isOhlcPlotStyleCandles)(o)
			}

			function Ct(e, t) {
				(0, r.assert)(void 0 !== e, "zOrder must be defined"), (0, r.assert)(!t.has(e), "zOrder must be unique")
			}

			function xt(e, t) {
				return e.plots.some((e => ((0, V.isColorerPlot)(e) || (0, V.isDataPlot)(e)) && e.target === t))
			}
			class It extends S.PriceDataSource {
				constructor(e, t, i, s) {
					var n, o, a;
					super(e), this._onStart = new(v()), this._onHibernationStateChange = new(v()), this._symbolsResolved = new(v()), this._statusChanged = new(v()), this._restarting = !1, this._paneViews = [], this._legendView = null, this._priceAxisViews = [], this._inputsAnchorsPaneView = null, this._inputsLinesPaneView = null, this._inputsTimeAxisPaneViews = [], this._inputsPriceAxisPaneViews = [], this._resolvedSymbols = {}, this._resolvedSymbolsByInput = {}, this._source = null, this._status = {
						type: ot.StudyStatusType.Undefined
					}, this._wasCompletedBefore = !1, this._studyId = null, this._isSubscribedToSessionId = !1, this._titleStrCache = {}, this._titleInPartsCache = {}, this._children = [], this._numericFormatter = new N.NumericFormatter, this._priceAxisViewsBase = [], this._priceLinesAxisViews = [], this._graphicsPriceAxisViews = [], this._labelPaneViews = [], this._ownFirstValue = null, this._plotOffsets = {}, this._formatter = null, this._ongoingDataUpdate = Promise.resolve(), this._studyModified = !1, this._isDestroyed = !1, this._graphics = new C.LiveStudyGraphics, this._tagsChanged = new(v()), this._studyName = "", this._turnaround = "st0", this._pendingResolveSymbols = new Map, this._onIsActualIntervalChange = new(v()), this._childStudyByRebind = new(v()), this._lastNonEmptyPlotRowCache = {}, this._startMovingPoint = null, this._processHibernateBound = this.processHibernate.bind(this, 1), this._maxOffset = new(ut())(0), this._currencySourceSymbolInfo = null, this._currencySourceSymbolInputProperty = null, this._turnaroundCounter = 0, this._deferredPinePatchProps = !1, this._isChildStudy = !1, this._chartApi = e.chartApi(), this._properties = t, this._metaInfo = s, this._series = this._model.mainSeries(), this._series.onIntervalChanged().subscribe(this, this._calcIsActualInterval), this._showStudyArgumentsProperty = e.properties().childs().paneProperties.childs().legendProperties.childs().showStudyArguments, e.collapsed().subscribe(this._processHibernateBound), i instanceof It && (this._source = i, this._isChildStudy = !0, this._source.setChild(this), P.StudyMetaInfo.setChildStudyMetaInfoPropertiesSourceId(s, null !== (n = i.sourceId()) && void 0 !== n ? n : `#${i.id()}`, t));
					const l = this.parentSource();
					l.currencyChanged().subscribe(this, this._onSourceCurrencyChanged), l.unitChanged().subscribe(this, this._onSourceUnitChanged), l.priceRangeReadyChanged().subscribe(this, this._onSourcePriceRangeReadyChanged), l.formatterChanged().subscribe(this, this._onSourceFormatterChanged), l.priceStepChanged().subscribe(this, this._onSourcePriceStepChanged),
						St && this._model.mainSeries().properties().childs().statusViewStyle.childs().symbolTextSource.listeners().subscribe(this, (() => {
							this.invalidateTitleCache(!0)
						}));
					const h = this._properties.childs();
					for (const e of P.StudyMetaInfo.getSourceInputIds(s)) null === (o = h.inputs.childs()[e]) || void 0 === o || o.subscribe(this, this._onSourceInputChanged);
					this._properties.subscribe(this, this._onPropertiesChanged), h.visible.subscribe(this, this._visibleChanged), h.visible.subscribe(this, (() => this.processHibernate())), h.intervalsVisibilities.subscribe(this, this._calcIsActualInterval), h.inputs.listeners().subscribe(this, this._updateMaxOffsetValue), void 0 !== h.offsets && h.offsets.listeners().subscribe(this, this._updateMaxOffsetValue), void 0 !== h.offset && h.offset.listeners().subscribe(this, this._updateMaxOffsetValue), R.hideAllIndicators().subscribe(this, this._visibleChanged);
					for (let e = 0; e < this._metaInfo.plots.length; e++) {
						const t = this._metaInfo.plots[e].id,
							i = this._properties.childs().styles.childs()[t];
						null == i || i.childs().display.subscribe(this, (() => this.processHibernate()))
					}
					for (const e of Object.keys(this._metaInfo.graphics))
						for (const t of Object.keys(this._metaInfo.graphics[e])) {
							const i = null === (a = h.graphics.childs()[e]) || void 0 === a ? void 0 : a.childs()[t];
							i && i.childs().visible && (0, r.ensureDefined)(i.childs().visible).subscribe(this, (() => this.processHibernate()))
						}
					this._isActualInterval = (0, at.isActualInterval)(this._series.intervalObj(), this._properties.childs().intervalsVisibilities), this._initializeStudyInputsPaneViews(), this._handler = e => this.onData(e), this._handler.isTVScriptStrategy = this._metaInfo.isTVScriptStrategy
				}
				destroy() {
					var e;
					const t = this.parentSource();
					t.currencyChanged().unsubscribeAll(this), t.unitChanged().unsubscribeAll(this), t.priceRangeReadyChanged().unsubscribeAll(this), t.formatterChanged().unsubscribeAll(this), t.priceStepChanged().unsubscribeAll(this), this._series.properties().childs().statusViewStyle.childs().symbolTextSource.unsubscribeAll(this), this._series.onIntervalChanged().unsubscribeAll(this), this.formatterChanged().unsubscribe(this, this.invalidateTitleCache), R.hideAllIndicators().unsubscribe(this, this._visibleChanged), this._model.collapsed().unsubscribe(this._processHibernateBound), null === (e = this._legendView) || void 0 === e || e.destroy()
				}
				properties() {
					return this._properties
				}
				isDraggable() {
					return !this._metaInfo.linkedToSeries
				}
				lastValueData(e, t, i) {
					var s, r;
					const n = {
							noData: !0
						},
						o = this.priceScale();
					if (this._model.timeScale().isEmpty() || null === o || o.isEmpty() || this.data().isEmpty()) return n;
					const a = this._model.timeScale().visibleBarsStrictRange(),
						l = this.firstValue(!0);
					if (null === a || null === l) return n;
					if (!this._properties.childs().visible.value()) return n;
					const h = this._properties.childs().styles,
						d = this._properties.childs().ohlcPlots;
					let u, c;
					if (h && h.childs()[e] && (u = h.childs()[e]), d && d.childs()[e] && (u = d.childs()[e]), !u || 0 === u.childs().display.value()) return n;
					const p = this.metaInfo().plots;
					for (c = 0; c < p.length; c++) {
						const t = p[c];
						if (t.id === e || (0, V.isOhlcClosePlot)(t) && t.target === e) break
					}
					const _ = c + 1,
						f = this.offset(e),
						m = this.nearestIndex(a.lastBar() - f, w.PlotRowSearchMode.NearestLeft, _);
					if (void 0 === m) return n;
					const y = this._lastNonEmptyPlotRow(_),
						v = null !== y && a.contains(y.index),
						g = null !== y ? y.value : null,
						S = t || v ? g : this.data().valueAt(m);
					if (!S || !(0, k.isNumber)(S[_])) return n;
					const b = S[_],
						P = (0, se.createStudyPlotColorProvider)(this.metaInfo(), this.properties(), e).getPlotPointStyle(S).colors[0],
						C = o.priceToCoordinate(b, l),
						x = {
							...o.getFormattedValues(b, l),
							noData: !1,
							color: null != P ? P : null !== (r = null === (s = u.child("color")) || void 0 === s ? void 0 : s.value()) && void 0 !== r ? r : "",
							floatCoordinate: C,
							coordinate: C
						};
					return i && (x.price = b), x
				}
				isFailed() {
					return this._status.type === ot.StudyStatusType.Error
				}
				isLoading() {
					return this._status.type === ot.StudyStatusType.Loading
				}
				isSymbolInvalid() {
					return this._status.type === ot.StudyStatusType.Error && this._status.errorDescription.error === vt
				}
				state(e, t) {
					var i;
					const s = (0, r.ensureNotNull)((0, a.className)(this.constructor)),
						n = this.metaInfo();
					let o;
					n instanceof P.StudyMetaInfo ? o = (0, k.clone)(n.state()) : (o = (0, k.clone)(this.metaInfo()), o.id = P.StudyMetaInfo.parseIdString(o.id + (o.version ? "-" + o.version : "")).fullId);
					const l = {
						type: s,
						id: this.id(),
						state: this.properties().state(),
						zorder: this.zorder(),
						ownFirstValue: this.isVisible() ? null : this._ownFirstValue,
						metaInfo: o
					};
					e && (l.data = this.data().state(), l.data.symbols = this._resolvedSymbols, l.data.graphics = (0, C.saveStudyGraphics)(this.graphics()), l.data.plotOffsets = this._plotOffsets), this.ownerSource() && (l.ownerSource = null === (i = this.ownerSource()) || void 0 === i ? void 0 : i.id());
					for (let e = 0; e < n.inputs.length; e++)
						if ("bar_time" === n.inputs[e].type) {
							const t = n.inputs[e].id,
								i = l.state.inputs[t];
							if (i < 0) {
								const e = this._rightOffsetToUnixTime(-i);
								l.state.inputs[t] = e && e >= 0 ? e : 0
							}
						} var h;
					return this._isChildStudy && P.StudyMetaInfo.patchChildStudyMetaInfoState(l), t && (h = l).metaInfo && h.metaInfo.scriptIdPart && h.metaInfo.scriptIdPart.startsWith("USER;") && (function(e) {
						if (!e.metaInfo) return;
						const t = e.metaInfo.scriptIdPart;
						if (!t) return;
						const i = t.split(";")[0],
							s = e.metaInfo;
						s.id = (s.id || "").replace(t, i), s.fullId = (s.fullId || "").replace(t, i), s.name = (s.name || "").replace(t, i), s.shortId = (s.shortId || "").replace(t, i), s.scriptIdPart = (s.scriptIdPart || "").replace(t, i), e.state && (e.state.id = (e.state.id || "").replace(t, i), e.state.fullId = (e.state.fullId || "").replace(t, i), e.state.name = (e.state.name || "").replace(t, i), e.state.shortId = (e.state.shortId || "").replace(t, i), e.state.scriptIdPart = (e.state.scriptIdPart || "").replace(t, i))
					}(h), function(e) {
						const t = (e.metaInfo && e.metaInfo.inputs || []).find((e => "ILScript" === e.name));
						t && (t.defval = "", e.state && e.state.inputs && (e.state.inputs[t.id] = ""), e.metaInfo.defaults.inputs && (e.metaInfo.defaults.inputs[t.id] = ""))
					}(h)), l
				}
				restoreData(e) {
					var t, i;
					this._invalidateLastNonEmptyPlotRowCache(), this.data().restoreState(e), this._resolvedSymbols = null !== (t = e.symbols) && void 0 !== t ? t : {}, this._graphics = e.graphics ? (0, C.loadStudyGraphics)(e.graphics) : (0, C.emptyStudyGraphics)(), this._postProcessGraphics(), this._plotOffsets = null !== (i = e.plotOffsets) && void 0 !== i ? i : {}, this._setStatus({
						type: ot.StudyStatusType.Completed
					}, !0)
				}
				hasStateForAlert() {
					return Z.enabled("alerts") && !this.isFailed() && (this.metaInfo().isTVScript ? this._hasAlertConditions() || this._hasAvailableAlertPlots() || this._hasAlertFunction() : this._hasAlertablePlots())
				}
				stateForAlert() {
					const e = this.metaInfo(),
						t = this._plotsForAlert(),
						i = this._collectDepsForAlert(),
						s = i.idForAlert,
						n = i.studyDependencies,
						o = i.inputsForAlert,
						a = (this.priceScale() || this.model().mainSeries().priceScale()).formatter(),
						d = a ? u.FormattersSerializer.serialize(a) : null,
						c = {
							id: s,
							uniqueId: s,
							type: (0, r.ensureNotNull)(window.TradingView.className(this.constructor)),
							title: (0, l.clean)(this._title(!1, {}, !1), !0),
							shortTitle: (0, l.clean)(this._title(!0, {}, !1), !0),
							shortDescription: (0, l.clean)(e.shortDescription || "Study", !0),
							fullId: e.fullId,
							isTVScript: Boolean(e.isTVScript),
							isTVScriptStrategy: Boolean(e.isTVScriptStrategy),
							isTVLibrary: Boolean(e.isTVLibrary),
							hasAlertFunction: Boolean(e.hasAlertFunction),
							plots: t,
							inputs: o,
							alerts: e.alerts,
							scriptIdPart: e.scriptIdPart,
							scriptVersion: e.pine ? e.pine.version : "-1",
							callStudyDependencies: (0, h.formatCallstudyArg)(this._dependenciesForAlerts()),
							studyDependencies: n,
							formatter: d
						},
						_ = p(this);
					_ && (c.dangerReason = _);
					const f = e.defaultStrategyAlertMessage;
					return f && (c.defaultStrategyAlertMessage = (0, l.clean)(f, !0)), c
				}
				hasBarColorer() {
					return (0, r.ensureNotNull)(this._metaInfo).plots.some(V.isBarColorerPlot)
				}
				barColorer() {
					const e = this._metaInfo.plots;
					let t = null;
					for (let i = 0; i < e.length; ++i)
						if ((0, V.isBarColorerPlot)(e[i])) {
							const e = new ft.StudyBarColorer(this, i);
							null === t ? t = e : t.pushBackBarColorer(e)
						} return t
				}
				restart(e) {
					this._restarting = !0, this.clearData(), (e || Z.enabled("stop_study_on_restart")) && this.stop(), setTimeout(this.start.bind(this), 0)
				}
				stop(e, t) {
					if (!0 === e && this._children)
						for (const e of this._children) e.stop(!0);
					this._stopStudyOnServer(), this.clearData(), this._unsubscribeToSessionId(), this.recalculate()
				}
				disconnect() {
					this._studyId = null, this._model.isSnapshot() || (this._resolvedSymbols = {}, this._resolvedSymbolsByInput = {})
				}
				sourceId() {
					return this._studyId
				}
				parentSource() {
					return this._source || this._series
				}
				symbolSource() {
					return this.parentSource().symbolSource()
				}
				ownerSource() {
					return this._isChildStudy ? this._source : super.ownerSource()
				}
				source() {
					return this.parentSource()
				}
				isChildStudy() {
					return this._isChildStudy
				}
				hasChildren() {
					return this._children.length > 0
				}
				isStarted() {
					return Boolean(this._studyId)
				}
				isRestarting() {
					return this._restarting
				}
				isActualInterval() {
					return this._isActualInterval
				}
				onIsActualIntervalChange() {
					return this._onIsActualIntervalChange
				}
				isVisible() {
					var e, t, i;
					const s = this._properties.childs();
					if (this._model.collapsed().value() || !s.visible.value() || !this.isActualInterval()) return !1;
					const r = this.metaInfo();
					if (r.plots.length > 0)
						for (let e = 0; e < r.plots.length; e++) {
							const t = r.plots[e].id,
								i = s.styles.childs()[t];
							if (void 0 === i) continue;
							if (0 !== i.childs().display.value()) return !0
						}
					if (r.bands)
						for (let e = 0; e < r.bands.length; e++)
							if (s.bands.childs()[e].childs().visible.value()) return !0;
					for (const n of Object.keys(r.graphics))
						for (const o of Object.keys(r.graphics[n])) {
							const r = null === (e = s.graphics.childs()[n]) || void 0 === e ? void 0 : e.childs()[o];
							if (void 0 !== r && (null === (i = null === (t = r.child("visible")) || void 0 === t ? void 0 : t.value()) || void 0 === i || i)) return !0
						}
					if (r.filledAreas)
						for (let e = 0; e < r.filledAreas.length; e++)
							if (s.filledAreasStyle.childs()[r.filledAreas[e].id].childs().visible.value()) return !0;
					return !(!r.isTVScriptStrategy && !r.hasAlertFunction)
				}
				start(e, t, i) {
					const s = this._model.mainSeries();
					if (!s.isStarted()) return void s.dataEvents().completed().subscribe(this, (() => this.start(e, t)), !0);
					this._isChildStudy && (0, r.ensureNotNull)(this._source).isHibernated() && (0, r.ensureNotNull)(this._source).start();
					const n = !(this.isHibernationAllowed() && !this.isVisible()) || !0 === t;
					this._chartApi && this._chartApi.isConnected().value() && n && this._allSymbolsAreResolved().then((() => this._startAfterSymbolsResolved(e, t))).catch((e => {
						yt.logError("ERROR: " + this._debugId() + " start failed, " + e), this._restarting = !1
					}))
				}
				inputs(e) {
					const t = (0, k.merge)((0, k.clone)(gt), e || {});
					return t.skipOptionalEmptySymbolInputs && (t.keepOptionalSymbolsEmpty = !0), this._buildInputs(t)
				}
				metaInfo() {
					return this._metaInfo
				}
				status() {
					return this._status
				}
				name(e) {
					return e ? this.metaInfo().shortDescription || this._properties.childs().shortDescription && this._properties.childs().shortDescription.value() || "Study" : this.metaInfo().description || this._properties.childs().description && this._properties.childs().description.value() || "Study"
				}
				title(e, t, i, s) {
					i = void 0 === i ? !this._showStudyArgumentsProperty.value() : i;
					const r = JSON.stringify([e, t, i, s]);
					if (this._titleStrCache[r]) return this._titleStrCache[r];
					if (this._titleInPartsCache[r]) return this._joinTitlesParts(this._titleInPartsCache[r]);
					const n = this._title(e, t, i, s);
					return this._titleStrCache[r] = n, n
				}
				titleInParts(e, t, i, s) {
					i = void 0 === i ? !this._showStudyArgumentsProperty.value() : i;
					const r = JSON.stringify([e, t, i, s]);
					if (this._titleInPartsCache[r]) return this._titleInPartsCache[r];
					const n = this._titleInParts(e, t, i, s);
					return this._titleInPartsCache[r] = n, n
				}
				invalidateTitleCache(e) {
					if (this._titleStrCache = {}, this._titleInPartsCache = {}, !0 === e && this._children)
						for (let t = 0; t < this._children.length; ++t) this._children[t].invalidateTitleCache(e)
				}
				graphicsInfo() {
					return this._metaInfo.graphics
				}
				setOwnFirstValue(e) {
					this._ownFirstValue = e
				}
				firstValue(e) {
					if (!this._isChildStudy && "Compare@tv-basicstudies" === this._metaInfo.id || !this._metaInfo.is_price_study) {
						const t = this._model.timeScale().visibleBarsStrictRange();
						if (null === t) return null;
						const i = this.properties().childs();
						if (!i.visible.value() || !this.isActualInterval() || null !== this._startMovingPoint) return this._ownFirstValue;
						const s = t.firstBar(),
							n = t.lastBar();
						let o = function(e) {
							const t = e.model().timeScale();
							if (t.isEmpty()) return null;
							const i = t.visibleBarsStrictRange();
							if (null === i) return null;
							const s = i.firstBar(),
								r = i.lastBar(),
								n = $(e),
								o = new X;
							for (const e of n) {
								const t = e.firstValue(s, r);
								o.improve(t)
							}
							return o.bestPrice()
						}(this);
						const a = this._metaInfo.plots || [];
						if (null === o) {
							const t = new Set,
								l = this._metaInfo.filledAreas || [];
							for (let e = 0; e < l.length; e++) {
								const s = l[e];
								i.filledAreasStyle.childs()[s.id].childs().visible.value() && (t.add(s.objAId), t.add(s.objBId))
							}
							const h = this.data().rangeIterator(s, n);
							for (; h.hasNext();) {
								const s = h.next().value;
								for (let n = 0; n < a.length; ++n) {
									if ((0, V.isColorerPlot)(a[n])) continue;
									const l = s[n + 1];
									if (null == l) continue;
									const h = a[n].id;
									if ((0 !== (0, r.ensureDefined)(i.styles.childs()[h]).childs().display.value() || t.has(h)) && !(e && Math.abs(l) < 1e-10)) {
										o = l;
										break
									}
								}
								if (null !== o) break
							}
						}
						return this._ownFirstValue = o, null !== o ? o : this._bandsFirstValue(e)
					}
					if (this._isChildStudy) {
						const e = this._getNonPriceParent();
						if (e && this.priceScale() === e.priceScale()) return null !== e._ownFirstValue ? e._ownFirstValue : e.firstValue()
					}
					return this._series.firstValue()
				}
				priceRange(e, t) {
					let i = null;
					const s = this._metaInfo,
						n = this._fillPrecalculatedAutoscaleInfo(e, t);
					let o = this.data().minMaxOnRangeCached(e, t, n.fields);
					if (o = (0, w.mergeMinMax)(n.baseValueMinMax, o), n.useMainSeriesRange) {
						const i = [{
								name: "low",
								offset: 0
							}, {
								name: "high",
								offset: 0
							}],
							s = this.series().data().bars().minMaxOnRangeCached(e, t, i);
						o = (0, w.mergeMinMax)(o, s)
					}
					if (null !== o && (i = new b.PriceRange(o.min, o.max)), s.bands)
						for (let e = 0; e < s.bands.length; e++) {
							const t = (0, r.ensureDefined)(this._properties.childs().bands.childs()[e]).childs();
							if (t.visible.value()) {
								const e = t.value.value();
								if (!(0, k.isNumber)(e)) continue;
								i ? i.apply(e, e) : i = new b.PriceRange(e, e)
							}
						} {
							const s = function(e, t, i) {
								const s = $(e);
								let r = null;
								for (const e of s) {
									const s = e.groupPriceRange(t, i);
									null !== s && (r = null === r ? s : r.merge(s))
								}
								return r
							}(this, e, t);
							s && (i = i ? i.merge(s) : s)
						}
					return this._postProcessPriceRange(i)
				}
				autoScaleInfo(e, t) {
					const i = this.priceRange(e, t),
						s = function(e, t, i) {
							const s = {
									topPixelMargin: 0,
									bottomPixelMargin: 0
								},
								r = $(e);
							for (const e of r) {
								const r = e.groupPixelMargins(t, i);
								s.bottomPixelMargin = Math.max(s.bottomPixelMargin, r.bottomPixelMargin), s.topPixelMargin = Math.max(s.topPixelMargin, r.topPixelMargin)
							}
							return s
						}(this, e, t);
					return {
						range: i,
						topPixelMargin: s.topPixelMargin,
						bottomPixelMargin: s.bottomPixelMargin
					}
				}
				formatter() {
					return this._formatter || this.parentSource().formatter(!1)
				}
				updateAllViews(e) {
					var t, i, s, r, n;
					this._paneViews.forEach((t => t.update(e))), this._labelPaneViews.forEach((t => t.update(e))), null === (t = this._dataWindowView) || void 0 === t || t.update(), null === (i = this._legendView) || void 0 === i || i.update(), null === (s = this._statusView) || void 0 === s || s.update(), this._priceAxisViews.forEach((t => t.update(e))), this._priceLinesAxisViews.forEach((t => t.update(e))), null === (r = this._inputsLinesPaneView) || void 0 === r || r.update(e), null === (n = this._inputsAnchorsPaneView) || void 0 === n || n.update(e), this._inputsTimeAxisPaneViews.forEach((t => t.update(e))), this._inputsPriceAxisPaneViews.forEach((t => t.update(e)))
				}
				getStudyName() {
					return this._studyName
				}
				childStudyByRebind() {
					return this._childStudyByRebind
				}
				isPine() {
					return void 0 !== this._metaInfo.pine
				}
				isStandardPine() {
					return this.isPine() && P.StudyMetaInfo.isStandardPine(this._metaInfo.id)
				}
				isLinkedToSeries() {
					return !0 === this._metaInfo.linkedToSeries
				}
				defaultPlotIdForAlert() {
					return this._metaInfo.plots.length ? this._metaInfo.plots[0].id : null
				}
				resolvedSymbolInfoBySymbol(e) {
					return this._resolvedSymbols && e && this._resolvedSymbols[this._getSymbolForResolve(e)] || null
				}
				currency() {
					const e = this.metaInfo();
					return Boolean(e) && e.is_price_study ? this.parentSource().currency() : null
				}
				currencySourceSymbolInfo() {
					var e, t, i;
					return null !== (e = this._currencySourceSymbolInfo) && void 0 !== e ? e : null !== (i = null === (t = this.symbolSource()) || void 0 === t ? void 0 : t.symbolInfo()) && void 0 !== i ? i : null
				}
				unit() {
					const e = this.metaInfo();
					return Boolean(e) && e.is_price_study ? this.parentSource().unit() : null
				}
				dataWindowView() {
					return this._dataWindowView
				}
				statusView() {
					return this._statusView
				}
				legendView() {
					return this._legendView
				}
				inputsForAlertState() {
					return this.inputs()
				}
				sessionId() {
					return this.parentSource().sessionId()
				}
				sessionIdChanged() {
					return this.parentSource().sessionIdChanged()
				}
				getSymbolString(e) {
					return "" === e ? "" : (0, B.encodeExtendedSymbolOrGetSimpleSymbolString)(this._getSymbolObject(e))
				}
				onStatusChanged() {
					return this._statusChanged
				}
				symbolsResolved() {
					return this._symbolsResolved
				}
				onHibernationStateChange() {
					return this._onHibernationStateChange
				}
				valuesProvider() {
					return new T.StudyLegendValuesProvider(this, this.model())
				}
				statusProvider(e) {
					return new D.StudyStatusProvider(this, this._model.properties().childs().scalesProperties.childs().textColor)
				}
				correctScaleMargins(e) {
					if ("Volume" === this.metaInfo().shortId) {
						const t = this.model().paneForSource(this);
						return null !== t && t.isOverlay(this) && t.containsMainSeries() ? {
							top: .75,
							bottom: 0
						} : {
							top: e.top,
							bottom: 0
						}
					}
					return e
				}
				canBeHiddenByGlobalFlag() {
					return !0
				}
				isSourceHidden() {
					return !this.isVisible() || this.canBeHiddenByGlobalFlag() && R.hideAllIndicators().value()
				}
				paneViews(e) {
					if (this.isSourceHidden() || !e.hasPriceDataSource(this)) return null;
					const t = [];
					return !this._startMovingPoint && this._wasCompletedBefore && t.push(...this._paneViews), this._inputsLinesPaneView && (this._startMovingPoint || this._model.selection().isSelected(this)) && t.push(this._inputsLinesPaneView), this._inputsAnchorsPaneView && t.push(this._inputsAnchorsPaneView), t
				}
				labelPaneViews() {
					return this.isSourceHidden() ? null : this._labelPaneViews
				}
				timeAxisViews() {
					return this._model.selection().isSelected(this) ? this._inputsTimeAxisPaneViews : null
				}
				priceAxisViews(e, t) {
					const i = this._properties.childs().oldShowLastValue;
					if (i && !i.value()) return null;
					let s = this._priceAxisViews.slice();
					return this._model.selection().isSelected(this) && (s = s.concat(this._inputsPriceAxisPaneViews)), e.findTargetPriceAxisViews(this, t, s, this._priceLinesAxisViews)
				}
				movable() {
					return null !== this._inputsAnchorsPaneView
				}
				startMoving(e, t, i, s) {
					this._startMovingPoint = e, this.stop()
				}
				move(e, t, i, s) {
					if (void 0 !== e.logical && null !== this._startMovingPoint) {
						if (Array.isArray(t)) {
							const i = t;
							this._updateInputValue(e.logical, i[0]), this._updateInputValue(e.logical, i[1])
						} else this._updateInputValue(e.logical, t);
						this.updateAllViews((0, ht.dataSourceChangeEvent)(this.id()))
					}
				}
				endMoving(e, t) {
					return this._startMovingPoint = null, this.start(), {
						indexesChanged: !1,
						pricesChanged: !1
					}
				}
				clearData() {
					var e;
					this._invalidateLastNonEmptyPlotRowCache(), this.data().clear(),
						this._graphics instanceof C.LiveStudyGraphics && (null === (e = this._graphics) || void 0 === e || e.clear()), this._plotOffsets = {}, this.hasBarColorer() && this._model.mainSeries().invalidateBarStylesCache(), this.updateAllViews((0, ht.dataSourceChangeEvent)(this.id(), void 0, !0))
				}
				convertYCoordinateToPriceForMoving(e, t) {
					const i = this.priceScale();
					if (!t || !i || i.isEmpty()) return null;
					const s = t.firstValue();
					return null === s ? null : i.coordinateToPrice(e, s)
				}
				processHibernate(e) {
					const t = this.isVisible();
					if (!this.isStarted() && t && (this._isChildStudy && (0, r.ensureNotNull)(this._source).processHibernate(), this.start(void 0, void 0, e), this._onHibernationStateChange.fire(!1)), this.isHibernationAllowed() && this.isStarted() && !t) {
						for (const e of this._children) e.processHibernate();
						this.stop(void 0, e), this._onHibernationStateChange.fire(!0)
					}
				}
				isHibernationAllowed() {
					return !this.metaInfo().historyCalculationMayChange && (!this.hasChildren() || !!this._model.collapsed().value() && this._children.every((e => e.isHibernationAllowed())))
				}
				isPlotVisibleAt(e, t) {
					let i;
					const s = this.metaInfo().plots.find((t => t.id === e));
					if (i = void 0 !== s ? (0, V.isOhlcPlot)(s) ? this._properties.childs().ohlcPlots.childs()[s.target] : this._properties.childs().styles.childs()[e] : this._properties.childs().ohlcPlots.childs()[e], void 0 === i) throw new Error(`Study does not contain ${e} plot`);
					const r = i.childs().display.value();
					return null !== r && (r & t) === t
				}
				recalculate() {
					const e = this._model.paneForSource(this);
					this._model.recalculatePane(e, (0, ht.dataSourceChangeEvent)(this.id())), this._model.updateSource(this)
				}
				maxOffset() {
					return this._maxOffset
				}
				onStart() {
					return this._onStart
				}
				isHibernated() {
					return !this.isVisible() && !this.isStarted()
				}
				_incrementTurnaround() {
					this._turnaround = "st" + ++this._turnaroundCounter
				}
				_createStudyOnServer() {
					var e;
					const t = this._getStudyIdWithLatestVersion();
					this._studyId = (0, L.makeNextStudyId)(), this._incrementTurnaround(), this._studyName = t, this._chartApi.createStudy(this._studyId, this._turnaround, this._isChildStudy ? (0, r.ensure)(null === (e = this._source) || void 0 === e ? void 0 : e.sourceId()) : (0, r.ensureNotNull)(this._series.seriesSource().instanceId()), this._studyName, (0, r.ensureDefined)(this._inputs), this._handler, this._isChildStudy);
					for (const e of this._children) P.StudyMetaInfo.setChildStudyMetaInfoPropertiesSourceId(e.metaInfo(), this._studyId, e.properties());
					this._deferredPinePatchProps && this._pinePatchPropsAllowed() && this._pinePatchProps()
				}
				_stopStudyOnServer() {
					this._chartApi && this._chartApi.isConnected().value() && this.isStarted() && (this._chartApi.removeStudy((0, r.ensureNotNull)(this._studyId), this._isChildStudy), this._setStatus({
						type: ot.StudyStatusType.Undefined
					})), this._studyId = null
				}
				_modifyStudyOnServer(e) {
					this._chartApi.modifyStudy((0, r.ensureNotNull)(this._studyId), this._turnaround, e, this._handler)
				}
				_transformData(e) {}
				_updateMaxOffsetValue() {
					let e = -1 / 0;
					for (const t of this._metaInfo.plots) e = Math.max(this.offset(t.id), e);
					this._maxOffset.setValue(e)
				}
				_rightOffsetToUnixTime(e) {
					if (this._series.bars().size() >= e) {
						const t = (0, r.ensureNotNull)(this._series.bars().lastIndex()) - e;
						return (0,
							r.ensureNotNull)(this._series.bars().valueAt(t))[0]
					}
					return null
				}
				_invalidateLastNonEmptyPlotRowCache() {
					this._lastNonEmptyPlotRowCache = {}
				}
				_collectDepsForAlert() {
					const e = [this, ...this._getAllOwnerSources().filter((e => e instanceof It))];
					return (0, _.collectDepsForAlert)(e)
				}
				_allInputsAreValid() {
					for (const e of this._metaInfo.inputs)
						if ("bar_time" === e.type) {
							const t = e.id;
							if (null == this._properties.childs().inputs.childs()[t].value()) return !1
						} return !0
				}
				_startAfterSymbolsResolved(e, t) {
					if (!this.isStarted() || this._restarting) {
						if (this._isChildStudy) {
							const e = (0, r.ensureNotNull)(this._source);
							if (!e.isStarted() || e.isRestarting()) return void e.onStart().subscribe(this, this._startAfterSymbolsResolved, !0)
						}
						if (this._restarting = !1, this._allInputsAreValid() && (this._inputs = this._apiInputs(), this._createStudyOnServer(), this._subscribeToSessionId(), this._onStart.fire(), !0 === e && this._children))
							for (const e of this._children) e.start(!0, t)
					}
				}
				_changeInputsImpl(e, t) {
					const i = this._calcSource();
					let s = !0;
					i !== this.source() ? s = this._rebindToSourceOrRestorePreviousValue(i, e, t) : (this._incrementTurnaround(), this.disablePriceRangeReady(), this._modifyStudyOnServer(e)), this.invalidateTitleCache(), s && (this._studyModified = s)
				}
				createPriceAxisView(e) {
					return new pt.StudyPriceAxisView(this, {
						plotIndex: e
					})
				}
				createPriceLineAxisView(e) {
					return new _t.StudyPriceLineAxisView(this, e)
				}
				_createViews() {
					var e, t, i, s;
					this._priceAxisViewsBase = [], this._priceLinesAxisViews = [], this._paneViews = [], this._labelPaneViews = [];
					const n = new Set,
						o = this.metaInfo(),
						a = Boolean(o.usePlotsZOrder),
						l = new Map,
						h = this._properties.childs();
					if (h.filledAreas && o.filledAreas)
						for (let e = 0; e < o.filledAreas.length; ++e) {
							const t = o.filledAreas[e],
								i = (0, r.ensureDefined)(h.filledAreasStyle.childs()[t.id]),
								s = xt(o, t.id);
							let n;
							if ("plot_plot" === t.type || s ? n = new Ze(this, this.model(), t, i) : "hline_hline" === t.type ? n = new nt(this, t, i) : yt.logWarn("Unsupported filledArea type: " + t.type), void 0 !== n) {
								const e = a ? (0, r.ensureDefined)(t.zorder) : l.size;
								Ct(e, l), l.set(e, {
									paneViews: [n]
								})
							}
						} {
							let s = -1e5;
							for (let h = 0; h < o.plots.length; h++) {
								const d = o.plots[h];
								let u, c, p, _, f;
								if ((0, V.isNonVisualPlot)(d)) continue;
								let m = d.id,
									y = o.styles;
								const v = (0, V.isBgColorerPlot)(d);
								if (v) u = new re(this, this._series, this._model, m);
								else if ((0, V.isShapesPlot)(d)) u = new Pe(this, this._series, this._model, m);
								else if ((0, V.isCharsPlot)(d)) u = new Ae(this, this._series, this._model, m);
								else if ((0, V.isArrowsPlot)(d)) u = new Ee(this, this._series, this._model, m);
								else if ((0, V.isOhlcPlot)(d)) {
									const e = d.target;
									if (n.has(e)) continue;
									if (n.add(e), wt(o, h)) u = new He(this, this._series, this._model, e);
									else {
										if (!Pt(o, h)) {
											yt.logError(`plot ${d.id} looks to be invalid`);
											continue
										}
										u = new ze(this, this._series, this._model, e)
									}
									_ = this.createPriceAxisView(e), p = new Ge.PanePriceAxisView(_, this, this._model), m = e, y = o.ohlcPlots
								} else(0, V.isDataPlot)(d) || (_ = this.createPriceAxisView(m), f = this.createPriceLineAxisView(m), u = new Ye.StudyPlotPaneView(this, this._series, this._model, m), (null === (t = null === (e = this._properties.childs().styles.childs()[m]) || void 0 === e ? void 0 : e.child("trackPrice")) || void 0 === t ? void 0 : t.value()) && (c = new $e(this, m)),
									p = new Ge.PanePriceAxisView(_, this, this._model));
								const g = a ? v ? s++ : (0, r.ensureDefined)(null === (i = null == y ? void 0 : y[m]) || void 0 === i ? void 0 : i.zorder) : l.size;
								Ct(g, l);
								const S = {
									paneViews: void 0 !== u ? [u] : [],
									labelView: p,
									priceAxisView: _,
									priceLineAxisView: f
								};
								void 0 !== c && S.paneViews.push(c), l.set(g, S)
							}
						}(null !== (s = this._metaInfo.bands) && void 0 !== s ? s : []).forEach(((e, t) => {
							const i = h.bands.childs()[t];
							if (i && i.childs().visible.value()) {
								const t = new tt(i, this),
									s = a ? (0, r.ensureDefined)(e.zorder) : l.size;
								Ct(s, l), l.set(s, {
									paneViews: [t]
								})
							}
						})), h.bandsBackground && ((0, r.assert)(!a, "'usePlotsZOrder' flag does not supported"), l.set(l.size, {
							paneViews: [new rt(this)]
						}));
					const d = this._paneViews;
					(0, C.createGraphicsPaneViews)(this, this.model()).then((e => {
						for (let t = 0; t < e.length; t++) d.push(e[t]);
						this._model.lightUpdate()
					})), h.areaBackground && ((0, r.assert)(!a, "'usePlotsZOrder' flag does not supported"), l.set(l.size, {
						paneViews: [new qe.AreaBackgroundPaneView(this, this.model())]
					}));
					const u = Array.from(l.keys()).sort(((e, t) => e - t));
					for (let e = 0; e < u.length; e++) {
						const t = (0, r.ensureDefined)(l.get(u[e]));
						this._paneViews.push(...t.paneViews), t.labelView && this._labelPaneViews.push(t.labelView), t.priceAxisView && this._priceAxisViewsBase.push(t.priceAxisView), t.priceLineAxisView && this._priceLinesAxisViews.push(t.priceLineAxisView)
					}
					this._dataWindowView || (this._dataWindowView = new Qe.StudyDataWindowView(this, this._model)), this._legendView || (this._legendView = new M(this, this._model)), this._statusView || (this._statusView = new A.StudyStatusView(this)), this._concatPriceAxisViews()
				}
				_concatPriceAxisViews() {
					this._priceAxisViews = [...this._priceAxisViewsBase, ...this._graphicsPriceAxisViews]
				}
				onData(e) {
					switch (e.method) {
						case "study_loading":
							this._onStudyLoading();
							break;
						case "study_error":
							this._onStudyError(e.params[2]);
							break;
						case "study_completed":
							if (!this._checkTurnaround(e.params[1])) return;
							this._onStudyCompleted(e.params[e.params.length - 1]);
							break;
						case "data_update":
							if (e.params.customId !== this.sourceId() || !this._checkTurnaround(e.params.turnaround)) return;
							(0, r.assert)(!!e.params.nonseries, "data.params.nonseries is missing"), this._onDataUpdate(e.params.plots, (0, r.ensureDefined)(e.params.nonseries));
							break;
						case "clear_data":
							this._checkTurnaround(e.params.turnaround) && this.clearData()
					}
				}
				_onStudyLoading() {
					var e;
					this._setStatus({
						type: ot.StudyStatusType.Loading,
						startTime: Date.now()
					}), null === (e = this._statusView) || void 0 === e || e.update(), this._model.updateSource(this)
				}
				_getTelemetryObjectName() {
					return "study"
				}
				_handleStudyError(e) {
					var t, i, s;
					this.clearData(), this._setStatus(e); {
						const s = (0, ot.convertStudyStatusToString)(e),
							r = this._getTelemetryAdditionalData(),
							n = s.indexOf("Command info");
						r.reason = n >= 0 ? s.slice(0, n).trim() : s;
						if (!/study in error state|the data vendor doesn\'t provide volume data for this symbol.|error in series|unsupported resolution/gi.test(null !== (i = null === (t = r.reason) || void 0 === t ? void 0 : t.toLowerCase()) && void 0 !== i ? i : "")) {
							const e = this._getTelemetryObjectName();
							this._sendTelemetryCounter(e + "_error", r)
						}
					}
					null === (s = this._statusView) || void 0 === s || s.update(), this._model.updateSource(this)
				}
				_onStudyError(e) {
					const t = "string" == typeof e ? {
						error: this._getStudyErrorText(e)
					} : e;
					this._handleStudyError({
						type: ot.StudyStatusType.Error,
						errorDescription: t
					}), this._enablePriceRangeReady()
				}
				_onStudyCompleted(e) {
					var t;
					this._studyModified && (this.clearData(), this._studyModified = !1), this._sendTelemetryCounter(this._getTelemetryObjectName() + "_loaded"), this._setStatus({
						type: ot.StudyStatusType.Completed
					}), null === (t = this._statusView) || void 0 === t || t.update();
					const i = this._model.paneForSource(this);
					this._model.recalculatePane(i, (0, ht.dataSourceChangeEvent)(this.id())), this._updateSources();
					const s = lt.InvalidationMask.full();
					null !== this._model.appliedTimeFrame().value() && s.lockVisibleTimeRangeOnResize(), this._model.invalidate(s)
				}
				_onDataUpdated(e, t, i, s) {
					if (this.hasBarColorer() && e.length > 0) {
						const t = (0, r.ensureNotNull)(this.barColorer()).firstColoredBar(e[0].index);
						this._model.mainSeries().invalidateBarStylesCache(t)
					}
					null !== t && this._postProcessGraphics();
					const n = this._model.paneForSource(this);
					this._model.recalculatePane(n, (0, ht.dataSourceChangeEvent)(this.id(), null != s ? s : void 0)), this._updateSources()
				}
				_updateSources() {
					this._model.updateSource(this), this.hasBarColorer() && this._model.updateSource(this._model.mainSeries())
				}
				_titleInputs(e, t) {
					return this.inputs(this._titleInputsOptions(e, t))
				}
				_titleInputsOptions(e, t) {
					return {
						symbolsForDisplay: !0,
						skipHiddenInputs: !0,
						skipFakeInputs: !1,
						fakeInputsForDisplay: !0,
						asObject: !1,
						skippedGroups: [],
						noExchanges: e,
						noResolution: t,
						skipColorInputs: !0,
						skipTimeInputs: !0,
						priceInputsForDisplay: !0,
						skipOptionalEmptySymbolInputs: bt
					}
				}
				_postProcessGraphics() {
					this._graphicsPriceAxisViews = this._createGraphicsPriceAxisViews(), this._concatPriceAxisViews()
				}
				_createGraphicsPriceAxisViews() {
					return (0, C.createGraphicsPriceAxisViews)(this)
				}
				_subscribeToSessionId() {
					!this._isSubscribedToSessionId && this.hasSymbolInputs() && (this.sessionIdChanged().subscribe(this, this._onSessionIdChanged), this._isSubscribedToSessionId = !0)
				}
				_unsubscribeToSessionId() {
					this._isSubscribedToSessionId && (this.sessionIdChanged().unsubscribe(this, this._onSessionIdChanged), this._isSubscribedToSessionId = !1)
				}
				_onSessionIdChanged() {
					this.restart(!0)
				}
				_title(e, t, i, s) {
					const r = this._titleInParts(e, t, i, s);
					return this._joinTitlesParts(r)
				}
				_postProcessPriceRange(e) {
					if (e && e.minValue() === e.maxValue() && !this.metaInfo().is_price_study) {
						const t = .005 * e.minValue();
						e = new b.PriceRange(e.minValue() - t, e.maxValue() + t)
					}
					const t = this.priceScale();
					return t && t.isLog() && e ? new b.PriceRange(t.priceToLogical(e.minValue()), t.priceToLogical(e.maxValue())) : e
				}
				_joinTitlesParts(e) {
					const t = e[1] ? e[1].join(", ") : "";
					return e[0] + (t.length > 0 ? " (" + t + ")" : "")
				}
				_titleInParts(e, t, i, s) {
					var o;
					const a = this.name(e);
					t = t || {};
					const l = [(0, n.t)(a, {
						context: "study"
					})];
					let h = [];
					if (!i) {
						const i = this._getMTFResolutionInputTitle();
						null !== i && i.length > 0 && l.push(i);
						const n = this.metaInfo(),
							a = this._titleInputs(s, !0) || [];
						if (a.length > 0) {
							const i = {};
							if (this._isChildStudy)
								for (let t = 0; t < n.inputs.length; ++t) {
									const a = n.inputs[t];
									if (!P.StudyMetaInfo.isSourceInput(a)) continue;
									const l = a.id,
										h = (0,
											r.ensureDefined)(this._properties.childs().inputs.child(l)).value();
									if (h.indexOf("$") >= 0 && this._source) {
										const t = this._source.metaInfo(),
											r = this._source.title(e, {}, !0, s);
										if (1 === t.plots.length) i[h] = r;
										else {
											const e = h.split("$")[1],
												s = null === (o = t.plots[parseInt(e)]) || void 0 === o ? void 0 : o.id,
												n = t.styles && t.styles[s],
												a = n && n.title || s;
											i[h] = r + ":â€‰" + a
										}
									}
									break
								}
							h = a.map((e => {
								let s = (0, k.isNumber)(e) ? this._numericFormatter.format(e) : i && i[e.toString()] || e.toString();
								return t && t[s.toString()] && (s = t[s.toString()]), s
							}))
						}
					}
					return [l.join(" Â· "), h]
				}
				_getMTFResolutionInputTitle() {
					const e = this.metaInfo();
					for (let t = 0; t < e.inputs.length; t++) {
						const i = e.inputs[t];
						if ("resolution" === i.type && i.isMTFResolution) return (0, r.ensureDefined)(this._properties.childs().inputs.child(i.id)).value()
					}
					return null
				}
				_hasAvailableAlertPlots() {
					const e = this.stateForAlert(),
						t = d.alertBandFactory.create(e).getPlots();
					return null != t && t.length > 0
				}
				_hasAlertablePlots() {
					return (this.metaInfo().plots || []).some((e => "line" === e.type))
				}
				_hasAlertConditions() {
					if (this.metaInfo().plots.some(V.isAlertConditionPlot)) return !0;
					const e = this.stateForAlert();
					return Boolean(e.alerts && e.alerts.conditions)
				}
				_hasAlertFunction() {
					const e = this.metaInfo();
					return Boolean(e.hasAlertFunction)
				}
				_onDataUpdate(e, t) {
					this._studyModified && (this.clearData(), this._studyModified = !1);
					const i = (0, g.unpackNonSeriesData)(t.d);
					return this._ongoingDataUpdate = this._ongoingDataUpdate.then((() => i), (() => i)).then(this._onDataUnpacked.bind(this, e, t.indexes)), this._ongoingDataUpdate
				}
				_mergeData(e) {
					var t, i;
					return this._invalidateLastNonEmptyPlotRowCache(), null !== (i = null === (t = this.data().merge(e)) || void 0 === t ? void 0 : t.index) && void 0 !== i ? i : null
				}
				_getSymbolForResolve(e) {
					return this.getSymbolString(this._getSymbolForApi(e))
				}
				_allSymbolsAreResolved() {
					const e = this.metaInfo(),
						t = [];
					let i = !1;
					for (let s = 0; s < e.inputs.length; s++)
						if ("symbol" === e.inputs[s].type) {
							const n = e.inputs[s].id,
								o = (0, r.ensureDefined)(this._properties.childs().inputs.child(n)).value(),
								a = this._getSymbolForResolve(o);
							if ("" !== a)
								if (this._resolvedSymbols[a]) i = !0;
								else {
									const e = this._resolveSymbol(a, o);
									t.push(e)
								}
						} if (0 === t.length) {
						const e = Promise.resolve();
						return i ? e.then((() => this._symbolsResolved.fire())) : e
					}
					return Promise.all(t).catch((e => (this._setStatus({
						type: ot.StudyStatusType.Error,
						errorDescription: {
							error: vt
						}
					}), this.stop(!0), this._model.updateSource(this), Promise.reject("Invalid symbol, " + e)))).then((() => {
						null !== this._studyId && this.stop(!0), this.start(!0), this._symbolsResolved.fire(), this._recheckLineToolsActuality()
					}))
				}
				_getSymbolForApi(e) {
					return e
				}
				_resolveSymbol(e, t) {
					if ("" === e) return Promise.resolve();
					let i = this._pendingResolveSymbols.get(e);
					return void 0 !== i || (i = new Promise(((i, s) => {
						this._onSymbolResolvingStart(), this._chartApi.resolveSymbol((0, L.makeNextSymbolId)(), e, (r => {
							switch (this._pendingResolveSymbols.delete(e), r.method) {
								case "symbol_resolved":
									this._setStatus({
										type: ot.StudyStatusType.Undefined
									}), this._resolvedSymbols[e] = r.params[1], this._resolvedSymbolsByInput[t] = r.params[1], this._onSymbolResolved(e, t, r.params[1]), this.invalidateTitleCache(!0), i();
									break;
								case "symbol_error":
									if (this._setStatus({
											type: ot.StudyStatusType.Error,
											errorDescription: {
												error: r.params[1]
											}
										}), this._onSymbolError(), r.params[1] === O.permissionDenied && r.params[2]) {
										if (r.params[2] !== O.SymbolErrorPermissionDeniedReason.Symbol) return void this._resolveSymbol(r.params[2], t).then(i);
										if (r.params[3]) return void this._resolveSymbol(r.params[3], t).then(i)
									}
									this._sendTelemetryCounter("symbol_error", Object.assign(this._getTelemetryAdditionalData(), {
										symbol: e,
										reason: r.params[1]
									})), s()
							}
						}))
					})), this._pendingResolveSymbols.set(e, i)), i
				}
				_recheckLineToolsActuality() {
					const e = this._model.paneForSource(this);
					null !== e && e.sourcesByGroup().lineSourcesForAllSymbols().forEach((e => {
						e.ownerSource() === this && e.calcIsActualSymbol()
					}))
				}
				_getSymbolObject(e) {
					const t = {
							symbol: e
						},
						i = this.currency();
					return null !== this._currencySourceSymbolInputProperty && this._getSymbolForApi(this._currencySourceSymbolInputProperty.value()) === e && (t["currency-id"] = i), t.session = this.sessionId(), t
				}
				_onSymbolResolved(e, t, i) {
					{
						const e = (0, r.ensureNotNull)(this._model.alertsWatcher());
						e.syncSourceAlertLabels(this);
						const t = this.getAllChildren();
						for (const i of t) e.syncSourceAlertLabels(i)
					}
					this._onCurrencyMayChange()
				}
				_onSymbolResolvingStart() {}
				_onSymbolError() {}
				_setStatus(e, t) {
					var i;
					this._status = e, e.type === ot.StudyStatusType.Completed ? this._wasCompletedBefore = !0 : e.type !== ot.StudyStatusType.Error && e.type !== ot.StudyStatusType.Undefined || (this._wasCompletedBefore = !1), t || (null === (i = this._statusView) || void 0 === i || i.update(), this._model.updateSource(this), this._statusChanged.fire(e))
				}
				_onPropertiesChanged() {
					this._restarting || (this._inputs ? this._tryChangeInputs() : this._chartApi && this._chartApi.isConnected().value() && this.restart()), this._metaInfo.isTVScript && this._metaInfo.TVScriptMetaInfoExprs && (this._pinePatchPropsAllowed() ? this._pinePatchProps() : this._deferredPinePatchProps = !0), this._recreatePaneViews(), (0, mt.emit)("study_properties_changed", this._id)
				}
				_bandsFirstValue(e) {
					const t = this._metaInfo;
					if (!t.bands) return null;
					for (let i = 0; i < t.bands.length; i++) {
						const t = (0, r.ensureDefined)(this._properties.childs().bands).childs()[i];
						if (t.childs().visible.value()) {
							const i = t.childs().value.value();
							if (e && 0 === i) continue;
							return i
						}
					}
					return null
				}
				_prepareInputs(e) {
					(0, r.assert)(!!e, "options not set");
					const t = this.metaInfo(),
						i = {},
						s = e.allowedInputTypes ? new Set(e.allowedInputTypes) : null;
					for (let r = 0; r < t.inputs.length; r++) {
						const n = t.inputs[r];
						if (null !== s && !s.has(n.type)) continue;
						if (n.isFake && e.skipFakeInputs) continue;
						if (n.isMTFResolution && e.noResolution) continue;
						if (e.skipHiddenInputs) {
							let t = !1;
							switch (n.type) {
								case "bool":
									t = e.skipBooleanInputs;
									break;
								case "color":
									t = e.skipColorInputs;
									break;
								case "time":
									t = e.skipTimeInputs;
									break;
								case "text_area":
									t = e.skipTextareaInputs;
									break;
								default:
									t = Boolean(n.isHidden)
							}
							if (t) continue
						}
						if (void 0 !== n.groupId && -1 !== e.skippedGroups.indexOf(n.groupId)) continue;
						if (-1 !== e.skippedInputs.indexOf(n.id)) continue;
						const o = this._prepareInput(n, e);
						"symbol" === n.type && e.skipOptionalEmptySymbolInputs && "" === o || (i[n.id] = (0, k.clone)(o))
					}
					return i
				}
				_getAllOwnerSources() {
					const e = [];
					let t = this.ownerSource();
					for (; null !== t;) e.push(t), t = t.ownerSource();
					return e
				}
				_getStudyIdWithLatestVersion() {
					return P.StudyMetaInfo.getStudyIdWithLatestVersion(this.metaInfo())
				}
				_lastNonEmptyPlotRow(e) {
					var t;
					if (!(0, k.isInteger)(e)) return yt.logDebug("_lastNonEmptyPlotRow: incorrect plotIndex"), null;
					let i = null !== (t = this._lastNonEmptyPlotRowCache[e]) && void 0 !== t ? t : null;
					if (null !== i) return i;
					return i = this.data().findLast(((t, i) => void 0 !== i[e]), 1e3), null === i ? null : (this._lastNonEmptyPlotRowCache[e] = i, i)
				}
				_onCurrencyChanged() {
					"alwaysOff" !== (0, ct.currencyUnitVisibilityProperty)().value() && this._model.fullUpdate(), this.isStarted() && this._tryChangeInputs(), this._currencyChanged.fire()
				}
				_apiInputs() {
					return this.inputs({
						keepOptionalSymbolsEmpty: !0
					})
				}
				_tryChangeInputs() {
					const e = this.isStarted() && this._chartApi.isConnected().value();
					if (e && this._allInputsAreValid()) this._allSymbolsAreResolved().then((() => {
						const e = this._apiInputs(),
							t = JSON.stringify(e) !== JSON.stringify(this._inputs);
						this._isStopped() ? t && this.disablePriceRangeReady() : t && (this._changeInputsImpl(e, (0, r.ensureDefined)((0, k.clone)(this._inputs))), this._inputs = e, (0, r.ensureNotNull)(this.model().alertsWatcher()).syncSourceAlertLabels(this))
					})).catch((e => {
						yt.logError("ERROR: " + this._debugId() + " _tryChangeInputs: cannot modify study, " + e)
					}));
					else {
						e && this.stop(!0);
						const t = this._apiInputs(),
							i = (0, r.ensureDefined)((0, k.clone)(this._inputs));
						if (JSON.stringify(t) !== JSON.stringify(this._inputs)) {
							const e = this._calcSource();
							e !== this.source() && (this._rebindToSourceOrRestorePreviousValue(e, t, i), this._inputs = t)
						}
					}
					this._tagsChanged.fire()
				}
				_debugId() {
					const e = [];
					return this._studyId && e.push(this._studyId), e.push(this._metaInfo.fullId), e.push(this._metaInfo.description), JSON.stringify({
						study: e
					})
				}
				_calcSource() {
					const e = this._properties.childs().inputs.state(),
						t = P.StudyMetaInfo.getSourceIdByInputs(this._metaInfo.inputs, e);
					if (t) {
						if ("high" === t || "open" === t || "low" === t || "close" === t || "hl2" === t || "ohl3" === t || "ohlc4" === t) return this._model.mainSeries(); {
							const e = t.startsWith("#") ? t.slice(1) : null,
								i = this._model.priceDataSources().find((i => i instanceof It && i.canHaveChildren() && (i.sourceId() === t || i.id() === e)));
							if (void 0 !== i) return i
						}
					}
					return this.source()
				}
				_isStopped() {
					return !this.isStarted()
				}
				_onDataUnpacked(e, t, i) {
					if (this._isDestroyed) return;
					"nochange" !== t && this._processPlotOffsets(i), this._transformData(e);
					const s = this._mergeData(e);
					null !== i && (i.indexes_replace ? ((0, r.assert)("nochange" !== t), this._graphics.replaceIndexesTo(t)) : ("nochange" !== t && this._graphics.replaceIndexesTo(t), void 0 !== i.graphicsCmds && this._graphics.processCommands(i.graphicsCmds, this._metaInfo.graphics))), this._onDataUpdated(e, i, t, s), this.priceRangeReady() || this._enablePriceRangeReady()
				}
				_processPlotOffsets(e) {
					if (e && e.indexes_replace) return;
					const t = this._plotOffsets;
					this._plotOffsets = e && e.offsets || {}, (0, s.default)(t, this._plotOffsets) || this.updateAllViews((0, ht.dataSourceChangeEvent)(this.id(), void 0, !0)), this._updateMaxOffsetValue()
				}
				_applyPlotToPrecalculatedAutoscaleInfo(e, t, i, s) {
					var n;
					const o = s.id,
						a = this._properties.childs().styles.childs()[o],
						l = (0,
							V.isShapesPlot)(s) || (0, V.isCharsPlot)(s);
					i.useMainSeriesRange = i.useMainSeriesRange || (0, V.isArrowsPlot)(s);
					let h = (0, V.isLinePlot)(s) || (0, V.isOhlcPlot)(s);
					if (l) {
						const e = (0, r.ensureDefined)(a).childs().location.value(),
							t = [x.MarkLocation.Absolute, x.MarkLocation.Top, x.MarkLocation.Bottom].indexOf(e) < 0;
						i.useMainSeriesRange = i.useMainSeriesRange || l && t, h = h || e === x.MarkLocation.Absolute
					}
					if (!h) return i;
					const d = {
							name: o,
							offset: this.offset(o)
						},
						u = a,
						c = u.childs().plottype.value();
					if (!this._properties.childs().skipHistogramBaseOnAutoScale && [V.LineStudyPlotStyle.Histogram, V.LineStudyPlotStyle.Columns, V.LineStudyPlotStyle.Area].indexOf(c) >= 0) {
						const s = null === (n = u.childs().histogramBase) || void 0 === n ? void 0 : n.value(),
							r = this.data().minMaxOnRangeCached(e, t, [d]);
						return (0, k.isNumber)(s) && null !== r && (i.baseValueMinMax = (0, w.mergeMinMax)(i.baseValueMinMax, {
							min: s,
							max: s
						}), i.baseValueMinMax = (0, w.mergeMinMax)(i.baseValueMinMax, r)), i
					}
					return i.fields.push(d), i
				}
				_fillPrecalculatedAutoscaleInfo(e, t) {
					const i = this._metaInfo,
						s = this.properties().childs(),
						r = new Set,
						n = this._metaInfo.filledAreas || [];
					for (let e = 0; e < n.length; e++) {
						const t = n[e];
						s.filledAreasStyle.childs()[t.id].childs().visible.value() && (r.add(t.objAId), r.add(t.objBId))
					}
					return i.plots.filter((e => !(0, V.isPlotWithTechnicalValues)(e))).filter((e => r.has(e.id) || this.isPlotVisibleAt(e.id, 1))).reduce(((i, s) => this._applyPlotToPrecalculatedAutoscaleInfo(e, t, i, s)), {
						fields: [],
						useMainSeriesRange: !1,
						baseValueMinMax: null
					})
				}
				_onSourceInputChanged() {
					if (!this.isStarted()) {
						const e = this._calcSource();
						e !== this.source() && this._rebindToSource(e, this._apiInputs())
					}
				}
				_rebindToSourceOrRestorePreviousValue(e, t, i) {
					let s = !0;
					if (!this._rebindToSource(e, t)) {
						const e = this._properties.childs().inputs.state(),
							n = P.StudyMetaInfo.getSourceIdByInputs(this._metaInfo.inputs, e);
						for (const e in i)
							if (i.hasOwnProperty(e) && i[e] !== t[e] && null !== n && (0, k.isString)(t[e]) && 0 === t[e].indexOf(n)) {
								const t = (0, r.ensureDefined)(this._properties.childs().inputs.child(e)),
									n = i[e];
								t.setValue(n), s = !1;
								break
							}
					}
					return s
				}
				_rebindToSource(e, t) {
					const i = this.isStarted() && this._chartApi.isConnected().value(),
						s = this.parentSource();
					let n;
					if (this._isChildStudy) {
						let s;
						(0, r.ensureNotNull)(this._source).unsetChild(this);
						let o = null;
						if (e === this._model.mainSeries()) this._source = null, this._isChildStudy = !1, this._ownerSource = null, s = this._series.seriesSource().instanceId(), o = 2;
						else {
							if (!(e instanceof It)) return yt.logError("Unable to rebind study to source of this type"), !1;
							this._ownerSource = e, this._source = e, s = this._source.sourceId(), e.setChild(this), null === s && (n = e)
						}
						i && null !== s && (this._incrementTurnaround(), this.disablePriceRangeReady(), this._chartApi.rebindStudy((0, r.ensureNotNull)(this._studyId), this._turnaround, s, this._studyName, t, this._handler, o))
					} else {
						if (!(e instanceof It)) return yt.logError("Unable to rebind study to source of this type"), !1;
						if (i) {
							if (!this._chartApi.isCanCreateStudy(!0)) return (0, m.createGoProDialog)({
								feature: "studyOnStudy"
							}), !1;
							const i = e.sourceId();
							if (null !== i) {
								this._incrementTurnaround(), this.disablePriceRangeReady();
								const e = this._chartApi.rebindStudy((0,
									r.ensureNotNull)(this._studyId), this._turnaround, i, this._studyName, t, this._handler, 1);
								(0, r.assert)(e)
							} else n = e
						}
						this._isChildStudy = !0, this._ownerSource = e, this._source = e, e.setChild(this), this._childStudyByRebind.fire()
					}
					n && (this.isStarted() && this.stop(), n.start(!0)), s instanceof It && s.processHibernate();
					const o = this.m_priceScale,
						a = (0, r.ensureNotNull)(e.priceScale());
					if (o !== a) {
						const t = this._model.paneForSource(this),
							i = (0, r.ensureNotNull)(this._model.paneForSource(e));
						t === i && i.move(this, a, !0)
					}
					const l = this.parentSource();
					return s.formatterChanged().unsubscribe(this, this._onSourceFormatterChanged), l.formatterChanged().subscribe(this, this._onSourceFormatterChanged), s.priceStepChanged().unsubscribe(this, this._onSourcePriceStepChanged), l.priceStepChanged().subscribe(this, this._onSourcePriceStepChanged), s.currencyChanged().unsubscribeAll(this), l.currencyChanged().subscribe(this, this._onSourceCurrencyChanged), s.unitChanged().unsubscribeAll(this), l.unitChanged().subscribe(this, this._onSourceUnitChanged), s.priceRangeReadyChanged().unsubscribeAll(this), l.priceRangeReadyChanged().subscribe(this, this._onSourcePriceRangeReadyChanged), this._recreatePriceFormattingDependencies(), !0
				}
				_buildInputs(e) {
					(0, r.assert)(!!e, "options not set");
					let t = {};
					try {
						t = this._prepareInputs(e)
					} catch (e) {
						yt.logWarn("Failed to prepare study inputs: " + e)
					}
					if (e.asObject) {
						const e = {};
						return Object.keys(t).forEach((i => {
							null != t[i] && (e[i] = t[i])
						})), e
					} {
						const e = [];
						return Object.keys(t).forEach((i => {
							null != t[i] && e.push(t[i])
						})), e
					}
				}
				_prepareInput(e, t) {
					const i = this._prepareInputValue(e, t);
					return !e.isFake || t.fakeInputsForDisplay || t.onlyAtomValues ? i : {
						v: i,
						f: !0,
						t: e.type
					}
				}
				_plotsForAlert() {
					return (0, _.plotsForAlert)(this.metaInfo(), this.offset.bind(this))
				}
				_dependenciesForAlerts() {
					const e = this._getAllOwnerSources().filter((e => e instanceof It));
					return (0, _.dependenciesForAlerts)(e, this._model.studyMetaInfoRepository())
				}
				_calcIsActualInterval() {
					const e = this._isActualInterval;
					this._isActualInterval = (0, at.isActualInterval)(this._series.intervalObj(), this._properties.childs().intervalsVisibilities), e !== this._isActualInterval && (this._onIsActualIntervalChange.fire(), this._visibleChanged(), this.processHibernate())
				}
				_visibleChanged() {
					this._series.invalidateBarColorerCache()
				}
				_getNonPriceParent() {
					const e = this.source();
					if (e instanceof It) {
						const t = e.metaInfo();
						return t.is_price_study && "Compare@tv-basicstudies" !== t.id ? e._getNonPriceParent() : e
					}
					return null
				}
				_updateInputValue(e, t) {
					const i = this._properties.childs().inputs.childs();
					if (i[t.id])
						if ("price" === t.type) i[t.id].setValue(e.price);
						else if ("time" === t.type) {
						const s = this._model.timeScale().indexToTimePoint(e.index);
						null !== s && i[t.id].setValue(1e3 * s)
					}
				}
				_initializeStudyInputsPaneViews() {
					const e = (0, J.editableStudyInputs)(this._metaInfo.inputs);
					if (0 === e.length) return;
					const t = {
						convertPriceToCoordinate: e => {
							const t = this.priceScale();
							if (null !== t && !t.isEmpty()) {
								const i = this.firstValue();
								if (null !== i) return t.priceToCoordinate(e, i)
							}
							return null
						},
						formatPrice: e => {
							const t = this.priceScale();
							if (null !== t && !t.isEmpty()) {
								const i = this.firstValue();
								if (null !== i) return t.formatPrice(e, i)
							}
							return ""
						},
						getInputValue: e => {
							var t, i;
							return null !== (i = null === (t = this._properties.childs().inputs.child(e)) || void 0 === t ? void 0 : t.value()) && void 0 !== i ? i : null
						},
						isSelected: () => this._model.selection().isSelected(this),
						isHovered: () => this === this._model.hoveredSource()
					};
					Promise.all([i.e(62183).then(i.bind(i, 568031)), i.e(62183).then(i.bind(i, 905355)), i.e(62183).then(i.bind(i, 76248)), i.e(62183).then(i.bind(i, 650693))]).then((i => {
						const [s, r, n, o] = i;
						this._inputsAnchorsPaneView = new s.StudyInputsAnchorsPaneView(e, this._model, t);
						const a = e.filter((e => !Array.isArray(e)));
						this._inputsLinesPaneView = new r.StudyInputsLinesPaneView(a, this._model, t);
						let l = !1;
						e.forEach((e => {
							if (Array.isArray(e)) {
								const i = "time" === e[0].type ? e[0] : e[1],
									s = "price" === e[0].type ? e[0] : e[1];
								this._inputsTimeAxisPaneViews.push(new n.StudyInputTimeAxisPaneView(i, this._model, t.getInputValue)), this._inputsPriceAxisPaneViews.push(new o.StudyInputPriceAxisPaneView(s, t)), l = !0
							} else "time" === e.type ? this._inputsTimeAxisPaneViews.push(new n.StudyInputTimeAxisPaneView(e, this._model, t.getInputValue)) : (this._inputsPriceAxisPaneViews.push(new o.StudyInputPriceAxisPaneView(e, t)), l = !0)
						})), l && this.formatterChanged().subscribe(this, this.invalidateTitleCache)
					}))
				}
				_updateCurrencySourceSymbolInfo() {}
				_initializeCurrencySource() {
					var e;
					const t = this.metaInfo(),
						i = "symbolInputTargetCurrency" === (null === (e = t.targetCurrency) || void 0 === e ? void 0 : e.type) && t.targetCurrency.inputId,
						s = t.inputs.find((e => e.id === i)),
						r = "symbol" === (null == s ? void 0 : s.type);
					if ("string" == typeof i && r && t.is_price_study) {
						const e = this._properties.childs().inputs.childs()[i];
						void 0 !== e && (e.subscribe(this, this._onCurrencyMayChange), this._currencySourceSymbolInputProperty = e)
					}
				}
				_onCurrencyMayChange() {
					if (null !== this._currencySourceSymbolInputProperty) {
						const e = this.currency();
						this._updateCurrencySourceSymbolInfo(), e !== this.currency() && this._onCurrencyChanged()
					}
				}
				_recreatePaneViews() {
					this.hasBarColorer() && this._model.mainSeries().invalidateBarStylesCache(), this._createViews(), this.recalculate(), this.updateAllViews((0, ht.dataSourceChangeEvent)(this.id()))
				}
				_pinePatchPropsAllowed() {
					return (this.isStarted() || this._metaInfo.inputs.some((e => "symbol" === e.type))) && !this._restarting
				}
				_pinePatchProps() {
					this._deferredPinePatchProps = !1;
					const e = this._prepareInputs({
						fakeInputsForDisplay: !1,
						symbolsForDisplay: !1,
						symbolsForChartApi: !0,
						skipHiddenInputs: !0,
						skipFakeInputs: !1,
						onlyAtomValues: !0,
						skipBooleanInputs: !1,
						skipColorInputs: !1,
						skipTimeInputs: !1,
						skipOptionalEmptySymbolInputs: !1,
						skippedGroups: [],
						skippedInputs: [],
						noExchanges: !1,
						noResolution: !1,
						keepOptionalSymbolsEmpty: !1,
						skipTextareaInputs: !1,
						priceInputsForDisplay: !1
					});
					if (!this._areStudyInputsModified(e)) return;
					this._oldStudyInputs = e;
					const t = (0, f.patchPropertiesAsync)(this._properties, this._metaInfo, e),
						i = this._allSymbolsAreResolved();
					Promise.all([t, i]).then((() => {
						this._createViews(), this.recalculate(), this.updateAllViews((0, ht.dataSourceChangeEvent)(this.id())), this.invalidateTitleCache()
					})).catch((e => {
						yt.logError(`ERROR: ${this._debugId()} pine inputs patching failed, reason: ${e}`)
					}))
				}
				_areStudyInputsModified(e) {
					if (0 === Object.keys(e).length) return !1;
					if (void 0 === this._oldStudyInputs) return !0;
					const t = Object.keys(this._oldStudyInputs);
					(0, r.assert)(t.length === Object.keys(e).length, "keys quantity should be equal");
					for (const i of t)
						if ((0, r.assert)(e.hasOwnProperty(i), `key '${i}' should exist in study inputs`), (0, r.ensureDefined)(this._oldStudyInputs)[i] !== e[i]) return !0;
					return !1
				}
				_getStudyErrorText(e) {
					var t;
					switch (null === (t = e.match(/^study_not_auth:(.*)?@.*/)) || void 0 === t ? void 0 : t[1]) {
						case "Script":
						case "StrategyScript":
							return "This script is invite-only. To request access, please contact its author.";
						case "VbPSessions":
						case "VbPPeriodic":
						case "VbPVisible":
							return "Volume Profile indicator available only on our upgraded plans."
					}
					return e.split(":", 2)[0]
				}
			}
		},
		285339: (e, t, i) => {
			i.d(t, {
				StudyPriceAxisView: () => r
			});
			var s = i(498424);
			class r extends s.PriceAxisView {
				constructor(e, t) {
					super(), this._model = e.model(), this._source = e, this._data = t
				}
				_updateRendererData(e, t, i) {
					e.visible = !1, t.visible = !1;
					const s = this._source.model(),
						r = this._source.priceScale();
					if (null === r) return;
					if (!s.isPriceScaleVisible(r)) return;
					const n = this._source.lastValueData(this._data.plotIndex, !1);
					if (n.noData) return;
					i.background = n.color;
					let o = n.color;
					"transparent" === o && (o = this._model.properties().childs().scalesProperties.childs().backgroundColor.value()), i.textColor = this.generateTextColor(o), i.coordinate = n.coordinate, i.floatCoordinate = n.floatCoordinate, this._showAxisLabel() && (e.text = n.text, e.visible = !0), this._updatePaneRendererData(t)
				}
				_showPaneLabel() {
					const e = this._model.properties().childs().scalesProperties.childs();
					return (e.showStudyPlotLabels.value() || e.showFundamentalNameLabel.value()) && this._source.properties().childs().showLabelsOnPriceScale.value() && this._source.isPlotVisibleAt(this._data.plotIndex, 4)
				}
				_showAxisLabel() {
					const e = this._model.properties().childs().scalesProperties.childs();
					return (e.showStudyLastValue.value() || e.showFundamentalLastValue.value()) && this._source.properties().childs().showLabelsOnPriceScale.value() && this._source.isPlotVisibleAt(this._data.plotIndex, 4)
				}
				_updatePaneRendererData(e) {
					e.text = "", this._showPaneLabel() && (e.text = this._source.priceLabelText(this._data.plotIndex), e.visible = !0)
				}
			}
		},
		448874: (e, t, i) => {
			var s = i(232567),
				r = i(97639),
				n = i(588537).assert,
				o = i(749473).symbolTitle,
				a = i(289627).StudyBarColorer,
				l = i(761850).ChartApiInterface,
				h = i(175203).telemetry,
				d = i(346090).DefaultProperty,
				u = i(689765).PriceFormatter,
				c = i(591419).VolumeFormatter,
				p = i(965513).PercentageFormatter,
				_ = i(752280).PlotList,
				f = i(970028).StudyMetaInfo,
				m = i(251954),
				y = i(418458),
				v = y.LineStudyPlotStyle,
				g = y.STUDYPLOTDISPLAYTARGET,
				S = i(523083).studyPlotFunctionMap,
				b = i(523083).studyEmptyPlotValuePredicate,
				w = i(611688),
				P = i(107555).StudyBase,
				C = i(52500).IntervalsVisibilitiesProperty,
				x = i(721386).colorToInteger,
				I = i(194543).intervalsVisibilitiesDefaults,
				T = i(911905).getLogger("Chart.Study"),
				V = w.enabled("datasource_copypaste"),
				M = w.enabled("study_symbol_ticker_description"),
				R = w.enabled("hide_unresolved_symbols_in_legend");

			function A(e, t, i) {
				var s = new d(t, i, !0);
				s.removeProperty("intervalsVisibilities"), s.addChild("intervalsVisibilities", new C(i && i.intervalsVisibilities)), s.addExclusion("visible"), s.addExclusion("precision"), s.addExclusion("minTick"), s.addExclusion("intervalsVisibilities");
				for (var r = 0; r < e.inputs.length; ++r) {
					var n = e.inputs[r];
					n.isHidden && (s.addExclusion("inputs." + r.toString()), s.addExclusion("inputs." + n.id))
				}
				return "PivotPointsStandard@tv-basicstudies" !== e.id && "PivotPointsHighLow@tv-basicstudies" !== e.id || !s.hasChild("font") || s.removeProperty("font"), s
			}

			function B(e, t) {
				if (t.plots)
					for (var i = 0; i < t.plots.length; i++) {
						var s = t.plots[i],
							r = s.id;
						if (!y.isColorerPlot(s)) {
							var n = {
								display: g.All,
								color: "#0496FF",
								linestyle: CanvasEx.LINESTYLE_SOLID,
								linewidth: 2,
								plottype: v.Line,
								histogramBase: 0,
								transparency: 50,
								trackPrice: !1,
								joinPoints: !1
							};
							y.isBarColorerPlot(s) && (n.transparency = 0), n.plottype = s.type, n.title = r, e.styles && r in e.styles && TradingView.merge(n, e.styles[r]), e.styles[r] = n
						}
					}
			}

			function L(e, t) {
				return e && e[t] && e[t].hasOwnProperty("showLast") ? e[t].showLast.value() : null
			}
			class O extends P {
				constructor(e, t, i, s) {
					super(e, t, i, s), this._resolvedSymbols = {}, this._chartApi = e._chartApi, this._plotFields = [];
					var n = this.metaInfo().plots;
					if (n)
						for (var o = 0, a = n.length; o < a; o++) {
							var l = n[o].id;
							this._plotFields.push(l)
						}
					this._invalidateLastNonEmptyPlotRowCache(), this.m_data = new _(S(this._metaInfo), b), this._plotOffsetsMetaInfoOverride = {}, this._createViews(), this._recreatePriceFormattingDependencies(), this._properties.precision.listeners().subscribe(this, this._precisionChanged), this._showStudyArgumentsProperty.listeners().subscribe(this, this.invalidateTitleCache), this._properties.description.listeners().subscribe(this, this.invalidateTitleCache), this._properties.inputs.listeners().subscribe(this, this.invalidateTitleCache), this._properties.shortDescription && this._properties.shortDescription.listeners().subscribe(this, this.invalidateTitleCache), w.enabled("update_study_formatter_on_symbol_resolve") && e.mainSeries().dataEvents().symbolResolved().subscribe(this, this._recreatePriceFormattingDependencies), e.mainSeries().dataEvents().symbolResolved().subscribe(this, this.invalidateTitleCache);
					var h = this,
						d = {};
					this._simplePlotsCount = s.plots.filter((function(e, t) {
						if (y.isLinePlot(e)) return !0;
						if (y.isOhlcPlot(e)) {
							var i = h.metaInfo().plots[t].target;
							return !d[i] && (d[i] = i, !0)
						}
						return !1
					})).length, this.hasBarColorer() && this._properties.visible.listeners().subscribe(e.mainSeries(), e.mainSeries().invalidateBarStylesCache), this._formatterChanged = new r, this._priceStepChanged = new r, this._aboutToBeDestroyed = new r, this._definitionsViewModel = null, this._updateMaxOffsetValue()
				}
				series() {
					return this._series
				}
				model() {
					return this._model
				}
				onTagsChanged() {
					return this._tagsChanged
				}
				idForAlert() {
					return this._collectDepsForAlert().idForAlert
				}
				alertCreationAvailable() {
					return !this.metaInfo().isTVLibrary && super.alertCreationAvailable()
				}
				isSavedInStudyTemplates() {
					for (var e = 0; e < this._metaInfo.inputs.length; e++)
						if ("bar_time" === this._metaInfo.inputs[e].type) return !1;
					return !0
				}
				setChild(e) {
					e instanceof O && e.source() === this && (this._children || (this._children = []), -1 === this._children.indexOf(e) && this._children.push(e))
				}
				unsetChild(e) {
					if (e instanceof O && e.source() === this && this._children) {
						var t = this._children.indexOf(e);
						~t && this._children.splice(t, 1)
					}
				}
				getAllChildren() {
					if (!Array.isArray(this._children)) return [];
					for (var e = this._children.slice(), t = 0; t < e.length; ++t)
						for (var i = e[t].getAllChildren(), s = 0; s < i.length; ++s) ~e.indexOf(i[s]) || e.push(i[s]);
					return e
				}
				inputsForAlert() {
					var e = this.offset(),
						t = this.inputs();
					return e && t.push(e), t
				}
				_prepareInputValue(e, t) {
					var i = e.id;
					if (t.valuesAsIsFromProperties) return this._properties.inputs[i].value();
					if ("symbol" === e.type) {
						var s = t && t.symbolsForDisplay,
							r = this._properties.inputs[i].value(),
							n = s ? r : this._getSymbolForApi(r),
							a = this._resolvedSymbols && this._resolvedSymbols[this._getSymbolForResolve(n)];
						if ("" === n && e.optional) {
							if (t && t.keepOptionalSymbolsEmpty) return n;
							n = this._model.mainSeries().symbol(), a = this._model.mainSeries().symbolInfo()
						}
						if (s)
							if (a)
								if (M) {
									switch (this._model.mainSeries().symbolTextSourceProxyProperty().value()) {
										case "description":
											n = a.description;
											break;
										case "ticker-and-description":
											n = `${a.name}, ${a.description}`;
											break;
										case "ticker":
											n = a.name
									}
								} else n = o(a, t.noExchanges);
						else R && (n = "");
						else a && (n = a.ticker || a.full_name), !this.isPine() && t && t.symbolsForChartApi && (n = this.getSymbolString(n));
						return n
					}
					if ("bar_time" === e.type) {
						var l = this._properties.inputs[i].value();
						if (l < 0) {
							var h = this._rightOffsetToUnixTime(-l);
							l = h && h >= 0 ? h : l
						}
						return l
					}
					if (this._metaInfo.isTVScript || this._metaInfo.pine) {
						if ("text" === i) return this._metaInfo.defaults.inputs.text;
						if ("pineId" === i) return this._metaInfo.scriptIdPart;
						if ("pineVersion" === i) return this._metaInfo.pine ? this._metaInfo.pine.version : "-1";
						if ("color" === e.type && this._metaInfo.isRGB) {
							var d = this._properties.inputs[i].value();
							return x(d)
						}
						if ("price" === e.type) {
							var u = this._properties.inputs[i].value();
							return t.priceInputsForDisplay ? this.formatter().format(u) : u
						}
						return this._properties.inputs[i].value()
					}
					return this._properties.inputs[i].value()
				}
				priceLabelText(e) {
					var t, i = this._metaInfo.styles,
						s = this._metaInfo.ohlcPlots;
					i && i[e] && (t = i[e]), s && s[e] && (t = s[e]);
					var r = t.title;
					return 1 !== this._simplePlotsCount || y.isPlotTitleDefined(r) ? this._metaInfo.is_price_study && r !== this._metaInfo.shortDescription ? "" === r ? this._metaInfo.shortDescription : this._metaInfo.shortDescription + ":" + r : r : this._metaInfo.shortDescription
				}
				data() {
					return this.m_data
				}
				graphics() {
					return this._graphics
				}
				turnaround(e) {
					var t = this.source();
					return !0 === e ? (t === this._series ? t.seriesSource().turnaround() : t.turnaround(!0)) + "_" + this._turnaround : this._turnaround
				}
				_checkTurnaround(e) {
					return e === this._turnaround || e === this._model.mainSeries().seriesSource().turnaround() || e === this.turnaround(!0)
				}
				moveData(e) {
					this._ongoingDataUpdate = this._ongoingDataUpdate.then(function() {
						this._invalidateLastNonEmptyPlotRowCache(), this.data().move(e)
					}.bind(this))
				}
				replaceData(e, t, i) {
					this._invalidateLastNonEmptyPlotRowCache(), this.data().remove(e + 1), this.data().addTail(i, t)
				}
				static offset(e, t) {
					var i = 0;
					return e._plotOffsets && void 0 !== e._plotOffsets[t] && (i += e._plotOffsets[t]), e.properties().offsets && void 0 !== e.properties().offsets[t] && (i += e.properties().offsets[t].val.value()), e.properties().offset && (i += e.properties().offset.val.value()), i
				}
				offset(e) {
					return O.offset(this, e)
				}
				_showLastValueOnPriceScale() {
					return this._model.properties().scalesProperties.showStudyLastValue.value()
				}
				barColorer() {
					const e = this._metaInfo.plots;
					let t = null;
					for (let i = 0; i < e.length; ++i)
						if (y.isBarColorerPlot(e[i])) {
							const e = new a(this, i);
							null == t ? t = e : t.pushBackBarColorer(e)
						} if (null == t) throw new Error("Cannot create BarColorer: study doesn't have a bar_colorer plot!");
					return t
				}
				base() {
					return 0
				}
				_priceScaleByProperties() {
					if ("default" === this.properties().precision.value()) return null;
					var e = parseInt(this.properties().precision.value());
					return isFinite(e) ? Math.pow(10, e) : null
				}
				_formatterByProperties() {
					var e = this._priceScaleByProperties();
					return null !== e ? new u(e) : null
				}
				_priceScaleByMetaInfo() {
					var e = this.metaInfo().format,
						t = isNumber(e.precision) ? Math.pow(10, e.precision) : void 0;
					if ("price" === e.type || "percent" === e.type) return t || 100;
					if ("volume" === e.type) {
						if (void 0 === e.precision) {
							var i = this.series().symbolInfo();
							if (null !== i && isNumber(i.volume_precision)) return Math.pow(10, i.volume_precision)
						}
						return 1
					}
					return "inherit" === e.type || T.logWarn("Unsupported format type: " + e.type), null
				}
				_formatterByMetaInfo() {
					var e = this.metaInfo().format,
						t = isNumber(e.precision) ? Math.pow(10, e.precision) : void 0;
					switch (e.type) {
						case "price":
							return new u(t);
						case "volume":
							var i = e.precision;
							if (void 0 === i) {
								var s = this.series().symbolInfo();
								i = s && isNumber(s.volume_precision) ? s.volume_precision : 0
							}
							return new c(i);
						case "percent":
							return new p(t);
						case "inherit":
							return null;
						default:
							return T.logWarn("Unsupported format type: " + e.type), null
					}
				}
				_onSourceFormatterChanged() {
					null === this._formatter && (null !== this.priceScale() && this.priceScale().updateFormatter(), this._formatterChanged.fire())
				}
				_onSourcePriceStepChanged() {
					null === this._priceStep && this._priceStepChanged.fire()
				}
				_precisionChanged() {
					this._recreatePriceFormattingDependencies()
				}
				_recreatePriceFormattingDependencies() {
					this._recreateFormatter(), this._recreatePriceStep()
				}
				_recreateFormatter() {
					this._formatter = this._tryCreateFormatter(), this._formatterChanged.fire(), null !== this.priceScale() && this.priceScale().updateFormatter(), this._model.fullUpdate()
				}
				_recreatePriceStep() {
					var e = null,
						t = this._tryToGetPriceScale();
					null !== t && (e = 1 / t), this._priceStep !== e && (this._priceStep = e, this._priceStepChanged.fire())
				}
				_tryToGetPriceScale() {
					var e = this._priceScaleByProperties();
					return null === e && (e = this._priceScaleByMetaInfo()), e
				}
				_tryCreateFormatter() {
					var e = this._formatterByProperties();
					return null === e && (e = this._formatterByMetaInfo()), e
				}
				priceStep() {
					return this._priceStep || this.parentSource().priceStep(!1)
				}
				setOwnerSource(e) {
					super.setOwnerSource(e), this._recreatePriceFormattingDependencies()
				}
				nearestIndex(e, t, i) {
					if (TradingView.isInteger(e)) {
						var s = this.data().search(e, t, i);
						return null !== s ? s.index : void 0
					}
					T.logDebug("nearestIndex: incorrect logicalPoint")
				}
				tags() {
					return !this._metaInfo || !this._metaInfo.description || this._metaInfo.isTVScriptStub || this._metaInfo.is_hidden_study || this._metaInfo.isTVScript && "tv-scripting" === this._metaInfo.productId ? [] : [this._metaInfo.description]
				}
				onExtendedHoursChanged() {
					this.restart(!0)
				}
				hasSymbolInputs() {
					for (var e = this._metaInfo.inputs.length; e--;)
						if ("symbol" === this._metaInfo.inputs[e].type) return !0;
					return !1
				}
				canOverrideMinTick() {
					return !1
				}
				_subscribeExtendedHours() {
					!this._isSubscribedToExtendedHours && this.hasSymbolInputs() && (this._series.onExtendedHoursChanged().subscribe(this, this.onExtendedHoursChanged), this._isSubscribedToExtendedHours = !0)
				}
				removeByRemoveAllStudies() {
					return !0
				}
				canHaveChildren() {
					return void 0 === this._canHaveChildren && (this._canHaveChildren = !!f.canHaveChildren(this._metaInfo)), this._canHaveChildren
				}
				static getInputRebindType(e, t, i) {
					var s = f.isSourceInput(e);
					return s && !~t.indexOf("$") && ~i.indexOf("$") ? l.REBIND_STUDY_STANDALONE_TO_CHILD : s && ~t.indexOf("$") && !~i.indexOf("$") ? l.REBIND_STUDY_CHILD_TO_STANDALONE : 0
				}
				getPlotFields() {
					return this._plotFields
				}
				getMinFirstBarIndexForPlot(e) {
					var t = L(this._properties.styles, e) || L(this._properties.ohlcPlots, e) || L(this._properties.filledAreasStyle, e);
					if (null === t) return -1 / 0;
					var i = this.data().lastIndex();
					return null === i ? -1 / 0 : i - t + 1
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.resolve(null)
				}
				getPropertyDefinitionsViewModel() {
					if (null === this._definitionsViewModel) {
						var e = this;
						return e._getPropertyDefinitionsViewModelClass().then((function(t) {
							return null === t || e._isDestroyed ? null : (null === e._definitionsViewModel && (e._definitionsViewModel = new t(e._model.undoModel(), e)), e._definitionsViewModel)
						}))
					}
					return Promise.resolve(this._definitionsViewModel)
				}
				_getTelemetryAdditionalData() {
					var e = "";
					return this._metaInfo.pine && this._metaInfo.pine.version && this._metaInfo.shortId.indexOf("USER") >= 0 && (e = "_v" + this._metaInfo.pine.version), {
						symbol: this.series().actualSymbol(),
						resolution: this.series().interval(),
						study: this._metaInfo.shortId + e
					}
				}
				_sendTelemetryReport(e, t, i) {
					void 0 === i && (i = this._getTelemetryAdditionalData());
					var s = Object.assign(t, {
						additional: i
					});
					h.sendChartReport(e, s)
				}
				_sendTelemetryCounter(e, t) {
					this._sendTelemetryReport(e, {
						count: 1
					}, t)
				}
				onAboutToBeDestroyed() {
					return this._aboutToBeDestroyed
				}
				destroy() {
					this._aboutToBeDestroyed.fire(), this._isDestroyed = !0, null !== this._definitionsViewModel && (this._definitionsViewModel.destroy(), this._definitionsViewModel = null), this._properties.precision.listeners().unsubscribe(this, this._precisionChanged), this._showStudyArgumentsProperty.listeners().unsubscribe(this, this.invalidateTitleCache), this._properties.description.listeners().unsubscribe(this, this.invalidateTitleCache), this._properties.shortDescription && this._properties.shortDescription.listeners().unsubscribe(this, this.invalidateTitleCache), this._model.mainSeries().dataEvents().symbolResolved().unsubscribeAll(this), this.hasBarColorer() && this._properties.visible.listeners().unsubscribe(this._model.mainSeries(), this._model.mainSeries().invalidateBarStylesCache), this._model.mainSeries().dataEvents().symbolResolved().unsubscribe(this, this._recreatePriceFormattingDependencies), void 0 !== this._properties.offsets && this._properties.offsets.listeners().unsubscribe(this, this._updateMaxOffsetValue), void 0 !== this._properties.offset && this._properties.offset.listeners().unsubscribe(this, this._updateMaxOffsetValue), super.destroy()
				}
				desiredPriceScalePosition() {
					return this.metaInfo().isTVScriptStub ? "overlay" : this.metaInfo().linkedToSeries ? "as-series" : void 0 === this.metaInfo().priceScale ? null : ["right", "left", "overlay"][this.metaInfo().priceScale]
				}
				guiPlotName(e) {
					var t = this.properties().styles;
					return t && t[e] && t[e].title ? t[e].title.value() : this.title()
				}
				formatterChanged() {
					return this._formatterChanged
				}
				copiable() {
					return V && !this.isChildStudy()
				}
				setPriceScale(e) {
					super.setPriceScale(e), m.emit("study_event", this.id(), "price_scale_changed")
				}
			}
			TradingView.Study = O, t.Study = O, t.prepareStudyProperties = function(e, t, r, o, a) {
				return function(e, t, r, o, a, l) {
					var h = function(e, t, r, o) {
							var a = i(610498);
							if (f.versionOf(e) < 1) throw new Error("This function cannot work with metainfo of the old format version. Required format version >= 1");
							var l = TradingView.clone(defaults("study"));
							B(l, e);
							var h = f.getStudyPropertyRootName(e),
								d = TradingView.clone(defaults(h, o));
							d.intervalsVisibilities = TradingView.clone(I), ("Overlay" === e.shortId || "Compare" === e.shortId) && (d.currencyId = null, d.unitId = null);
							e.isTVScript && e.TVScriptSourceCode !== d.TVScriptSourceCode && (d = TradingView.clone(TradingView.factoryDefaults(h, o)));
							TradingView.merge(l, d), t && (n(!(t instanceof s), "propsState should not be an instance of Property"), TradingView.merge(l, t));
							var u = TradingView.clone(e),
								c = {};
							a.mergeInputsObjPart(c, u.defaults.inputs), a.mergeInputsObjPart(c, l.inputs), l.inputs = c, delete u.inputs, delete u.defaults.inputs;
							var p = {};
							if (TradingView.merge(p, u.defaults), TradingView.merge(p, TradingView.factoryDefaults(h)), TradingView.merge(p, l), TradingView.merge(p, u), delete p.defaults, l = p, null !== r) {
								var _ = r.model().studiesColorRotatorFactory().getColorRotator(e);
								null !== _ && ("Overlay@tv-basicstudies" === e.id ? l.lineStyle.color = _.getColor(l.lineStyle.color, e) : TradingView.merge(l, function(e, t) {
									for (var i in e.styles) {
										var s = e.styles[i].color;
										s && (e.styles[i].color = t.getColor(s))
									}
									return e
								}(l, _)))
							}
							t && TradingView.merge(l.styles, t.styles);
							return l
						}(e, t, r, o),
						d = f.getSourceInputIds(e);
					if (d.length > 0) {
						var u = d[0];
						l instanceof O ? h.inputs[u] = "{pid}$0" : void 0 !== h.inputs[u] && -1 !== h.inputs[u].indexOf("$") && (h.inputs[u] = "close")
					}
					return A(e, a, h)
				}(e, t, r, o, f.getStudyPropertyRootName(e), a)
			}, t.prepareStudyPropertiesForLoadChart = function(e, t, s, r, n, o) {
				return function(e, t, s, r, n, o, a) {
					var l = function(e, t, s, r, n, o) {
						var a = i(610498);
						e.version && s.version && e.version !== s.version && T.logWarn("Serialized metaInfo version " + e.version + " is not equal to the saved state version " + s.version);
						var l = TradingView.clone(defaults("study"));
						l.intervalsVisibilities = TradingView.clone(I), TradingView.merge(l, TradingView.factoryDefaults(f.getStudyPropertyRootName(e))), B(l, e), TradingView.merge(l, s), l = n.updateStudyState(l, e, t), void 0 !== o && (l = o(s, l, e, t));
						var h = TradingView.clone(t || e);
						if (h && f.versionOf(h) >= 1) {
							var d = {};
							a.mergeInputsObjPart(d, (h.defaults || {}).inputs), a.mergeInputsObjPart(d, l.inputs), l.inputs = d, delete h.inputs, h.defaults && delete h.defaults.inputs;
							var u = {};
							TradingView.merge(u, h.defaults), TradingView.merge(u, TradingView.factoryDefaults(f.getStudyPropertyRootName(h))), TradingView.merge(u, l), delete h.defaults, TradingView.merge(u, h), l = u
						}
						return l
					}(e, t, s, 0, n, a);
					return A(t || e, o, l)
				}(e, t, s, 0, n, f.getStudyPropertyRootName(e), o)
			}
		},
		96989: (e, t, i) => {
			i.d(t, {
				plotShapesData: () => r
			});
			var s = i(575932);
			const r = {
				shape_arrow_down: {
					guiName: (0, s.t)("Arrow Down"),
					id: "shape_arrow_down",
					paneRendererClass: "PaneRendererArrowDown",
					pineName: "shape.arrowdown",
					icon: "arrow_down"
				},
				shape_arrow_up: {
					guiName: (0, s.t)("Arrow Up"),
					id: "shape_arrow_up",
					paneRendererClass: "PaneRendererArrowUp",
					pineName: "shape.arrowup",
					icon: "arrow_up"
				},
				shape_circle: {
					guiName: (0, s.t)("Circle"),
					id: "shape_circle",
					paneRendererClass: "PaneRendererCircleShape",
					pineName: "shape.circle",
					icon: "circle"
				},
				shape_cross: {
					guiName: (0, s.t)("Cross"),
					id: "shape_cross",
					paneRendererClass: "PaneRendererCrossShape",
					pineName: "shape.cross",
					icon: "cross"
				},
				shape_diamond: {
					guiName: (0, s.t)("Diamond"),
					id: "shape_diamond",
					paneRendererClass: "PaneRendererDiamond",
					pineName: "shape.diamond",
					icon: "diamond"
				},
				shape_flag: {
					guiName: (0, s.t)("Flag"),
					id: "shape_flag",
					paneRendererClass: "PaneRendererFlagShape",
					pineName: "shape.flag",
					icon: "flag"
				},
				shape_label_down: {
					guiName: (0, s.t)("Label Down"),
					id: "shape_label_down",
					paneRendererClass: "PaneRendererLabelDown",
					pineName: "shape.labeldown",
					icon: "label_down"
				},
				shape_label_up: {
					guiName: (0, s.t)("Label Up"),
					id: "shape_label_up",
					paneRendererClass: "PaneRendererLabelUp",
					pineName: "shape.labelup",
					icon: "label_up"
				},
				shape_square: {
					guiName: (0, s.t)("Square"),
					id: "shape_square",
					paneRendererClass: "PaneRendererSquare",
					pineName: "shape.square",
					icon: "square"
				},
				shape_triangle_down: {
					guiName: (0, s.t)("Triangle Down"),
					id: "shape_triangle_down",
					paneRendererClass: "PaneRendererTriangleApexDown",
					pineName: "shape.triangledown",
					icon: "triangle_down"
				},
				shape_triangle_up: {
					guiName: (0, s.t)("Triangle Up"),
					id: "shape_triangle_up",
					paneRendererClass: "PaneRendererTriangleApexUp",
					pineName: "shape.triangleup",
					icon: "triangle_up"
				},
				shape_xcross: {
					guiName: (0, s.t)("X Cross"),
					id: "shape_xcross",
					paneRendererClass: "PaneRendererXCross",
					pineName: "shape.xcross",
					icon: "x_cross"
				}
			}
		},
		405222: (e, t, i) => {
			i.d(t, {
				TextWidthCache: () => s
			});
			class s {
				constructor(e = 150) {
					this._actualSize = 0, this._usageTick = 1, this._oldestTick = 1, this._tick2Labels = new Map, this._cache = new Map, this._maxSize = e
				}
				reset() {
					this._actualSize = 0, this._cache.clear(), this._usageTick = 1, this._oldestTick = 1, this._tick2Labels.clear()
				}
				measureText(e, t) {
					return this.getMetrics(e, t).width
				}
				yMidCorrection(e, t) {
					const i = this.getMetrics(e, t);
					return "actualBoundingBoxAscent" in i && "actualBoundingBoxDescent" in i ? (i.actualBoundingBoxAscent - i.actualBoundingBoxDescent) / 2 : 0
				}
				getMetrics(e, t) {
					const i = this._cache.get(t);
					if (void 0 !== i) return i.metrics;
					if (this._actualSize === this._maxSize) {
						const e = this._tick2Labels.get(this._oldestTick);
						this._tick2Labels.delete(this._oldestTick), this._cache.delete(e), this._oldestTick++, this._actualSize--
					}
					e.save(), e.textBaseline = "middle";
					const s = e.measureText(t);
					return e.restore(), 0 === s.width && t.length || (this._cache.set(t, {
						metrics: s,
						tick: this._usageTick
					}), this._tick2Labels.set(this._usageTick, t), this._actualSize++, this._usageTick++), s
				}
			}
		},
		611239: (e, t, i) => {
			i.d(t, {
				createVisibilityController: () => l
			});
			var s = i(575932),
				r = i(778785),
				n = i(860949),
				o = i(62802);

			function a(e) {
				return "alwaysOn" === e || "alwaysOff" === e ? e : "visibleOnMouseOver"
			}

			function l(e, t) {
				let i, l;

				function h() {
					if (!i) {
						i = (0, n.createPrimitiveProperty)();
						let s = o.getValue(e);
						void 0 === s && void 0 !== t && (s = o.getValue(t)), i.setValue(a(s)), i.subscribe(i, (t => {
							o.setValue(e, a(t.value()))
						}))
					}
					return i
				}
				return {
					property: h,
					availableValues: function() {
						return [{
							id: "visibleOnMouseOver",
							value: "visibleOnMouseOver",
							title: (0, s.t)("Visible on mouse over")
						}, {
							id: "alwaysOn",
							value: "alwaysOn",
							title: (0, s.t)("Always visible")
						}, {
							id: "alwaysOff",
							value: "alwaysOff",
							title: (0, s.t)("Always invisible")
						}]
					},
					actualBehavior: function() {
						if (!l) {
							l = (0, n.createPrimitiveProperty)();
							const e = h(),
								t = () => {
									let t = e.value();
									"alwaysOn" !== t && "alwaysOff" !== t && (t = r.mobiletouch ? "alwaysOn" : "visibleOnMouseOver"), l && l.setValue(t)
								};
							e.subscribe(l, t), t()
						}
						return l
					}
				}
			}
		},
		165035: (e, t, i) => {
			function s(e, t) {
				const i = new Map;
				return function(...s) {
					const r = "" + (t ? t.apply(null, s) : s[0]);
					if (!i.has(r)) {
						const t = e.apply(this, s);
						return i.set(r, t), t
					}
					return i.get(r)
				}
			}

			function r(e) {
				return (t, i, r) => {
					const n = r.value,
						o = Symbol();
					return {
						get() {
							return void 0 === this[o] && (this[o] = s(n, e)), this[o].bind(this)
						}
					}
				}
			}
			i.d(t, {
				memoize: () => s,
				memoizeDecorator: () => r
			})
		}
	}
]);