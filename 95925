"use strict";
(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
	[95925], {
		813652: (t, e, i) => {
			i.d(e, {
				Version: () => n
			});
			var r = i(588537);
			class n {
				constructor(t, e) {
					this._major = t, this._minor = e
				}
				major() {
					return this._major
				}
				minor() {
					return this._minor
				}
				isZero() {
					return 0 === this._major && 0 === this._minor
				}
				toString() {
					return this._major + "." + this._minor
				}
				compareTo(t) {
					return this._major < t._major ? -1 : this._major > t._major ? 1 : this._minor < t._minor ? -1 : this._minor > t._minor ? 1 : 0
				}
				isLess(t) {
					return this.compareTo(t) < 0
				}
				isLessOrEqual(t) {
					return this.compareTo(t) <= 0
				}
				isEqual(t) {
					return 0 === this.compareTo(t)
				}
				isGreater(t) {
					return this.compareTo(t) > 0
				}
				isGreaterOrEqual(t) {
					return this.compareTo(t) >= 0
				}
				static parse(t) {
					if (t instanceof n) return new n(t.major(), t.minor());
					if ("number" == typeof t) return (0, r.assert)(Math.floor(t) === t, "Version should not be a float number"), new n(t, 0);
					if ("string" == typeof t) {
						const e = t.split(".");
						if (1 === e.length) {
							const i = parseInt(e[0], 10);
							return (0, r.assert)(!isNaN(i), "Bad version string: " + t), new n(i, 0)
						}
						if (2 === e.length) {
							const i = parseInt(e[0], 10);
							(0, r.assert)(!isNaN(i), "Bad version string: " + t);
							const s = parseInt(e[1], 10);
							return (0, r.assert)(!isNaN(s), "Bad version string: " + t), new n(i, s)
						}
						throw new Error("Bad version string (one dot expected): " + t)
					}
					throw new Error("Bad version: " + t)
				}
			}
			n.ZERO = new n(0, 0)
		},
		469411: (t, e, i) => {
			i.d(e, {
				patchSourceState: () => n
			});
			var r = i(575932);

			function n(t) {
				const e = {
					palettes: {},
					inputs: [{
						defval: 2,
						id: "upper diviation",
						max: 500,
						min: -500,
						name: (0, r.t)("Upper Deviation"),
						type: "integer"
					}, {
						defval: -2,
						id: "lower diviation",
						max: 500,
						min: -500,
						name: (0, r.t)("Lower Deviation"),
						type: "integer"
					}, {
						defval: !0,
						id: "use upper diviation",
						name: (0, r.t)("Use Upper Deviation"),
						type: "bool"
					}, {
						defval: !0,
						id: "use lower diviation",
						name: (0, r.t)("Use Lower Deviation"),
						type: "bool"
					}, {
						defval: 0,
						id: "first bar time",
						max: 253370764800,
						min: 0,
						name: (0, r.t)("First bar time"),
						type: "time"
					}, {
						defval: 0,
						id: "last bar time",
						max: 253370764800,
						min: 0,
						name: (0, r.t)("Last bar time"),
						type: "time"
					}, {
						defval: "close",
						id: "source",
						name: (0, r.t)("Source"),
						options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"],
						type: "text"
					}],
					plots: [],
					graphics: {},
					defaults: {
						inputs: {
							"first bar time": 0,
							"last bar time": 0,
							"lower diviation": -2,
							source: "close",
							"upper diviation": 2,
							"use lower diviation": !0,
							"use upper diviation": !0
						}
					},
					_metainfoVersion: 6,
					description: "Regression Trend",
					id: "RegressionTrend@tv-basicstudies",
					is_price_study: !0,
					shortDescription: "Reg Trend",
					shortId: "RegressionTrend",
					version: "2",
					fullId: "RegressionTrend@tv-basicstudies-2",
					name: "RegressionTrend@tv-basicstudies"
				};
				return t.metaInfo || (t.metaInfo = e), t
			}
		},
		344265: (t, e, i) => {
			var r = i(281640);

			function n(t) {
				var e = JSON.stringify(t);
				return e = e.replace(/'/g, "\\'")
			}
			t.exports = {
				formatCallstudyArg: n,
				prepareCallStudyArgs: function(t, e) {
					var i = {};
					if (e.isTVScript) {
						var s = e.defaults.inputs.text;
						i.text = r.patchILTemplate(s, e, t)
					} else
						for (var o = Object.keys(t), a = o.length - 1; a >= 0; a--) {
							var l = o[a],
								u = t[l] ? t[l].id : null;
							u && t[u] && (i[u] = t[u])
						}
					return n(i)
				}
			}
		},
		902105: (t, e, i) => {
			i.d(e, {
				generateSplitTitleForGui: () => l,
				generateTitleForGui: () => u
			});
			var r = i(588537),
				n = i(575932),
				s = i(773547);

			function o(t, e) {
				return (Math.round(t * Math.pow(10, e)) / Math.pow(10, e)).toString() || ""
			}
			const a = "TradingView";

			function l(t) {
				const e = "QUANDL" === (t = t || {}).exchange,
					i = {
						title: "",
						description: "",
						interval: "",
						exchange: "",
						provider: "",
						chartStyle: "",
						sessionDescription: ""
					};
				let l = "";
				if (t.description && e)
					if (2 === t.description.split("/").length) l = t.description.split("/")[1];
					else {
						t.description.split("'").filter((t => t.length)).forEach((t => {
							let e = [];
							e = t && ("/" === t[0] || /\d+\/\(?/.test(t)) ? [t] : t.split("/").filter((t => t.length)), l += e[2 === e.length ? 1 : 0]
						}))
					}
				else l = t.description ? t.description : t.symbol;
				if (t.ticker ? (i.title = t.ticker, i.description = d(l)) : i.title = d(l), t.interval && (i.interval = (0, s.translatedIntervalString)(t.interval)), e && t.description) {
					const e = /[\w_]+\/[\w_]+/.exec(t.description);
					e && e[0] ? i.provider = d(e[0].split("/")[0]) : i.provider = d(t.description.split("/")[0])
				}
				return t.exchange && (i.exchange = d(t.exchange)), i.chartStyle = d(function(t) {
					const e = t.inputs;
					switch (t.style) {
						case 4:
							const i = e.style + ("ATR" === e.style ? `(${e.atrLength})` : ""),
								s = (0, r.ensureDefined)(t.boxSize || e.boxSize);
							return `${(0,n.t)("Renko")} [${i}, ${o(s,4)}]`;
						case 7:
							return `${(0,n.t)("Line Break")} [${e.lb}]`;
						case 5:
							const a = e.style + ("ATR" === e.style ? `(${e.atrLength})` : ""),
								l = t.reversalAmount || e.reversalAmount,
								u = void 0 !== l ? `, ${o(l,8)}` : "";
							return `${(0,n.t)("Kagi")} [${a}${u}]`;
						case 6:
							const d = `${e.style}${"ATR"===e.style?"("+e.atrLength+")":""}`,
								p = t.boxSize || e.boxSize;
							return `${(0,n.t)("PnF")} [${d}, ${o((0,r.ensureDefined)(p),8)}, ${e.reversalAmount}]`
					}
					return 11 === t.style ? (0, n.t)("Range") : 8 === t.style ? (0, n.t)("Heikin Ashi") : ""
				}(t)), t.branding && !l.toUpperCase().includes(a.toUpperCase()) && (i.branding = a), t.sessionDescription && (i.sessionDescription = d(t.sessionDescription)), i
			}

			function u(t) {
				const e = l(t);
				return (t.ticker ? e.description : e.title) + (e.interval ? ", " + e.interval : "") + function(t, e = ", ") {
					return (t.provider ? `${e}${t.provider}` : "") + (t.exchange ? `${e}${t.exchange}` : "") + (t.chartStyle ? `${e}${t.chartStyle}` : "") + (t.branding ? `${e}${t.branding}` : "") + (t.sessionDescription ? `${e}${t.sessionDescription}` : "")
				}(e)
			}

			function d(t) {
				return t.replace(/'/g, "")
			}
		},
		481211: (t, e, i) => {
			i.d(e, {
				migrateMetaInfoAndPropState: () => d
			});
			var r = i(588537),
				n = i(970028),
				s = i(270617);
			const o = ["PennantCP@tv-basicstudies", "WedgeCP@tv-basicstudies"],
				a = ["DoubleTopCP@tv-basicstudies", "BullishFlagCP@tv-basicstudies", "HeadAndShouldersCP@tv-basicstudies", "TripleTopCP@tv-basicstudies"];
			class l {
				targetMetaInfoVersion() {
					return 53
				}
				migrateMetaInfo(t) {
					const e = t,
						i = t;
					if (i._metainfoVersion = 53, void 0 !== e.defaults && void 0 !== e.defaults.inputs && (o.includes(e.id) || a.includes(e.id) && Number(e.version) < 156)) {
						const t = e.defaults.inputs["Invert Pattern"];
						i.id = this._getNewIdStudies(e.id, t)
					}
				}
				migratePropState(t) {}
				_getNewIdStudies(t, e) {
					return t.startsWith("WedgeCP") ? e ? "WedgeFallingCP@tv-basicstudies" : "WedgeRisingCP@tv-basicstudies" : t.startsWith("PennantCP") ? e ? "PennantBearishCP@tv-basicstudies" : "PennantBullishCP@tv-basicstudies" : t.startsWith("DoubleTopCP") && e ? "DoubleBottomCP@tv-basicstudies" : t.startsWith("BullishFlagCP") && e ? "BearishFlagCP@tv-basicstudies" : t.startsWith("HeadAndShouldersCP") && e ? "HeadAndShouldersInverseCP@tv-basicstudies" : t.startsWith("TripleTopCP") && e ? "TripleBottomCP@tv-basicstudies" : t
				}
			}
			const u = [new class {
				targetMetaInfoVersion() {
					return 47
				}
				migrateMetaInfo(t) {
					const e = t,
						i = t;
					if (i._metainfoVersion = 47, !e.defaults || void 0 === e.defaults.precision) return void(i.format = {
						type: "inherit"
					});
					const r = e.defaults && e.defaults.precision,
						n = (0, s.isNumber)(r) ? r : parseInt(r);
					0 === n ? i.format = {
						type: "volume"
					} : isFinite(n) ? i.format = {
						type: "price",
						precision: n
					} : i.format = {
						type: "inherit"
					}, delete e.defaults.precision
				}
				migratePropState(t) {}
			}, new class {
				targetMetaInfoVersion() {
					return 50
				}
				migrateMetaInfo(t) {
					const e = t,
						i = t;
					if (i._metainfoVersion = 50, void 0 === e.defaults || void 0 === e.defaults.ohlcPlots || void 0 === e.ohlcPlots) return;
					const n = e.ohlcPlots,
						s = e.defaults.ohlcPlots,
						o = (0, r.ensureDefined)((0, r.ensureDefined)(i.defaults).ohlcPlots);
					for (const t of Object.keys(s)) {
						const e = s[t];
						if ("ohlc_candles" === e.plottype) {
							let i = !1;
							const r = n[t];
							void 0 !== r && (i = !!r.drawBorder, delete r.drawBorder), o[t] = {
								borderColor: "#000000",
								drawBorder: i,
								...e
							}
						}
					}
				}
				migratePropState(t) {}
			}, new class {
				targetMetaInfoVersion() {
					return 53
				}
				migrateMetaInfo(t) {
					const e = t,
						i = t;
					if (i._metainfoVersion = 53, void 0 !== e.defaults) {
						if (void 0 !== e.defaults.ohlcPlots && void 0 !== e.ohlcPlots) {
							const t = Object.keys(e.ohlcPlots),
								n = e.defaults.ohlcPlots,
								s = (0, r.ensureDefined)((0, r.ensureDefined)(i.defaults).ohlcPlots);
							for (const e of t) {
								const t = n[e];
								if (void 0 === t || void 0 === t.visible) continue;
								const i = t.visible ? 15 : 0;
								delete t.visible, s[e] = {
									display: i,
									...t
								}
							}
						}
						if (void 0 !== e.defaults.styles && void 0 !== e.plots) {
							const t = e.plots.map((t => t.id)),
								n = e.defaults.styles,
								s = (0, r.ensureDefined)((0, r.ensureDefined)(i.defaults).styles);
							for (const e of t) {
								const t = n[e];
								if (void 0 === t || void 0 === t.visible) continue;
								const i = t.visible ? 15 : 0;
								delete t.visible, s[e] = {
									display: i,
									...t
								}
							}
						}
					}
				}
				migratePropState(t) {
					if (t.ohlcPlots)
						for (const e of Object.keys(t.ohlcPlots)) {
							const i = (0, r.ensureDefined)(t.ohlcPlots[e]);
							void 0 !== i.visible && (i.display = i.visible ? 15 : 0, delete i.visible)
						}
					if (t.styles)
						for (const e of Object.keys(t.styles)) {
							const i = (0, r.ensureDefined)(t.styles[e]);
							void 0 !== i.visible && (i.display = i.visible ? 15 : 0, delete i.visible)
						}
				}
			}];

			function d(t, e) {
				const i = n.StudyMetaInfo.versionOf(t),
					s = t;
				void 0 === s._serverMetaInfoVersion && (s._serverMetaInfoVersion = i);
				const o = ["PennantCP@tv-basicstudies", "WedgeCP@tv-basicstudies"].includes(t.id);
				u.forEach((n => {
					(i < 0 || i >= n.targetMetaInfoVersion()) && !o || (n.migrateMetaInfo(t), void 0 !== e && n.migratePropState(e), (0, r.assert)(t._metainfoVersion === n.targetMetaInfoVersion()))
				}))
			}
			u.push(new l), u.sort((function(t, e) {
				return t.targetMetaInfoVersion() - e.targetMetaInfoVersion()
			}))
		},
		244276: (t, e, i) => {
			function r(t, e) {
				return `${t}@${e}`
			}

			function n(t) {
				return t.replace(/(@[^-]+-[^-]+).*$/, "$1")
			}
			i.d(e, {
				studyIdString: () => r,
				extractStudyId: () => n
			})
		},
		349692: (t, e, i) => {
			i.r(e), i.d(e, {
				collectDepsForAlert: () => h,
				dependenciesForAlerts: () => g,
				idForAlert: () => v,
				patchChildIdInInputs: () => f,
				plotsForAlert: () => y
			});
			var r = i(588537),
				n = i(911905),
				s = i(290557);
			var o = Array.isArray || function(t) {
					return "[object Array]" === {}.toString.call(t)
				},
				a = Object.keys || function(t) {
					var e = Object.prototype.hasOwnProperty || function() {
							return !0
						},
						i = [];
					for (var r in t) e.call(t, r) && i.push(r);
					return i
				},
				l = i(244276),
				u = i(970028),
				d = i(418458),
				p = i(270617);
			const c = (0, n.getLogger)("Chart.Study");

			function f(t, e, i) {
				void 0 !== e && void 0 !== i && i.forEach((i => {
					const r = t[i];
					if ("string" == typeof r) {
						const n = r.split("$")[1];
						t[i] = e + (void 0 === n ? "" : "$" + n)
					} else if ((0, p.isObject)(r) && "source" === r.t) {
						const t = r.v.split("$")[1];
						r.v = e + (void 0 === t ? "" : "$" + t)
					} else c.logError(`Cannot patch source input, its type is not source: ${JSON.stringify(r)}`)
				}))
			}

			function v(t, e, i) {
				return (0, s.hash)(t + function(t, e) {
					e || (e = {}), "function" == typeof e && (e = {
						cmp: e
					});
					var i = e.space || "";
					"number" == typeof i && (i = Array(i + 1).join(" "));
					var r, n = "boolean" == typeof e.cycles && e.cycles,
						s = e.replacer || function(t, e) {
							return e
						},
						l = e.cmp && (r = e.cmp, function(t) {
							return function(e, i) {
								var n = {
										key: e,
										value: t[e]
									},
									s = {
										key: i,
										value: t[i]
									};
								return r(n, s)
							}
						}),
						u = [];
					return function t(e, r, d, p) {
						var c = i ? "\n" + new Array(p + 1).join(i) : "",
							f = i ? ": " : ":";
						if (d && d.toJSON && "function" == typeof d.toJSON && (d = d.toJSON()), void 0 !== (d = s.call(e, r, d))) {
							if ("object" != typeof d || null === d) return JSON.stringify(d);
							if (o(d)) {
								for (var v = [], y = 0; y < d.length; y++) {
									var h = t(d, y, d[y], p + 1) || JSON.stringify(null);
									v.push(c + i + h)
								}
								return "[" + v.join(",") + c + "]"
							}
							if (-1 !== u.indexOf(d)) {
								if (n) return JSON.stringify("__cycle__");
								throw new TypeError("Converting circular structure to JSON")
							}
							u.push(d);
							var g = a(d).sort(l && l(d));
							for (v = [], y = 0; y < g.length; y++) {
								var I = t(d, r = g[y], d[r], p + 1);
								if (I) {
									var S = JSON.stringify(r) + f + I;
									v.push(c + i + S)
								}
							}
							return u.splice(u.indexOf(d), 1), "{" + v.join(",") + c + "}"
						}
					}({
						"": t
					}, "", t, 0)
				}(e) + (null != i ? i : "")).toString()
			}

			function y(t, e, i) {
				const n = [d.isLinePlot, d.isShapesPlot, d.isCharsPlot, d.isArrowsPlot, d.isOhlcPlot, d.isAlertConditionPlot];
				return t.plots.map(((t, e) => ({
					...t,
					pinePlotIndex: e
				}))).filter((t => !(void 0 !== i && !i.includes(t.id)) && n.some((e => e(t))))).map((i => {
					const n = {
						id: i.id,
						type: i.type,
						pinePlotIndex: i.pinePlotIndex,
						offset: e(i.id)
					};
					if (t.styles && void 0 !== t.styles[i.id]) {
						const e = (0, r.ensureDefined)((0, r.ensureDefined)(t.styles)[i.id]);
						n.title = e.title || "", n.text = e.text || ""
					}
					return (0, d.isOhlcPlot)(i) && i.target && t.ohlcPlots && t.ohlcPlots[i.target] && (n.ohlcTitle = (0, r.ensureDefined)((0, r.ensureDefined)(t.ohlcPlots)[i.target]).title), n
				}))
			}

			function h(t, e) {
				const i = [];
				let n, s;
				for (let r = t.length - 1; r >= 0; r--) {
					const o = t[r],
						a = (0, l.extractStudyId)(o.metaInfo().id),
						d = u.StudyMetaInfo.getStudyIdWithLatestVersion(o.metaInfo());
					s = o.inputsForAlertState();
					f(s, n, o.metaInfo().inputs.filter((t => "source" === t.type)).map((t => t.id)));
					const p = Object.assign({}, s);
					o.metaInfo().isTVScript && delete p.text;
					const c = v(a, p, e);
					i.push({
						id: c,
						study: d,
						inputs: s
					}), n = c
				}
				return {
					idForAlert: (0, r.ensureDefined)(n),
					inputsForAlert: (0, r.ensureDefined)(s),
					studyDependencies: i.reverse()
				}
			}

			function g(t, e) {
				return t.map((t => {
					const i = t.inputs(),
						r = t.metaInfo();
					let n = u.StudyMetaInfo.cutDollarHash(r.fullId);
					if ("tv-scripting" === r.productId) {
						const t = e.findByIdSync({
							type: "java",
							studyId: "Script@tv-scripting"
						});
						null !== t && (n = t.fullId)
					}
					const s = {
						id: t.sourceId(),
						study: n,
						inputs: i,
						scriptIdPart: void 0,
						scriptVersion: void 0
					};
					return r.pine ? {
						...s,
						scriptIdPart: r.scriptIdPart,
						scriptVersion: r.pine.version
					} : s
				}))
			}
		},
		594930: (t, e, i) => {
			i.d(e, {
				applyOverridesToStudy: () => u,
				applyOverridesToStudyDefaults: () => d
			});
			var r = i(588537),
				n = i(418458);
			const s = (0, i(911905).getLogger)("Chart.Model.StudyPropertiesOverrider");
			var o, a;

			function l(t, e, i, r) {
				const n = i.split(".");
				if (0 === n.length || 0 === n[0].length) return;
				const l = function(t) {
						const e = t.split(":");
						return {
							name: e[0],
							type: 2 === e.length ? e[1] : null
						}
					}(n[0]),
					u = l.name,
					d = l.type,
					p = null !== d,
					c = !p || "band" === d,
					f = !p || "area" === d,
					v = !p || "input" === d,
					y = !p || "plot" === d ? a.getPlotIdByTitle(t, u) : null,
					h = c ? a.getBandIndexByName(t, u) : null,
					g = f ? a.getFilledAreaIdByTitle(t, u) : null,
					I = v ? a.getInputByName(t, u) : null,
					S = e.hasOwnProperty(u);
				if ((null !== y ? 1 : 0) + (null !== h ? 1 : 0) + (null !== g ? 1 : 0) + (null !== I ? 1 : 0) + (S ? 1 : 0) > 1) return void s.logWarn(`Study '${t.description}' has ambiguous identifier '${u}'`);
				const m = n[1];
				if (null !== y) {
					if (1 === n.length) return void s.logWarn(`Path of sub-property of '${u}' plot for study '${t.description}' must be not empty`);
					const i = n.slice(1);
					o.applyPlotProperty(t, e, y, i, r)
				} else if (null !== I) o.applyInputValue(e, I, r);
				else if (null !== h) {
					if (void 0 === m) return void s.logWarn(`Property name of '${u}' band for study '${t.description}' must be set`);
					o.applyBandProperty(e, h, m, r)
				} else if (null !== g) {
					if (void 0 === m) return void s.logWarn(`Property name of '${u}' area for study '${t.description}' must be set`);
					o.applyFilledAreaProperty(e, g, m, r)
				} else S ? o.setRootProperty(e, n, r) : s.logWarn(`Study '${t.description}' has no plot or input '${u}'`)
			}

			function u(t, e) {
				const i = t.properties(),
					r = i.state();
				for (const i in e) e.hasOwnProperty(i) && l(t.metaInfo(), r, i, e[i]);
				i.mergeAndFire(r)
			}

			function d(t, e, i) {
				for (const r in t) {
					if (!t.hasOwnProperty(r)) continue;
					const n = r.indexOf(".");
					if (-1 === n) continue;
					const o = r.substring(0, n),
						u = a.getMetaInfoByDescription(e, o);
					if (null === u) {
						s.logWarn(`There is no such study ${o}`);
						continue
					}
					const d = i(u);
					null !== d ? l(u, d, r.substring(n + 1), t[r]) : s.logWarn(`Cannot apply overrides for study ${o}`)
				}
			}! function(t) {
				const e = {
					line: n.LineStudyPlotStyle.Line,
					histogram: n.LineStudyPlotStyle.Histogram,
					cross: n.LineStudyPlotStyle.Cross,
					area: n.LineStudyPlotStyle.Area,
					columns: n.LineStudyPlotStyle.Columns,
					circles: n.LineStudyPlotStyle.Circles,
					line_with_breaks: n.LineStudyPlotStyle.LineWithBreaks,
					area_with_breaks: n.LineStudyPlotStyle.AreaWithBreaks
				};
				t.applyPlotProperty = function(t, i, o, a, l) {
					if (void 0 === i.styles) return void s.logWarn("Study does not have styles");
					const u = a[0];
					if ("color" === u) {
						const e = function(t, e, i) {
							if (void 0 === t.plots) return null;
							for (const r of t.plots) {
								if (!(0, n.isPaletteColorerPlot)(r) || void 0 === e.palettes) continue;
								const t = e.palettes[r.palette];
								if (r.target === i && void 0 !== t) return t
							}
							return null
						}(t, i, o);
						return void
						function(t, e, i, n, o) {
							var a;
							void 0 !== t.styles ? null === e && !isNaN(n) && n > 0 ? s.logWarn(`Study plot does not have color #${n}`) : ((0 === n || isNaN(n)) && ((0, r.ensureDefined)(t.styles[i]).color = String(o), n = 0), null !== e && ((0, r.ensureDefined)(null === (a = e.colors) || void 0 === a ? void 0 : a[n]).color = String(o))) : s.logWarn("Study does not have styles")
						}(i, e, o, a.length > 1 ? parseInt(a[1]) : NaN, l)
					}
					const d = i.styles[o];
					if (void 0 !== d && d.hasOwnProperty(u)) {
						if ("plottype" === u) {
							const t = e[String(l)];
							if (void 0 === t) return void s.logWarn(`Unsupported plot type for plot: ${l}`);
							l = t
						}
						d[u] = l
					} else s.logWarn(`Study plot does not have property '${u}'`)
				}, t.applyBandProperty = function(t, i, r, n) {
					if (void 0 === t.bands) return void s.logWarn("Study does not have bands");
					const o = t.bands[i];
					if (void 0 !== o && o.hasOwnProperty(r)) {
						if ("plottype" === r) {
							const t = e[String(n)];
							if (void 0 === t) return void s.logWarn(`Unsupported plot type for band: ${n}`);
							n = t
						}
						o[r] = n
					} else s.logWarn(`Study band does not have property '${r}'`)
				}, t.applyFilledAreaProperty = function(t, e, i, r) {
					if (void 0 === t.filledAreasStyle) return void s.logWarn("Study does not have areas");
					const n = t.filledAreasStyle[e];
					void 0 !== n && n.hasOwnProperty(i) ? n[i] = r : s.logWarn(`Study area does not have property '${i}'`)
				}, t.applyInputValue = function(t, e, i) {
					void 0 !== t.inputs && t.inputs.hasOwnProperty(e) ? t.inputs[e] = i : s.logWarn(`Study does not have input '${e}'`)
				}, t.setRootProperty = function(t, e, i) {
					if (0 === e.length) return;
					let r = t;
					for (const t of e.slice(0, -1)) {
						if (null == r || !r.hasOwnProperty(t)) break;
						r = r[t]
					}
					const n = e[e.length - 1];
					null != r && r.hasOwnProperty(n) ? r[n] = i : s.logWarn(`Study does not have property ${e.join(".")}`)
				}
			}(o || (o = {})),
			function(t) {
				t.getInputByName = function(t, e) {
					if (void 0 === t.inputs) return null;
					e = e.toLowerCase();
					for (const i of t.inputs)
						if (i.name.toLowerCase() === e) return i.id;
					return null
				}, t.getPlotIdByTitle = function(t, e) {
					if (void 0 === t.styles) return null;
					e = e.toLowerCase();
					for (const i in t.styles) {
						const r = t.styles[i];
						if ((void 0 !== r && void 0 !== r.title ? r.title : i).toLowerCase() === e) return i
					}
					return null
				}, t.getFilledAreaIdByTitle = function(t, e) {
					if (void 0 === t.filledAreas) return null;
					e = e.toLowerCase();
					for (const i of t.filledAreas)
						if (i.title.toLowerCase() === e) return i.id;
					return null
				}, t.getBandIndexByName = function(t, e) {
					if (void 0 === t.bands) return null;
					e = e.toLowerCase();
					for (let i = 0; i < t.bands.length; ++i)
						if (t.bands[i].name.toLowerCase() === e) return i;
					return null
				}, t.getMetaInfoByDescription = function(t, e) {
					e = e.toLowerCase();
					for (const i of t)
						if (i.description.toLowerCase() === e || i.shortDescription.toLowerCase() === e) return i;
					return null
				}
			}(a || (a = {}))
		},
		170112: (t, e, i) => {
			var r = i(813652).Version,
				n = i(911905).getLogger("Chart.StudyMigration");

			function s(t) {
				this._studyId = t, this._maxToVers = r.ZERO, this._maxFromVers = r.ZERO, this._migrs = []
			}
			s.prototype.addMigration = function(t, e, i) {
					var n = r.parse(t),
						s = r.parse(e);
					n.isGreater(this._maxFromVers) && (this._maxFromVers = n), s.isGreater(this._maxToVers) && (this._maxToVers = s), this._migrs.push({
						fromVers: n,
						toVers: s,
						rules: i
					})
				}, s.prototype.updateInputs = function(t, e, i) {
					if (!i) return i;
					for (var r = TradingView.clone(i), s = t; s.isLess(e);) {
						var o = this._findMigration(s);
						if (null == o) break;
						if (n.logNormal("Migrating study inputs from " + o.fromVers + " to " + o.toVers + " version, studyId: " + this._studyId + ", migration: " + JSON.stringify(o) + ", inputs: " + JSON.stringify(i)), r = this._applyMigration(r, o), !s.isLess(o.toVers)) throw new Error("Problems in study migration process... Possible infinite cycle has been detected and stopped.");
						s = o.toVers
					}
					return s > t && n.logNormal("Study inputs migration is done, studyId: " + this._studyId + ", inputs: " + JSON.stringify(r)), r
				}, s.prototype._findMigration = function(t) {
					for (var e = -1, i = this._maxFromVers, r = 0; r < this._migrs.length; r++) {
						var n = this._migrs[r];
						n.fromVers.isLess(t) || n.fromVers.isLessOrEqual(i) && (i = n.fromVers, e = r)
					}
					return e < 0 ? null : this._migrs[e]
				}, s.prototype._applyMigration = function(t, e) {
					for (var i = t, r = 0; r < e.rules.length; r++) {
						var n = e.rules[r];
						i = this._getApplyRuleFun(n.type)(i, n)
					}
					return i
				}, s.prototype._getApplyRuleFun = function(t) {
					if ("inputRemoved" === t) return s._applyInputRemovedRule;
					if ("inputChangedType" === t) return s._applyInputChangedTypeRule;
					if ("inputChangedMinMax" === t) return s._applyInputChangedMinMaxRule;
					if ("inputChangedOptions" === t) return s._applyInputChangedOptionsRule;
					throw new Error("Unknown migration rule type: " + t)
				}, s._applyInputRemovedRule = function(t, e) {
					if (!(e.inputId in t)) return t;
					if ("removeVal" !== e.action) throw new Error("Unexpected rule.action=" + e.action + " in rule.type=" + e.type);
					var i = t[e.inputId];
					return delete t[e.inputId], n.logNormal("Input " + e.inputId + "=" + i + " removed"), t
				}, s._applyInputChangedTypeRule = function(t, e) {
					var i = t[e.inputId];
					if ("resetToDefVal" === e.action) return t[e.inputId] = e.defVal, n.logNormal("Input " + e.inputId + "=" + i + " reset to default value " + e.defVal), t;
					if ("convertVal" === e.action) {
						if (null == i) return t;
						if ("float" === e.inputTypeFrom && "integer" === e.inputType) return t[e.inputId] = Math.round(t[e.inputId]), n.logNormal("Input " + e.inputId + "=" + i + " converted to value " + t[e.inputId]), t;
						if ("integer" === e.inputTypeFrom && "float" === e.inputType) return t;
						if ("text" === e.inputTypeFrom && "source" === e.inputType) return s._isValidSource(i, e.options) || (t[e.inputId] = e.defVal), t;
						throw new Error("Cannot convertVal from " + e.inputTypeFrom + " to " + e.inputType)
					}
					throw new Error("Unknown action " + e.action + " for rule with type " + e.type)
				}, s._isValidSource = function(t, e) {
					return t.indexOf("$") >= 0 || e.indexOf(t) >= 0
				}, s._applyInputChangedMinMaxRule = function(t, e) {
					if ("adjustValIfNeeded" !== e.action) throw new Error("Unknown action " + e.action + " for rule with type " + e.type);
					var i = t[e.inputId];
					return i < e.minVal ? t[e.inputId] = e.minVal : i > e.maxVal && (t[e.inputId] = e.maxVal), n.logNormal("Input " + e.inputId + "=" + i + " adjusted to value " + t[e.inputId]), t
				}, s._applyInputChangedOptionsRule = function(t, e) {
					if (!(["text"].indexOf(e.inputType) >= 0 && "resetToDefValIfNeeded" === e.action)) throw new Error("Unexpected rule.inputType=" + e.inputType + " in rule.action=" + e.action);
					var i = t[e.inputId];
					return e.options.indexOf(i) < 0 && (t[e.inputId] = e.defVal, n.logNormal("Input " + e.inputId + "=" + i + " reset to default value " + e.defVal)), t
				},
				t.exports = s
		},
		610498: (t, e, i) => {
			var r = i(588537).assert,
				n = i(469411).patchSourceState,
				s = i(366156),
				o = i(813652).Version,
				a = i(911905).getLogger("Chart.Study.Versioning"),
				l = i(66974),
				u = i(970028).StudyMetaInfo,
				d = i(971417).extractPineId,
				p = i(481211).migrateMetaInfoAndPropState;

			function c(t, e) {
				if (!t) throw new Error("No studies metainfo");
				var r = i(170112);
				if (this._studiesMetainfo = t, !e) throw new Error("No studies migrations");
				this._studiesMigrations = e, this._migrations = {};
				for (var n = 0; n < this._studiesMigrations.length; n++)
					for (var s = this._studiesMigrations[n], o = s.versFrom, l = s.versTo, u = 0; u < s.studyMigrations.length; u++) {
						var d = s.studyMigrations[u],
							p = d.studyId;
						if (0 !== d.rules.length) {
							var c = p in this._migrations ? this._migrations[p] : new r(p);
							c.addMigration(o, l, d.rules), this._migrations[p] = c
						} else a.logError("Study Migration should have at least one convertion rule")
					}
				this._clientMigrations = [function(t, e) {
					if (0 === this._studiesMetainfo.length || !t.isTVScript || t.version >= 22) return e;
					for (var i = {}, r = 0, n = 0;;) {
						var s = e[n];
						if (void 0 === s) break;
						var o = e[s.id];
						s.isFake && (s.id = "in_" + r++), i[n] = s, i[s.id] = o, n++
					}
					return i
				}]
			}
			c.prototype.updateMetaInfo = function(t) {
					if (!t) return t;
					r(!t.isTVScript, "This method should update only built-in java indicators metaInfo. For Pine indicators use updateMetaInfoAsync");
					for (var e = null, i = this._studiesMetainfo, n = 0; n < i.length; n++)
						if (i[n].id === t.id) {
							e = i[n];
							break
						} return TradingView.clone(e)
				}, c.prototype.updateMetaInfoAsync = function(t) {
					if (!t) return {
						sync: !1,
						result: Promise.reject("No old metaInfo was given")
					};
					var e = new u(t),
						i = u.versionOf(t);
					if (t.isTVScript && !t.pine && i < u.VERSION_PINE_PROTECT_TV_4164) {
						r(TradingView.isExistent(t.scriptIdPart), "scriptIdPart is missing, study " + JSON.stringify(t));
						var n = t.scriptIdPart,
							o = new Promise((function(i, r) {
								s.processLegacy(n, t.TVScriptSourceCode).done((function(t) {
									e.removeDefaults();
									var r = new u(t);
									r.createDefaults(), p(r), i(r)
								})).fail((function(t, e) {
									r(t)
								}))
							}));
						return {
							sync: !1,
							result: o
						}
					}
					if (t.isTVScript && t.pine) {
						if ((t._serverMetaInfoVersion || i) < u.CURRENT_METAINFO_FORMAT_VERSION) {
							o = new Promise((function(i, r) {
								s.translateScriptAsync2(t.scriptIdPart, t.pine.version).done((function(t) {
									e.removeDefaults();
									var r = new u(t);
									r.createDefaults(), p(r), i(r)
								})).fail((function(t, e) {
									r(t)
								}))
							}));
							return {
								sync: !1,
								result: o
							}
						}
						return e.createDefaults(), {
							sync: !0,
							result: e
						}
					}
					for (var a = null, l = this._studiesMetainfo, d = 0; d < l.length; d++)
						if (l[d].id === t.id) {
							a = l[d];
							break
						} return {
						sync: !0,
						result: a ? TradingView.clone(a) : null
					}
				}, c.prototype.lastVersionOfStudy = function(t) {
					return this._studiesMetainfo.find((function(e) {
						return e.id === t
					})).version
				}, c.prototype.updateStudyInputs = function(t, e, i, r, n) {
					var s = TradingView.clone(r);
					if (t in this._migrations) {
						var l, u = o.parse(e);
						if ("last" === i) {
							var d = this.lastVersionOfStudy(t);
							l = o.parse(d)
						} else l = o.parse(i);
						s = this._migrations[t].updateInputs(u, l, s)
					}
					if (null == n) return s;
					for (var p in n) p in s || (s[p] = n[p]);
					for (var p in s)
						if (!(p in n)) {
							var c = s[p];
							a.logWarn("Extra input detected, studyId=" + t + ", versionFrom=" + e + ", inputId=" + p + ", inputValue=" + c + ", removing it and continue..."), delete s[p]
						} return s
				},
				c.prototype.updateStudyState = function(t, e, i) {
					if (null == t || null == e || null == i) return t;
					if (t = TradingView.clone(t), !(e.isTVScript || !!e.pine) && e.version !== i.version) {
						var r = i && i.defaults.inputs,
							n = this.updateStudyInputs(e.id, e.version, i.version, t.inputs, r);
						t.inputs = n
					}
					for (var s = 0; s < this._clientMigrations.length; ++s) {
						n = this._clientMigrations[s].call(this, e, t.inputs);
						Object.keys(n).length === Object.keys(t.inputs).length ? t.inputs = n : a.logWarn("StudyVersioning._clientMigrations application returned bad result. Skipping it...")
					}
					var o = u.versionOf(e);
					if (e.isTVScript && e.TVScriptSourceCode && o >= 12 && o <= 26) {
						var l = {};
						for (s = 0; s < e.plots.length; ++s) {
							var d = e.plots[s],
								p = i.plots[s];
							l[d.id] = p.id
						}
						var c = Object.keys(t.styles);
						for (s = 0; s < c.length; ++s) {
							var f = c[s],
								v = t.styles[f];
							delete t.styles[f];
							var y = l[f];
							t.styles[y] = v
						}
						var h = Object.keys(t.plots);
						for (s = 0; s < h.length; ++s) {
							var g = h[s];
							f = t.plots[g].id;
							t.plots[g].id = l[f]
						}
					}
					return t
				}, c.prototype.patchPointsBasedStudyState = function(t) {
					return c._fixInputsMaxValue(t.state, t.metaInfo), "LineToolRegressionTrend" === t.type && (t = n(t)), t
				}, c.prototype.patchPointsBasedStudyData = function(t, e) {
					if (!l.isProd()) return e;
					if (!t || !e) return e;
					var i = TradingView.clone(e);
					return "VbPFixed@tv-volumebyprice" === t.id && t.version && t.version <= 4 && c._patchOldVolumeProfiles(0, i), i
				}, c.prototype.patchStudyData = function(t, e, i, r) {
					if (!l.isProd()) return {
						data: e,
						nsData: i,
						indexes: r
					};
					var n = TradingView.clone(e),
						s = TradingView.clone(i),
						o = TradingView.clone(r);
					"VbPVisible@tv-volumebyprice" === t.id && t.version && t.version <= 4 && c._patchOldVolumeProfiles(0, n.graphics), "VbPSessions@tv-volumebyprice" === t.id && t.version && t.version <= 4 && c._patchOldVolumeProfiles(0, n.graphics);
					var a = u.versionOf(t);
					if (t.isTVScript && t.TVScriptSourceCode && a >= 12 && a <= 26) {
						var d = n.columns;
						n.columns = [];
						for (var p = 0; p < d.length; ++p) {
							var f = "plot_" + p;
							n.columns.push(f)
						}
					}
					return {
						data: n,
						nsData: s,
						indexes: o
					}
				}, c._patchOldVolumeProfiles = function(t, e) {
					var i = e.hhists[t].data,
						r = [];
					for (var n in i) r = r.concat(i[n]);
					e.hhists[0].data = r
				}, c._fixInputsOrder = function(t, e) {
					for (var i = u.getOrderedInputIds(e), r = c.splitInputs(t.inputs), n = r.arr, s = r.obj, o = TradingView.merge({}, s), a = 0; a < i.length; ++a) {
						var l = i[a],
							d = c.findInputKeyById(n, l);
						if (null !== d) {
							var p = n[d];
							o[a] = p
						}
					}
					t.inputs = o
				}, c.INPUT_MAX_VALUE = 1e12, c._verifyInputsMaxValue = function(t) {
					var e = c.INPUT_MAX_VALUE;
					if (t.inputs)
						for (var i = 0; i < t.inputs.length; i++) {
							var r = t.inputs[i];
							"integer" === r.type && (r.max && r.max > e && a.logWarn("Bad integer input max value in metaInfo id=" + t.id + " title=" + t.description))
						}
				}, c._fixInputsMaxValue = function(t, e) {
					if (!TradingView.isAbsent(e)) {
						var i = c.INPUT_MAX_VALUE;
						if (e.inputs)
							for (var r = 0; r < e.inputs.length; r++) {
								"integer" === (a = e.inputs[r]).type && (a.max && a.max > i && (a.max = i))
							}
						if (t && t.inputs) {
							var n = c.splitInputs(t.inputs),
								s = n.arr;
							for (var o in s) {
								var a;
								"integer" === (a = s[o]).type && (a.max && a.max > i && (a.max = i))
							}
							t.inputs = TradingView.merge(n.obj, n.arr)
						}
					}
				}, c.prototype.patchPropsStateAndMetaInfo = function(t, e, i) {
					"Script$BOOKER" !== e.productId || e.alerts || delete t.alerts, c._fixInputsOrder(t, e), c._fixInputsMaxValue(t, e);
					var r = c.splitInputs(t.inputs);
					t.inputs = r.obj;
					var n = u.versionOf(e);
					n < u.METAINFO_FORMAT_VERSION_SOS_V2 && e.isChildStudy && (t.isChildStudy = e.isChildStudy);
					if (e.isTVScript && e.version < 60 && ("Script$TV_EARNINGS@tv-scripting" !== e.id && "Script$TV_DIVIDENDS@tv-scripting" !== e.id && "Script$TV_SPLITS@tv-scripting" !== e.id || delete e.TVScriptSourceCode), "Volume" !== e.id && "Volume@tv-basicstudies" !== e.id || 0 !== e.inputs.length || (e.inputs = [{
							id: "length",
							type: "integer",
							defval: 20,
							min: 1,
							max: 1e3
						}], e.plots.push({
							id: "vol_ma",
							type: "line"
						})), "Volume@tv-basicstudies" === e.id && e.version && e.version <= 46 && void 0 === t.styles.vol.transparency && (t.styles.vol.transparency = t.transparency || 87), "PivotPointsStandard@tv-basicstudies" === e.id && (0 === e.inputs.length ? (t.inputs = {
							kind: "Traditional",
							showHistoricalPivots: !0
						}, e.inputs = [{
							defval: "Traditional",
							id: "kind",
							type: "text",
							options: ["Traditional", "Fibonacci", "Woodie", "Classic", "DeMark", "Camarilla"]
						}, {
							id: "showHistoricalPivots",
							type: "bool",
							defval: !0
						}]) : 1 === e.inputs.length && (t.inputs = {
							kind: "Traditional"
						}, e.inputs = [{
							defval: "Traditional",
							id: "kind",
							type: "text",
							options: ["Traditional", "Fibonacci", "Woodie", "Classic", "DeMark", "Camarilla"]
						}, {
							id: "showHistoricalPivots",
							type: "bool",
							defval: !0
						}]), void 0 === t._hardCodedDefaultsVersion)) {
						t._hardCodedDefaultsVersion = 1;
						var s = t.color;
						delete t.color, t.levelsStyle = {
							colors: {
								P: s,
								"S1/R1": s,
								"S2/R2": s,
								"S3/R3": s,
								"S4/R4": s,
								"S5/R5": s
							}
						}
					}
					"CMF" === e.shortId && 2 === e.inputs.length && (t.inputs = {
						length: t.inputs["length fast"]
					}, e.inputs = e.inputs.splice(0, 1), e.inputs[0].id = "length"), e.defaults && void 0 === e.defaults.precision && n < u.VERSION_NEW_STUDY_PRECISION_FORMAT && (-1 !== ["Volume@tv-basicstudies", "VbPVisible@tv-volumebyprice", "VbPSessions@tv-volumebyprice"].indexOf(e.id) ? e.defaults.precision = 0 : e.defaults.precision = 4);
					if (e.version < 60)
						for (var o = ["TV_DIVIDENDS", "TV_SPLITS", "TV_EARNINGS"], a = "Script".length, l = 0; l < o.length; l++) e.id.startsWith("Script$" + o[l] + "@tv-scripting") && (e.fullId = "ESD" + e.fullId.substring(a), e.id = "ESD" + e.id.substring(a), e.name = "ESD" + e.name.substring(a), e.shortId = "ESD" + e.shortId.substring(a), e.productId = "ESD" + e.productId.substring(a));
					var f = {
						"ESD$TV_EARNINGS@tv-scripting": {
							fullId: "Earnings@tv-basicstudies-129!",
							id: "Earnings@tv-basicstudies",
							name: "Earnings@tv-basicstudies",
							shortId: "Earnings",
							productId: "tv-basicstudies"
						},
						"ESD$TV_SPLITS@tv-scripting": {
							fullId: "Splits@tv-basicstudies-129!",
							id: "Splits@tv-basicstudies",
							name: "Splits@tv-basicstudies",
							shortId: "Splits",
							productId: "tv-basicstudies"
						},
						"ESD$TV_DIVIDENDS@tv-scripting": {
							fullId: "Dividends@tv-basicstudies-129!",
							id: "Dividends@tv-basicstudies",
							name: "Dividends@tv-basicstudies",
							shortId: "Dividends",
							productId: "tv-basicstudies"
						}
					};
					if (e.id in f && Object.assign(e, f[e.id]), n < u.VERSION_PINE_PROTECT_TV_4164) {
						var v = {
							"StrategyScript$STD;Consecutive%1Ups/Downs%1Strategy": {
								pineId: "STD;Consecutive%1Ups%1Downs%1Strategy",
								className: "StrategyScript"
							},
							Script$EDGR_NET_INCOME_FROM_CONTINUING_OPERATIONS_APPLICABLE_TO_COMMON_V2: {
								pineId: "Script$EDGR_NET_INCOME_FROM_CONTINUING_OPS_APPLICABLE_TO_COMMON_V2",
								className: "Script"
							}
						};
						if (e.shortId in v) {
							var y = v[e.shortId].className + "$" + v[e.shortId].pineId,
								h = {
									scriptIdPart: v[e.shortId].pineId,
									fullId: e.fullId.replace(e.shortId, y),
									id: e.id.replace(e.shortId, y),
									name: e.name.replace(e.shortId, y),
									shortId: y
								};
							TradingView.merge(e, h), TradingView.merge(t, h)
						}
						var g = d(e.fullId),
							I = g && g.match(/^(USER)(_\d+)(;)(.*)$/);
						if (I) {
							var S = I[0],
								m = I[1] + I[3] + I[2] + I[4];
							h = {
								scriptIdPart: m,
								fullId: e.fullId.replace(S, m),
								id: e.id.replace(S, m),
								name: e.name.replace(S, m),
								shortId: e.shortId.replace(S, m)
							};
							TradingView.merge(e, h), TradingView.merge(t, h)
						}
					}
					if ("MA" === e.id) {
						var _ = new u({
								id: "MAExp",
								properties: [{
									id: "is_price_study",
									type: "bool",
									value: "true"
								}],
								inputs: [{
									id: "length",
									type: "integer",
									defval: 20,
									min: 1,
									max: 500
								}, {
									id: "source",
									type: "text",
									defval: "close",
									options: ["open", "high", "low", "close"]
								}],
								plots: [{
									id: "MovAvgExp",
									type: "line"
								}],
								palettes: {}
							}),
							b = new u({
								id: "MASimple",
								properties: [{
									id: "is_price_study",
									type: "bool",
									value: "true"
								}],
								inputs: [{
									id: "length",
									type: "integer",
									defval: 20,
									min: 1,
									max: 500
								}, {
									id: "source",
									type: "text",
									defval: "close",
									options: ["open", "high", "low", "close"]
								}],
								plots: [{
									id: "MovAvgSimple",
									type: "line"
								}],
								palettes: {}
							}),
							P = new u({
								id: "MAVolumeWeighted",
								properties: [{
									id: "is_price_study",
									type: "bool",
									value: "true"
								}],
								inputs: [{
									id: "length",
									type: "integer",
									defval: 20,
									min: 1,
									max: 500
								}, {
									id: "source",
									type: "text",
									defval: "close",
									options: ["open", "high", "low", "close"]
								}],
								plots: [{
									id: "MovAvgVolumeWeighted",
									type: "line"
								}],
								palettes: {}
							}),
							T = new u({
								id: "MAWeighted",
								properties: [{
									id: "is_price_study",
									type: "bool",
									value: "true"
								}],
								inputs: [{
									id: "length",
									type: "integer",
									defval: 20,
									min: 1,
									max: 500
								}, {
									id: "source",
									type: "text",
									defval: "close",
									options: ["open", "high", "low", "close"]
								}],
								plots: [{
									id: "MovAvgWeighted",
									type: "line"
								}],
								palettes: {}
							});
						switch (t.inputs.type) {
							case "exp":
								e = _;
								break;
							case "simple":
								e = b;
								break;
							case "weighted":
								e = T;
								break;
							case "volume weighted":
								e = P
						}
						t.styles[e.plots[0].id] = t.styles.MovAvg, delete t.styles.MovAvg, delete t.inputs.type
					}
					return i.oldShowStudyLastValueProperty && (t.oldShowLastValue = t.showLastValue), delete t.showLastValue, delete t.showStudyArguments, p(e, t), {
						propsState: t,
						metaInfo: e
					}
				}, c.mergeInputs = function(t, e) {
					c.mergeInputsArrPart(t, e), c.mergeInputsObjPart(t, e)
				}, c.mergeInputsArrPart = function(t, e) {
					var i = c.splitInputs(e);
					for (var r in i.arr) {
						var n = c.findInputKeyById(t, i.arr[r].id);
						n ? TradingView.merge(t[n], i.arr[r]) : c.appendInputInfoToArr(t, i.arr[r])
					}
				}, c.mergeInputsObjPart = function(t, e) {
					var i = c.splitInputs(e);
					TradingView.merge(t, i.obj)
				}, c.appendInputInfoToArr = function(t, e) {
					var i = -1;
					for (var r in t) {
						var n = parseInt(r, 10);
						isNumber(n) && (n > i && (i = n))
					}
					t[i + 1] = e
				}, c.splitInputs = function(t) {
					var e = {},
						i = {};
					for (var r in t) isNumber(parseInt(r, 10)) ? e[r] = t[r] : i[r] = t[r];
					return {
						arr: e,
						obj: i
					}
				}, c.findInputKeyById = function(t, e) {
					var i = null;
					for (var r in t)
						if (isNumber(parseInt(r, 10)) && t[r].id === e) {
							i = r;
							break
						} return i
				}, c.getInputKeyById = function(t, e) {
					var i = c.findInputKeyById(t, e);
					if (!i) throw new Error("Cannot find input with id: " + e);
					return i
				}, t.exports = c
		},
		773547: (t, e, i) => {
			i.d(e, {
				translatedIntervalString: () => n
			});
			var r = i(364019);

			function n(t) {
				const e = (0, r.getTranslatedResolutionModel)(t, !0);
				return null === e ? t : e.multiplier + (e.mayOmitShortKind ? "" : e.shortKind)
			}
		},
		333453: (t, e, i) => {
			i.d(e, {
				StudyMetaInfoBase: () => l
			});
			var r = i(827147),
				n = i(281640);
			const s = new Set(["CorrelationCoefficient@tv-basicstudies", "Correlation - Log@tv-basicstudies-1"]),
				o = new Set([]),
				a = new Set(["line"]);
			class l {
				static getSourceIdByInputs(t, e) {
					if (!Array.isArray(t) || !e) return null;
					for (const i of t)
						if (l.isSourceInput(i) && (0, r.default)(e[i.id])) {
							const t = e[i.id];
							if (t.includes("$")) return t.split("$")[0]
						} return null
				}
				static isSourceInput(t) {
					return Boolean(t.id && (("source" === t.id || "src" === t.id) && ("text" === t.type || "source" === t.type) || "source" === t.type))
				}
				static getSourceInputIds(t) {
					const e = [];
					for (const i of t.inputs) l.isSourceInput(i) && e.push(i.id);
					return e
				}
				static setChildStudyMetaInfoPropertiesSourceId(t, e, i) {
					for (const r of t.inputs) {
						if (!l.isSourceInput(r)) continue;
						const t = i.childs().inputs && i.childs().inputs.childs()[r.id];
						if (t) {
							const i = t.value();
							if (i.includes("$")) {
								const r = i.replace(/^[^\$]+/, e);
								t.setValue(r)
							}
						}
					}
				}
				static canBeChild(t) {
					if ((0, r.default)(t)) return !0;
					if (!t) return !1;
					if (t.extra && !l.isAllowedSourceInputsCount(t.extra.sourceInputsCount) || !0 === t.canNotBeChild || !1 === t.canBeChild || s.has(t.id)) return !1;
					let e = 0;
					for (const i of t.inputs) l.isSourceInput(i) && (e += 1);
					return l.isAllowedSourceInputsCount(e)
				}
				static isAllowedSourceInputsCount(t) {
					return 1 === t
				}
				static canHaveChildren(t) {
					if (t) {
						if (t.isTVScriptStrategy || t.TVScriptSourceCode && (0, n.isStrategy)(t.TVScriptSourceCode)) return !1;
						if (t.id && !o.has(t.id) && Array.isArray(t.plots))
							for (const e of t.plots)
								if (a.has(e.type)) return !0
					}
					return !1
				}
				static getChildSourceInputTitles(t, e, i) {
					var r;
					const n = {};
					if (e.plots && e.plots.length && t.options && t.options.length)
						for (const s of t.options) {
							const t = s ? +s.split("$")[1] : NaN,
								o = isFinite(t) && e.plots[t];
							o && a.has(o.type) && (n[s] = e.styles && e.styles[o.id] && (null === (r = e.styles[o.id]) || void 0 === r ? void 0 : r.title) || o.id, i && (n[s] = i + ":â€‰" + n[s]))
						}
					return n
				}
				static canPlotBeSourceOfChildStudy(t) {
					return a.has(t)
				}
			}
		},
		970028: (t, e, i) => {
			i.r(e), i.d(e, {
				StudyMetaInfo: () => u
			});
			var r = i(911905).getLogger("Chart.Study.MetaInfo"),
				n = i(594930).applyOverridesToStudyDefaults,
				s = i(333453).StudyMetaInfoBase,
				o = i(520533).PineKind,
				a = {},
				l = new Map([
					["AnchoredVWAP@tv-basicstudies", "linetoolanchoredvwap"],
					["RegressionTrend@tv-basicstudies", "linetoolregressiontrend"]
				]);
			class u extends s {
				constructor(t) {
					super(), TradingView.merge(this, {
						palettes: {},
						inputs: [],
						plots: [],
						graphics: {},
						defaults: {}
					}), TradingView.merge(this, t);
					var e = t.fullId || t.id;
					TradingView.merge(this, u.parseIdString(e))
				}
				static versionOf(t) {
					var e = "_metainfoVersion" in t && isNumber(t._metainfoVersion) ? t._metainfoVersion : 0;
					return e < 0 && r.logError("Metainfo format version cannot be negative: " + e), e
				}
				static parseIdString(t) {
					var e = {};
					if (-1 === t.indexOf("@")) e.shortId = t, e.packageId = "tv-basicstudies", e.id = t + "@" + e.packageId, e.version = 1;
					else {
						var i = t.split("@");
						e.shortId = i[0];
						var r = i[1].split("-");
						if (3 === r.length) e.packageId = r.slice(0, 2).join("-"), e.id = e.shortId + "@" + e.packageId, e.version = r[2];
						else if (1 === r.length && "decisionbar" === r[0]) e.packageId = "les-" + r[0], e.id = e.shortId + "@" + e.packageId, e.version = 1;
						else {
							if (1 !== r.length) throw new Error("unexpected study id:" + t);
							e.packageId = "tv-" + r[0], e.id = e.shortId + "@" + e.packageId, e.version = 1
						}
					}
					if (e.fullId = e.id + "-" + e.version, "tv-scripting" === e.packageId) {
						var n = e.shortId;
						if (0 === n.indexOf("Script$") || 0 === n.indexOf("StrategyScript$")) {
							var s = n.indexOf("_");
							e.productId = s >= 0 ? n.substring(0, s) : e.packageId
						} else e.productId = e.packageId
					} else e.productId = e.packageId;
					return e
				}
				static getPackageName(t) {
					return (/^[^@]+@([^-]+-[^-]+)/.exec(t || "") || [0, "tv-basicstudies"])[1]
				}
				static cutDollarHash(t) {
					var e = t.indexOf("$"),
						i = t.indexOf("@");
					return -1 === e ? t : t.substring(0, e) + (i >= 0 ? t.substring(i) : "")
				}
				static hasUserIdSuffix(t) {
					return /^USER;[\d\w]+;\d+$/.test(t)
				}
				static isStandardPine(t) {
					return /^(Strategy)?Script\$STD;.*@tv-scripting$/.test(t)
				}
				static patchChildStudyMetaInfoState(t) {
					t.state && function t(e) {
						if ("object" == typeof e)
							for (var i in e) "string" == typeof e[i] && /^[^\$]+\$\d+$/.test(e[i]) ? e[i] = e[i].replace(/^[^\$]+/, "{pid}") : t(e[i])
					}(t.state.inputs), t.state.isChildStudy = !0
				}
				static getStudyIdWithLatestVersion(t) {
					const e = u.cutDollarHash(t.id),
						i = e.indexOf("CP@tv-basicstudies") >= 0;
					let r = e;
					return e.indexOf("@tv-scripting") >= 0 ? r += "-101!" : r += i ? "-" + t.version + "!" : "-" + t.version, r
				}
				parseValue(t, e) {
					return "bool" === t ? TradingView.parseBool(e) : e
				}
				defaultInputs() {
					for (var t = [], e = 0; e < this.inputs.length; e++) t.push(this.inputs[e].defval);
					return t
				}
				state(t) {
					var e = {};
					for (var i in this) this.hasOwnProperty(i) && (e[i] = this[i], !0 !== t && "id" === i && (e[i] += "-" + this.version));
					return e
				}
				symbolInputId() {
					var t = this.inputs.filter((function(t) {
						return "symbol" === t.type
					}));
					return t.length > 0 ? t[0].id : null
				}
				createDefaults() {
					if (this.defaults) {
						var t = TradingView.clone(this.defaults);
						t.precision = "default";
						var e = u.getStudyPropertyRootName(this);
						defaults.create(e, t)
					}
				}
				removeDefaults() {
					defaults.remove(u.getStudyPropertyRootName(this))
				}
				static findStudyMetaInfoByDescription(t, e) {
					if (t) {
						for (var i = 0; i < t.length; ++i)
							if (t[i].description.toLowerCase() === e.toLowerCase()) return t[i];
						throw new Error("unexpected study id:" + e)
					}
					throw new Error("There is no studies metainfo")
				}
				static isParentSourceId(t) {
					return "string" == typeof t && /^[^\$]+\$\d+$/.test(t)
				}
				static getStudyPropertyRootName(t) {
					var e = l.get(t.id);
					if (void 0 !== e) return e;
					var i = "study_" + t.id;
					return t.pine && t.pine.version && (i += "_" + t.pine.version.replace(".", "_")), i
				}
				static getStudyPropertyRootNameById(t) {
					var e = l.get(t);
					return void 0 !== e ? e : "study_" + t
				}
				static overrideDefaults(t) {
					0 !== t.length && n(a, t, (function(t) {
						return TradingView.defaultProperties[u.getStudyPropertyRootName(t)] || null
					}))
				}
				static mergeDefaultsOverrides(t) {
					TradingView.merge(a, t)
				}
				static isScriptStrategy(t) {
					if (t.extra && t.extra.kind) return t.extra.kind === o.Strategy;
					if (!0 === t.isTVScriptStrategy) return !0;
					var e = t.TVScriptSourceCode || t.scriptSource;
					return !!e && TVScript.isStrategy(e)
				}
				static getOrderedInputIds(t) {
					for (var e = [], i = t.inputs, r = 0; r < i.length; ++r) {
						var n = i[r];
						e.push(n.id)
					}
					return e
				}
			}
			u.VERSION_STUDY_ARG_SOURCE = 41, u.METAINFO_FORMAT_VERSION_SOS_V2 = 42, u.VERSION_PINE_PROTECT_TV_4164 = 43, u.CURRENT_METAINFO_FORMAT_VERSION = 52, u.VERSION_NEW_STUDY_PRECISION_FORMAT = 46, u.FilledArea = {}, u.FilledArea.TYPE_PLOTS = "plot_plot",
				u.FilledArea.TYPE_HLINES = "hline_hline", TradingView.StudyMetaInfo = u
		},
		270369: (t, e, i) => {
			var r;
			i.d(e, {
					DataSourceDangerReason: () => r
				}),
				function(t) {
					t.Spread = "spread", t.PineRepainting = "pine-repainting", t.CryptoCap = "cryptocap"
				}(r || (r = {}))
		},
		386189: (t, e, i) => {
			var r = i(575932).t,
				n = i(496396).isStudyStateForAlertType,
				s = i(418458),
				o = i(902105).generateTitleForGui,
				a = i(911905).getLogger("Alerts.Band"),
				l = i(749473),
				u = i(143498);
			TradingView = "object" == typeof i.g ? i.g.TradingView : TradingView || {};
			var d = {
				create: function(t) {
					var e, i = t || {},
						r = i.type;
					if ("MainSeries" === r) e = c;
					else if (n(r, !0)) e = f;
					else if ("Value" === r) e = v;
					else {
						if (!/^LineTool.*/i.test(r)) return a.logError("Unknown alert band type " + r), null;
						e = y
					}
					return new e(i)
				}
			};

			function p(t) {
				this._band = t || {}
			}

			function c() {
				p.apply(this, arguments)
			}

			function f() {
				p.apply(this, arguments)
			}

			function v() {
				p.apply(this, arguments)
			}

			function y() {
				p.apply(this, arguments)
			}
			p.prototype.id = function() {
				return this._band.id
			}, p.prototype.type = function() {
				return this._band.type
			}, p.prototype.title = function() {
				return this._band.title
			}, p.prototype.hasPlots = function() {
				return this._band.plots && this._band.plots.length
			}, p.prototype.getActualSymbol = function() {
				return this._band.actualSymbol
			}, p.prototype.getSymbolString = function() {
				return this._band.symbolString
			}, p.prototype.getPlotTitle = function(t) {
				return t.title ? t.title : s.isOhlcOpenPlot(t) ? t.ohlcTitle + " " + r("Open") : s.isOhlcHighPlot(t) ? t.ohlcTitle + " " + r("High") : s.isOhlcLowPlot(t) ? t.ohlcTitle + " " + r("Low") : s.isOhlcClosePlot(t) ? t.ohlcTitle + " " + r("Close") : "vol" === t.id ? r("Volume") : "vol_ma" === t.id ? r("Volume MA") : "open" === t.id ? r("Open") : "high" === t.id ? r("High") : "low" === t.id ? r("Low") : "close" === t.id ? r("Close") : t.id
			}, p.prototype.getPlots = function(t) {
				var e = t || {};
				if (!this._band.plots || !this._band.plots.length) return this._band.plots;
				if ("inputSelect" === e.format) {
					var i = -1;
					return this._band.plots.map((function(t) {
						return {
							value: ++i,
							title: this.getPlotTitle(t)
						}
					}), this)
				}
				return this._band.plots
			}, p.prototype.hasUsualPlots = function() {
				var t = this._band.plots;
				return !t || t.filter(s.isAlertConditionPlot).length < t.length
			}, p.prototype.getInputs = function() {
				return {}
			}, inherit(c, p), c.prototype.title = function(t) {
				var e = i(166437),
					r = t || {},
					n = !!r.withInterval,
					s = this._band.actualSymbol;
				return e && (s = e.shortName(s)), o({
					symbol: s,
					interval: n ? this._band.interval : null,
					style: this._band.style,
					inputs: this._band.styleInputs || {},
					boxSize: this._band.boxSize,
					reversalAmount: this._band.reversalAmount,
					sessionDescription: r.sessionDescription
				})
			}, c.prototype.getInterval = function() {
				return this._band.interval
			}, c.prototype.getStyle = function() {
				return this._band.style
			}, c.prototype.getStyleInputs = function() {
				return this._band.styleInputs
			}, c.prototype.isRangeBasedStyle = function() {
				return l.isRangeBasedStyle(this._band.style)
			}, c.prototype.isSpread = function() {
				return this._band.isSpread
			}, c.prototype.sessionId = function() {
				return this._band.sessionId
			}, c.prototype.sessionDescription = function() {
				return this._band.sessionDescription
			}, c.prototype.getDividendsAdjustment = function() {
				return this._band.dividendsAdjustment
			}, c.prototype.getBackAdjustment = function() {
				return this._band.backAdjustment
			}, c.prototype.getSettlementAsClose = function() {
				return this._band.settlementAsClose
			}, inherit(f, p), f.prototype.title = function(t) {
				var e, i, n, s = t || {},
					o = s.withPlotTitle,
					a = this._band;
				return s.short && a.shortTitle ? e = a.shortTitle : a.title ? e = a.title : (e = a.shortDescription || "Study", i = [], Object.keys(a.inputs).forEach((function(t) {
					var e = a.inputs[t] && a.inputs[t].id;
					e && !a.inputs[t].isHidden && void 0 !== a.inputs[e] && i.push(a.inputs[e])
				})), i.length && (e += " (" + i.join(", ") + ")")), o && (n = this.selectedPlot()) && (e += " " + (n.title || r("Untitled Plot"))), u.isRtl() && (e = u.forceLTRStr(e)), e
			}, f.prototype.selectedPlot = function() {
				var t = this._band;
				return void 0 === t.plotIndex ? null : this.getPlots().filter((function(e) {
					return e.value === t.plotIndex
				}))[0] || null
			}, f.prototype.getInputs = function() {
				return this._band.inputs || {}
			}, f.prototype.isTVLibrary = function() {
				return this._band.isTVLibrary || !1
			}, inherit(v, p), v.prototype.title = function(t) {
				var e = this._band.value || 0;
				return t.formatter ? t.formatter.format(parseFloat(e)) : parseFloat(e).toString()
			}, inherit(y, p), t.exports.AlertBandAbstract = p, t.exports.AlertBandValue = v, t.exports.AlertBandStudy = f, t.exports.alertBandFactory = d
		},
		496396: (t, e, i) => {
			var r;

			function n(t, e) {
				let i = "Study" === t || t === r.StudyLineTool || /^study_\w+/.test(t);
				return e && (i = i || "StudyStrategy" === t), i
			}
			i.r(e), i.d(e, {
					StateForAlertType: () => r,
					isStudyStateForAlertType: () => n
				}),
				function(t) {
					t.StudyLineTool = "StudyLineTool"
				}(r || (r = {}))
		},
		290557: (t, e, i) => {
			function r(t) {
				let e, i = 0;
				if (0 === t.length) return i;
				for (var r = 0; r < t.length; r++) e = t.charCodeAt(r), i = (i << 5) - i + e, i &= i;
				return i
			}
			i.r(e), i.d(e, {
				hash: () => r
			})
		},
		971417: (t, e, i) => {
			function r(t) {
				return t === n(t)
			}

			function n(t) {
				const e = t.indexOf("$"),
					i = t.indexOf("@");
				return e < 0 && i >= 0 ? null : t.substring(Math.max(e + 1, 0), i >= 0 ? i : t.length)
			}

			function s(t) {
				return t.startsWith("PUB;")
			}

			function o(t) {
				return t.startsWith("USER;")
			}

			function a(t) {
				return t.startsWith("STD;")
			}

			function l(t) {
				return t.includes("Candlestick%1Pattern%1")
			}

			function u(t) {
				return t.startsWith("EDGR_")
			}
			i.d(e, {
				isPineIdString: () => r,
				extractPineId: () => n,
				isPublishedPineId: () => s,
				isCustomPineId: () => o,
				isStandardPineId: () => a,
				isCandleStickId: () => l,
				isEdgrPineId: () => u
			})
		}
	}
]);