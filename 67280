"use strict";
(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
	[67280], {
		827147: (t, e, s) => {
			s.d(e, {
				default: () => o
			});
			var i = s(128177),
				n = s(854814),
				r = s(383527);
			const o = function(t) {
				return "string" == typeof t || !(0, n.default)(t) && (0, r.default)(t) && "[object String]" == (0, i.default)(t)
			}
		},
		294766: (t, e, s) => {
			s.d(e, {
				createDwmAligner: () => u,
				createTimeToBarTimeAligner: () => c
			});
			var i = s(393987),
				n = s(611688),
				r = s(273044),
				o = s(874200),
				a = s(566190);
			const l = new o.SessionInfo("Etc/UTC", "0000-0000:1234567");

			function u(t, e) {
				if (!d() || !r.Interval.isDWM(t)) return null;
				const s = new o.SessionInfo(e.timezone, e.session, e.session_holidays, e.corrections),
					n = (0, a.newBarBuilder)(t, s, l);
				return {
					timeToSessionStart: t => n.tradingDayToSessionStart(t),
					timeToExchangeTradingDay: t => {
						const e = i.utc_to_cal(s.timezone, t),
							n = s.spec.correctTradingDay(e);
						return i.set_hms(n, 0, 0, 0, 0, i.get_timezone("Etc/UTC")), n.getTime()
					}
				}
			}

			function d() {
				return !n.enabled("disable_resolution_rebuild")
			}

			function c(t, e) {
				if (!d()) return t => t;
				const s = new o.SessionInfo(e.timezone, e.session, e.session_holidays, e.corrections),
					i = (0, a.newBarBuilder)(t, s, s, !1);
				return t => i.alignTimeIfPossible(t)
			}
		},
		540968: (t, e, s) => {
			s.r(e), s.d(e, {
				cloneLineTool: () => te,
				createLineTool: () => Gt,
				createLineToolProperties: () => qt,
				createStudyLineToolProperties: () => Kt,
				getNewToolProperties: () => jt,
				isLineDrawnWithPressedButton: () => Wt.isLineDrawnWithPressedButton,
				isLineTool: () => Jt,
				isLineToolName: () => Wt.isLineToolName,
				isStudyLineTool: () => Qt,
				isStudyLineToolName: () => Wt.isStudyLineToolName,
				isTrading: () => Yt,
				lineToolByLinkKey: () => ee,
				prepareLineToolPropertiesByOwnerSource: () => Ht,
				setNewToolProperties: () => zt,
				supportsPhantomMode: () => Xt,
				tryFindStudyLineToolNameByStudyId: () => Zt,
				unsetNewToolProperties: () => $t
			});
			var i = {};
			s.r(i), s.d(i, {
				LineStudyMtpAnalysis: () => tt,
				LineStudyMtpDecisionPoint: () => st,
				LineStudyMtpDownWave1OrA: () => _t,
				LineStudyMtpDownWave2OrB: () => St,
				LineStudyMtpDownWave3: () => ft,
				LineStudyMtpDownWave4: () => gt,
				LineStudyMtpDownWave5: () => bt,
				LineStudyMtpDownWaveC: () => vt,
				LineStudyMtpElliotWaveMain: () => at,
				LineStudyMtpElliotWaveMajor: () => ut,
				LineStudyMtpElliotWaveMinor: () => ct,
				LineStudyMtpRiskReward: () => nt,
				LineStudyMtpUpWave1OrA: () => Tt,
				LineStudyMtpUpWave2OrB: () => Vt,
				LineStudyMtpUpWave3: () => Dt,
				LineStudyMtpUpWave4: () => Mt,
				LineStudyMtpUpWave5: () => Rt,
				LineStudyMtpUpWaveC: () => Bt
			});
			var n = s(588537),
				r = s(86441),
				o = s(417791),
				a = s(724145),
				l = s(103573),
				u = s.t(l, 2),
				d = s(676745),
				c = s(244276),
				p = s(970028),
				h = s(448874),
				_ = s(424146),
				y = s(270617),
				S = s(346090);
			const m = (0, c.studyIdString)("RegressionTrend", "tv-basicstudies");

			function f(t) {
				return void 0 !== t.startPrice && void 0 !== t.endPrice
			}

			function P(t, e, s, i) {
				return e.styles && (g(e.styles.baseLine), g(e.styles.downLine), g(e.styles.upLine)), e
			}

			function g(t) {
				void 0 !== t && void 0 !== t.visible && (t.display = t.visible ? 15 : 0, delete t.visible)
			}
			class I extends o.StudyLineDataSource {
				constructor(t, e, i, r, o) {
					i = null != i ? i : (0, n.ensureNotNull)(t.studyMetaInfoRepository().findByIdSync({
						type: "java",
						studyId: m
					}));
					super(t, i, "linreg_", null != e ? e : I.createProperties(t), r, o), this.version = 2, this._trendData = null,
						Promise.all([s.e(93987), s.e(44572), s.e(51583)]).then(s.bind(s, 691338)).then((t => {
							this._setPaneViews([new t.RegressionTrendPaneView(this, this._model)])
						}))
				}
				formatter() {
					throw new Error("This method should never be called")
				}
				pointsCount() {
					return 2
				}
				clearData() {
					this._trendData = null, super.clearData()
				}
				state(t) {
					var e;
					const s = super.state(t);
					return t ? {
						...s,
						nonseriesdata: null !== (e = this._trendData) && void 0 !== e ? e : void 0
					} : s
				}
				restoreData(t) {
					var e;
					super.restoreData(t), this._trendData = null !== (e = t.nonseriesdata) && void 0 !== e ? e : null
				}
				startIndex() {
					if (null === this._trendData || null === this._indexes) return null;
					const t = this._indexes[this._trendData.startIndex];
					return t !== d.INVALID_TIME_POINT_INDEX ? t : null
				}
				endIndex() {
					if (null === this._trendData || null === this._indexes) return null;
					const t = this._indexes[this._trendData.endIndex];
					return t !== d.INVALID_TIME_POINT_INDEX ? t : null
				}
				baseLine() {
					return null === this._trendData ? null : this._trendData.baseLine
				}
				downLine() {
					return null === this._trendData ? null : this._trendData.downLine
				}
				upLine() {
					return null === this._trendData ? null : this._trendData.upLine
				}
				pearsons() {
					return null === this._trendData ? null : this._trendData.pearsons
				}
				recalcStudyIfNeeded() {
					this._onStudyInputsMayChange()
				}
				cloneable() {
					return !1
				}
				static createProperties(t, e) {
					const s = p.StudyMetaInfo.getStudyPropertyRootNameById(m),
						i = (0, n.ensureNotNull)(t.studyMetaInfoRepository().findByIdSync({
							type: "java",
							studyId: m
						})),
						r = (0, S.createDefaultsState)(!0, s, [], t.studyVersioning());
					return I.createRegressionTrendPropertiesFromStudyMetaInfoAndState(i, i, (0, y.merge)((0, y.clone)(r), null != e ? e : {}), t.studyVersioning())
				}
				static createRegressionTrendPropertiesFromStudyMetaInfoAndState(t, e, s, i) {
					const n = (0, h.prepareStudyPropertiesForLoadChart)(t, e, s, null, i, P);
					return I._configureProperties(n), n
				}
				static studyId() {
					return m
				}
				_studyInputs(t) {
					(0, n.assert)(2 === t.length, "all the line tool points should be defined");
					const [e, s] = t;
					if (e.index === s.index) return null;
					const i = this._getPointTime(e.index <= s.index ? e : s, !0),
						r = this._getPointTime(s.index >= e.index ? s : e, !0);
					return null === i || null === r ? (this._subscribeApplyInputsOnSeriesCompleted(), null) : {
						...this.properties().childs().inputs.state(),
						"first bar time": 1e3 * i,
						"last bar time": 1e3 * r
					}
				}
				_onDataUpdated(t, e, s) {
					null !== e && (e.indexes_replace || (this._trendData = e.data), "nochange" !== s && (this._indexes = s), super._onDataUpdated(t, e, s))
				}
				_isReady() {
					return null !== this._trendData && void 0 !== this._trendData.startIndex && void 0 !== this._trendData.endIndex && f(this._trendData.upLine) && f(this._trendData.baseLine) && f(this._trendData.downLine)
				}
				_updateAnchorsPrice() {
					if (!this._trendData || (0, y.isNaN)(this._trendData.baseLine.startPrice) || (0, y.isNaN)(this._trendData.baseLine.endPrice)) return;
					const {
						startPrice: t,
						endPrice: e
					} = this._trendData.baseLine;
					2 === this._points.length && (this._points[0].price = (0, n.ensureDefined)(t), this._points[1].price = (0, n.ensureDefined)(e), this._timePoint[0].price = (0, n.ensureDefined)(t), this._timePoint[1].price = (0, n.ensureDefined)(e))
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([s.e(39509), s.e(64320), s.e(39261), s.e(60607)]).then(s.bind(s, 340647))).RegressionTrendDefinitionsViewModel
				}
				static _configureProperties(t) {
					o.StudyLineDataSource._configureProperties(t);
					const e = t.childs().styles.childs(),
						s = [e.upLine.childs().linewidth, e.downLine.childs().linewidth, e.baseLine.childs().linewidth];
					t.addChild("linesWidths", new _.LineToolWidthsProperty(s))
				}
			}
			var b = s(525056);
			const w = (0, c.studyIdString)("VbPFixed", "tv-basicstudies");
			class v extends b.LineToolVbPFixed {
				constructor(t, e, s, i, n, r) {
					const o = s || t.studyMetaInfoRepository().findByIdSync({
						type: "java",
						studyId: w
					});
					super(t, e, o, i, n, r)
				}
				calcIsActualSymbol() {
					o.StudyLineDataSource.prototype.calcIsActualSymbol.apply(this)
				}
				boundToSymbol() {
					return !0
				}
				isSynchronizable() {
					return this.priceScale() === this._model.mainSeries().priceScale()
				}
				static studyId() {
					return w
				}
				static createProperties(t, e) {
					const s = p.StudyMetaInfo.getStudyPropertyRootNameById(w),
						i = (0, n.ensureNotNull)(t.studyMetaInfoRepository().findByIdSync({
							type: "java",
							studyId: w
						})),
						r = (0, S.createDefaultsState)(!0, s, [], t.studyVersioning());
					return v.createPropertiesFromStudyMetaInfoAndState(i, i, (0, y.merge)((0, y.clone)(r), null != e ? e : {}), t.studyVersioning())
				}
				static createPropertiesFromStudyMetaInfoAndState(t, e, s, i) {
					const n = (0, h.prepareStudyPropertiesForLoadChart)(t, e, s, null, i);
					return v._configureProperties(n), n
				}
			}
			var A = s(611688),
				T = s(344265),
				x = s(362145),
				V = s(349692),
				C = s(232567),
				D = s.n(C),
				L = s(559270),
				M = s(752280),
				F = s(498424);
			class R extends F.PriceAxisView {
				constructor(t) {
					super(), this._model = t.model(), this._source = t
				}
				_updateRendererData(t, e, s) {
					t.visible = !1, e.visible = !1;
					const i = this._source.model(),
						n = this._source.priceScale();
					if (null === n) return;
					if (!i.isPriceScaleVisible(n)) return;
					const r = this._source.lastValueData("", !1);
					r.noData || (s.background = r.color, s.textColor = this.generateTextColor(r.color), s.coordinate = r.coordinate, s.floatCoordinate = r.floatCoordinate, this._showAxisLabel() && (t.text = r.text, t.visible = !0))
				}
				_showAxisLabel() {
					return this._source.properties().childs().axisLabelVisible.value()
				}
			}
			var N = s(127641),
				B = s(951433),
				W = s(707127);
			class E extends B.StudyPlotPaneView {
				constructor(t, e, s, i) {
					super(t, e, s, i), this._line = t
				}
				_updateImplFull() {
					if (super._updateImplFull(!0), window.TradingView.printing || !this._line.hasAlert.value() || this._model.readOnly() || this._model.isInReplay()) return !1;
					const t = this._items;
					if (!this._renderer.isEmpty() && t.length > 0) {
						const e = t[t.length - 1],
							s = this._model.timeScale().width();
						if (e.x < 0 || t[0].x > s) return !1;
						const i = Math.min(s - 5, e.x);
						let n = e.y;
						if (e.x > i) {
							let s = t.length - 2;
							for (; s >= 0;) {
								const r = t[s];
								if (r.x <= i) {
									const t = (i - r.x) / (e.x - r.x);
									n = r.y + (e.y - r.y) * t;
									break
								}
								s -= 1
							}
						}
						const o = new r.Point(i, n);
						return this._renderer.append(new W.PaneRendererClockIcon({
							points: [o],
							color: this._line.getAlertIsActive() ? this._lineColor : N.Constants.DrawingIconColor,
							horzMargin: -16
						})), !0
					}
					return !1
				}
				_updateImplLight() {
					this._updateImplFull()
				}
			}
			var O = s(911905),
				U = s(496396),
				k = s(51975),
				z = s(694755),
				$ = s(194459);
			const j = (0, O.getLogger)("Chart.AnchoredVWAP"),
				G = (0, c.studyIdString)("AnchoredVWAP", "tv-basicstudies");

			function H(t, e, s, i) {
				return "calculate_stDev" in (0, n.ensureDefined)(t.inputs) || void 0 === i.inputs.find((t => "calculate_stDev" === t.id)) || ((0, n.ensureDefined)(e.inputs).calculate_stDev = !1), e.styles && (q(e.styles.VWAP), q(e.styles.UpperBand), q(e.styles.LowerBand), q(e.styles.UpperBand_2), q(e.styles.LowerBand_2), q(e.styles.UpperBand_3), q(e.styles.LowerBand_3)), e
			}

			function q(t) {
				void 0 !== t && void 0 !== t.visible && (t.display = t.visible ? 15 : 0, delete t.visible)
			}
			class K extends o.StudyLineDataSource {
				constructor(t, e, s, i, r) {
					s = s || (0, n.ensureNotNull)(t.studyMetaInfoRepository().findByIdSync({
						type: "java",
						studyId: G
					}));
					const o = null != e ? e : K.createProperties(t);
					super(t, s, "anchoredvwap", o, i, r);
					const [a, l, u, d, c, p, h] = this.metaInfo().plots, _ = t.mainSeries(), y = [new E(this, _, t, a.id)];
					l && u && (y.push(new B.StudyPlotPaneView(this, _, t, l.id)), y.push(new B.StudyPlotPaneView(this, _, t, u.id))), d && c && p && h && (y.push(new B.StudyPlotPaneView(this, _, t, d.id)), y.push(new B.StudyPlotPaneView(this, _, t, c.id)), y.push(new B.StudyPlotPaneView(this, _, t, p.id)), y.push(new B.StudyPlotPaneView(this, _, t, h.id))), this._properties.childs().areaBackground && y.splice(0, 0, new k.AreaBackgroundPaneView(this, t)), this._lastValuePriceAxisView = new R(this), this._anchorPriceCalculated = !1, this._onInputsReadyCallbacks = [], this._setPaneViews(y), t.properties().childs().scalesProperties.childs().showStudyLastValue.subscribe(this, this._onShowStudyLastValueChanged), o.onRestoreFactoryDefaults().subscribe(this, this._onRestoreFactoryDefaults)
				}
				destroy() {
					this.properties().onRestoreFactoryDefaults().unsubscribeAll(this), this.model().properties().childs().scalesProperties.childs().showStudyLastValue.unsubscribeAll(this), this._onInputsReadyCallbacks = [], super.destroy()
				}
				canHasAlert() {
					return !0
				}
				pointsCount() {
					return 1
				}
				priceAxisViews(t, e) {
					if (e !== this.priceScale() || this.isSourceHidden()) return null;
					const s = super.priceAxisViews(t, e);
					return null === s ? [this._lastValuePriceAxisView] : [...s, this._lastValuePriceAxisView]
				}
				updateAllViews(t) {
					super.updateAllViews(t), this._lastValuePriceAxisView.update(t)
				}
				offset(t) {
					return 0
				}
				firstValue() {
					return this._model.mainSeries().firstValue()
				}
				getMinFirstBarIndexForPlot() {
					return -1 / 0
				}
				priceRange(t, e) {
					if (!this._isReady() || this.isSourceHidden()) return null;
					const s = this.plots().minMaxOnRangeCached(t, e, [{
						name: this.metaInfo().plots[0].id,
						offset: 0
					}]);
					if (null === s) return null;
					const i = (0, n.ensureNotNull)(this.priceScale());
					return i.isLog() ? new L.PriceRange(i.priceToLogical(s.min), i.priceToLogical(s.max)) : new L.PriceRange(s.min, s.max)
				}
				isIncludedInAutoScale() {
					return !0
				}
				lastValueData(t, e, s) {
					const i = {
							noData: !0
						},
						r = this.priceScale();
					if (this._model.timeScale().isEmpty() || null === this.priceScale() || null === r || r.isEmpty() || this.plots().isEmpty()) return i;
					const o = this._model.timeScale().visibleBarsStrictRange();
					if (null === o) return i;
					if (!this.properties().childs().visible.value()) return i;
					const a = this.plots().search(o.lastBar(), M.PlotRowSearchMode.NearestLeft, 1);
					if (null === a) return i;
					const l = o.contains(a.index),
						u = !e && l ? a : (0, n.ensureNotNull)(this.plots().last());
					if (!u || !(0, y.isNumber)(u.value[1])) return i;
					const d = u.value[1],
						c = this.properties().childs().styles.childs().VWAP,
						p = (0, n.ensureNotNull)(this.firstValue()),
						h = r.priceToCoordinate(d, p);
					return {
						...r.getFormattedValues(d, p),
						noData: !1,
						price: d,
						color: c.childs().color.value(),
						coordinate: h,
						floatCoordinate: h,
						index: u.index
					}
				}
				restoreData(t) {
					super.restoreData(t), void 0 !== t.data && (this._anchorPriceCalculated = !0)
				}
				properties() {
					return super.properties()
				}
				sourceId() {
					return this._studyId()
				}
				hasStateForAlert() {
					return A.enabled("alerts") && null !== this._inputs
				}
				alertCreationAvailable() {
					return !this.hasAlert.value() && this.hasStateForAlert()
				}
				stateForAlert() {
					const t = this.metaInfo(),
						e = (0, V.plotsForAlert)(t, this.offset.bind(this), ["VWAP"]),
						s = (0, V.collectDepsForAlert)([this], this.id()),
						i = s.idForAlert,
						n = s.studyDependencies,
						r = s.inputsForAlert,
						o = (this.priceScale() || this.model().mainSeries().priceScale()).formatter(),
						a = o ? x.FormattersSerializer.serialize(o) : null;
					return {
						id: i,
						uniqueId: i,
						type: U.StateForAlertType.StudyLineTool,
						title: (0, z.clean)(this.title(), !0),
						shortTitle: (0, z.clean)(this.title(), !0),
						shortDescription: (0, z.clean)(t.shortDescription || "Study", !0),
						interval: this._model.mainSeries().interval(),
						fullId: t.fullId,
						isTVScript: Boolean(t.isTVScript),
						isTVScriptStrategy: Boolean(t.isTVScriptStrategy),
						isTVLibrary: Boolean(t.isTVLibrary),
						hasAlertFunction: Boolean(t.hasAlertFunction),
						plots: e,
						inputs: r,
						alerts: t.alerts,
						scriptIdPart: t.scriptIdPart,
						scriptVersion: t.pine ? t.pine.version : "-1",
						callStudyDependencies: (0, T.formatCallstudyArg)((0, V.dependenciesForAlerts)([], this._model.studyMetaInfoRepository())),
						studyDependencies: n,
						formatter: a
					}
				}
				inputsForAlertState() {
					null === this._inputs && j.logError("Could not get inputsForAlertState if VWAP has no inputs");
					const {
						start_time: t,
						source: e
					} = this.inputs();
					return {
						start_time: t,
						source: e
					}
				}
				inputs() {
					return (0, n.ensureNotNull)(this._inputs)
				}
				idForAlert() {
					return (0, V.collectDepsForAlert)([this], this.id()).idForAlert
				}
				defaultPlotIdForAlert() {
					return this.metaInfo().plots[0].id
				}
				isPlotVisibleAt(t, e) {
					return (this.properties().childs().styles.childs()[t].childs().display.value() & e) === e
				}
				static createProperties(t, e) {
					const s = p.StudyMetaInfo.getStudyPropertyRootNameById(G),
						i = (0, n.ensureNotNull)(t.studyMetaInfoRepository().findByIdSync({
							type: "java",
							studyId: G
						})),
						r = (0, S.createDefaultsState)(!0, s, [], t.studyVersioning());
					return K.createPropertiesFromStudyMetaInfoAndState(i, i, (0, y.merge)((0, y.clone)(r), null != e ? e : {}), t.studyVersioning())
				}
				static studyId() {
					return G
				}
				static createPropertiesFromStudyMetaInfoAndState(t, e, s, i) {
					const n = (0, h.prepareStudyPropertiesForLoadChart)(t, e, s, null, i, H);
					return K._configureProperties(n), n
				}
				_onPointsetUpdated(t) {
					super._onPointsetUpdated(t), this._onStudyInputsMayChange()
				}
				_studyInputs(t) {
					(0, n.assert)(1 === t.length, "all the line tool points should be defined");
					const e = t[0],
						s = this._getPointTime(e, !1);
					return null === s ? (this._subscribeApplyInputsOnSeriesCompleted(), null) : {
						...this.properties().childs().inputs.state(["start_time"]),
						start_time: 1e3 * s
					}
				}
				_isReady() {
					return super._isReady() && (null !== this._inputs || this._anchorPriceCalculated) && this.model().lineBeingEdited() !== this
				}
				_onDataCleared() {
					super._onDataCleared(), this._anchorPriceCalculated = !1
				}
				_onInputsChanged() {
					if (super._onInputsChanged(), null !== this._inputs) {
						for (const t of this._onInputsReadyCallbacks) try {
							t(this._inputs)
						} catch (t) {
							j.logError(t.stack || t.message)
						}
						this._onInputsReadyCallbacks = []
					}
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([s.e(39509), s.e(39261), s.e(18537)]).then(s.bind(s, 873109))).AnchoredVWAPDefinitionsViewModel
				}
				_updateAnchorsPrice(t) {
					if (!t && (this._anchorPriceCalculated || !this.isActualSymbol())) return;
					const e = this.firstValue(),
						s = this.points();
					if (null === e || 0 === s.length) return;
					const i = s[0].index,
						n = this.plots().valueAt(i);
					if (null === n) return;
					const r = n[1];
					null != r && (this._points[0].price = r, this._timePoint[0].price = r, this._anchorPriceCalculated = !0)
				}
				_synchronizeAlert(t) {
					this._onInputsReady((() => super._synchronizeAlert(t)))
				}
				static _configureProperties(t) {
					o.StudyLineDataSource._configureProperties(t), t.hasChild("axisLabelVisible") || t.addChild("axisLabelVisible", new(D())(true));
					const e = t.childs().styles.childs().VWAP.childs().linewidth,
						s = t.childs().styles.childs().VWAP.childs().color;
					t.addChild("linesWidths", new _.LineToolWidthsProperty([e])), t.addChild("linesColors", new _.LineToolColorsProperty([s]))
				}
				_onInputsReady(t) {
					null !== this._inputs ? t(this._inputs) : this._onInputsReadyCallbacks.push(t)
				}
				_onShowStudyLastValueChanged() {
					this._lastValuePriceAxisView.update((0, $.dataSourceChangeEvent)(this.id())), this.model().updateSource(this)
				}
				_onRestoreFactoryDefaults() {
					this.properties().childs().axisLabelVisible.setValue(true)
				}
			}
			var X = s(721925),
				J = s(591419);

			function Q(t) {
				return (0, c.studyIdString)(t, "mtp-mtpredictor")
			}
			class Y extends o.StudyLineDataSource {
				constructor(t, e, s, i, n, r) {
					const o = Q(i),
						a = s || t.studyMetaInfoRepository().findByIdSync({
							type: "java",
							studyId: o
						}),
						l = e || Y._createPropertiesFromStudyMetaInfo(a, t.studyVersioning());
					super(t, a, i, l, n, r), this._formatter = new J.VolumeFormatter, (0, X.createGraphicsPaneViews)(this, t).then(this._setPaneViews.bind(this))
				}
				formatter() {
					return this._formatter
				}
				static _createPropertiesFromMtpStudyShortIdAndState(t, e) {
					return super._createPropertiesFromStudyIdAndState(Q(t), e)
				}
				static _createPropertiesFromStudyMetaInfo(t, e) {
					const s = (0, h.prepareStudyProperties)(t, null, null, e);
					return o.StudyLineDataSource._configureProperties(s), s
				}
			}
			const Z = "mtp_tsanalysis";
			class tt extends Y {
				constructor(t, e, s, i, n) {
					super(t, e, s, Z, i, n)
				}
				pointsCount() {
					return 1
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(Z, t)
				}
				static studyId() {
					return Q(Z)
				}
				_studyInputs(t) {
					(0, n.assert)(1 === t.length, "all the line tool points should be defined");
					const e = this._getPointTime(t[0], !0);
					return null === e ? (this._subscribeApplyInputsOnSeriesCompleted(), null) : {
						...this.properties().childs().inputs.state(),
						bar: 1e3 * e
					}
				}
			}
			const et = "mtp_decisionpoint";
			class st extends Y {
				constructor(t, e, s, i, n) {
					super(t, e, s, et, i, n), this._symbolIntervalChanged = !1, this._model.mainSeries().onSymbolIntervalChanged().subscribe(this, this._onSymbolIntervalChanged)
				}
				destroy() {
					this._model.mainSeries().onSymbolIntervalChanged().unsubscribeAll(this), super.destroy()
				}
				pointsCount() {
					return 1
				}
				onData(t) {
					super.onData(t), this._symbolIntervalChanged = !1
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(et, t)
				}
				static studyId() {
					return Q(et)
				}
				_studyInputs(t) {
					(0, n.assert)(1 === t.length, "all the line tool points should be defined");
					const e = this._getPointTime(t[0], !0);
					return null === e ? (this._subscribeApplyInputsOnSeriesCompleted(), null) : {
						...this.properties().childs().inputs.state(),
						symbolIntervalChanged: this._symbolIntervalChanged,
						bar: 1e3 * e
					}
				}
				_onSymbolIntervalChanged() {
					this._symbolIntervalChanged = !0
				}
			}
			const it = "mtp_riskreward";
			class nt extends Y {
				constructor(t, e, s, i, n) {
					super(t, e, s, it, i, n)
				}
				pointsCount() {
					return 3
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(it, t)
				}
				static getTooltipText(t) {
					return t && 0 !== t._points.length ? 1 === t._points.length ? "Select Stop Bar" : 2 === t._points.length ? "Select Target Point" : null : "Select Entry Setup Bar"
				}
				static studyId() {
					return Q(it)
				}
				_studyInputs(t) {
					(0, n.assert)(3 === t.length, "all the line tool points should be defined");
					const e = this._getPointTime(t[0], !0),
						s = this._getPointTime(t[1], !0),
						i = this._getPointTime(t[2], !0);
					return null === e || null === s || null === i ? (this._subscribeApplyInputsOnSeriesCompleted(), null) : {
						...this.properties().childs().inputs.state(),
						entry_bar: 1e3 * e,
						stop_bar: 1e3 * s,
						target_bar: 1e3 * i,
						target_price: t[2].price
					}
				}
			}
			class rt extends Y {
				pointsCount() {
					return 1
				}
				_studyInputs(t) {
					(0, n.assert)(1 === t.length, "all the line tool points should be defined");
					const e = this._getPointTime(t[0], !0);
					return null === e ? (this._subscribeApplyInputsOnSeriesCompleted(), null) : {
						...this.properties().childs().inputs.state(),
						bar: 1e3 * e
					}
				}
			}
			const ot = "mtp_ew_main";
			class at extends rt {
				constructor(t, e, s, i, n) {
					super(t, e, s, ot, i, n)
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(ot, t)
				}
				static studyId() {
					return Q(ot)
				}
			}
			const lt = "mtp_ew_major";
			class ut extends rt {
				constructor(t, e, s, i, n) {
					super(t, e, s, lt, i, n)
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(lt, t)
				}
				static studyId() {
					return Q(lt)
				}
			}
			const dt = "mtp_ew_minor";
			class ct extends rt {
				constructor(t, e, s, i, n) {
					super(t, e, s, dt, i, n)
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(dt, t)
				}
				static studyId() {
					return Q(dt)
				}
			}
			class pt extends Y {
				_studyInputs(t) {
					(0, n.assert)(t.length === this.pointsCount(), "all the line tool points should be defined");
					const e = {
						...this.properties().childs().inputs.state()
					};
					for (let s = 0; s < this.pointsCount(); ++s) {
						const i = this._getPointTime(t[s], !0);
						if (null === i) return this._subscribeApplyInputsOnSeriesCompleted(), null;
						e[`bar${s}`] = 1e3 * i
					}
					return e
				}
			}
			const ht = "mtp_wpt_down1ora";
			class _t extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, ht, i, n)
				}
				pointsCount() {
					return 2
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(ht, t)
				}
				static getTooltipText(t) {
					return `Down Wave 1 or A: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(ht)
				}
			}
			const yt = "mtp_wpt_down2orb";
			class St extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, yt, i, n)
				}
				pointsCount() {
					return 2
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(yt, t)
				}
				static getTooltipText(t) {
					return `Down Wave 2 or B: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(yt)
				}
			}
			const mt = "mtp_wpt_down3";
			class ft extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, mt, i, n)
				}
				pointsCount() {
					return 3
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(mt, t)
				}
				static getTooltipText(t) {
					return `Down Wave 3: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(mt)
				}
			}
			const Pt = "mtp_wpt_down4";
			class gt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, Pt, i, n)
				}
				pointsCount() {
					return 2
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(Pt, t)
				}
				static getTooltipText(t) {
					return `Down Wave 4: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(Pt)
				}
			}
			const It = "mtp_wpt_down5";
			class bt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, It, i, n)
				}
				pointsCount() {
					return 5
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(It, t)
				}
				static getTooltipText(t) {
					return `Down Wave 5: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(It)
				}
			}
			const wt = "mtp_wpt_downc";
			class vt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, wt, i, n)
				}
				pointsCount() {
					return 3
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(wt, t)
				}
				static getTooltipText(t) {
					return `Down Wave C: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(wt)
				}
			}
			const At = "mtp_wpt_up1ora";
			class Tt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, At, i, n)
				}
				pointsCount() {
					return 2
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(At, t)
				}
				static getTooltipText(t) {
					return `Up Wave 1 or A: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(At)
				}
			}
			const xt = "mtp_wpt_up2orb";
			class Vt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, xt, i, n)
				}
				pointsCount() {
					return 2
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(xt, t)
				}
				static getTooltipText(t) {
					return `Up Wave 2 or B: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(xt)
				}
			}
			const Ct = "mtp_wpt_up3";
			class Dt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, Ct, i, n)
				}
				pointsCount() {
					return 3
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(Ct, t)
				}
				static getTooltipText(t) {
					return `Up Wave 3: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(Ct)
				}
			}
			const Lt = "mtp_wpt_up4";
			class Mt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, Lt, i, n)
				}
				pointsCount() {
					return 2
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(Lt, t)
				}
				static getTooltipText(t) {
					return `Up Wave 4: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(Lt)
				}
			}
			const Ft = "mtp_wpt_up5";
			class Rt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, Ft, i, n)
				}
				pointsCount() {
					return 5
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(Ft, t)
				}
				static getTooltipText(t) {
					return `Up Wave 5: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(Ft)
				}
			}
			const Nt = "mtp_wpt_upc";
			class Bt extends pt {
				constructor(t, e, s, i, n) {
					super(t, e, s, Nt, i, n)
				}
				pointsCount() {
					return 3
				}
				static createProperties(t) {
					return super._createPropertiesFromMtpStudyShortIdAndState(Nt, t)
				}
				static getTooltipText(t) {
					return `Up Wave C: Select Point ${(t?t._points.length:0)+1}`
				}
				static studyId() {
					return Q(Nt)
				}
			}
			var Wt = s(29084),
				Et = s(157759),
				Ot = s(669415);

			function Ut(t) {
				for (const e of Object.keys(t)) TradingView[e] = t[e]
			}
			Ut(u), Ut({
				LineToolRegressionTrend: I,
				LineToolVbPFixed: b.LineToolVbPFixed,
				LineToolFixedRangeVolumeProfile: v
			}), Ut({
				LineToolAnchoredVWAP: K
			}), Ut(i);
			let kt = null;

			function zt(t, e, s) {
				return null !== kt && kt.tool === t && kt.toolData === e || (kt = {
					properties: qt(t, void 0, s),
					tool: t,
					toolData: e
				}), kt.properties
			}

			function $t() {
				kt = null
			}

			function jt(t) {
				return null !== kt && kt.tool === t ? kt.properties : null
			}

			function Gt(t, e, s, r, o, a) {
				let l;
				if ((0, n.assert)((0, Wt.isLineToolName)(t), "Unknown line tool: " + t), o || s || (s = jt(t) || void 0), "LineToolVbPFixed" === t) l = new b.LineToolVbPFixed(e, s, (0, n.ensureDefined)(r), e.mainSeries(), o, a);
				else if ("LineToolFixedRangeVolumeProfile" === t) l = new v(e, s, (0, n.ensureDefined)(r), e.mainSeries(), o, a);
				else if ("LineToolRegressionTrend" === t) l = new I(e, s, (0, n.ensureDefined)(r), o, a);
				else if ("LineToolAnchoredVWAP" === t) l = new K(e, s, (0, n.ensureDefined)(r), o, a);
				else if (t in i) {
					l = new((0, n.ensureDefined)(i[t]))(e, s, (0, n.ensureDefined)(r), o, a)
				} else {
					l = new((0, n.ensureDefined)(u[t]))(e, s, o, a)
				}
				return l.toolname = t, $t(), l
			}

			function Ht(t, e) {
				const s = (0, n.ensureNotNull)(e.symbolSource());
				t.childs().symbol.setValue(s.symbol()), s.model().currencyConversionEnabled() && t.childs().currencyId.setValue(s.currency()), s.model().unitConversionEnabled() && t.childs().unitId.setValue(s.unit()), t.childs().symbolStateVersion.setValue(2), t.childs().zOrderVersion.setValue(2)
			}

			function qt(t, e, s) {
				if ((0, n.assert)((0, Wt.isLineToolName)(t), `${t} should be name of the line tool`), "LineToolVbPFixed" === t) return b.LineToolVbPFixed.createProperties(s, e);
				if ("LineToolFixedRangeVolumeProfile" === t) return v.createProperties(s, e);
				if ("LineToolRegressionTrend" === t) return I.createProperties(s, e);
				if ("LineToolAnchoredVWAP" === t) return K.createProperties(s, e);
				if (t in i) {
					return (0, n.ensureDefined)(i[t]).createProperties(e)
				}
				return (0, n.ensureDefined)(u[t]).createProperties(e)
			}

			function Kt(t, e, s, r, o) {
				if ((0, n.assert)((0, Wt.isStudyLineToolName)(t), `${t} should be name of the study line tool`), "LineToolVbPFixed" === t) return b.LineToolVbPFixed.createPropertiesFromStudyMetaInfoAndState(e, s, r, o);
				if ("LineToolFixedRangeVolumeProfile" === t) return v.createPropertiesFromStudyMetaInfoAndState(e, s, r, o);
				if ("LineToolRegressionTrend" === t) return I.createRegressionTrendPropertiesFromStudyMetaInfoAndState(e, s, r, o);
				if ("LineToolAnchoredVWAP" === t) return K.createPropertiesFromStudyMetaInfoAndState(e, s, r, o);
				if (t in i) {
					return (0, n.ensureDefined)(i[t]).createPropertiesFromStudyMetaInfoAndState(e, s, r, o)
				}
				throw new Error(`Property creation is not implemented for study line tool ${t}`)
			}

			function Xt(t) {
				(0, n.assert)((0, Wt.isLineToolName)(t), `${t} should be name of the line tool`);
				const e = u[t];
				return void 0 !== e && Boolean(e.supportPhantomMode)
			}

			function Jt(t) {
				return t instanceof a.LineDataSource
			}

			function Qt(t) {
				return t instanceof o.StudyLineDataSource
			}

			function Yt(t) {
				return t instanceof Et.LineToolTrading
			}

			function Zt(t) {
				let e = null;
				if (t === I.studyId() ? e = "LineToolRegressionTrend" : t === b.LineToolVbPFixed.studyId() ? e = "LineToolVbPFixed" : t === v.studyId() && (e = "LineToolFixedRangeVolumeProfile"), null === e)
					for (const e in i)
						if (i[e].studyId() === t) return e;
				return e
			}

			function te(t, e, s, i) {
				const o = e.toolname,
					a = e.properties().state();
				a.intervalsVisibilities = (0, Ot.mergeIntervalVisibilitiesDefaults)(null == a ? void 0 : a.intervalsVisibilities);
				const l = qt(e.toolname, a, t);
				l.childs().visible.setValue(!0);
				const u = (0, n.ensureNotNull)(e.ownerSource()),
					d = Gt(o, t, l);
				void 0 !== i && d.setId(i), d.setOwnerSource(u), d.toolname = o;
				const c = d.clonePositionOffset(),
					p = e.fixedPoints();
				(s ? p.map((t => t.add(new r.Point(c.xCoordOffset, c.yCoordOffset)))) : p).forEach((t => d.addFixedPoint(t)));
				const h = e.normalizedPoints(),
					_ = s ? function(t, e, s) {
						const i = (0, n.ensureNotNull)(e.priceScale()),
							r = (0, n.ensureNotNull)(e.firstValue());
						return t.map((t => {
							const e = t.price,
								n = i.priceToCoordinate(e, r) + s.yCoordOffset,
								o = i.coordinateToPrice(n, r);
							return {
								time_t: t.time_t,
								price: o,
								offset: t.offset + s.barOffset
							}
						}))
					}(h, u, c) : h,
					y = e.points();
				return d.restorePoints(_, y), d.cloneData && d.cloneData(e), d.checkAlert && d.checkAlert(), d
			}

			function ee(t, e) {
				var s;
				return null !== (s = t.dataSources().find((t => Jt(t) && t.linkKey().value() === e))) && void 0 !== s ? s : null
			}
		},
		417791: (t, e, s) => {
			s.d(e, {
				StudyLineDataSource: () => v
			});
			var i = s(588537),
				n = s(270617),
				r = s(752280),
				o = s(724145),
				a = s(346090),
				l = s(970028),
				u = s(721925),
				d = s(624635),
				c = s(12270),
				p = s(183939),
				h = s(523083),
				_ = s(448874),
				y = s(393987),
				S = s(294766),
				m = s(194459),
				f = s(906096),
				P = s(5073);
			class g extends P.StatusProviderBase {
				constructor(t) {
					super(t.model().properties().childs().scalesProperties.childs().textColor), this._source = t
				}
				color() {
					return "#ff0000"
				}
				errorStatus() {
					const t = this._source.status();
					return t.type === f.StudyStatusType.Error ? {
						error: this.sourceStatusText(),
						solutionId: (0, f.studyStatusSolutionId)(t),
						title: (0, f.studyStatusTitle)(t),
						studyFeature: (0, f.studyStatusFeature)(t)
					} : null
				}
				getSplitTitle() {
					return this._source.titleInParts()
				}
				text() {
					return this._source.title()
				}
				sourceStatusText() {
					return (0, f.convertStudyStatusToString)(this._source.status(), !0)
				}
			}
			var I = s(388230),
				b = s(892139);
			class w extends b.StatusView {
				constructor(t) {
					super(t.statusProvider({}))
				}
				getSplitTitle() {
					return this._statusProvider.getSplitTitle()
				}
			}
			class v extends o.LineDataSource {
				constructor(t, e, i, n, r, o) {
					super(t, n, r, o), this._indexes = null, this._inputs = null, this._definitionsViewModel = null, this._pointsetPoints = null, this._loadedPlots = null, this._loadedGraphics = null, this._beingCreatedPaneView = null, this._anchorsPaneView = null, this._isLegendDisplayed = !1, this._alignerCache = null, Promise.all([Promise.all([s.e(93987), s.e(44572), s.e(51583)]).then(s.bind(s, 336644)), Promise.all([s.e(93987), s.e(44572), s.e(51583)]).then(s.bind(s, 301550))]).then((e => {
						const {
							LineToolBeingCreatedPaneView: s
						} = e[0], {
							StudyLineDataSourceAnchorsPaneView: i
						} = e[1];
						this._beingCreatedPaneView = new s(this, t), this._anchorsPaneView = new i(this, this.model()), this._model.lightUpdate()
					})), this._metaInfo = e, this._dataSource = new c.StudyDataSource(t.chartApi(), t.mainSeries().seriesSource(), i, e), this._dataSource.dataCleared().subscribe(this, this._onDataCleared), this._dataSource.dataUpdated().subscribe(this, this._onDataUpdated), this._dataSource.studyStatusChanged().subscribe(this, this._onStudyStatusChanged), this._statusProvider = new g(this), this._statusView = new w(this), this._showStudyArgumentsProperty = t.properties().childs().paneProperties.childs().legendProperties.childs().showStudyArguments
				}
				isDisplayedInLegend() {
					return this._isLegendDisplayed
				}
				titleInParts() {
					const t = [];
					if (this._showStudyArgumentsProperty.value() && this._inputs)
						for (const e of this._metaInfo.inputs) {
							if (!0 === e.isHidden || "bool" === e.type) continue;
							const s = this._inputs[e.id];
							t.push(s.toString())
						}
					return [this.name(), t]
				}
				destroy() {
					this._dataSource.dataUpdated().unsubscribeAll(this), this._dataSource.dataCleared().unsubscribeAll(this), this._dataSource.studyStatusChanged().unsubscribeAll(this), this._dataSource.destroy(), null !== this._definitionsViewModel && (this._definitionsViewModel.destroy(), this._definitionsViewModel = null), this._unsubscribeApplyInputsOnSeriesCompleted(), this._isDestroyed = !0, super.destroy()
				}
				stop() {
					super.stop(), this._isDestroyed || (this._dataSource.stop(), this.clearData())
				}
				start() {
					super.start(), this._isDestroyed || null === this._inputs || this._dataSource.start()
				}
				metaInfo() {
					return this._metaInfo
				}
				graphicsInfo() {
					return this._metaInfo.graphics
				}
				series() {
					return this._model.mainSeries()
				}
				translatedType() {
					return this._metaInfo.description
				}
				name() {
					return this._metaInfo.description
				}
				studyId() {
					return this._metaInfo.id
				}
				setPoint(t, e, s) {
					super.setPoint(t, this._preparePoint(e, s))
				}
				move(t) {}
				clearData() {
					this._clearAllDataExceptPointsetPoints(), this._pointsetPoints = null, this.updateAllViews((0, m.dataSourceChangeEvent)(this.id()))
				}
				data() {
					return this.plots()
				}
				plots() {
					return this._loadedPlots || this._dataSource.plots()
				}
				graphics() {
					return this._loadedGraphics || this._dataSource.graphics()
				}
				firstValue() {
					return this._model.mainSeries().firstValue()
				}
				state(t) {
					const e = super.state(t);
					let s;
					this.metaInfo() instanceof l.StudyMetaInfo ? s = this.metaInfo().state() : (s = (0, n.clone)(this.metaInfo()), s.id = l.StudyMetaInfo.parseIdString(s.id + (s.version ? "-" + s.version : "")).fullId);
					const i = {
						...e,
						metaInfo: s
					};
					return t && (i.data = this.plots().state(), i.nonseriesindexes = this._indexes, i.graphics = (0, u.saveStudyGraphics)(this.graphics())), i
				}
				restoreData(t) {
					var e;
					void 0 !== t.data && (this._loadedPlots = new r.PlotList((0, h.studyPlotFunctionMap)(this._metaInfo), h.studyEmptyPlotValuePredicate), this._loadedPlots.restoreState(t.data)), this._indexes = null !== (e = t.nonseriesindexes) && void 0 !== e ? e : this._indexes, this._loadedGraphics = t.graphics ? (0, u.loadStudyGraphics)(t.graphics) : this._loadedGraphics
				}
				getPropertyDefinitionsViewModel() {
					return null === this._definitionsViewModel ? this._getPropertyDefinitionsViewModelClass().then((t => null === t || this._isDestroyed ? null : (null === this._definitionsViewModel && (this._definitionsViewModel = new t(this._model.undoModel(), this)), this._definitionsViewModel))) : Promise.resolve(this._definitionsViewModel)
				}
				paneViews(t) {
					let e = [];
					if (this.isSourceHidden()) return e;
					if (this._isReady() && this._changeStatesStack.isEmpty()) {
						const s = super.paneViews(t);
						null !== s && (e = e.concat(s))
					} else null !== this._beingCreatedPaneView && e.push(this._beingCreatedPaneView);
					return null !== this._anchorsPaneView && e.push(this._anchorsPaneView), e
				}
				propertiesChanged(t) {
					super.propertiesChanged(t), this._onStudyInputsMayChange()
				}
				dataAndViewsReady() {
					return super.dataAndViewsReady() && this._isReady()
				}
				endChanging(t, e) {
					const s = super.endChanging(t, e);
					return s.indexesChanged ? this.clearData() : this._updateAnchorsPrice(!0), s
				}
				moveData(t) {
					this._dataSource.moveData(t)
				}
				restorePoints(t, e, s) {
					super.restorePoints(t, e, s), this._updateAnchorsPrice(!0)
				}
				realign() {
					super.realign(), null === this._model.mainSeries().symbolInfo() && (this._alignerCache = null)
				}
				statusProvider(t) {
					return this._statusProvider
				}
				statusView() {
					return this._statusView
				}
				legendView() {
					return null
				}
				dataProblemModel() {
					return null
				}
				dataUpdatedModeModel() {
					return null
				}
				marketStatusModel() {
					return null
				}
				onStatusChanged() {
					return this._dataSource.studyStatusChanged()
				}
				status() {
					return this._dataSource.studyStatus()
				}
				static createPropertiesFromStudyMetaInfoAndState(t, e, s, i) {
					const n = (0, _.prepareStudyPropertiesForLoadChart)(t, e, s, null, i);
					return v._configureProperties(n), n
				}
				_onStudyStatusChanged(t, e) {
					let s;
					switch (e.type) {
						case p.StudyStatusType.Error:
							s = !0;
							break;
						case p.StudyStatusType.Completed:
							s = !1;
							break;
						default:
							return
					}
					if (s === this._isLegendDisplayed) return;
					this._isLegendDisplayed = s;
					const i = this._model.paneForSource(this);
					if (i) {
						const t = this._model.panes().indexOf(i),
							e = I.InvalidationMask.invalidateLegendWidgetLayout(t);
						this.model().invalidate(e)
					}
				}
				_studyId() {
					return this._dataSource.studyId()
				}
				_isReady() {
					return !0
				}
				_updateAllPaneViews(t) {
					var e, s;
					super._updateAllPaneViews(t), null === (e = this._beingCreatedPaneView) || void 0 === e || e.update(), null === (s = this._anchorsPaneView) || void 0 === s || s.update(t)
				}
				_getPointTime(t, e) {
					const s = t.index,
						i = this._model.timeScale().indexToTimePoint(s);
					if (null !== i) return i;
					if (e || void 0 === t.time) return null;
					const n = this._model.mainSeries().symbolInfo();
					if (null === n) return null;
					let r = this._model.properties().childs().timezone.value();
					"exchange" === r && (r = n.timezone);
					const o = (0, y.cal_to_utc)((0, y.get_timezone)(r), t.time);
					return this._getStartBarAligner()(o) / 1e3
				}
				_updateAnchorsPrice(t) {}
				_onPointsetUpdated(t) {
					super._onPointsetUpdated(t), this._pointsetPoints = this._points.map((t => ({
						price: t.price,
						index: t.index,
						time: t.time
					}))), this._onStudyInputsMayChange()
				}
				_onDataCleared() {
					this.updateAllViews((0, m.dataSourceChangeEvent)(this.id(), void 0, !0)), this._model.updateSource(this)
				}
				_onDataUpdated(t, e, s) {
					var i;
					this._updateAnchorsPrice(), this.updateAllViews((0, m.dataSourceChangeEvent)(this.id(), null === (i = t[0]) || void 0 === i ? void 0 : i.index)),
						this._model.updateSource(this)
				}
				_onStudyInputsMayChange() {
					let t = null;
					if (null !== this._pointsetPoints && this._pointsetPoints.length === this.pointsCount() && (t = this._studyInputs(this._pointsetPoints), null === t && (this._clearAllDataExceptPointsetPoints(), this.updateAllViews((0, m.dataSourceChangeEvent)(this.id())))), null !== t) {
						const e = this.metaInfo().inputs.map((t => t.id)),
							s = Object.keys(t);
						for (const i of s) e.includes(i) || delete t[i]
					}
					this._areInputsEqual(this._inputs, t) || this._applyStudyInputs(t)
				}
				_preparePoint(t, e) {
					return super._preparePoint(this._alignPointToRangeOfActualData(t), e)
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.resolve(null)
				}
				_subscribeApplyInputsOnSeriesCompleted() {
					this._unsubscribeApplyInputsOnSeriesCompleted(), this._model.mainSeries().dataEvents().completed().subscribe(this, (() => this._onStudyInputsMayChange()), !0)
				}
				_unsubscribeApplyInputsOnSeriesCompleted() {
					this._model.mainSeries().dataEvents().completed().unsubscribeAll(this)
				}
				_onInputsChanged() {
					this.hasAlert.value() && (this._localAndServerAlertsMismatch = !0)
				}
				static _createPropertiesFromStudyIdAndState(t, e) {
					const s = l.StudyMetaInfo.getStudyPropertyRootNameById(t),
						i = new a.DefaultProperty(s, e);
					return v._configureProperties(i), i
				}
				static _configureProperties(t) {
					o.LineDataSource._configureProperties(t), t.removeExclusion("intervalsVisibilities")
				}
				_areInputsEqual(t, e) {
					return null === e ? null === t : null !== t && (0, d.areStudyInputsEqual)(this._metaInfo.inputs, t, e)
				}
				_applyStudyInputs(t) {
					const e = this._inputs;
					this._inputs = t, null !== t && (this._unsubscribeApplyInputsOnSeriesCompleted(), this._dataSource.setInputs(t), null === e && this.isStarted() && !this._dataSource.isStarted() && this._dataSource.start()), this._onInputsChanged()
				}
				_clearAllDataExceptPointsetPoints() {
					this._inputs = null, this._dataSource.clearData(), this._loadedPlots = null, this._indexes = null, this._loadedGraphics = null
				}
				_getStartBarAligner() {
					const t = this._model.mainSeries().interval();
					return null !== this._alignerCache && this._alignerCache.resolution === this._model.mainSeries().interval() || (this._alignerCache = {
						resolution: t,
						aligner: (0, S.createTimeToBarTimeAligner)(t, (0, i.ensureNotNull)(this._model.mainSeries().symbolInfo()))
					}), this._alignerCache.aligner
				}
			}
		},
		525056: (t, e, s) => {
			s.d(e, {
				LineToolVbPFixed: () => m
			});
			const i = function(t) {
				return null === t
			};
			var n = s(588537),
				r = s(244276),
				o = s(970028),
				a = s(417791),
				l = s(721925),
				u = s(951433),
				d = s(194459),
				c = s(270617),
				p = s(346090),
				h = s(448874);
			const _ = (0, r.studyIdString)("VbPFixed", "tv-volumebyprice");

			function y(t, e, s, i) {
				return e.styles && (S(e.styles.developingPoc), S(e.styles.developingVAHigh), S(e.styles.developingVALow)), e
			}

			function S(t) {
				void 0 !== t && void 0 !== t.visible && (t.display = t.visible ? 15 : 0, delete t.visible)
			}
			class m extends a.StudyLineDataSource {
				constructor(t, e, s, i, n, r) {
					const o = s || t.studyMetaInfoRepository().findByIdSync({
							type: "java",
							studyId: _
						}),
						a = null != e ? e : m.createProperties(t);
					super(t, o, "vbpfixed_", a, n, r), (0, l.createGraphicsPaneViews)(this, t).then((e => {
						if (i = t.mainSeries(), o.plots.length > 0) {
							const s = new u.StudyPlotPaneView(this, i, t, o.plots[0].id);
							e.push(s)
						}
						if (o.plots.length > 1) {
							const s = new u.StudyPlotPaneView(this, i, t, o.plots[1].id);
							e.push(s)
						}
						if (o.plots.length > 2) {
							const s = new u.StudyPlotPaneView(this, i, t, o.plots[2].id);
							e.push(s)
						}
						this._setPaneViews(e)
					})), this.clearData()
				}
				pointsCount() {
					return 2
				}
				boundToSymbol() {
					return !1
				}
				offset(t) {
					return 0
				}
				getMinFirstBarIndexForPlot() {
					return -1 / 0
				}
				calcIsActualSymbol() {
					this._isActualSymbol = !0, this._isActualCurrency = !0, this._isActualUnit = !0, this.calcIsActualInterval()
				}
				cloneable() {
					return !1
				}
				isSynchronizable() {
					return !1
				}
				isPlotVisibleAt(t, e) {
					return (this.properties().childs().styles.childs()[t].childs().display.value() & e) === e
				}
				static createProperties(t, e) {
					const s = o.StudyMetaInfo.getStudyPropertyRootNameById(_),
						i = (0, n.ensureNotNull)(t.studyMetaInfoRepository().findByIdSync({
							type: "java",
							studyId: _
						})),
						r = (0, p.createDefaultsState)(!0, s, [], t.studyVersioning());
					return m.createPropertiesFromStudyMetaInfoAndState(i, i, (0, c.merge)((0, c.clone)(r), null != e ? e : {}), t.studyVersioning())
				}
				static createPropertiesFromStudyMetaInfoAndState(t, e, s, i) {
					const n = (0, h.prepareStudyPropertiesForLoadChart)(t, e, s, null, i, y);
					return m._configureProperties(n), n
				}
				static studyId() {
					return _
				}
				_studyInputs(t) {
					(0, n.assert)(2 === t.length, "all the line tool points should be defined");
					const [e, s] = t, i = Math.max(e.index, s.index), r = this._model.mainSeries().bars().lastIndex(), o = this._getPointTime(e.index <= s.index ? e : s, !0), a = this._getPointTime(s.index >= e.index ? s : e, !0);
					if (null === o || null === a) return this._subscribeApplyInputsOnSeriesCompleted(), null;
					return {
						...this.properties().childs().inputs.state(),
						first_bar_time: 1e3 * o,
						last_bar_time: 1e3 * a,
						subscribeRealtime: r === i
					}
				}
				_isReady() {
					return !(0, l.isStudyGraphicsEmpty)(this.graphics())
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([s.e(39509), s.e(64320), s.e(39261), s.e(60607)]).then(s.bind(s, 601173))).StudyLineDataSourceDefinitionsViewModel
				}
				_onDataUpdated() {
					this._updateAnchors(), this.updateAllViews((0, d.dataSourceChangeEvent)(this.id())), this._model.updateSource(this)
				}
				_updateAnchors() {
					const t = this._calculateAnchors();
					if (!t) return;
					const [{
						index: e,
						price: s
					}, {
						index: i,
						price: n
					}] = t;
					if (this._timePoint.length && (this._timePoint[0].price = s, this._timePoint[1].price = n), this._points.length) {
						const t = this.model().timeScale(),
							r = t.indexToTimePoint(e),
							o = t.indexToTimePoint(e);
						this._points[0] = {
							index: e,
							price: s,
							time: (0, c.isNumber)(r) ? new Date(1e3 * r) : void 0
						}, this._points[1] = {
							index: i,
							price: n,
							time: (0, c.isNumber)(o) ? new Date(1e3 * o) : void 0
						}
					}
				}
				_calculateAnchors() {
					let t = null,
						e = null,
						s = null,
						n = null;
					if (this.graphics().hhists().forEach((i => {
							i.forEach((i => {
								const {
									priceLow: r,
									priceHigh: o,
									firstBarTime: a,
									lastBarTime: l
								} = i;
								(!t || r < t) && (t = r), (!e || o > e) && (e = o), (!s || a < s) && (s = a), (!n || l > n) && (n = l)
							}))
						})), !(i(t) || i(e) || i(n) || i(s))) return [{
						price: e,
						index: s
					}, {
						price: t,
						index: n
					}]
				}
				_updateAnchorsPrice() {
					const t = this._calculateAnchors();
					if (!t) return;
					const [{
						price: e
					}, {
						price: s
					}] = t;
					this._timePoint.length && (this._timePoint[0].price = e, this._timePoint[1].price = s), this._points.length && (this._points[0].price = e, this._points[1].price = s)
				}
			}
		},
		707127: (t, e, s) => {
			s.d(e, {
				PaneRendererClockIcon: () => o
			});
			var i = s(218718),
				n = s(380047);
			const r = Math.sqrt(3);
			class o extends n.ScaledPaneRenderer {
				constructor(t) {
					super(), this.update(t)
				}
				update(t) {
					var e;
					const s = t.points[0],
						i = null !== (e = t.points[1]) && void 0 !== e ? e : t.points[0],
						n = s.x - i.x,
						o = s.y - i.y;
					let a = t.horzMargin;
					void 0 === a && (a = n > 0 ? 10 : -25), this._x = s.x + a, this._y = s.y + (0 !== o && Math.abs(n) * r <= Math.abs(o) ? -7 : o > 0 ? -25 : 11), this._color = t.color
				}
				hitTest(t) {
					return t.x < this._x || t.x > this._x + 16 || t.y < this._y || t.y > this._y + 16 ? null : new i.HitTestResult(i.HitTestResult.REGULAR)
				}
				_drawImpl(t) {
					t.save(), t.translate(this._x - .5, this._y - .5), t.beginPath(), t.arc(8, 9, 6, 0, 2 * Math.PI, !0), t.closePath(), t.moveTo(8, 9), t.arc(8.5, 5.5, .5, Math.PI, 0), t.lineTo(9, 10), t.arc(5.5, 9.5, .5, .5 * Math.PI, 1.5 * Math.PI), t.closePath(), t.moveTo(1.71, 5.93), t.bezierCurveTo(-.61, 2.83, 3.86, -.76, 6.39, 2.18), t.bezierCurveTo(4.35, 2.67, 2.63, 4.04, 1.71, 5.93), t.closePath(), t.moveTo(14.29, 5.93), t.bezierCurveTo(16.61, 2.83, 12.14, -.76, 9.61, 2.18), t.bezierCurveTo(11.65, 2.67, 13.37, 4.04, 14.29, 5.93), t.fillStyle = this._color, t.fill(), t.restore()
				}
			}
		},
		127641: (t, e, s) => {
			var i;
			s.d(e, {
					Constants: () => i
				}),
				function(t) {
					t.DrawingIconColor = "rgba( 170, 170, 170, 1)", t[t.NameLengthLimit = 300] = "NameLengthLimit"
				}(i || (i = {}))
		},
		687795: t => {
			const e = 55296,
				s = 127995,
				i = 127999,
				n = [776, 2359, 2359, 2367, 2367, 2984, 3007, 3021, 3633, 3635, 3648, 3657, 4352, 4449, 4520];

			function r(t) {
				if ("string" != typeof t) throw new Error("string cannot be undefined or null");
				const e = [];
				let s = 0,
					i = 0;
				for (; s < t.length;) i += o(s + i, t), d(t[s + i]) && i++, l(t[s + i]) && i++, u(t[s + i]) && i++, c(t[s + i]) ? i++ : (e.push(t.substring(s, s + i)), s += i, i = 0);
				return e
			}

			function o(t, n) {
				const r = n[t];
				if (! function(t) {
						return t && h(t[0].charCodeAt(0), e, 56319)
					}(r) || t === n.length - 1) return 1;
				const o = r + n[t + 1];
				let l = n.substring(t + 2, t + 5);
				return a(o) && a(l) || function(t) {
					return h(p(t), s, i)
				}(l) ? 4 : 2
			}

			function a(t) {
				return h(p(t), 127462, 127487)
			}

			function l(t) {
				return "string" == typeof t && h(t.charCodeAt(0), 65024, 65039)
			}

			function u(t) {
				return "string" == typeof t && h(t.charCodeAt(0), 8400, 8447)
			}

			function d(t) {
				return "string" == typeof t && -1 !== n.indexOf(t.charCodeAt(0))
			}

			function c(t) {
				return "string" == typeof t && 8205 === t.charCodeAt(0)
			}

			function p(t) {
				return (t.charCodeAt(0) - e << 10) + (t.charCodeAt(1) - 56320) + 65536
			}

			function h(t, e, s) {
				return t >= e && t <= s
			}
			t.exports = r, t.exports.substr = function(t, e, s) {
				const i = r(t);
				if (void 0 === e) return t;
				if (e >= i.length) return "";
				const n = i.length - e;
				let o = e + (void 0 === s ? n : s);
				return o > e + n && (o = void 0), i.slice(e, o).join("")
			}
		}
	}
]);