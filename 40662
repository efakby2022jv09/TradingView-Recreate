(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
	[40662, 3657], {
		528847: e => {
			e.exports = {
				content: "content-meCuRfZr",
				titleWrapper: "titleWrapper-meCuRfZr",
				title: "title-meCuRfZr",
				subtitle: "subtitle-meCuRfZr",
				text: "text-meCuRfZr",
				icon: "icon-meCuRfZr",
				group: "group-meCuRfZr",
				groupIcon: "groupIcon-meCuRfZr",
				beforeMarketOpen: "beforeMarketOpen-meCuRfZr",
				afterMarketClose: "afterMarketClose-meCuRfZr",
				groupTitle: "groupTitle-meCuRfZr",
				groupRow: "groupRow-meCuRfZr",
				groupCell: "groupCell-meCuRfZr",
				link: "link-meCuRfZr",
				mob: "mob-meCuRfZr",
				mini: "mini-meCuRfZr"
			}
		},
		410685: (e, t, i) => {
			"use strict";
			i.d(t, {
				DialogRenderer: () => o
			});
			var s = i(262325),
				r = i.n(s);
			class o {
				constructor() {
					this._container = document.createElement("div"), this._visibility = new(r())(!1)
				}
				visible() {
					return this._visibility.readonly()
				}
				_setVisibility(e) {
					this._visibility.setValue(e)
				}
			}
		},
		827565: (e, t, i) => {
			"use strict";
			i.d(t, {
				LollipopGroupIcons: () => s,
				LollipopTooltipContentRow: () => h
			});
			var s, r = i(559496),
				o = i(497754),
				a = i.n(o),
				n = i(83436),
				l = i(528847);

			function h(e) {
				const {
					name: t,
					value: i,
					style: s,
					valueRightIcon: o
				} = e;
				return r.createElement("div", {
					className: l.groupRow,
					style: s
				}, t && r.createElement("div", {
					className: l.groupCell
				}, r.createElement("span", {
					className: l.text
				}, t)), r.createElement("div", {
					className: l.groupCell
				}, r.createElement("span", {
					className: l.text
				}, i), o && r.createElement(n.Icon, {
					icon: o.iconContent,
					className: a()(l.groupIcon, o.iconClass, "apply-common-tooltip"),
					title: o.tooltipText
				})))
			}! function(e) {
				e[e.BeforeMarketOpen = l.beforeMarketOpen] = "BeforeMarketOpen", e[e.AfterMarketClose = l.afterMarketClose] = "AfterMarketClose"
			}(s || (s = {}))
		},
		895405: (e, t, i) => {
			"use strict";
			i.d(t, {
				barFunctionByStyle: () => r
			});
			var s = i(103653);

			function r(e, t) {
				switch (e) {
					case 12:
						return (0, s.barFunction)("low");
					case 2:
					case 3:
					case 10:
					case 13:
						return (0, s.barFunction)(null != t ? t : "close");
					default:
						return (0, s.barFunction)("close", "open")
				}
			}
		},
		736643: (e, t, i) => {
			"use strict";
			i.d(t, {
				getDataVendorString: () => r
			});
			var s = i(611688);

			function r(e) {
				return null == e || s.enabled("bovespa_widget") ? null : "QUANDL" === e.exchange ? "Quandl.com" : ["BMFBOVESPA", "BME", "NAG", "TSE", "TFX", "NZX", "BCBA", "TWSE", "TASE", "EURONEXT", "TOCOM", "BMV", "SIX", "SGX", "GPW", "SWB", "BCS", "WB", "SZSE", "BELEX", "BAHRAIN", "EGX", "TADAWUL", "BVL", "LUXSE", "DFM", "BVC", "NSENG", "IDX", "HSI", "QSE", "OSE"].includes(e.exchange) ? "ICE Data Services" : null
			}
		},
		940448: (e, t, i) => {
			"use strict";
			i.d(t, {
				dateFormatProperty: () => l,
				restoreDateFormatSettingsValue: () => h
			});
			var s = i(62802),
				r = i(860949),
				o = i(830318);
			const a = "date_format";

			function n() {
				return s.getValue(a, (0, o.defaultDateFormat)())
			}
			const l = (0, r.createPrimitiveProperty)(n());

			function h() {
				l.setValue((0, o.defaultDateFormat)()), s.remove(a)
			}
			s.onSync.subscribe(null, (() => l.setValue(n()))), l.subscribe(null, (() => s.setValue(a, l.value())))
		},
		978265: (e, t, i) => {
			"use strict";

			function s(e) {
				const t = Math.abs(Math.round(1e3 * e) / 1e3).toFixed(3).split("."),
					i = t[0];
				let s = t[1];
				return "0" === s[s.length - 1] && (s = s.slice(0, -1)), `${e<0?"âˆ’":""}${i}.${s}`
			}
			i.d(t, {
				roundToThirdDigit: () => s
			})
		},
		740204: (e, t, i) => {
			"use strict";
			i.d(t, {
				LollipopPaneView: () => c
			});
			var s = i(588537),
				r = i(86441),
				o = i(270617),
				a = i(717611),
				n = i(405222),
				l = i(824112),
				h = i(673444),
				u = i(220422),
				d = i(218718);
			class c {
				constructor(e, t, i) {
					this._invalidated = !1, this._renderer = new a.CompositeRenderer, this._textWidthCache = new n.TextWidthCache, this._stylesCache = null, this._lollipops = {}, this._lollipopsCounter = 0, this._lastClickedId = null, this.onPaneBgChange = () => {
						this._recreateStyles(this._model)
					}, this._lastClickedId = null, this._model = e, this._source = t, this._hitTestHandler = i, this._recreateStyles(e), e.backgroundColor().subscribe(this.onPaneBgChange), e.mainSeries().onSymbolIntervalChanged().subscribe(this, this._onSymbolOrIntervalChanged)
				}
				destroy() {
					this._model.backgroundColor().unsubscribe(this.onPaneBgChange), this._model.mainSeries().onSymbolIntervalChanged().unsubscribeAll(this)
				}
				onClickOutside(e) {
					var t;
					if (null === this._lastClickedId || !e) return void this.clearLastClicked();
					let i = null;
					if (function(e) {
							return void 0 !== e.touches
						}(e)) {
						if (1 !== e.touches.length) return; {
							const t = (0, s.ensureNotNull)(e.target).getBoundingClientRect(),
								o = e.touches[0];
							i = new r.Point(o.clientX - t.left, o.clientY - t.top)
						}
					} else i = new r.Point(e.offsetX, e.offsetY);
					const o = this._renderer.hitTest(i, {
						physicalHeight: 0,
						physicalWidth: 0,
						pixelRatio: 1,
						cssHeight: 0,
						cssWidth: 0
					});
					null !== o && (null === (t = o.data()) || void 0 === t ? void 0 : t.activeItem) === (0, s.ensureDefined)(this._lollipops[this._lastClickedId]).itemIndex || this.clearLastClicked()
				}
				clearLastClicked() {
					const e = null !== this._lastClickedId && this._lollipops[this._lastClickedId] || null;
					null !== e && (e.active = !1), this._lastClickedId = null
				}
				getLastClickedLollipopId() {
					return this._lastClickedId
				}
				update() {
					this._invalidated = !0
				}
				afterUpdate(e, t, i, s) {}
				getStyle(e) {
					const t = e.active ? "active" : e.hovered ? "hovered" : "default";
					let i = t;
					if (e.stack && (i += "_stack:" + e.stack), "active" === i) return this._activeStyle;
					if ("hovered" === i) return this._hoveredStyle;
					if ("default" === i) return this._defaultStyle;
					if (this._stylesCache || (this._stylesCache = {}), !this._stylesCache[i]) {
						const s = (0, o.clone)("active" === t ? this._activeStyle : "hovered" === t ? this._hoveredStyle : this._defaultStyle);
						e.stack && (s.lollipop.incHeight = 25 * e.stack), this._stylesCache[i] = s
					}
					return this._stylesCache[i]
				}
				hasTooltip(e) {
					return !0
				}
				_getY() {
					let e = 0;
					const t = this._model.panes();
					for (let i = t.length; i--;) {
						const s = t[i];
						s.containsMainSeries() && (e += s.height())
					}
					return e
				}
				_showBarLine(e) {
					return this.hasTooltip(e) && (e.hovered || e.active)
				}
				_createRenderers(e, t) {
					this._renderer.clear();
					const i = new l.Size(e, t);
					for (const e in this._lollipops)
						if (this._lollipops.hasOwnProperty(e)) {
							const t = (0, s.ensureDefined)(this._lollipops[e]);
							if (t.visible) {
								const e = this.getStyle(t),
									s = {
										id: t.id,
										centerPoint: new r.Point(t.basePoint.x, t.basePoint.y - e.lollipop.bottom - e.lollipop.height / 2 - (e.lollipop.incHeight || 0)),
										style: e
									},
									o = {
										activeItem: t.itemIndex,
										clickHandler: this._lollipopMouseClickHandler.bind(this, s, i),
										tapHandler: this._lollipopMouseClickHandler.bind(this, s, i)
									};
								if (this._renderer.append(this._createRendererForLollipop(s, o)), this._showBarLine(t)) {
									const {
										strokeStyle: i,
										lineStyle: s,
										lineWidth: r
									} = e.barLine, o = {
										color: i,
										linestyle: s,
										linewidth: r,
										x: t.basePoint.x,
										top: 0,
										bottom: t.basePoint.y - e.lollipop.bottom - e.lollipop.height
									}, a = new h.VerticalLineRenderer;
									a.setData(o), this._renderer.insert(a, 0)
								}
							}
						}
				}
				_recreateStyles(e) {
					this._stylesCache = null
				}
				_createRendererForLollipop(e, t) {
					return new u.LollipopRenderer(e, new d.HitTestResult(d.HitTestResult.CUSTOM, t), this._textWidthCache)
				}
				_onSymbolOrIntervalChanged() {
					this._lollipops = {}, this._lollipopsCounter = 0, this._renderer.clear(), this.clearLastClicked()
				}
				_lollipopMouseClickHandler(e, t, i) {
					i.preventDefault();
					const o = e.id;
					if (this._lastClickedId = this._lastClickedId === o ? null : o, null === this._lastClickedId) return;
					const a = {
						target: i.target,
						targetSize: t,
						point: new r.Point(e.centerPoint.x, e.centerPoint.y - e.style.lollipop.height / 2 - 8),
						marginTop: 15
					};
					this._hitTestHandler(a, (() => {
						const e = (0, s.ensureDefined)(this._lollipops[o]),
							t = this.createTooltipContent(e);
						return t ? [t] : null
					}))
				}
			}
		},
		668004: (e, t, i) => {
			"use strict";
			i.d(t, {
				EarningLollipopRenderer: () => u
			});
			var s = i(220422),
				r = i(72461),
				o = i(345185);
			const a = {
					fillPath: new Path2D("M8.961.92a3 3 0 0 1 3.078 0l7.5 4.48A3 3 0 0 1 21 7.975V20a3 3 0 0 1-3 3H3a3 3 0 0 1-3-3V7.975A3 3 0 0 1 1.461 5.4l7.5-4.48z"),
					strokePath: new Path2D("M9.867 2.742c.39-.23.875-.23 1.266 0l7.5 4.406c.382.225.617.635.617 1.078V20c0 .69-.56 1.25-1.25 1.25H3c-.69 0-1.25-.56-1.25-1.25V8.226c0-.443.235-.853.617-1.078l7.5-4.406z")
				},
				n = {
					fillPath: new Path2D("M8.961 22.08a3 3 0 0 0 3.078 0l7.5-4.48A3 3 0 0 0 21 15.025V3a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3v12.025A3 3 0 0 0 1.461 17.6l7.5 4.48z"),
					strokePath: new Path2D("M9.866 20.257c.391.23.877.23 1.268 0l7.5-4.414a1.25 1.25 0 0 0 .616-1.078V3c0-.69-.56-1.25-1.25-1.25H3c-.69 0-1.25.56-1.25 1.25v11.765c0 .443.234.853.616 1.078l7.5 4.414z")
				},
				l = {
					fillPath: new Path2D("M3 0h15c1.662 0 3 1.338 3 3v15c0 1.662-1.338 3-3 3H3c-1.662 0-3-1.338-3-3V3c0-1.662 1.338-3 3-3z"),
					strokePath: new Path2D("M3 1.75h15c.693 0 1.25.557 1.25 1.25v15c0 .693-.557 1.25-1.25 1.25H3c-.692 0-1.25-.558-1.25-1.25V3c0-.692.558-1.25 1.25-1.25z")
				};

			function h(e, t, i, s, a) {
				const n = i.pixelRatio;
				e.save(), e.translate(t.x - s.lollipop.width * n / 2, t.y - s.lollipop.height * n / 2), e.scale(n, n), s.lollipop.fillCircle && s.lollipop.backgroundColor && (e.fillStyle = s.lollipop.backgroundColor, e.fill(a.fillPath)), e.strokeStyle = s.lollipop.strokeStyle, e.lineWidth = Math.round(s.lollipop.lineWidth * n) / n, (0, r.setLineStyle)(e, o.LINESTYLE_SOLID), s.lollipop.fillCircle && s.lollipop.fillStyle && (e.fillStyle = s.lollipop.fillStyle, e.fill(a.strokePath)), e.stroke(a.strokePath), e.restore()
			}
			class u extends s.LollipopRenderer {
				_drawLollipop(e, t, i) {
					const s = this._data.style;
					switch (s.type) {
						case "Positive":
							! function(e, t, i, s) {
								h(e, t, i, s, a)
							}(e, t, i, s);
							break;
						case "Negative":
							! function(e, t, i, s) {
								h(e, t, i, s, n)
							}(e, t, i, s);
							break;
						default:
							! function(e, t, i, s) {
								h(e, t, i, s, l)
							}(e, t, i, s)
					}
				}
			}
		},
		859081: (e, t, i) => {
			"use strict";

			function s(e, t) {
				return e.pixelRatio === t.pixelRatio
			}
			i.d(t, {
				areEqualPaneRenderParams: () => s
			})
		},
		220422: (e, t, i) => {
			"use strict";
			i.d(t, {
				LollipopRenderer: () => u
			});
			var s = i(934026),
				r = i(86441),
				o = i(72461),
				a = i(345185),
				n = i(164149),
				l = i(824112),
				h = i(601132);
			class u {
				constructor(e, t, i) {
					this._data = e, this._hittest = t, this._textWidthCache = i
				}
				draw(e, t) {
					const i = t.pixelRatio,
						s = this._data.centerPoint,
						o = Math.round(s.x * i),
						a = Math.round(s.y * i),
						n = Math.max(1, Math.floor(i)) % 2 / 2,
						l = new r.Point(o + n, a - n);
					this._drawLollipop(e, l, t), this._drawLabel(e, l, t.pixelRatio), this._drawImage(e, l, t.pixelRatio)
				}
				hitTest(e, t) {
					const i = (0, h.interactionTolerance)().esd,
						o = this._data.centerPoint.y - this._data.style.lollipop.height / 2 - i,
						a = this._data.centerPoint.x - this._data.style.lollipop.width / 2 - i,
						n = (0, r.box)(new r.Point(a, o), new r.Point(a + this._data.style.lollipop.width + 2 * i, o + this._data.style.lollipop.height + 2 * i));
					return (0, s.pointInBox)(e, n) ? this._hittest : null
				}
				_drawLollipop(e, t, i) {
					const s = this._data.style,
						r = i.pixelRatio,
						l = Math.max(1, Math.floor(r));
					let h = Math.round(s.lollipop.width * r);
					h % 2 != l % 2 && (h += 1);
					const u = h / 2;
					s.lollipop.fillCircle && s.lollipop.backgroundColor && (e.fillStyle = s.lollipop.backgroundColor, (0, n.createCircle)(e, t.x, t.y, u), e.fill());
					const d = Math.round(s.lollipop.lineWidth * r);
					e.strokeStyle = s.lollipop.strokeStyle, e.lineWidth = d, (0, o.setLineStyle)(e, a.LINESTYLE_SOLID);
					const c = u - Math.round(1 * r + d / 2);
					(0, n.createCircle)(e, t.x, t.y, c), s.lollipop.fillCircle && s.lollipop.fillStyle && (e.fillStyle = s.lollipop.fillStyle, e.fill()), e.stroke()
				}
				_drawLabel(e, t, i) {
					const s = this._data.style.lollipop.text,
						r = s.label;
					if ("" === r) return;
					e.textAlign = "center", e.textBaseline = "middle", e.fillStyle = s.strokeStyle, e.font = s.font;
					const o = this._textWidthCache.yMidCorrection(e, r);
					e.translate(t.x, t.y + ((s.deltaY || 0) + o) * i), (0, l.drawScaled)(e, i, (() => {
						e.fillText(r, 0, 0)
					}))
				}
				_drawImage(e, t, i) {
					const s = this._data.style.lollipop.image;
					if (void 0 === s) return;
					const {
						width: r,
						height: o
					} = s, a = Math.round(r * i), n = Math.round(o * i), l = Math.round(t.x - a / 2), h = Math.round(t.y - n / 2);
					e.drawImage(s, 0, 0, r, o, l, h, a, n)
				}
			}
		},
		663090: (e, t, i) => {
			"use strict";
			i.d(t, {
				IconsContainer: () => n
			});
			var s = i(588537),
				r = i(97639),
				o = i.n(r);
			class a {
				constructor(e, t, i) {
					this._ready = !1, this._img = function(e, t, i) {
						const s = new Image;
						return s.width = t, s.height = t, s.onload = i, s.src = e, s
					}(e, t, (() => {
						this._ready = !0, i()
					}))
				}
				ready() {
					return this._ready
				}
				image() {
					return this._img
				}
			}
			class n {
				constructor(e, t) {
					this._icons = new Map, this._onAllIconsLoaded = new(o()), this._pendingLoading = e.length;
					const i = () => {
						0 == --this._pendingLoading && this._onAllIconsLoaded.fire()
					};
					e.forEach((e => {
						const s = this._icons.get(e.name) || new Map;
						s.set(e.theme, new a(e.imageData, t, i)), this._icons.set(e.name, s)
					}))
				}
				getIcon(e, t) {
					return (0, s.ensureDefined)((0, s.ensureDefined)(this._icons.get(e)).get(t))
				}
				onAllIconsReady() {
					return this._onAllIconsLoaded
				}
			}
		},
		115653: (e, t, i) => {
			"use strict";
			i.d(t, {
				calculateLabelPosition: () => p,
				getTextBoundaries: () => m,
				wordWrap: () => v,
				TextRenderer: () => R
			});
			var s = i(86441),
				r = i(588537),
				o = i(934026),
				a = i(143498),
				n = i(218718),
				l = i(164149),
				h = i(72461),
				u = i(270617),
				d = i(824112),
				c = i(345185),
				_ = i(638456);

			function p(e, t, i, r, o) {
				const a = .5 * (t.x + i.x);
				let n = i.y;
				return t.y > i.y ? (n -= e.height / 2 + r.y, n = Math.max(e.height / 2, n)) : (n += e.height / 2 + r.y, n = Math.min(o - e.height / 2, n)), new s.Point(a, n)
			}

			function m(e, t, i) {
				if (e.isOutOfScreen(t, i)) return null;
				const s = e.getPolygonPoints();
				return 0 === s.length ? null : s
			}
			let y;

			function g() {
				const e = document.createElement("canvas");
				e.width = 0,
					e.height = 0, (0, _.isMac)() && (e.style.display = "none", document.body.append(e)), y = (0, r.ensureNotNull)(e.getContext("2d"))
			}

			function v(e, t, i) {
				y || g(), i = (0, u.isString)(i) ? parseInt(i) : i, e += "";
				const s = !(0, u.isNumber)(i) || !isFinite(i) || i <= 0 ? e.split(/\r\n|\r|\n|$/) : e.split(/[^\S\r\n]*(?:\r\n|\r|\n|$)/);
				if (s[s.length - 1] || s.pop(), !(0, u.isNumber)(i) || !isFinite(i) || i <= 0) return s;
				y.font = t;
				const r = [];
				for (let e = 0; e < s.length; e++) {
					const t = s[e],
						o = y.measureText(t).width;
					if (o <= i) {
						r.push(t);
						continue
					}
					const a = t.split(/([-)\]},.!?:;])|(\s+)/);
					let n = 0;
					for (; a.length;) {
						let e = ~~(i / o * (a.length + 2) / 3);
						if (e <= 0 || y.measureText(a.slice(0, 3 * e - 1).join("")).width <= i)
							for (; y.measureText(a.slice(0, 3 * (e + 1) - 1).join("")).width <= i;) e++;
						else
							for (; e > 0 && y.measureText(a.slice(0, 3 * --e - 1).join("")).width > i;);
						if (e > 0) r.push(a.slice(0, 3 * e - 1).join("")), a.splice(0, 3 * e);
						else {
							const e = a[0] + (a[1] || "");
							if (n = 1 === n ? 1 : ~~(i / y.measureText(e).width * e.length), y.measureText(e.substring(0, n)).width <= i)
								for (; y.measureText(e.substring(0, n + 1)).width <= i;) n++;
							else
								for (; n > 1 && y.measureText(e.substring(0, --n)).width > i;);
							n < 1 && (n = 1), r.push(e.substring(0, n)), a[0] = e.substring(n), a[1] = ""
						}
						if (y.measureText(a.join("")).width <= i) {
							r.push(a.join(""));
							break
						}
					}
				}
				return r
			}

			function S(e, t, i) {
				if (0 === i) return e.clone();
				const r = (e.x - t.x) * Math.cos(i) - (e.y - t.y) * Math.sin(i) + t.x,
					o = (e.x - t.x) * Math.sin(i) + (e.y - t.y) * Math.cos(i) + t.y;
				return new s.Point(r, o)
			}

			function b(e, t) {
				const i = Math.round(t + 2 * I(e) + 2 * x(e));
				return i % 2 ? i + 1 : i
			}

			function f(e, t) {
				return T(e) * t + P(e) * (t - 1) + 2 * C(e) + 2 * w(e)
			}

			function w(e) {
				return void 0 !== e.boxPaddingVert ? e.boxPaddingVert * L(e) : void 0 !== e.boxPadding ? e.boxPadding * L(e) : T(e) / 3
			}

			function x(e) {
				return void 0 !== e.boxPaddingHorz ? e.boxPaddingHorz * L(e) : void 0 !== e.boxPadding ? e.boxPadding * L(e) : T(e) / 3
			}

			function C(e) {
				return (e.backgroundVertInflate || 0) * L(e)
			}

			function I(e) {
				return (e.backgroundHorzInflate || 0) * L(e)
			}

			function P(e) {
				return (e.padding || 0) * L(e)
			}

			function T(e) {
				return Math.ceil(D(e) * L(e))
			}

			function D(e) {
				return e.fontsize || e.fontSize || 30
			}

			function L(e) {
				const t = Math.min(1, Math.max(.2, Math.min(e.scaleX || 1, e.scaleY || 1)));
				if (1 === t) return t;
				const i = D(e);
				return Math.ceil(t * i) / i
			}
			class R {
				constructor(e, t) {
					this._data = null, this._internalData = null, this._boxSize = null, this._polygonPoints = null, this._linesInfo = null, this._fontInfo = null, this._hittest = t || new n.HitTestResult(n.HitTestResult.MOVEPOINT, {
						areaName: n.AreaName.Text
					}), void 0 !== e && this.setData(e)
				}
				setData(e) {
					e.horzTextAlign || (e.horzTextAlign = e.horzAlign),
						function(e, t) {
							if (null === e || null === t) return null === e == (null === t);
							if (void 0 === e.points != (void 0 === t.points)) return !1;
							if (void 0 !== e.points && void 0 !== t.points) {
								if (e.points.length !== t.points.length) return !1;
								for (let r = 0; r < e.points.length; ++r)
									if (i = e.points[r], s = t.points[r], i.x !== s.x || i.y !== s.y) return !1
							}
							var i, s;
							return e.text === t.text && e.vertAlign === t.vertAlign && e.horzAlign === t.horzAlign && e.horzTextAlign === t.horzTextAlign && e.font === t.font && e.offsetX === t.offsetX && e.offsetY === t.offsetY && e.bold === t.bold && e.italic === t.italic && e.fontsize === t.fontsize && e.fontSize === t.fontSize && e.backgroundRoundRect === t.backgroundRoundRect && e.forceTextAlign === t.forceTextAlign && e.wordWrapWidth === t.wordWrapWidth && e.forceCalculateMaxLineWidth === t.forceCalculateMaxLineWidth && e.padding === t.padding && e.scaleY === t.scaleY && e.scaleX === t.scaleX && e.highlightBorder === t.highlightBorder && e.backgroundHorzInflate === t.backgroundHorzInflate && e.backgroundVertInflate === t.backgroundVertInflate && e.boxPadding === t.boxPadding && e.boxPaddingVert === t.boxPaddingVert && e.boxPaddingHorz === t.boxPaddingHorz && e.angle === t.angle && e.maxHeight === t.maxHeight && (0, u.deepEquals)(e.boxShadow, t.boxShadow)[0]
						}(this._data, e) ? this._data = e : (this._data = e, this._internalData = null, this._boxSize = null, this._polygonPoints = null, this._linesInfo = null, this._fontInfo = null)
				}
				hitTest(e) {
					return null === this._data || void 0 === this._data.points || 0 === this._data.points.length ? null : (0, o.pointInPolygon)(e, this.getPolygonPoints()) ? this._hittest : null
				}
				doesIntersectWithBox(e) {
					return null !== this._data && void 0 !== this._data.points && 0 !== this._data.points.length && (0, o.pointInBox)(this._data.points[0], e)
				}
				measure() {
					if (null === this._data) return {
						width: 0,
						height: 0
					};
					const e = this._getBoxSize();
					return {
						width: e.boxWidth,
						height: e.boxHeight
					}
				}
				rect() {
					if (null === this._data) return {
						x: 0,
						y: 0,
						width: 0,
						height: 0
					};
					const e = this._getInternalData();
					return {
						x: e.boxLeft,
						y: e.boxTop,
						width: e.boxWidth,
						height: e.boxHeight
					}
				}
				isOutOfScreen(e, t) {
					if (null === this._data || void 0 === this._data.points || 0 === this._data.points.length) return !0;
					const i = this._getInternalData();
					if (i.boxLeft + i.boxWidth < 0 || i.boxLeft > e) {
						const i = (0, s.box)(new s.Point(0, 0), new s.Point(e, t));
						return this.getPolygonPoints().every((e => !(0, o.pointInBox)(e, i)))
					}
					return !1
				}
				setPoints(e, t) {
					(0, r.ensureNotNull)(this._data).points = e, this._hittest = t || new n.HitTestResult(n.HitTestResult.MOVEPOINT)
				}
				fontStyle(e) {
					return null === this._data ? "" : this._getFontInfo().fontStyle
				}
				wordWrap(e, t, i) {
					return v(e, i || this.fontStyle(), t)
				}
				draw(e, t) {
					if (null === this._data || void 0 === this._data.points || 0 === this._data.points.length) return;
					if (this.isOutOfScreen(t.cssWidth, t.cssHeight)) return;
					const i = t.pixelRatio,
						s = this._getInternalData(),
						r = this._getRotationPoint().scaled(i);
					e.save(), e.translate(r.x, r.y), e.rotate(this._data.angle || 0), e.translate(-r.x, -r.y);
					const o = this._getFontInfo().fontSize;
					e.textBaseline = s.textBaseLine, e.textAlign = s.textAlign, e.font = this.fontStyle();
					const {
						scaledLeft: a,
						scaledRight: n,
						scaledTop: u,
						scaledBottom: _
					} = function(e, t) {
						const i = Math.round(e.boxLeft * t),
							s = Math.round(e.boxTop * t);
						return {
							scaledLeft: i,
							scaledRight: i + Math.round(e.boxWidth * t),
							scaledTop: s,
							scaledBottom: s + Math.round(e.boxHeight * t)
						}
					}(s, i);
					if (this._data.backgroundColor || this._data.borderColor || this._data.highlightBorder && this._data.wordWrapWidth) {
						const t = this._data.borderWidth || Math.max(o / 12, 1),
							s = Math.round(t * i),
							r = s / 2;
						let d = !1;
						if (this._data.boxShadow) {
							e.save();
							const {
								shadowColor: t,
								shadowBlur: i,
								shadowOffsetX: s = 0,
								shadowOffsetY: r = 0
							} = this._data.boxShadow;
							e.shadowColor = t, e.shadowBlur = i, e.shadowOffsetX = s, e.shadowOffsetY = r, d = !0
						}
						if (this._data.backgroundRoundRect) this._data.backgroundColor && ((0, l.drawRoundRect)(e, a, u, n - a, _ - u, this._data.backgroundRoundRect * i), e.fillStyle = this._data.backgroundColor, e.fill(), d && (e.restore(), d = !1)), this._data.borderColor && ((0, l.drawRoundRect)(e, a - r, u - r, n - a + s, _ - u + s, this._data.backgroundRoundRect * i + s), e.strokeStyle = this._data.borderColor, e.lineWidth = s, e.stroke(), d && (e.restore(), d = !1));
						else if (this._data.backgroundColor && (e.fillStyle = this._data.backgroundColor, e.fillRect(a, u, n - a, _ - u), d && (e.restore(), d = !1)), this._data.borderColor || this._data.highlightBorder) {
							let t;
							this._data.borderColor ? (e.strokeStyle = this._data.borderColor, t = s) : (e.strokeStyle = this._data.color, (0, h.setLineStyle)(e, c.LINESTYLE_DASHED), t = Math.max(1, Math.floor(i))), e.lineWidth = t, e.beginPath(), e.moveTo(a - t / 2, u - t / 2), e.lineTo(a - t / 2, _ + t / 2), e.lineTo(n + t / 2, _ + t / 2), e.lineTo(n + t / 2, u - t / 2), e.lineTo(a - t / 2, u - t / 2), e.stroke(), d && e.restore()
						}
					}
					e.fillStyle = this._data.color;
					const p = (a + Math.round(s.textStart * i)) / i,
						m = .05 * o;
					let y = (u + Math.round((s.textTop + m) * i)) / i;
					const g = P(this._data),
						v = this.getLinesInfo();
					for (const t of v.lines)(0, d.drawScaled)(e, i, (() => e.fillText(t, p, y))), y += o + g;
					e.restore()
				}
				getPolygonPoints() {
					if (null !== this._polygonPoints) return this._polygonPoints;
					if (null === this._data) return [];
					const e = this._data.angle || 0,
						{
							boxLeft: t,
							boxTop: i,
							boxWidth: r,
							boxHeight: o
						} = this._getInternalData(),
						a = this._getRotationPoint();
					return this._polygonPoints = [S(new s.Point(t, i), a, e), S(new s.Point(t + r, i), a, e), S(new s.Point(t + r, i + o), a, e), S(new s.Point(t, i + o), a, e)], this._polygonPoints
				}
				getLinesInfo() {
					if (null === this._linesInfo) {
						const e = (0, r.ensureNotNull)(this._data);
						let t = this.wordWrap(e.text, e.wordWrapWidth);
						if (void 0 !== e.maxHeight) {
							const i = function(e) {
								const t = (0, r.ensureDefined)(e.maxHeight),
									i = T(e),
									s = P(e);
								return Math.floor((t + s) / (i + s))
							}(e);
							t.length > i && (t = t.slice(0, i))
						}
						this._linesInfo = {
							linesMaxWidth: this._getLinesMaxWidth(t),
							lines: t
						}
					}
					return this._linesInfo
				}
				_getLinesMaxWidth(e) {
					if (y || g(), y.textBaseline = "alphabetic", y.font = this.fontStyle(), null !== this._data && this._data.wordWrapWidth && !this._data.forceCalculateMaxLineWidth) return this._data.wordWrapWidth * L(this._data);
					let t = 0;
					for (const i of e) t = Math.max(t, y.measureText(i).width);
					return t
				}
				_getInternalData() {
					if (null !== this._internalData) return this._internalData;
					const e = (0, r.ensureNotNull)(this._data),
						t = this._getBoxSize(),
						i = t.boxWidth,
						s = t.boxHeight,
						o = (0, r.ensureDefined)(e.points)[0];
					let n = o.y;
					switch (e.vertAlign) {
						case "bottom":
							n -= s + e.offsetY;
							break;
						case "middle":
							n -= s / 2;
							break;
						case "top":
							n += e.offsetY
					}
					let l = o.x;
					const h = x(e),
						u = w(e),
						d = I(e) + h;
					let c;
					const _ = n + (C(e) + u) + T(e) / 2;
					let p;
					switch (e.horzAlign) {
						case "left":
							l += e.offsetX;
							break;
						case "center":
							l -= i / 2;
							break;
						case "right":
							l -= i + e.offsetX
					}
					switch ((0, r.ensureDefined)(e.horzTextAlign)) {
						case "left":
							p = "start", c = l + d, (0, a.isRtl)() && (e.forceTextAlign ? p = "left" : (c = l + i - d, p = "right"));
							break;
						case "center":
							p = "center", c = l + i / 2;
							break;
						case "right":
							p = "end", c = l + i - d, (0,
								a.isRtl)() && e.forceTextAlign && (p = "right")
					}
					return this._internalData = {
						boxLeft: l,
						boxTop: n,
						boxWidth: i,
						boxHeight: s,
						textStart: c - l,
						textTop: _ - n,
						textAlign: p,
						textBaseLine: "middle"
					}, this._internalData
				}
				_getFontInfo() {
					if (null === this._fontInfo) {
						const e = (0, r.ensureNotNull)(this._data),
							t = T(e),
							i = (e.bold ? "bold " : "") + (e.italic ? "italic " : "") + t + "px " + e.font;
						this._fontInfo = {
							fontStyle: i,
							fontSize: t
						}
					}
					return this._fontInfo
				}
				_getBoxSize() {
					if (null === this._boxSize) {
						const e = this.getLinesInfo(),
							t = (0, r.ensureNotNull)(this._data);
						this._boxSize = {
							boxWidth: b(t, e.linesMaxWidth),
							boxHeight: f(t, e.lines.length)
						}
					}
					return this._boxSize
				}
				_getRotationPoint() {
					const {
						boxLeft: e,
						boxTop: t,
						boxWidth: i,
						boxHeight: o
					} = this._getInternalData(), {
						horzAlign: a,
						vertAlign: n
					} = (0, r.ensureNotNull)(this._data);
					let l, h;
					switch (a) {
						case "center":
							l = e + i / 2;
							break;
						case "left":
							l = e;
							break;
						case "right":
							l = e + i
					}
					switch (n) {
						case "middle":
							h = t + o / 2;
							break;
						case "top":
							h = t;
							break;
						case "bottom":
							h = t + o
					}
					return new s.Point(l, h)
				}
			}
		},
		821555: (e, t, i) => {
			"use strict";
			i.d(t, {
				drawArrow: () => c,
				TrendLineRenderer: () => _
			});
			var s = i(588537),
				r = i(204652),
				o = i(963985),
				a = i(218718),
				n = i(72461),
				l = i(601132),
				h = i(164149),
				u = i(824112);

			function d(e, t, i, s, r) {
				t.save(), t.fillStyle = "#000000", t.beginPath(), t.arc(e.x * r, e.y * r, i * r, 0, 2 * Math.PI, !1), t.fill(), s.strokeWidth && (t.lineWidth = s.strokeWidth, t.stroke()), t.restore()
			}

			function c(e, t, i, s, r, o = !1) {
				if (t.subtract(e).length() < 1) return;
				const a = (0, l.getArrowPoints)(e, t, s, o);
				for (let e = 0; e < a.length; ++e) {
					const t = a[e][0],
						s = a[e][1];
					(0, n.drawLine)(i, t.x * r, t.y * r, s.x * r, s.y * r)
				}
			}
			class _ {
				constructor() {
					this._data = null, this._hittest = new a.HitTestResult(a.HitTestResult.MOVEPOINT)
				}
				setData(e) {
					this._data = e
				}
				setHitTest(e) {
					this._hittest = e
				}
				draw(e, t) {
					const i = this._data;
					if (null === i) return;
					if ("points" in i && i.points.length < 2) return;
					const s = t.pixelRatio;
					void 0 !== i.excludeBoundaries && (e.save(), (0, u.addExclusionArea)(e, t, i.excludeBoundaries)), e.lineCap = "butt", e.strokeStyle = i.color, e.lineWidth = Math.max(1, Math.floor(i.linewidth * s)), (0, n.setLineStyle)(e, i.linestyle);
					const r = i.points[0],
						o = i.points[1];
					let a = [];
					i.overlayLineEndings ? a = [r.clone(), o.clone()] : this._drawEnds(e, [r, o], i.linewidth, s);
					const l = this._extendAndClipLineSegment(r, o, t);
					null !== l && i.linewidth > 0 && (l[0].x === l[1].x ? (0, h.drawVerticalLine)(e, Math.round(l[0].x * s), l[0].y * s, l[1].y * s) : l[0].y === l[1].y ? (0, h.drawHorizontalLine)(e, Math.round(l[0].y * s), l[0].x * s, l[1].x * s) : (0, n.drawLine)(e, l[0].x * s, l[0].y * s, l[1].x * s, l[1].y * s)), i.overlayLineEndings && this._drawEnds(e, a, i.linewidth, s), void 0 !== i.excludeBoundaries && e.restore()
				}
				hitTest(e, t) {
					const i = this._data;
					if (null === i) return null;
					if ("points" in i && i.points.length < 2) return null;
					const s = (0, l.interactionTolerance)().line,
						o = i.points[0],
						a = i.points[1],
						n = this._extendAndClipLineSegment(o, a, t);
					if (null !== n) {
						if ((0, r.distanceToSegment)(n[0], n[1], e).distance <= s) return this._hittest
					}
					return null
				}
				_extendAndClipLineSegment(e, t, i) {
					const r = (0, s.ensureNotNull)(this._data);
					return (0, l.extendAndClipLineSegment)(e, t, i.cssWidth, i.cssHeight, r.extendleft, r.extendright)
				}
				_drawEnds(e, t, i, r) {
					const a = t[0],
						n = t[1],
						l = (0, s.ensureNotNull)(this._data);
					switch (l.leftend) {
						case o.LineEnd.Arrow:
							c(n, a, e, i, r);
							break;
						case o.LineEnd.Circle:
							d(a, e, i, (0, s.ensureDefined)(l.endstyle), r)
					}
					switch (l.rightend) {
						case o.LineEnd.Arrow:
							c(a, n, e, i, r);
							break;
						case o.LineEnd.Circle:
							d(n, e, i, (0, s.ensureDefined)(l.endstyle), r)
					}
				}
			}
		},
		673444: (e, t, i) => {
			"use strict";
			i.d(t, {
				VerticalLineRenderer: () => l
			});
			var s = i(218718),
				r = i(72461),
				o = i(164149),
				a = i(601132),
				n = i(824112);
			class l {
				constructor() {
					this._data = null, this._hitTest = new s.HitTestResult(s.HitTestResult.MOVEPOINT)
				}
				setData(e) {
					this._data = e
				}
				setHitTest(e) {
					this._hitTest = e
				}
				hitTest(e) {
					if (null === this._data || null === this._hitTest) return null;
					const t = (0, a.interactionTolerance)().line,
						i = Math.abs(e.x - this._data.x) <= t + this._data.linewidth / 2,
						s = void 0 === this._data.top || this._data.top - e.y <= t,
						r = void 0 === this._data.bottom || e.y - this._data.bottom <= t;
					return i && s && r ? this._hitTest : null
				}
				draw(e, t) {
					if (null === this._data) return;
					if (this._data.linewidth <= 0) return;
					if (this._data.x < -this._data.linewidth / 2 || this._data.x > t.cssWidth + this._data.linewidth / 2) return;
					const i = t.pixelRatio;
					e.lineCap = "butt", e.strokeStyle = this._data.color, e.lineWidth = Math.max(1, Math.floor(this._data.linewidth * i)), void 0 !== this._data.linestyle && (0, r.setLineStyle)(e, this._data.linestyle);
					const s = void 0 !== this._data.top ? Math.max(this._data.top, 0) : 0,
						a = void 0 !== this._data.bottom ? Math.min(this._data.bottom, t.cssHeight) : t.cssHeight,
						l = Math.round(this._data.x * i),
						h = Math.floor(s * i),
						u = Math.ceil(a * i),
						d = this._data.excludeBoundaries;
					void 0 !== d && (e.save(), (0, n.addExclusionArea)(e, t, d)), (0, o.drawVerticalLine)(e, l, h, u), void 0 !== d && e.restore()
				}
			}
		},
		943615: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				fromPercent: () => a,
				toPercent: () => n,
				toPercentRange: () => l,
				fromIndexedTo100: () => h,
				toIndexedTo100: () => u,
				toIndexedTo100Range: () => d,
				toLog: () => c,
				fromLog: () => _,
				logFormulaForPriceRange: () => p,
				logFormulasAreSame: () => m,
				getCurrentModePriceText: () => y,
				getOppositeModePriceText: () => g
			});
			var s = i(559270),
				r = i(466915);
			const o = {
				logicalOffset: 4,
				coordOffset: 1e-4
			};

			function a(e, t) {
				return t < 0 && (e = -e), e / 100 * t + t
			}

			function n(e, t) {
				const i = 100 * (e - t) / t;
				return t < 0 ? -i : i
			}

			function l(e, t) {
				const i = n(e.minValue(), t),
					r = n(e.maxValue(), t);
				return new s.PriceRange(i, r)
			}

			function h(e, t) {
				return t < 0 && (e = -e), (e -= 100) / 100 * t + t
			}

			function u(e, t) {
				const i = 100 * (e - t) / t + 100;
				return t < 0 ? -i : i
			}

			function d(e, t) {
				const i = u(e.minValue(), t),
					r = u(e.maxValue(), t);
				return new s.PriceRange(i, r)
			}

			function c(e, t) {
				const i = Math.abs(e);
				if (i < 1e-15) return 0;
				const s = (0, r.log10)(i + t.coordOffset) + t.logicalOffset;
				return e < 0 ? -s : s
			}

			function _(e, t) {
				const i = Math.abs(e);
				if (i < 1e-15) return 0;
				const s = Math.pow(10, i - t.logicalOffset) - t.coordOffset;
				return e < 0 ? -s : s
			}

			function p(e) {
				if (null === e) return o;
				const t = Math.abs(e.maxValue() - e.minValue());
				if (t >= 1 || t < 1e-15) return o;
				const i = Math.ceil(Math.abs(Math.log10(t))),
					s = o.logicalOffset + i;
				return {
					logicalOffset: s,
					coordOffset: 1 / Math.pow(10, s)
				}
			}

			function m(e, t) {
				return e.logicalOffset === t.logicalOffset && e.coordOffset === t.coordOffset
			}

			function y(e, t) {
				return e.isPercentage() ? t.formattedPricePercentage : e.isIndexedTo100() ? t.formattedPriceIndexedTo100 : t.formattedPriceAbsolute
			}

			function g(e, t) {
				return e.isPercentage() || e.isIndexedTo100() ? t.formattedPriceAbsolute : t.formattedPricePercentage
			}
		},
		214729: (e, t, i) => {
			"use strict";
			i.d(t, {
				combineProperty: () => l,
				createPrimitivePropertyFromGetterAndSubscription: () => n,
				createWVFromGetterAndSubscription: () => s.createWVFromGetterAndSubscription,
				createWVFromGetterAndSubscriptions: () => r.createWVFromGetterAndSubscriptions,
				createWVFromProperty: () => o
			});
			var s = i(841926),
				r = i(60674);

			function o(e) {
				return (0, s.createWVFromGetterAndSubscription)((() => e.value()), e)
			}
			var a = i(860949);

			function n(e, t) {
				const i = (0, a.createPrimitiveProperty)(e()),
					s = {};
				return i.destroy = () => {
					t.unsubscribeAll(s)
				}, t.subscribe(s, (() => {
					i.setValue(e())
				})), i
			}

			function l(e, ...t) {
				const i = () => e(...t.map((e => e.value()))),
					s = (0, a.createPrimitiveProperty)(i()),
					r = () => s.setValue(i()),
					o = {};
				for (const e of t) e.subscribe(o, r);
				return s.destroy = () => {
					t.forEach((e => e.unsubscribeAll(o)))
				}, s
			}
		},
		841926: (e, t, i) => {
			"use strict";
			i.d(t, {
				createWVFromGetterAndSubscription: () => o
			});
			var s = i(262325),
				r = i.n(s);

			function o(e, t) {
				const i = new(r())(e()),
					s = {};
				t.subscribe(s, (() => {
					i.setValue(e())
				}));
				return i.readonly().spawn((() => t.unsubscribeAll(s)))
			}
		},
		60674: (e, t, i) => {
			"use strict";
			i.d(t, {
				createWVFromGetterAndSubscriptions: () => o
			});
			var s = i(262325),
				r = i.n(s);

			function o(e, t) {
				const i = new(r())(e()),
					s = {};
				t.forEach((t => t.subscribe(s, (() => {
					i.setValue(e())
				}))));
				return i.readonly().spawn((() => t.forEach((e => e.unsubscribeAll(s)))))
			}
		},
		556074: (e, t, i) => {
			"use strict";
			i.d(t, {
				QuotesProvider: () => n
			});
			var s = i(124418),
				r = i(97639),
				o = i.n(r),
				a = i(95935);
			class n {
				constructor(e = "full") {
					this._quotes = null, this._quoteSessionSymbol = null, this._quoteSessionClientId = "", this._quotesUpdate = new(o()), this._quoteSymbolChanged = new(o()), this._multiplexerType = e
				}
				setQuotesSessionSymbol(e) {
					this._quoteSessionSymbol !== e && (this._quoteSessionClientId || (this._quoteSessionClientId = "series-" + (0, a.guid)()), this._unsubscribeQuoteSession(), e && this._subscribeQuoteSession(e), this._quoteSymbolChanged.fire())
				}
				quotesUpdate() {
					return this._quotesUpdate
				}
				quoteSymbolChanged() {
					return this._quoteSymbolChanged
				}
				quotes() {
					return this._quotes
				}
				destroy() {
					this._unsubscribeQuoteSession()
				}
				_onUpdate(e, t) {
					this._quotes = e && e.values || null, t && t.values && this._quotesUpdate.fire(e, t)
				}
				_subscribeQuoteSession(e) {
					this._quoteSessionSymbol = e, (0, s.getQuoteSessionInstance)(this._multiplexerType).subscribe(this._quoteSessionClientId, this._quoteSessionSymbol, this._onUpdate.bind(this))
				}
				_unsubscribeQuoteSession() {
					this._quoteSessionSymbol && ((0, s.getQuoteSessionInstance)(this._multiplexerType).unsubscribe(this._quoteSessionClientId, this._quoteSessionSymbol), this._quoteSessionSymbol = null, this._quotes = null)
				}
			}
		},
		328057: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesAreaPaneView: () => l
			});
			var s = i(721386),
				r = i(896949),
				o = i(717611),
				a = i(859447),
				n = i(671676);
			class l extends n.SeriesSingleLinePaneView {
				renderer(e, t) {
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const i = this._source.priceScale();
					if (!i) return null;
					const n = this._source.properties().childs().areaStyle.childs(),
						l = n.transparency.value(),
						h = {
							simpleMode: !1,
							barSpacing: this._model.timeScale().barSpacing(),
							items: this._items,
							lineColor: n.linecolor.value(),
							lineStyle: n.linestyle.value(),
							lineWidth: n.linewidth.value(),
							isSeries: !0,
							withMarkers: !1,
							bottom: i.height(),
							color1: (0, s.generateColor)(n.color1.value(), l),
							color2: (0, s.generateColor)(n.color2.value(), l)
						},
						u = new o.CompositeRenderer;
					return u.append(new r.PaneRendererArea(h)), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData && u.append(new a.SelectionRenderer(this._selectionData)), u
				}
			}
		},
		702052: (e, t, i) => {
			"use strict";

			function s(e, t) {
				return 100 * (t - e) / Math.abs(e)
			}
			i.d(t, {
				barPercentChange: () => s
			})
		},
		837778: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesBarsPaneView: () => n
			});
			var s = i(717611),
				r = i(859447),
				o = i(338891),
				a = i(207152);
			class n extends o.SeriesBarCandlesPaneView {
				renderer(e, t) {
					this._invalidated && (this._updateImpl(null), this._invalidated = !1);
					const i = this._source.properties().childs(),
						o = {
							bars: this._bars,
							barSpacing: this._model.timeScale().barSpacing(),
							dontDrawOpen: i.barStyle.childs().dontDrawOpen.value(),
							thinBars: 11 === i.style.value() ? i.rangeStyle.childs().thinBars.value() : i.barStyle.childs().thinBars.value()
						},
						n = new s.CompositeRenderer;
					return n.append(new a.PaneRendererBars(o)), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData && n.append(new r.SelectionRenderer(this._selectionData)), n
				}
				_createItem(e, t, i) {
					const s = {
						time: e,
						open: NaN,
						high: NaN,
						low: NaN,
						close: NaN,
						color: i.barColor
					};
					return (0, o.baseBarCandlesUpdater)(t, s) ? s : null
				}
			}
		},
		870914: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesBaselinePaneView: () => m
			});
			var s = i(721386),
				r = i(717611),
				o = i(86441),
				a = i(5531),
				n = i(204652),
				l = i(601132),
				h = i(377884),
				u = i(380047),
				d = i(218718);
			class c extends u.ScaledPaneRenderer {
				constructor() {
					super(...arguments), this._data = null
				}
				setData(e) {
					this._data = e
				}
				hitTest(e) {
					if (null === this._data) return null;
					const {
						items: t,
						topLineWidth: i,
						bottomLineWidth: s
					} = this._data, r = (0, l.interactionTolerance)().series + (i + s) / 4, a = (0, h.lowerbound)(t, e, ((e, t) => e.x <= t.x)), u = Math.max(1, a - 1), c = Math.min(t.length - 1, a + 1);
					for (let i = u; i <= c; ++i) {
						const s = t[i - 1],
							a = t[i],
							{
								distance: l
							} = (0, n.distanceToSegment)(new o.Point(s.x, s.y), new o.Point(a.x, a.y), new o.Point(e.x, e.y));
						if (l <= r) return new d.HitTestResult(d.HitTestResult.REGULAR)
					}
					return null
				}
				_drawImpl(e) {
					if (null === this._data) return;
					const {
						items: t,
						baseLevelCoordinate: i,
						bottom: s,
						bottomFillColor1: r,
						bottomFillColor2: n,
						topFillColor1: h,
						topFillColor2: u,
						topLineColor: d,
						bottomLineColor: c,
						topLineWidth: _,
						bottomLineWidth: p
					} = this._data;
					if (! function(e) {
							if (0 === e.length) return !1;
							const t = e.findIndex((e => (0, l.coordinateIsValid)(e.y)));
							if (-1 === t) return !1;
							let i = e.length - 1;
							for (; i > t && !(0, l.coordinateIsValid)(e[i].y);) i--;
							return !(t > i)
						}(t)) return;
					const {
						topItems: m,
						bottomItems: y
					} = function(e, t) {
						const i = [],
							s = [];
						let r = null;
						for (let n = 0; n < e.length; n++) {
							let h = e[n];
							const u = e[n + 1] || {};
							if ((0, l.coordinateIsValid)(h.y)) h.y <= t && i.push(h), h.y >= t && s.push(h), r = h;
							else {
								if (null === r) continue;
								h = r
							}
							if ((0, l.coordinateIsValid)(u.y) && (h.y > t && u.y < t || h.y < t && u.y > t))
								if (Math.abs(h.x - u.x) < 1) {
									const e = new o.Point(h.x, t);
									i.push(e), s.push(e)
								} else {
									const e = (0, a.intersectLineSegments)(h, u, new o.Point(h.x, t), new o.Point(u.x, t));
									if (null !== e) {
										const t = h.add(u.subtract(h).scaled(e));
										i.push(t), s.push(t)
									}
								}
						}
						return {
							topItems: i,
							bottomItems: s
						}
					}(t, i);
					e.lineCap = "round", e.lineJoin = "round", 0 !== m.length && (e.beginPath(), e.moveTo(m[0].x, i), this._makeLine(e, m, !0, 0), e.closePath(), e.fillStyle = this._makeLinearGradient(e, h, u, i - s, i), e.fill(), e.beginPath(), this._makeLine(e, m, !1, 0), e.lineWidth = _, e.strokeStyle = d, e.stroke()), 0 !== y.length && (e.beginPath(), e.moveTo(y[0].x, i), this._makeLine(e, y, !0, 1), e.closePath(), e.fillStyle = this._makeLinearGradient(e, r, n, i, i + s), e.fill(), e.beginPath(), this._makeLine(e, y, !1, 1), e.lineWidth = p, e.strokeStyle = c, e.stroke())
				}
				_makeLine(e, t, i, s) {
					if (null === this._data) return;
					const r = t.findIndex((e => (0, l.coordinateIsValid)(e.y)));
					if (-1 === r) return;
					const {
						barSpacing: o,
						baseLevelCoordinate: a
					} = this._data, n = .25 * o;
					let h;
					const u = t.length;
					for (let o = r; o < u; o++) {
						const u = t[o],
							d = t[o + 1] || {};
						if ((0, l.coordinateIsValid)(u.y)) {
							if (0 === s) {
								if (h && h.y >= a && u.y >= a) {
									e.moveTo(u.x, u.y);
									continue
								}
							} else if (h && h.y <= a && u.y <= a) {
								e.moveTo(u.x, u.y);
								continue
							}
							if (h && (0, l.coordinateIsValid)(h.y)) e.lineTo(u.x, u.y), i && !(0, l.coordinateIsValid)(d.y) && e.lineTo(u.x, a);
							else if (d && (0, l.coordinateIsValid)(d.y)) i ? (o !== r && e.lineTo(u.x, a), e.lineTo(u.x, u.y)) : e.moveTo(u.x, u.y);
							else if (i) {
								if (0 === o) continue;
								o !== r && e.lineTo(u.x - n, a), e.lineTo(u.x - n, u.y), e.lineTo(u.x + n, u.y), e.lineTo(u.x + n, a)
							} else e.moveTo(u.x - n, u.y), e.lineTo(u.x + n, u.y);
							h = u
						}
					}
				}
				_makeLinearGradient(e, t, i, s, r) {
					const o = e.createLinearGradient(0, s, 0, r);
					return o.addColorStop(0, t), o.addColorStop(1, i), o
				}
			}
			var _ = i(859447),
				p = i(671676);
			class m extends p.SeriesSingleLinePaneView {
				constructor() {
					super(...arguments), this._renderer = new c, this._topFillColor1 = "", this._topFillColor2 = "", this._bottomFillColor1 = "", this._bottomFillColor2 = "", this._topLineColor = "", this._bottomLineColor = "", this._topLineWidth = 0, this._bottomLineWidth = 0, this._barSpacing = 0, this._bottom = 0, this._baseLevelCoordinate = 0
				}
				renderer(e, t) {
					this._invalidated && (this._updateImpl(), this._invalidated = !1), this._renderer.setData({
						items: this._items,
						topFillColor1: this._topFillColor1,
						topFillColor2: this._topFillColor2,
						bottomFillColor1: this._bottomFillColor1,
						bottomFillColor2: this._bottomFillColor2,
						topLineColor: this._topLineColor,
						bottomLineColor: this._bottomLineColor,
						topLineWidth: this._topLineWidth,
						bottomLineWidth: this._bottomLineWidth,
						barSpacing: this._barSpacing,
						baseLevelCoordinate: this._baseLevelCoordinate,
						bottom: this._bottom
					});
					const i = new r.CompositeRenderer;
					return i.append(this._renderer), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData && i.append(new _.SelectionRenderer(this._selectionData)), i
				}
				_updateImpl() {
					super._updateImpl();
					const e = this._source.priceScale();
					if (!e) return;
					const t = this._source.properties().childs().baselineStyle.childs(),
						i = t.transparency.value();
					this._topFillColor1 = (0, s.generateColor)(t.topFillColor1.value(), i), this._topFillColor2 = (0, s.generateColor)(t.topFillColor2.value(), i), this._bottomFillColor1 = (0, s.generateColor)(t.bottomFillColor1.value(), i), this._bottomFillColor2 = (0, s.generateColor)(t.bottomFillColor2.value(), i), this._topLineColor = t.topLineColor.value(),
						this._bottomLineColor = t.bottomLineColor.value(), this._topLineWidth = t.topLineWidth.value(), this._bottomLineWidth = t.bottomLineWidth.value(), this._barSpacing = this._model.timeScale().barSpacing(), this._bottom = e.height(), this._baseLevelCoordinate = Math.round(this._bottom * (Math.abs(100 - t.baseLevelPercentage.value()) / 100))
				}
			}
		},
		156776: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesWaterlinePaneView: () => n
			});
			var s = i(350985),
				r = i(87511),
				o = i(218718),
				a = i(345185);
			class n extends s.HorizontalLinePaneView {
				constructor(e) {
					super(), this._getters = e;
					const t = {
						cursorType: r.PaneCursorType.VerticalResize,
						activeItem: 0,
						areaName: o.AreaName.SourceItemMove
					};
					this._lineRenderer.setHitTest(new o.HitTestResult(o.HitTestResult.MOVEPOINT, t)), this._lineRendererData.visible = !0, this._lineRendererData.linestyle = a.LINESTYLE_SPARSE_DOTTED
				}
				_updateImpl() {
					const {
						baseLevelPercentage: e,
						paneHeight: t,
						color: i
					} = this._getters, s = Math.abs(100 - e());
					this._lineRendererData.y = Math.round(t() * (s / 100)), this._lineRendererData.color = i()
				}
			}
		},
		38080: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesCandlesPaneView: () => l
			});
			var s = i(717611),
				r = i(601132),
				o = i(859447),
				a = i(338891),
				n = i(280446);
			class l extends a.SeriesBarCandlesPaneView {
				renderer(e, t) {
					this._invalidated && (this._updateImpl(null), this._invalidated = !1);
					const i = this._source.priceScale();
					if (!i) return null;
					const a = this._source.properties().childs().candleStyle.childs(),
						l = this._model.timeScale().barSpacing(),
						h = {
							bars: this._bars,
							barSpacing: l,
							bodyVisible: a.drawBody.value(),
							borderVisible: a.drawBorder.value(),
							borderColor: a.borderColor.value(),
							wickColor: a.wickColor.value(),
							barWidth: (0, r.optimalBarWidth)(l),
							wickVisible: a.drawWick.value(),
							isPriceScaleInverted: i.isInverted()
						},
						u = new s.CompositeRenderer;
					return u.append(new n.PaneRendererCandles(h)), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData && u.append(new o.SelectionRenderer(this._selectionData)), u
				}
				_createItem(e, t, i) {
					const s = {
						time: e,
						open: NaN,
						high: NaN,
						low: NaN,
						close: NaN,
						color: i.barColor,
						borderColor: i.barBorderColor,
						wickColor: i.barWickColor,
						hollow: i.isBarHollow
					};
					return (0, a.baseBarCandlesUpdater)(t, s) ? s : null
				}
			}
		},
		514628: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesColumnsPaneView: () => _
			});
			var s = i(588537),
				r = i(86441),
				o = i(611688),
				a = i(203308),
				n = i(218718),
				l = i(717611),
				h = i(752280),
				u = i(346037),
				d = i(859447),
				c = i(737191);
			class _ {
				constructor(e, t) {
					this._items = [], this._invalidated = !0, this._isMarkersEnabled = (0, o.enabled)("source_selection_markers"), this._selectionData = null, this._histogramBase = 0, this._source = e, this._model = t, this._selectionIndexer = new u.SelectionIndexes(t.timeScale())
				}
				update() {
					this._invalidated = !0
				}
				renderer(e, t) {
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const i = {
							barSpacing: this._model.timeScale().barSpacing(),
							items: this._items,
							lineColor: "",
							histogramBase: this._histogramBase
						},
						s = new l.CompositeRenderer;
					return s.append(new c.PaneRendererColumns(i)), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData && s.append(new d.SelectionRenderer(this._selectionData)), s
				}
				_updateImpl() {
					this._items = [];
					const e = this._model.timeScale(),
						t = this._source.priceScale();
					if (e.isEmpty() || !t || t.isEmpty()) return;
					const i = e.visibleBarsStrictRange();
					if (null === i) return;
					if (0 === this._source.bars().size()) return;
					const o = this._source.nearestIndex(i.firstBar(), h.PlotRowSearchMode.NearestRight),
						l = this._source.nearestIndex(i.lastBar(), h.PlotRowSearchMode.NearestLeft);
					if (void 0 === o || void 0 === l) return;
					const u = this._source.bars().range(o, l),
						d = this._source.barColorer(),
						c = {},
						_ = this._source.barFunction(),
						p = u.reduce(((e, t, s) => {
							const o = _(s);
							if (!(0, a.default)(o)) return e;
							c.value = s;
							let n = this._source.precomputedBarStyle(s);
							void 0 === n && (n = d.barStyle(t, !1, c), this._source.setPrecomputedBarStyle(s, n));
							const l = new r.Point(t, o);
							return l.style = n, l.timePointIndex = t, this._items.push(l), c.previousValue = s, i.contains(t) && null != e ? e : o
						}), null);
					if (null !== p)
						if (t.pointsArrayToCoordinates(this._items, p), e.timedValuesToCoordinates(this._items), this._histogramBase = t.isInverted() ? 0 : t.height(), this._model.selection().isSelected(this._source)) {
							const i = this._selectionIndexer.indexes();
							this._selectionData = {
								points: [],
								bgColors: [],
								visible: !0,
								barSpacing: e.barSpacing(),
								hittestResult: n.HitTestResult.REGULAR
							};
							const o = (0, s.ensureNotNull)(this._model.paneForSource(this._source)).height();
							this._selectionData.hittestResult = n.HitTestResult.REGULAR;
							for (let s = 0; s < i.length; s++) {
								const a = i[s],
									n = this._source.bars().valueAt(a);
								if (null === n) continue;
								const l = _(n),
									h = e.indexToCoordinate(a),
									u = t.priceToCoordinate(l, p);
								this._selectionData.points.push(new r.Point(h, u)), this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(u / o))
							}
						} else this._selectionIndexer.clear()
				}
			}
		},
		30347: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesHiLoPaneView: () => m
			});
			var s = i(588537),
				r = i(208214),
				o = i(377884),
				a = i(601132),
				n = i(218718),
				l = i(380047);
			class h extends l.ScaledPaneRenderer {
				constructor() {
					super(...arguments), this._data = null, this._barWidth = null
				}
				setData(e) {
					this._data = e, this._barWidth = Math.max(1, Math.round((0, a.optimalHiLoWidth)(e.barSpacing)))
				}
				hitTest(e) {
					if (null === this._data || null === this._barWidth) return null;
					const t = this._data.bars,
						i = .5 * this._data.barSpacing;
					if (0 === t.length) return null;
					if (e.x < t[0].time - i) return null;
					if (e.x > t[t.length - 1].time + i) return null;
					const s = t[(0, o.lowerbound)(t, e.x - i, ((e, t) => e.time < t))];
					if (e.x < s.time - i || e.x > s.time + i) return null;
					const r = (0, a.interactionTolerance)().series + this._barWidth / 2,
						l = Math.min(s.high, s.low),
						h = Math.max(s.high, s.low),
						u = this._data.fontSize;
					return l - r - u <= e.y && e.y <= l + r || h - r <= e.y && e.y <= h + r + u ? new n.HitTestResult(n.HitTestResult.REGULAR) : null
				}
				_drawImpl(e) {
					var t;
					if (null === this._data || null === this._barWidth) return;
					e.save(), e.textAlign = "center", e.fillStyle = this._data.labelColor, e.font = (0, r.makeFont)(this._data.fontSize, this._data.font);
					const i = null !== (t = e.measureText("0.0").actualBoundingBoxAscent) && void 0 !== t ? t : .8 * this._data.fontSize,
						s = this._data.bars,
						o = this._data.inverted;
					for (let t = 0; t < s.length; ++t) {
						const r = s[t],
							a = Math.min(r.high, r.low),
							n = Math.max(r.high, r.low);
						e.fillText(o ? r.lowLabel : r.highLabel, r.time, a - this._data.labelsPadding),
							e.fillText(o ? r.highLabel : r.lowLabel, r.time, n + this._data.labelsPadding + i - 1)
					}
					e.restore()
				}
			}
			var u = i(280446),
				d = i(717611),
				c = i(859447),
				_ = i(588427),
				p = i(338891);
			class m extends p.SeriesBarCandlesPaneView {
				constructor(e, t) {
					super(e, t), this._labelsRenderer = new h, this._candlesRenderer = new u.PaneRendererCandles, this._lastCalculatedFontSize = null, this._canvas = document.createElement("canvas"), this._context = (0, s.ensureNotNull)(this._canvas.getContext("2d"))
				}
				renderer(e, t, i) {
					const s = this._source.priceScale();
					if (!s || s.isEmpty()) return null;
					const r = new d.CompositeRenderer,
						o = this._needLabels(),
						n = this._source.properties().childs().hiloStyle.childs(),
						l = this._model.timeScale().barSpacing();
					if (this._invalidated) {
						const e = this._source.formatter();
						this._updateImpl({
							generateLabels: o,
							formatter: e
						}), this._invalidated = !1
					}
					return this._candlesRenderer.setData({
						bars: this._bars,
						wickVisible: !1,
						bodyVisible: n.drawBody.value(),
						barSpacing: l,
						borderVisible: n.showBorders.value(),
						barWidth: (0, a.optimalHiLoWidth)(l)
					}), r.append(this._candlesRenderer), this._lastCalculatedFontSize = this._calculateLabelFontSize(), o && this._lastCalculatedFontSize && this._lastCalculatedFontSize >= 8 && this._lastCalculatedFontSize && (this._labelsRenderer.setData({
						bars: this._bars,
						barSpacing: l,
						font: _.CHART_FONT_FAMILY,
						fontSize: this._lastCalculatedFontSize,
						labelColor: n.labelColor.value(),
						inverted: s.isInverted(),
						labelsPadding: 3
					}), r.append(this._labelsRenderer)), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData && r.append(new c.SelectionRenderer(this._selectionData)), r
				}
				topPixelMargin() {
					return this._margin()
				}
				bottomPixelMargin() {
					return this._margin()
				}
				_createItem(e, t, i, s) {
					const r = {
						time: e,
						open: NaN,
						high: NaN,
						low: NaN,
						close: NaN,
						color: i.barColor,
						borderColor: i.barBorderColor,
						hollow: !1,
						highLabel: "",
						lowLabel: ""
					};
					return (0, p.baseBarCandlesUpdater)(t, r) ? (r.open = r.high, r.close = r.low, s.generateLabels && (r.highLabel = s.formatter.format(r.high), r.lowLabel = s.formatter.format(r.low)), r) : null
				}
				_margin() {
					return this._source.properties().childs().hiloStyle.childs().showLabels.value() && this._lastCalculatedFontSize ? this._lastCalculatedFontSize + 6 : 0
				}
				_calculateLabelFontSize() {
					const e = this._model.timeScale().barSpacing() - 2,
						t = this._bars.reduce(((e, {
							highLabel: t,
							lowLabel: i
						}) => {
							const s = t.length > i.length ? t : i;
							return s.length > e.length ? s : e
						}), "");
					if ("" === t) return null;
					this._context.save(), this._context.textAlign = "center";
					const i = Math.max(1, (0, o.lowerboundExt)((e => e + 1), null, (i => (this._context.font = (0, r.makeFont)(i, _.CHART_FONT_FAMILY), this._context.measureText(t).width <= e)), 0, 36) - 1);
					return this._context.restore(), i
				}
				_needLabels() {
					const e = this._model.timeScale().barSpacing();
					return this._source.properties().childs().hiloStyle.childs().showLabels.value() && e > 5
				}
			}
		},
		487765: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesHollowCandlesPaneView: () => l
			});
			var s = i(717611),
				r = i(601132),
				o = i(859447),
				a = i(280446),
				n = i(38080);
			class l extends n.SeriesCandlesPaneView {
				renderer(e, t) {
					this._invalidated && (this._updateImpl(null), this._invalidated = !1);
					const i = this._source.priceScale();
					if (!i) return null;
					const n = this._source.properties().childs().hollowCandleStyle.childs(),
						l = this._model.timeScale().barSpacing(),
						h = {
							bars: this._bars,
							barSpacing: l,
							bodyVisible: n.drawBody.value(),
							borderVisible: n.drawBorder.value(),
							borderColor: n.borderColor.value(),
							wickColor: n.wickColor.value(),
							barWidth: (0, r.optimalBarWidth)(l),
							wickVisible: n.drawWick.value(),
							isPriceScaleInverted: i.isInverted()
						},
						u = new s.CompositeRenderer;
					return u.append(new a.PaneRendererCandles(h)), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData && u.append(new o.SelectionRenderer(this._selectionData)), u
				}
			}
		},
		142426: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesLinePaneView: () => u
			});
			var s = i(218718),
				r = i(717611),
				o = i(729828),
				a = i(68226),
				n = i(859447),
				l = i(195048),
				h = i(671676);
			class u extends h.SeriesSingleLinePaneView {
				renderer(e, t) {
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					const i = this._source.properties().childs().lineStyle.childs(),
						h = {
							barSpacing: this._model.timeScale().barSpacing(),
							items: this._items,
							lineColor: i.color.value(),
							lineStyle: i.linestyle.value(),
							withMarkers: i.styleType.value() === l.STYLE_LINE_TYPE_MARKERS,
							lineWidth: i.linewidth.value(),
							simpleMode: !0,
							hitTestResult: s.HitTestResult.REGULAR
						};
					let u, d;
					if (u = i.styleType.value() === l.STYLE_LINE_TYPE_STEP ? new a.PaneRendererStepLine(h) : new o.PaneRendererLine(h), this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
						const e = new r.CompositeRenderer;
						e.append(u), e.append(new n.SelectionRenderer(this._selectionData)), d = e
					} else d = u;
					return d
				}
			}
		},
		338891: (e, t, i) => {
			"use strict";
			i.d(t, {
				baseBarCandlesUpdater: () => h,
				SeriesBarCandlesPaneView: () => u
			});
			var s = i(86441),
				r = i(611688),
				o = i(346037),
				a = i(752280),
				n = i(218718);

			function l(e) {
				return null != e
			}

			function h(e, t) {
				const i = e[1],
					s = e[2],
					r = e[3],
					o = e[4];
				return !!(l(i) && l(s) && l(r) && l(o)) && (t.open = i, t.high = s, t.low = r, t.close = o, !0)
			}
			class u {
				constructor(e, t) {
					this._bars = [], this._invalidated = !0, this._isMarkersEnabled = (0, r.enabled)("source_selection_markers"), this._selectionData = null, this._source = e, this._model = t, this._selectionIndexer = new o.SelectionIndexes(t.timeScale())
				}
				items() {
					return this._bars
				}
				update() {
					this._invalidated = !0
				}
				_updateImpl(e) {
					const t = this._model.timeScale(),
						i = this._source.priceScale();
					if (this._bars = [], t.isEmpty() || !i || i.isEmpty()) return;
					const r = t.visibleBarsStrictRange();
					if (null === r) return;
					if (0 === this._source.bars().size()) return;
					let o = this._source.nearestIndex(r.firstBar(), a.PlotRowSearchMode.NearestRight);
					const l = this._source.nearestIndex(r.lastBar(), a.PlotRowSearchMode.NearestLeft);
					if (void 0 === o || void 0 === l) return;
					for (; o <= l; o++) {
						if (null !== this._source.bars().valueAt(o)) break
					}
					if (o > l) return;
					const h = this._source.bars().range(o, l),
						u = this._source.barColorer(),
						d = {};
					if (h.each(((t, i) => {
							d.value = i;
							let s = this._source.precomputedBarStyle(i);
							void 0 === s && (s = u.barStyle(t, !1, d), this._source.setPrecomputedBarStyle(i, s));
							const r = this._createItem(Math.round(t), i, s, e);
							return !!r && (d.previousValue = i, this._bars.push(r), !1)
						})), 0 === this._bars.length) return;
					const c = this._source.firstValue();
					if (null !== c)
						if (i.barPricesToCoordinates(this._bars, c),
							t.barIndexesToCoordinates(this._bars), this._model.selection().isSelected(this._source)) {
							const e = this._selectionIndexer.indexes();
							this._selectionData = {
								points: [],
								bgColors: [],
								visible: !0,
								hittestResult: n.HitTestResult.REGULAR,
								barSpacing: t.barSpacing()
							};
							const r = this._model.paneForSource(this._source);
							if (!r) return;
							const o = r.height();
							for (let r = 0; r < e.length; r++) {
								const a = e[r],
									n = this._source.bars().valueAt(a);
								if (null === n) continue;
								const l = n[1],
									h = n[4];
								if (null == l || null == h) continue;
								const u = .5 * (l + h),
									d = t.indexToCoordinate(a),
									_ = i.priceToCoordinate(u, c);
								this._selectionData.points.push(new s.Point(d, _)), this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(_ / o))
							}
						} else this._selectionIndexer.clear()
				}
			}
		},
		671676: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesSingleLinePaneView: () => d
			});
			var s = i(203308),
				r = i(86441),
				o = i(588537),
				a = i(611688),
				n = i(346037),
				l = i(752280),
				h = i(218718),
				u = i(377884);
			class d {
				constructor(e, t) {
					this._items = [], this._invalidated = !0, this._isMarkersEnabled = (0, a.enabled)("source_selection_markers"), this._selectionData = null, this._source = e, this._model = t, this._selectionIndexer = new n.SelectionIndexes(t.timeScale())
				}
				update() {
					this._invalidated = !0
				}
				_updateImpl() {
					var e, t;
					this._items = [];
					const i = this._model.timeScale(),
						a = this._source.priceScale();
					if (i.isEmpty() || !a || a.isEmpty()) return;
					const n = i.visibleBarsStrictRange();
					if (null === n) return;
					if (0 === this._source.bars().size()) return;
					const d = null !== (e = this._source.nearestIndex(n.firstBar() - 1, l.PlotRowSearchMode.NearestLeft)) && void 0 !== e ? e : n.firstBar() - 1,
						c = null !== (t = this._source.nearestIndex(n.lastBar() + 1, l.PlotRowSearchMode.NearestRight)) && void 0 !== t ? t : n.lastBar() + 1,
						_ = this._source.barFunction();
					let p = null;
					const m = this._model.timeScale().barSpacing();
					if (m < .1 && this._source.supportsPressedChunks()) {
						p = this._source.firstValue();
						const e = this._source.pressedChunks(m, (0, o.ensureNotNull)(this._source.priceSource())),
							t = (0, u.lowerbound)(e, d, ((e, t) => e.startTime < t)),
							i = Math.min(e.length - 1, (0, u.lowerbound)(e, c, ((e, t) => e.endTime < t)));
						for (let s = t; s <= i; s++) {
							const t = e[s];
							[t.open, t.high, t.low, t.close].forEach((e => {
								const i = new r.Point(t.startTime, e);
								this._items.push(i)
							}))
						}
					} else {
						p = this._source.bars().range(d, c).reduce(((e, t, i) => {
							const o = _(i);
							if (!(0, s.default)(o)) return e;
							const a = new r.Point(t, o);
							return this._items.push(a), n.contains(t) ? null != e ? e : o : e
						}), null)
					}
					if (null !== p)
						if (a.pointsArrayToCoordinates(this._items, p), i.timedValuesToCoordinates(this._items), this._model.selection().isSelected(this._source)) {
							const e = this._selectionIndexer.indexes();
							this._selectionData = {
								points: [],
								bgColors: [],
								visible: !0,
								barSpacing: i.barSpacing(),
								hittestResult: h.HitTestResult.REGULAR
							};
							const t = (0, o.ensureNotNull)(this._model.paneForSource(this._source)).height();
							this._selectionData.hittestResult = h.HitTestResult.REGULAR;
							for (let s = 0; s < e.length; s++) {
								const o = e[s],
									n = this._source.bars().valueAt(o);
								if (null === n) continue;
								const l = _(n),
									h = i.indexToCoordinate(o),
									u = a.priceToCoordinate(l, p);
								this._selectionData.points.push(new r.Point(h, u)), this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(u / t))
							}
						} else this._selectionIndexer.clear();
					else this._items = []
				}
			}
		},
		394683: (e, t, i) => {
			"use strict";
			i.d(t, {
				calculateColor: () => x,
				SeriesValuesProvider: () => C
			});
			var s = i(588537),
				r = i(793751),
				o = i(724377),
				a = i(575932),
				n = i(638456),
				l = i(721386),
				h = i(143498),
				u = i(752280),
				d = i(308170),
				c = i(965513),
				_ = i(591419),
				p = i(289627),
				m = i(702052),
				y = i(676809),
				g = i(29084);
			const v = n.CheckMobile.any(),
				S = v && !1,
				b = new c.PercentageFormatter,
				f = new _.VolumeFormatter(2),
				w = "âˆ…";

			function x(e, t) {
				const i = (0, o.parseRgb)(t),
					s = (0, o.parseRgb)(e);
				return (0, o.distanceRgb)(i, s) < 70 ? (0, o.rgbToHexString)((0, o.invertRgb)(i)) : t
			}
			class C {
				constructor(e, t) {
					this._series = e, this._model = t, this._emptyValues = [{
						title: (0, a.t)("Open"),
						visible: !1,
						value: "",
						index: 0,
						id: ""
					}, {
						title: (0, a.t)("High"),
						visible: !1,
						value: "",
						index: 1,
						id: ""
					}, {
						title: (0, a.t)("Low"),
						visible: !1,
						value: "",
						index: 2,
						id: ""
					}, {
						title: (0, a.t)("Close"),
						visible: !1,
						value: "",
						index: 3,
						id: ""
					}, {
						title: "",
						visible: !1,
						value: "",
						index: 4,
						id: ""
					}, {
						title: "",
						visible: !1,
						value: "",
						index: 5,
						id: ""
					}, {
						title: (0, a.t)("Change"),
						visible: !1,
						value: "",
						index: 6,
						id: ""
					}, {
						title: (0, a.t)("Vol"),
						visible: !1,
						value: "",
						index: 7,
						id: ""
					}]
				}
				getItems() {
					return this._emptyValues
				}
				getValues(e) {
					var t;
					const i = this._showLastPriceAndChangeOnly(),
						o = this._emptyValues.map((e => ({
							...e,
							visible: !i
						})));
					o[0].value = w, o[1].value = w, o[2].value = w, o[3].value = w, o[6].value = "âˆ… (âˆ…%)", o[7].value = w, o[5].visible = !1;
					const a = o[4];
					if (a.value = w, a.visible = !1, this._model.timeScale().isEmpty() || 0 === this._series.bars().size() || this._series.priceScale().isEmpty()) return o;
					(0, r.isNumber)(e) || (e = (0, s.ensureNotNull)(this._series.data().last()).index);
					const n = this._series.nearestIndex(e, u.PlotRowSearchMode.NearestLeft);
					if (void 0 === n) return o;
					const d = this._series.data().valueAt(n),
						c = this._model.backgroundTopColor().value();
					if (null === d) return o;
					const _ = d[1],
						m = d[2],
						g = d[3],
						v = d[4],
						{
							values: C
						} = this._changesData(v, n, i),
						I = (0, y.getPriceValueFormatterForSource)(this._series);
					if ((0, y.shouldBeFormattedAsPercent)(this._series) || (0, y.shouldBeFormattedAsIndexedTo100)(this._series)) o[6].value = "";
					else if (void 0 !== C) {
						const e = this._series.formatter();
						o[6].value = (0, h.forceLTRStr)(`${e.format(C.change,!0)} (${b.format(C.percentChange,!0)})`)
					}
					if (i) o[5].value = null == v ? w : I(v), o[5].visible = !0, o[6].visible = !0;
					else {
						o[0].value = null == _ ? w : I(_), o[1].value = null == m ? w : I(m), o[2].value = null == g ? w : I(g), o[3].value = null == v ? w : I(v), o[4].value = I(this._series.barFunction()(d));
						const e = d[5];
						(0, r.isNumber)(e) ? o[7].value = f.format(e): o[7].visible = !1
					}
					let P = null;
					if (i && !S) P = void 0 === C || C.change >= 0 ? p.SeriesBarColorer.upColor(this._series.properties()) : p.SeriesBarColorer.downColor(this._series.properties());
					else {
						const e = this._series.barColorer().barStyle(n, !1);
						P = x(c, null !== (t = e.barBorderColor) && void 0 !== t ? t : e.barColor)
					}
					P = (0, l.resetTransparency)(x(c, P));
					for (const e of o) e.color = P;
					return o
				}
				_showLastPriceAndChangeOnly() {
					return v && (null === this._model.crossHairSource().pane || (0, g.isLineToolName)(d.tool.value()) || null !== this._model.lineBeingEdited())
				}
				_changesData(e, t, i) {
					var s;
					if (i && !S) {
						const e = this._series.quotes();
						if (null !== e) return {
							values: {
								change: e.change,
								percentChange: e.change_percent
							}
						}
					} else {
						const i = this._series.data().search(t - 1, u.PlotRowSearchMode.NearestLeft),
							r = null !== (s = null == i ? void 0 : i.value[4]) && void 0 !== s ? s : null;
						if (null !== r && null != e) return {
							values: {
								change: e - r,
								percentChange: (0, m.barPercentChange)(r, e)
							}
						}
					}
					return {}
				}
			}
		},
		381886: (e, t, i) => {
			"use strict";
			i.d(t, {
				financialPeriodToString: () => o,
				financialPeriodToShortString: () => a
			});
			var s = i(588537),
				r = i(575932);

			function o(e) {
				switch (e) {
					case "FQ":
						return (0, r.t)("Quarterly");
					case "FY":
						return (0, r.t)("Annual");
					case "TTM":
						return (0, r.t)("TTM")
				}(0, s.ensureNever)(e)
			}

			function a(e) {
				switch (e) {
					case "FQ":
						return (0, r.t)("FQ");
					case "FY":
						return (0, r.t)("FY");
					case "TTM":
						return (0, r.t)("TTM")
				}(0, s.ensureNever)(e)
			}
		},
		320681: (e, t, i) => {
			"use strict";
			i.d(t, {
				Fundamental: () => p
			});
			var s = i(575932),
				r = i(448874),
				o = i(381886),
				a = i(285339);
			class n extends a.StudyPriceAxisView {
				constructor(e, t) {
					super(e, t), this._fundamental = e
				}
				_updatePaneRendererData(e) {
					e.text = "", this._showPaneLabel() && (e.text = this._fundamental.labelTitle(), e.visible = !0)
				}
			}
			var l = i(267850);
			class h extends l.StudyPriceLineAxisView {
				constructor(e, t) {
					super(e, t), this._model = e.model()
				}
				_isVisible() {
					return this._model.properties().childs().scalesProperties.childs().showFundamentalLastValue.value() && this._study.properties().childs().styles.childs()[this._plotname].childs().trackPrice.value()
				}
			}
			var u = i(651620),
				d = i(906096);
			const c = (0, s.t)("This fundamental metric is not available for this symbol");
			class _ extends u.StudyStatusProvider {
				sourceStatusText() {
					const e = this._source.status();
					return e.type === d.StudyStatusType.Error && 0 === e.errorDescription.error.indexOf("resolve_error ") ? c : super.sourceStatusText()
				}
			}
			class p extends r.Study {
				labelTitle() {
					return this.title(!0)
				}
				createPriceAxisView(e) {
					return new n(this, {
						plotIndex: e
					})
				}
				createPriceLineAxisView(e) {
					return new h(this, e)
				}
				hasStateForAlert() {
					return !1
				}
				titleInParts(e, t, i, s) {
					return [this._title(!!e)]
				}
				statusProvider(e) {
					return new _(this, this._model.properties().childs().scalesProperties.childs().textColor)
				}
				_title(e) {
					const t = this.metaInfo();
					let i;
					if (i = e ? t.shortDescription : t.description, void 0 !== t.financialPeriod) {
						const r = e ? (0, o.financialPeriodToShortString)(t.financialPeriod) : (0, o.financialPeriodToString)(t.financialPeriod);
						i = `${(0,s.t)(i,{context:"study"})} Â· ${r}`
					}
					const r = this._titleInputs(!0);
					return r.length > 0 && (i = `${(0,s.t)(r[0],{context:"study"})} Â· ${i}`), i
				}
				_titleInputsOptions(e, t) {
					return {
						...super._titleInputsOptions(e, t),
						skipOptionalEmptySymbolInputs: !0,
						allowedInputTypes: ["symbol"]
					}
				}
			}
		},
		741139: (e, t, i) => {
			"use strict";

			function s(e, t, i) {
				let s = e[`${t}#${i}`] || null;
				return null === s && (s = e[t] || null), null === s && Object.keys(e).forEach((i => {
					null === s && i.startsWith(`${t}#`) && (s = e[i] || null)
				})), s
			}
			i.d(t, {
				getObsoleteIdeaSymbolInfo: () => s
			})
		},
		659251: (e, t, i) => {
			"use strict";
			i.d(t, {
				NonSeriesStudy: () => o
			});
			var s = i(588537),
				r = i(448874);
			class o extends r.Study {
				clearData() {
					this._customData = null, this._indexes = null
				}
				restoreData(e, t, i) {
					super.restoreData(e), this._customData = t, this._indexes = i
				}
				state(e) {
					const t = super.state(e);
					return e && (t.nonSeriesData = this._customData, t.indexes = this._indexes), t
				}
				customData() {
					return this._customData
				}
				_setPaneViews(e) {
					this._paneViews = e, this.model().lightUpdate()
				}
				_onDataUpdated(e, t, i) {
					null !== t && (t.indexes_replace ? ((0, s.assert)("nochange" !== i), this._indexes = i) : (this._customData = t.data, "nochange" !== i && (this._indexes = i))), super._onDataUpdated(e, t, i)
				}
			}
		},
		637030: (e, t, i) => {
			"use strict";
			i.d(t, {
				OverlayDataWindowView: () => u
			});
			var s = i(793751),
				r = i(734906),
				o = i(638456),
				a = i(29084),
				n = i(308170),
				l = i(456525);
			const h = o.CheckMobile.any();
			class u extends r.DataWindowView {
				constructor(e, t) {
					super(), this._invalidated = !0, this._study = e, this._model = t, this._valueProvider = this._createValuesProvider(e, t), this._items = this._valueProvider.getItems().map((e => new r.DataWindowItem(e.id, e.title, ""))), this.update()
				}
				items() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._items
				}
				update() {
					this._invalidated = !0
				}
				study() {
					return this._study
				}
				_updateImpl() {
					this._header = this._study.title();
					let e;
					this._showLastPriceAndChangeOnly() ? e = this._study.data().lastIndex() : (e = this._model.crossHairSource().appliedIndex(), (0, s.isNumber)(e) || (e = this._study.data().lastIndex()));
					const t = this._valueProvider.getValues(e);
					for (let e = 0; e < t.length; ++e) {
						const i = t[e],
							s = this._items[e];
						s.setValue(i.value), s.setVisible(i.visible), s.setColor(i.color)
					}
				}
				_showLastPriceAndChangeOnly() {
					return h && (null === this._model.crossHairSource().pane || (0, a.isLineToolName)(n.tool.value()) || null !== this._model.lineBeingEdited())
				}
				_createValuesProvider(e, t) {
					return new l.StudyLegendValuesProvider(e, t)
				}
			}
		},
		405075: (e, t, i) => {
			"use strict";
			i.d(t, {
				OverlayLegendValuesProvider: () => f
			});
			var s = i(749473),
				r = i(793751),
				o = i(575932),
				a = i(638456),
				n = i(721386),
				l = i(143498),
				h = i(965513),
				u = i(394683),
				d = i(752280),
				c = i(308170),
				_ = i(702052),
				p = i(289627),
				m = i(676809),
				y = i(29084);
			const g = a.CheckMobile.any(),
				v = g && !1,
				S = new h.PercentageFormatter,
				b = "âˆ…";
			class f extends class {
				constructor(e, t) {
					this._study = e, this._model = t, this._emptyValues = [{
						title: (0, o.t)("Open"),
						visible: !1,
						value: "",
						index: 0,
						id: ""
					}, {
						title: (0, o.t)("High"),
						visible: !1,
						value: "",
						index: 1,
						id: ""
					}, {
						title: (0, o.t)("Low"),
						visible: !1,
						value: "",
						index: 2,
						id: ""
					}, {
						title: (0, o.t)("Close"),
						visible: !1,
						value: "",
						index: 3,
						id: ""
					}, {
						title: "",
						visible: !1,
						value: "",
						index: 4,
						id: ""
					}, {
						title: "",
						visible: !1,
						value: "",
						index: 5,
						id: ""
					}, {
						title: (0, o.t)("Change"),
						visible: !1,
						value: "",
						index: 6,
						id: ""
					}]
				}
				getItems() {
					return this._emptyValues
				}
				getValues(e) {
					var t;
					const i = this._emptyValues.map((e => ({
						...e
					})));
					if (this._model.timeScale().isEmpty()) return i;
					if (0 === this._study.data().size()) return i;
					const s = this._showLastPriceAndChangeOnly();
					if ((0, r.isNumber)(e) || (s ? e = this._study.data().lastIndex() : (e = this._model.crossHairSource().appliedIndex(), (0, r.isNumber)(e) || (e = this._study.data().lastIndex()))), null === e || !(0, r.isNumber)(e)) return i;
					const o = this._study.data().search(e, d.PlotRowSearchMode.NearestLeft, 1),
						a = this._model.backgroundTopColor().value();
					if (null === o) return i;
					const h = o.index,
						c = o.value,
						_ = c[1],
						y = c[2],
						g = c[3],
						f = c[4];
					i[0].value = b, i[1].value = b, i[2].value = b, i[3].value = b, i[6].value = "âˆ… (âˆ…%)";
					for (const e of i) e.visible = !s;
					const w = i[4];
					w.visible = !1;
					const {
						values: x
					} = this._changesData(f, _, h, s), C = (0, m.getPriceValueFormatterForSource)(this._study);
					if ((0,
							m.shouldBeFormattedAsPercent)(this._study) || (0, m.shouldBeFormattedAsIndexedTo100)(this._study)) i[6].value = "";
					else if (void 0 !== x) {
						const e = this._study.formatter();
						i[6].value = (0, l.forceLTRStr)(`${e.format(x.change,!0)} (${S.format(x.percentChange,!0)})`)
					}
					s ? (i[5].value = null == f ? b : C(f), i[5].visible = !0, i[6].visible = !0) : (i[0].value = null == _ ? b : C(_), i[1].value = null == y ? b : C(y), i[2].value = null == g ? b : C(g), i[3].value = null == f ? b : C(f), w.value = C(this._study.barFunction()(c)), i[5].visible = !1);
					let I = null;
					if (s && !v) I = void 0 === x || x.change >= 0 ? p.SeriesBarColorer.upColor(this._study.properties()) : p.SeriesBarColorer.downColor(this._study.properties());
					else {
						const e = this._study.barColorer().barStyle(h, !1),
							i = null !== (t = e.barBorderColor) && void 0 !== t ? t : e.barColor;
						I = (0, u.calculateColor)(a, i)
					}
					I = (0, n.resetTransparency)((0, u.calculateColor)(a, I));
					for (const e of i) e.color = I;
					return i
				}
				_showLastPriceAndChangeOnly() {
					return g && (null === this._model.crossHairSource().pane || (0, y.isLineToolName)(c.tool.value()) || null !== this._model.lineBeingEdited())
				}
				_changesData(e, t, i, s) {
					var r;
					if (s && !v) {
						const e = this._study.quotes();
						if (null !== e) return {
							values: {
								change: e.change,
								percentChange: e.change_percent
							},
							priceDirection: {
								basedOnCurrentBar: e.change >= 0 ? 0 : 1,
								basedOnPrevClose: e.change >= 0 ? 0 : 1
							}
						}
					} else {
						const s = this._study.data().search(i - 1, d.PlotRowSearchMode.NearestLeft, 1),
							o = null !== (r = null == s ? void 0 : s.value[4]) && void 0 !== r ? r : null;
						if (null !== o && null != e && null != t) return {
							values: {
								change: e - o,
								percentChange: (0, _.barPercentChange)(o, e)
							},
							priceDirection: {
								basedOnCurrentBar: e >= t ? 0 : 1,
								basedOnPrevClose: e >= o ? 0 : 1
							}
						}
					}
					return null == e || null == t ? {} : {
						priceDirection: {
							basedOnCurrentBar: e >= t ? 0 : 1,
							basedOnPrevClose: e >= t ? 0 : 1
						}
					}
				}
			} {
				constructor(e, t) {
					super(e, t);
					const i = t.properties().childs().paneProperties.childs().legendProperties.childs();
					this._showBarChange = i.showBarChange, this._showSeriesOHLC = i.showSeriesOHLC, this._seriesStyle = e.properties().childs().style
				}
				getValues(e) {
					const t = super.getValues(e);
					if (!this._showLastPriceAndChangeOnly()) {
						const e = (0, s.isPriceSourceStyle)(this._seriesStyle.value()),
							i = this._showSeriesOHLC.value(),
							r = i && !e,
							o = i && e;
						t[0].visible = r, t[1].visible = r, t[2].visible = r, t[3].visible = r, t[6].visible = this._showBarChange.value(), t[4].visible = o
					}
					return t
				}
			}
		},
		109776: (e, t, i) => {
			"use strict";
			i.d(t, {
				OverlayStatusProvider: () => r
			});
			var s = i(651620);
			class r extends s.StudyStatusProvider {
				getSplitTitle() {
					return this._source.titleInParts(!0, void 0, !1, !1)
				}
				text() {
					return this._source.isActualInterval() ? this._source.isFailed() ? `${this._source.title(!0,void 0,!1,!1)}: ${this.sourceStatusText()}` : `${this._source.title(!0,void 0,!1,!1)} ${this.sourceStatusText()}` : this._source.title(!0, void 0, !1, !1)
				}
			}
		},
		920962: (e, t, i) => {
			"use strict";
			i.d(t, {
				PivotPointsStandardLastPricesView: () => a
			});
			var s = i(752280);
			const r = ["p", "s1", "r1", "s2", "r2", "s3", "r3", "s4", "r4", "s5", "r5"],
				o = {
					P: "P",
					S1: "S1/R1",
					S2: "S2/R2",
					S3: "S3/R3",
					S4: "S4/R4",
					S5: "S5/R5",
					R1: "S1/R1",
					R2: "S2/R2",
					R3: "S3/R3",
					R4: "S4/R4",
					R5: "S5/R5"
				};
			class a {
				constructor(e) {
					this._visiblePivots = new Set, this._invidated = !0, this._prices = [], this._source = e
				}
				visiblePivots() {
					return this._visiblePivots
				}
				update() {
					this._invidated = !0
				}
				prices() {
					return this._invidated && (this._updateImpl(), this._invidated = !1), this._prices
				}
				_updateImpl() {
					this._visiblePivots.clear();
					const e = this._source.model(),
						t = this._source.priceScale();
					if (null === t) return;
					if (e.timeScale().isEmpty() || t.isEmpty()) return;
					const i = e.timeScale().visibleBarsStrictRange();
					if (null === i) return;
					if (!this._source.customData() || !this._source.customData().pivots) return;
					const a = e.mainSeries().bars().search(i.lastBar(), s.PlotRowSearchMode.NearestLeft);
					if (null === a) return;
					const n = a.index,
						l = this._source.customData().pivots,
						h = this._source.indexes(),
						u = this._source.properties().childs(),
						d = this._source.firstValue();
					for (let e = 0; e < l.length; e++) {
						if (!l[e]) continue;
						const i = h[l[e].startIndex],
							s = h[l[e].endIndex],
							a = u.inputs.childs().showHistoricalPivots.value();
						if (i <= n && (s >= n || a)) {
							this._visiblePivots.add(l[e]), this._prices = [];
							for (let i = 0; i < r.length; i++) {
								const s = r[i],
									a = l[e][s];
								if (void 0 === a || null === d) continue;
								const n = t.priceToCoordinate(a, d),
									h = s.toUpperCase(),
									c = o[h],
									_ = u.levelsStyle.childs().colors.childs()[c].value();
								this._prices.push({
									formatted: t.formatPrice(a, d),
									price: a,
									coordinate: n,
									color: _
								})
							}
						}
					}
				}
			}
		},
		398640: (e, t, i) => {
			"use strict";
			i.d(t, {
				PaneRendererStandardPivotLabel: () => r
			});
			var s = i(218718);
			class r {
				constructor(e, t, i) {
					this._drawRects = [], this._cacheProvider = e, this._point = t, this._label = i
				}
				draw(e, t) {
					const i = this._cacheProvider(t);
					e.save(), e.setTransform(1, 0, 0, 1, 0, 0);
					const s = t.pixelRatio;
					this._drawRects = [];
					const r = t => {
							const r = i.labelRectByIndex(t),
								o = {
									left: Math.round(this._point.x - r.width + a),
									top: Math.round(this._point.y - r.height / 2),
									width: r.width,
									height: r.height
								};
							return e.drawImage(i.canvas(), Math.round(r.left * s), Math.round(r.top * s), r.width * s, r.height * s, Math.round(o.left * s), Math.round(o.top * s), o.width * s, o.height * s), this._drawRects.push(o), r.width
						},
						o = this._label.split("/");
					let a = 0;
					for (let e = 0; e < o.length; e++) {
						const t = ["P", "S1", "R1", "S2", "R2", "S3", "R3", "S4", "R4", "S5", "R5"].indexOf(o[e]);
						e > 0 && (a += r(t + 11) / 2), a += r(t) / 2
					}
					e.restore()
				}
				hitTest(e) {
					for (const t of this._drawRects)
						if (e.x >= t.left && e.x <= t.left + t.width && e.y >= t.top && e.y <= t.top + t.height) return new s.HitTestResult(s.HitTestResult.REGULAR);
					return null
				}
			}
		},
		722464: (e, t, i) => {
			"use strict";
			i.d(t, {
				StandardPivotPointsImageCache: () => o
			});
			var s = i(824112),
				r = i(588537);
			class o {
				constructor(e, t, i, r) {
					this._priceAxisFontSize = 11, this._prices = [], this._labelWidth = 0, this._paneRenderParams = e, this._recreateCanvasAndContext(new s.Size(0, 0)), this.reset({
						font: t,
						fontSize: i,
						backColors: r
					})
				}
				destroy() {
					delete this._canvas, delete this._cache
				}
				canvas() {
					return this._canvas
				}
				reset(e) {
					this._renderParams = e, this._prices = [], this._cache.font = e.fontSize + "px " + e.font, this._labelWidth = ["P", "S1", "R1", "S2", "R2", "S3", "R3", "S4", "R4", "S5", "R5", "/"].reduce(((e, t) => {
						const i = this._cache.measureText(t).width;
						return Math.max(i, e)
					}), 0)
				}
				rowHeight() {
					return this._priceAxisFontSize + 4
				}
				labelRectByIndex(e) {
					return {
						left: 0,
						top: Math.round(this._topByIndex(e)),
						width: Math.round(this._labelWidth + 4),
						height: Math.round(this._renderParams.fontSize + 8)
					}
				}
				setPrices(e) {
					let t = !1;
					const i = (e, t) => {
						const i = void 0 === e,
							s = void 0 === t;
						return (!i && !s || i === s) && (0, r.ensureDefined)(e).formatted === (0, r.ensureDefined)(t).formatted
					};
					if (e.length !== this._prices.length) t = !0;
					else
						for (let s = 0; s < this._prices.length; s++)
							if (!i(this._prices[s], e[s])) {
								t = !0;
								break
							} if (t) {
						const t = this._labelWidth + 6,
							i = this._renderParams.fontSize,
							r = Math.max(e.length, 22) * (i + 8);
						this._recreateCanvasAndContext(new s.Size(t, r)), this._prices = e, this._cache.save(), (0, s.drawScaled)(this._cache, this._paneRenderParams.pixelRatio, (() => {
							this._cache.translate(.5, .5), this._cache.font = this._renderParams.fontSize + "px " + this._renderParams.font, this._cache.textBaseline = "middle";
							for (let e = 0; e < this._prices.length; e++) {
								if (!this._prices[e]) continue;
								const t = ["P", "S1", "R1", "S2", "R2", "S3", "R3", "S4", "R4", "S5", "R5"][e];
								this._cache.fillStyle = this._renderParams.backColors[e], this._cache.fillText(t, 0, this._centerByIndex(e)), this._cache.fillText("/", 0, this._centerByIndex(e + 11))
							}
						})), this._cache.restore(), this._prices = e
					}
				}
				_recreateCanvasAndContext(e) {
					this._canvas = document.createElement("canvas"), this._canvas.width = e.w * this._paneRenderParams.pixelRatio, this._canvas.height = e.h * this._paneRenderParams.pixelRatio, this._cache = (0, r.ensureNotNull)(this._canvas.getContext("2d"))
				}
				_centerByIndex(e) {
					return Math.round((e + .5) * (this._renderParams.fontSize + 8))
				}
				_topByIndex(e) {
					return Math.round(e * (this._renderParams.fontSize + 8))
				}
			}
		},
		330401: (e, t, i) => {
			"use strict";
			i.d(t, {
				StandardPivotPointsPriceAxisView: () => o
			});
			var s = i(498424);
			const r = ["P", "S1", "R1", "S2", "R2", "S3", "R3", "S4", "R4", "S5", "R5"];
			class o extends s.PriceAxisView {
				constructor(e, t) {
					super(), this._source = e, this._data = t;
					const i = t.name;
					this._completeName = "P" === i.toUpperCase() ? "P" : `S${i[1]}/R${i[1]}`
				}
				_updateRendererData(e, t, i) {
					e.visible = !1, t.visible = !1;
					const s = this._source.properties().childs();
					if (!s.visible.value()) return;
					const o = this._completeName,
						a = s.levelsStyle.childs().visibility.childs();
					if (!a[o] || !a[o].value()) return;
					const n = this._source.model().timeScale(),
						l = this._source.priceScale();
					if (n.isEmpty() || null === n.visibleBarsStrictRange() || null !== l && l.isEmpty()) return;
					const h = this._source.customData();
					if (!h || !h.pivots) return;
					const u = this._source.pricesView().prices()[r.indexOf(this._data.name.toUpperCase())];
					if (!u) return;
					i.background = u.color, i.textColor = this.generateTextColor(u.color), i.coordinate = u.coordinate, i.floatCoordinate = u.floatCoordinate;
					const d = this._source.model().properties().childs().scalesProperties.childs();
					d.showStudyLastValue.value() && (e.text = u.formatted, e.visible = !0), d.showStudyPlotLabels.value() && (t.text = this._source.priceLabelText(this._data.name), t.visible = !0)
				}
			}
		},
		302359: (e, t, i) => {
			"use strict";
			var s = i(559270).PriceRange,
				r = i(86441).Point,
				o = i(234840).StudyStatusView,
				a = i(287597).StudyDataWindowView,
				n = i(659251).NonSeriesStudy,
				l = i(330401).StandardPivotPointsPriceAxisView,
				h = i(613648).PanePriceAxisView,
				u = i(218718).HitTestResult,
				d = i(717611).CompositeRenderer,
				c = i(859081).areEqualPaneRenderParams,
				_ = i(722464).StandardPivotPointsImageCache,
				p = i(920962).PivotPointsStandardLastPricesView,
				m = i(398640).PaneRendererStandardPivotLabel,
				y = i(37689).HorizontalLineRenderer,
				g = i(588427);
			class v {
				constructor(e, t) {
					this._model = e, this._source = t, this._pivots = [], this._textCache = {}
				}
				setCache(e) {
					this._cache = e
				}
				priceAxisViews(e, t) {
					return this._priceAxisViews
				}
				mergeLabel(e, t, i) {
					var s = "" + t;
					void 0 === e[s] ? (e[s] = {}, e[s].text = i, e[s].ids = [this.complete(i)]) : (e[s].text += "/" + i, e[s].ids.push(this.complete(i)))
				}
				complete(e) {
					return "P" === e ? e : "S" + e[1] + "/R" + e[1]
				}
				update() {
					this._invalidated = !0
				}
				_updateImpl() {
					if (this._source.pricesView().prices(), this._pivots = [], this._source.customData() && this._source.customData().pivots && this._source.properties().visible.value()) {
						var e = this._source.customData().pivots,
							t = this._source._indexes,
							i = this._model.timeScale(),
							s = this._source.priceScale();
						if (s && !s.isEmpty() && !i.isEmpty() && e) {
							var r = i.visibleBarsStrictRange(),
								o = r.firstBar(),
								a = r.lastBar();
							if (this._source.ownerSource())
								for (var n = this._source.ownerSource().firstValue(), l = 0; l < e.length; l++)
									if (e[l]) {
										var h = t[e[l].startIndex],
											u = t[e[l].endIndex];
										if (!(u < o || h > a)) {
											var d = {},
												c = this._source.properties().levelsStyle.visibility;
											c.P.value() && this.mergeLabel(d, e[l].p, "P"), c["S1/R1"].value() && (this.mergeLabel(d, e[l].s1, "S1"), this.mergeLabel(d, e[l].r1, "R1")), c["S2/R2"].value() && (this.mergeLabel(d, e[l].s2, "S2"), this.mergeLabel(d, e[l].r2, "R2")), c["S3/R3"].value() && (this.mergeLabel(d, e[l].s3, "S3"), this.mergeLabel(d, e[l].r3, "R3")), c["S4/R4"].value() && (this.mergeLabel(d, e[l].s4, "S4"), this.mergeLabel(d, e[l].r4, "R4")), c["S5/R5"].value() && (this.mergeLabel(d, e[l].s5, "S5"), this.mergeLabel(d, e[l].r5, "R5"));
											var _ = i.indexToCoordinate(h),
												p = i.indexToCoordinate(u);
											for (var m in d) {
												var y = parseFloat(m),
													g = s.priceToCoordinate(y, n);
												this._pivots.push({
													x1: _,
													x2: p,
													y: g,
													label: d[m].text,
													labelIds: d[m].ids,
													src: e[l]
												})
											}
										}
									}
						}
					}
				}
				renderer() {
					this._invalidated && (this._updateImpl(), this._invalidated = !1);
					for (var e = new d, t = this._source.properties().levelsStyle.colors, i = this._source.properties().levelsStyle.widths, s = this._source.visiblePivots(), o = 0; o < this._pivots.length; o++) {
						var a = this._pivots[o];
						if (s.has(a.src)) {
							var n = {
									width: this._model.timeScale().width(),
									height: this._source.priceScale().height(),
									color: t[a.labelIds[0]].value(),
									linewidth: i[a.labelIds[0]].value(),
									linestyle: CanvasEx.LINESTYLE_SOLID,
									y: a.y,
									left: a.x1,
									right: a.x2
								},
								l = new y;
							if (l.setData(n), l.setHitTest(new u(u.REGULAR)), e.append(l), this._source.properties().levelsStyle.showLabels.value()) {
								var h = function(e) {
									return this._source.getCache(e)
								}.bind(this);
								e.append(new m(h, new r(a.x1, a.y), a.label))
							}
						}
					}
					return e
				}
			}
			t.study_PivotPointsStandard = class extends n {
				constructor(e, t, i, s) {
					super(e, t, i, s);
					for (var r = ["P", "S1/R1", "S2/R2", "S3/R3", "S4/R4", "S5/R5"], o = this.properties().levelsStyle.visibility, a = 0; a < r.length; a++) o[r[a]].listeners().subscribe(this, this.processHibernate);
					this._cacheDrawParams = null, this._cache = null
				}
				indexes() {
					return this._indexes
				}
				getCache(e) {
					return this.createCacheIfRequred(e), this._cache
				}
				createCacheIfRequred(e) {
					if (null === this._cache || null == this._cacheDrawParams || !c(e, this._cacheDrawParams)) {
						this._cache && this._cache.destroy();
						var t = this._getActualCacheParams();
						this._cache = new _(e, t.font, t.fontSize, t.backColors),
							this._cache.setPrices(this._pricesView.prices()), this._cacheDrawParams = e, this._cacheInvalidated = !1, this._cache.reset(t), this._cache.setPrices(this._pricesView.prices())
					}
				}
				lastValueData(e, t, i) {
					var s = ["P", "S1", "R1", "S2", "R2", "S3", "R3", "S4", "R4", "S5", "R5"].indexOf(e.toUpperCase()),
						r = this._pricesView.prices()[s];
					return null != r ? r : {
						noData: !0
					}
				}
				priceLabelText(e) {
					return this._metaInfo.shortDescription + ":" + e.toUpperCase()
				}
				pricesView() {
					return this._pricesView
				}
				_getActualCacheParams() {
					var e = {};
					return e.font = g.CHART_FONT_FAMILY, e.fontSize = this.properties().fontsize.value(), e.backColors = [this.properties().levelsStyle.colors.P.value(), this.properties().levelsStyle.colors["S1/R1"].value(), this.properties().levelsStyle.colors["S1/R1"].value(), this.properties().levelsStyle.colors["S2/R2"].value(), this.properties().levelsStyle.colors["S2/R2"].value(), this.properties().levelsStyle.colors["S3/R3"].value(), this.properties().levelsStyle.colors["S3/R3"].value(), this.properties().levelsStyle.colors["S4/R4"].value(), this.properties().levelsStyle.colors["S4/R4"].value(), this.properties().levelsStyle.colors["S5/R5"].value(), this.properties().levelsStyle.colors["S5/R5"].value()], e
				}
				updateAllViews() {
					super.updateAllViews(), this._pricesView.update()
				}
				_createViews() {
					this._cache && (this._cache.destroy(), this._cache = null), this._priceAxisViews = [];
					var e = ["P", "S1", "R1", "S2", "R2", "S3", "R3", "S4", "R4", "S5", "R5"];
					this._paneViews.length = 0, this._labelPaneViews = [];
					var t = new v(this._model, this);
					t.setCache(this._cache), this._paneViews.push(t), this._mainPaneView = t;
					for (var i = 0; i < e.length; i++) {
						var s = new l(this, {
							name: e[i],
							cache: this._cache
						});
						this._priceAxisViews.push(s), this._labelPaneViews.push(new h(s, this, this._model))
					}
					this._dataWindowView || (this._dataWindowView = new a(this, this._model)), this._statusView || (this._statusView = new o(this, this._model.properties().scalesProperties.textColor)), this._legendView = null, this._pricesView = new p(this)
				}
				visiblePivots() {
					return this._pricesView.visiblePivots()
				}
				_postProcessGraphics() {}
				isVisible() {
					if (!this.properties().visible.value() || !this.isActualInterval()) return !1;
					for (var e = ["P", "S1/R1", "S2/R2", "S3/R3", "S4/R4", "S5/R5"], t = this.properties().levelsStyle.visibility, i = 0; i < e.length; i++)
						if (t[e[i]].value()) return !0;
					return !1
				}
				stop() {
					super.stop(), this._cache && (this._cache.destroy(), this._cache = null)
				}
				priceRange(e, t) {
					if (!this.customData() || !this.customData().pivots || !this._indexes) return null;
					if (!this.priceScale()) return null;
					for (var i = this.customData().pivots, r = this._indexes, o = null, a = 0; a < i.length; a++)
						if (i[a]) {
							var n = r[i[a].startIndex];
							if (!(r[i[a].endIndex] < e || n > t)) {
								var l = [],
									h = this._properties.levelsStyle.visibility;
								h.P.value() && l.push(i[a].p), h["S1/R1"].value() && l.push(i[a].s1, i[a].r1), h["S2/R2"].value() && l.push(i[a].s2, i[a].r2), h["S3/R3"].value() && l.push(i[a].s3, i[a].r3), h["S4/R4"].value() && l.push(i[a].s4, i[a].r4), h["S5/R5"].value() && l.push(i[a].s5, i[a].r5);
								for (var u = 0; u < l.length; u++) l[u] && (null === o ? o = new s(l[u], l[u]) : o.apply(l[u], l[u]))
							}
						}
					return this.priceScale().isLog() && o ? new s(this.priceScale().priceToLogical(o.minValue()), this.priceScale().priceToLogical(o.maxValue())) : o
				}
			}
		},
		140662: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				createStudy: () => Zt,
				isESDOrRollDatesStudy: () => Xt,
				isESDStudy: () => Qt,
				isFundamentalStudy: () => $t,
				isRollDatesStudy: () => jt,
				isStudy: () => Gt,
				isStudyStrategy: () => qt,
				isStudyStub: () => Yt,
				studyColorRotationMode: () => Jt,
				useSameColorRotationComparator: () => ei
			});
			var s = i(970028),
				r = i(448874),
				o = i(949156),
				a = i(735357),
				n = i.n(a),
				l = i(588537),
				h = i(679520),
				u = i(575932),
				d = i(827565),
				c = i(143498),
				_ = i(746511),
				p = i(270617),
				m = i(721386),
				y = i(208214),
				g = i(965513),
				v = i(591419),
				S = i(588427),
				b = i(218718),
				f = i(345185),
				w = i(668004),
				x = i(978265),
				C = i(86441),
				I = i(273044),
				P = i(224743),
				T = i(393987),
				D = i(504122),
				L = i(940448),
				R = i(813652),
				V = i(876322),
				k = i(199687),
				A = i(740204);
			let M;
			class E extends A.LollipopPaneView {
				constructor() {
					super(...arguments), this._stackStudies = [], this._getMoreFinancialsLinkInitialTabId = k.PageId.Overview, this._hideLollipops = !1, this._symbolName = null
				}
				addLollipop(e, t, i, s, r, o, a) {
					var n, l;
					const h = o[0];
					if (null === this._symbolName && (this._symbolName = null !== (l = null === (n = this._model.mainSeries().symbolInfo()) || void 0 === n ? void 0 : n.name) && void 0 !== l ? l : null, null === this._symbolName)) return;
					const u = this._source.metaInfo().id + "_" + h + "_" + this._symbolName,
						d = this._lollipops[u],
						c = void 0 !== d ? d.itemIndex : this._lollipopsCounter++,
						_ = this._model.lastHittestData(),
						p = u === this.getLastClickedLollipopId(),
						m = this._model.hoveredSource() === this._source && null !== _ && _.activeItem === c;
					this._lollipops[u] = {
						id: u,
						itemIndex: c,
						visible: !0,
						basePoint: new C.Point(i.indexToCoordinate(r), e),
						hovered: m,
						active: p,
						stack: a,
						...this.extraData(o)
					}
				}
				renderer(e, t) {
					return this._invalidated && (this._updateImpl(t, e), this._invalidated = !1), this._hideLollipops ? null : this._renderer
				}
				_updateImpl(e, t) {
					this._setStackStudies();
					const i = this._source.data(),
						s = this._model.timeScale(),
						r = s.visibleBarsStrictRange(),
						o = this._model.mainSeries().bars(),
						a = this._model.mainSeries(),
						n = a.priceScale(),
						h = a.firstBar();
					if (n.isEmpty() || s.isEmpty() || !h || !i || null === r) return;
					if (s.barSpacing() / 23 < 2 / 3 && I.Interval.parse(this._model.mainSeries().interval()).inMilliseconds() >= 432e6) return this._hideLollipops = !0, void this.clearLastClicked();
					this._hideLollipops = !1;
					for (const e in this._lollipops) this._lollipops.hasOwnProperty(e) && ((0, l.ensureDefined)(this._lollipops[e]).visible = !1);
					const u = this._getY(),
						d = r.firstBar(),
						c = r.lastBar();
					i.range(d, c).each(((e, t) => {
						let i = 0;
						for (let t = 0; t < this._stackStudies.length; ++t) this._stackStudies[t].data().contains(e) && ++i;
						return e > d && e < c && this.addLollipop(u, o, s, n, e, t, i), !1
					})), this.afterUpdate(u, o, s, n), this._createRenderers(e, t)
				}
				_formatDate(e, t) {
					let i, s = !0;
					if (s = R.Version.parse(this._source.metaInfo().version).isLessOrEqual(new R.Version(137, 0)), s) {
						let t = "Etc/UTC";
						const s = this._model.mainSeries();
						if (!s.isDWM() && (t = this._model.properties().childs().timezone.value(), "exchange" === t)) {
							const e = s.symbolInfo();
							t = e && e.timezone || ""
						}
						const r = (0, T.get_timezone)(t);
						i = (0, T.utc_to_cal)(r, e)
					} else i = new Date(e);
					return (t ? "â‰ˆ " : "") + function() {
						const e = L.dateFormatProperty.value();
						return void 0 !== M && M.format === e || (M = {
							format: e,
							formatter: new D.DateFormatter(e)
						}), M.formatter
					}().format(i)
				}
				_setStackStudies() {
					this._stackStudies = []
				}
				_getMoreFinancialsLink() {
					var e;
					if (!/\betf\b/i.test((null === (e = this._model.mainSeries().symbolInfo()) || void 0 === e ? void 0 : e.description) || "")) return {
						text: this._getMoreFinancialsLinkText(),
						onClick: () => {
							P.globalCloseDelegate.fire(), (0, V.showFinancialsDialog)({
								initialTabId: this._getMoreFinancialsLinkInitialTabId
							})
						}
					}
				}
				_getMoreFinancialsLinkText() {
					var e, t;
					return (0, u.t)("More {symbol} financials", {
						replace: {
							symbol: null !== (t = null === (e = this._model.mainSeries().symbolInfo()) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : ""
						}
					})
				}
				_onSymbolOrIntervalChanged() {
					super._onSymbolOrIntervalChanged(), this._symbolName = null
				}
			}
			var N = i(385442),
				B = i(777566),
				F = i(261820),
				O = i(274469),
				H = i(788600),
				W = i(323373),
				z = i(627086);
			const U = (0, u.t)("Earnings & Revenue"),
				G = (0, u.t)("Earnings"),
				q = (0, u.t)("Standardized"),
				Y = (0, u.t)("Reported"),
				$ = (0, u.t)("Estimate"),
				Q = (0, u.t)("Surprise"),
				j = (0, u.t)("Split"),
				X = (0, u.t)("Dividends"),
				Z = (0, u.t)("Net"),
				J = (0, u.t)("Gross"),
				K = (0, u.t)("Date"),
				ee = (0, u.t)("Ex-date"),
				te = (0, u.t)("Period Ending"),
				ie = (0, u.t)("Payment Date"),
				se = (0, u.t)("Revenue"),
				re = (0, u.t)("Before market open"),
				oe = (0, u.t)("After market close"),
				ae = {
					dark: (0, h.getHexColorByName)("color-cold-gray-900"),
					light: (0, h.getHexColorByName)("color-white")
				},
				ne = {
					positive: (0, h.getHexColorByName)("color-minty-green-600"),
					negative: (0, h.getHexColorByName)("color-ripe-red-600"),
					future: (0, h.getHexColorByName)("color-grapes-purple-a400"),
					unknown: (0, h.getHexColorByName)("color-cold-gray-350")
				},
				le = {
					positive: (0, h.getHexColorByName)("color-minty-green-500"),
					negative: (0, h.getHexColorByName)("color-ripe-red-500"),
					future: (0, h.getHexColorByName)("color-grapes-purple-a200"),
					unknown: (0, h.getHexColorByName)("color-cold-gray-700")
				};

			function he(e) {
				return e ? ne : le
			}
			const ue = new g.PercentageFormatter,
				de = new v.VolumeFormatter;
			class ce extends E {
				_setStackStudies() {
					if (super._setStackStudies(), !(this._source instanceof ke))
						for (const e of this._model.dataSources())(e instanceof ke || e instanceof Ve && this._source instanceof Re) && this._stackStudies.push(e)
				}
			}
			class _e extends ce {
				constructor(e, t, i) {
					super(e, t, i)
				}
				styles(e) {
					return e ? {
						positive: (0, h.getHexColorByName)("color-minty-green-600"),
						negative: (0, h.getHexColorByName)("color-ripe-red-600"),
						future: (0, h.getHexColorByName)("color-grapes-purple-a400"),
						unknown: (0, h.getHexColorByName)("color-cold-gray-350")
					} : {
						positive: (0, h.getHexColorByName)("color-minty-green-500"),
						negative: (0, h.getHexColorByName)("color-ripe-red-500"),
						future: (0, h.getHexColorByName)("color-grapes-purple-a200"),
						unknown: (0, h.getHexColorByName)("color-cold-gray-700")
					}
				}
				extraData(e) {
					const t = e[8],
						i = 14 === t,
						s = e[1],
						r = e[2],
						o = e[3],
						a = e[4],
						n = i ? null : e[5],
						l = null != n && null != r ? n - r : null,
						h = e[6],
						u = i ? null : e[7];
					let d;
					return null != t ? t < 20 ? d = "Future" : null !== l && (d = l < 0 ? "Negative" : "Positive") : null !== l ? d = l < 0 ? "Negative" : "Positive" : a > Date.now() && (d = "Future"), {
						standardized: s,
						reported: n,
						estimate: r,
						revenueValue: u,
						revenueEstimate: h,
						period: o,
						date: a,
						type: d,
						timeType: null != t ? t : void 0
					}
				}
				afterUpdate(e, t, i, s) {
					const r = this._source.getEstimate();
					if (r) {
						const o = r.value.slice();
						o[4] *= 1e3, this.addLollipop(e, t, i, s, r.index, o)
					}
				}
				createTooltipContent(e) {
					const t = e.standardized,
						i = null != t,
						s = e.reported,
						r = null != s,
						o = e.estimate,
						n = null != o,
						h = r && n ? s - o : null;
					let u = e.revenueEstimate,
						_ = !1;
					null != u && (_ = !0, u *= 1e6);
					let p = e.revenueValue,
						m = !1;
					null != p && (m = !0, p *= 1e6);
					const y = m && _ ? p - u : null,
						g = he(this._model.isDark());
					let v, S, b, f, w;
					switch (e.type) {
						case "Future":
							S = g.future, v = F;
							break;
						case "Negative":
							S = g.negative, v = B;
							break;
						case "Positive":
							S = g.positive, v = N;
							break;
						default:
							S = g.unknown, v = F
					}
					switch (e.timeType) {
						case 12:
						case 22:
							b = z, f = d.LollipopGroupIcons.AfterMarketClose, w = oe;
							break;
						case 11:
						case 21:
							b = W, f = d.LollipopGroupIcons.BeforeMarketOpen, w = re
					}
					const C = 10 === e.timeType || 14 === e.timeType,
						I = {
							name: K,
							value: this._formatDate(e.date, C)
						};
					b && (I.valueRightIcon = {
						iconContent: b,
						iconClass: f,
						tooltipText: w
					});
					const P = [I];
					e.period && P.push({
						name: te,
						value: a.unix(e.period).format("MMM 'YY")
					});
					const T = {
							title: m || _ ? U : G,
							subTitle: P,
							tooltipIcon: v,
							style: {
								color: S
							},
							content: [],
							anchor: this._getMoreFinancialsLink()
						},
						D = {
							title: G,
							content: []
						};
					if (i && D.content.push({
							name: q,
							value: (0, x.roundToThirdDigit)(t)
						}), r && D.content.push({
							name: Y,
							value: (0, x.roundToThirdDigit)(s)
						}), n && D.content.push({
							name: $,
							value: (0, x.roundToThirdDigit)(o)
						}), null !== h) {
						const e = 100 * Math.abs(h / o);
						let t = (0, x.roundToThirdDigit)(h);
						isFinite(e) && (t += " (" + ue.format(e) + ")"), D.content.push({
							name: Q,
							value: (0, c.forceLTRStr)(t),
							style: {
								fontWeight: "bold",
								color: S
							}
						})
					}
					if ((0, l.ensureDefined)(T.content).push(D), m || _) {
						const e = {
							title: se,
							content: []
						};
						if (m && e.content.push({
								name: Y,
								value: de.format(p)
							}), _ && e.content.push({
								name: $,
								value: de.format(u)
							}), null !== y) {
							const t = 100 * Math.abs(y / u);
							let i = de.format(y);
							isFinite(t) && (i += " (" + ue.format(t) + ")"), e.content.push({
								name: Q,
								value: (0, c.forceLTRStr)(i),
								style: {
									fontWeight: "bold",
									color: y >= 0 ? g.positive : g.negative
								}
							})
						}(0, l.ensureDefined)(T.content).push(e)
					}
					return T
				}
				getStyle(e) {
					if (void 0 === e.type) return super.getStyle(e);
					const t = e.active ? "active" : e.hovered ? "hovered" : "default";
					let i = t;
					e.stack && (i += "_stack:" + e.stack);
					let s = this._getStyleObject(e.type, i);
					if (null !== s) return s;
					if (this._stylesCache || (this._stylesCache = {}), !this._stylesCache[i]) {
						s = this._getStyleObject(e.type, t);
						const r = (0, p.clone)(s);
						r && (e.stack && (r.lollipop.incHeight = 25 * e.stack), this._stylesCache[i] = r)
					}
					return this._stylesCache[i]
				}
				_showBarLine(e) {
					return super._showBarLine(e) || this._model.mainSeries().properties().childs().esdShowBreaks.value()
				}
				_createRendererForLollipop(e, t) {
					return new w.EarningLollipopRenderer(e, new b.HitTestResult(b.HitTestResult.CUSTOM, t), this._textWidthCache)
				}
				_recreateStyles(e) {
					const t = e.isDark(),
						i = he(t),
						s = i.unknown,
						r = {
							barLine: {
								lineStyle: f.LINESTYLE_DASHED,
								lineWidth: 1,
								strokeStyle: s
							},
							lollipop: {
								width: 21,
								height: 21,
								bottom: 2,
								lineWidth: 1.5,
								importance: "earnings",
								strokeStyle: s,
								backgroundColor: t ? ae.dark : ae.light,
								fillCircle: !0,
								text: {
									label: "E",
									strokeStyle: s,
									font: (0, y.makeFont)(12, S.CHART_FONT_FAMILY, "bold")
								}
							}
						},
						o = {
							lollipop: {
								fillStyle: (0, m.generateColor)(s, 85)
							}
						},
						a = {
							lollipop: {
								fillStyle: s,
								text: {
									strokeStyle: (0,
										h.getHexColorByName)("color-cold-gray-50")
								}
							}
						};
					this._defaultStyle = (0, _.deepCopy)(r), this._hoveredStyle = (0, p.merge)((0, _.deepCopy)(r), o), this._activeStyle = (0, p.merge)((0, _.deepCopy)(r), a);
					const n = (e, t) => {
						const i = (0, _.deepCopy)(r);
						return i.barLine.strokeStyle = e, i.lollipop.strokeStyle = e, i.lollipop.text.strokeStyle = e, i.type = t, o.lollipop.fillStyle = (0, m.generateColor)(e, 85), a.lollipop.fillStyle = e, {
							default: i,
							hovered: (0, p.merge)((0, _.deepCopy)(i), o),
							active: (0, p.merge)((0, _.deepCopy)(i), a)
						}
					};
					a.lollipop.text.strokeStyle = (0, h.getHexColorByName)("color-grapes-purple-50");
					const l = n(i.future, "Future");
					r.lollipop.height = 23, r.lollipop.text.deltaY = 1, a.lollipop.text.strokeStyle = (0, h.getHexColorByName)("color-minty-green-50");
					const u = n(i.positive, "Positive");
					r.lollipop.bottom = .5, r.lollipop.text.deltaY = -.5, a.lollipop.text.strokeStyle = (0, h.getHexColorByName)("color-ripe-red-50");
					const d = n(i.negative, "Negative");
					this._earningTypeStyles = {
						Future: l,
						Positive: u,
						Negative: d
					}, this._stylesCache = null
				}
				_getStyleObject(e, t) {
					const i = this._earningTypeStyles[e];
					switch (t) {
						case "default":
							return i.default;
						case "hovered":
							return i.hovered;
						case "active":
							return i.active
					}
					return null
				}
			}
			const pe = (0, h.getHexColorByName)("color-tan-orange-600"),
				me = (0, h.getHexColorByName)("color-tan-orange-500");

			function ye(e) {
				return e ? pe : me
			}
			class ge extends ce {
				extraData(e) {
					const t = e[1];
					return {
						numerator: e[2],
						denominator: t,
						date: e[3]
					}
				}
				createTooltipContent(e) {
					let t = j;
					return (0, p.isNumber)(e.numerator) && (0, p.isNumber)(e.denominator) && (t += ": " + e.numerator + "/" + e.denominator), {
						title: t,
						subTitle: this._formatDate(e.date),
						tooltipIcon: O,
						style: {
							color: ye(this._model.isDark())
						},
						anchor: this._getMoreFinancialsLink()
					}
				}
				_recreateStyles(e) {
					const t = e.isDark(),
						i = ye(t),
						s = {
							barLine: {
								lineStyle: f.LINESTYLE_DASHED,
								lineWidth: 1,
								strokeStyle: i
							},
							lollipop: {
								width: 23,
								height: 23,
								bottom: 1,
								lineWidth: 1.5,
								importance: "splits",
								strokeStyle: i,
								backgroundColor: t ? ae.dark : ae.light,
								fillCircle: !0,
								text: {
									label: "S",
									strokeStyle: i,
									font: (0, y.makeFont)(12, S.CHART_FONT_FAMILY, "bold")
								}
							}
						},
						r = {
							lollipop: {
								fillStyle: (0, m.generateColor)(i, 85)
							}
						},
						o = {
							lollipop: {
								fillStyle: i,
								text: {
									strokeStyle: (0, h.getHexColorByName)("color-tan-orange-50")
								}
							}
						};
					this._defaultStyle = s, this._hoveredStyle = (0, p.merge)((0, _.deepCopy)(s), r), this._activeStyle = (0, p.merge)((0, _.deepCopy)(s), o), this._stylesCache = null
				}
			}
			const ve = (0, h.getHexColorByName)("color-tv-blue-600"),
				Se = (0, h.getHexColorByName)("color-tv-blue-500");

			function be(e) {
				return e ? ve : Se
			}
			class fe extends ce {
				constructor() {
					super(...arguments), this._getMoreFinancialsLinkInitialTabId = k.PageId.Dividends
				}
				extraData(e) {
					return {
						grossDividends: e[1],
						netDividends: e[3],
						date: e[2],
						paymentDate: e[4]
					}
				}
				createTooltipContent(e) {
					const t = [{
							name: ee,
							value: this._formatDate(e.date)
						}],
						i = +e.netDividends;
					isFinite(i) && 0 !== i && t.push({
						name: Z,
						value: (0, x.roundToThirdDigit)(i)
					});
					const s = +e.grossDividends;
					isFinite(s) && t.push({
						name: J,
						value: (0, x.roundToThirdDigit)(s)
					});
					const r = +e.paymentDate;
					return isFinite(r) && t.push({
						name: ie,
						value: this._formatDate(r)
					}), {
						title: X,
						subTitle: t,
						tooltipIcon: H,
						style: {
							color: be(this._model.isDark())
						},
						anchor: this._getMoreFinancialsLink()
					}
				}
				_recreateStyles(e) {
					const t = e.isDark(),
						i = be(t),
						s = {
							barLine: {
								lineStyle: f.LINESTYLE_DASHED,
								lineWidth: 1,
								strokeStyle: i
							},
							lollipop: {
								width: 23,
								height: 23,
								bottom: 1,
								lineWidth: 1.5,
								importance: "dividends",
								strokeStyle: i,
								backgroundColor: t ? ae.dark : ae.light,
								fillCircle: !0,
								text: {
									label: "D",
									strokeStyle: i,
									font: (0, y.makeFont)(12, S.CHART_FONT_FAMILY, "bold")
								}
							}
						},
						r = {
							lollipop: {
								fillStyle: (0, m.generateColor)(i, 85)
							}
						},
						o = {
							lollipop: {
								fillStyle: i,
								text: {
									strokeStyle: (0, h.getHexColorByName)("color-tv-blue-50")
								}
							}
						};
					this._defaultStyle = s, this._hoveredStyle = (0, p.merge)((0, _.deepCopy)(s), r), this._activeStyle = (0, p.merge)((0, _.deepCopy)(s), o), this._stylesCache = null
				}
				_getMoreFinancialsLinkText() {
					var e, t;
					return (0, u.t)("More {symbol} dividends", {
						replace: {
							symbol: null !== (t = null === (e = this._model.mainSeries().symbolInfo()) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : ""
						}
					})
				}
			}
			var we = i(534953),
				xe = i(676745),
				Ce = i(734906),
				Ie = i(234840);
			class Pe extends r.Study {
				constructor() {
					super(...arguments), this._restartRequired = !1
				}
				destroy() {
					this._paneView.destroy(), super.destroy()
				}
				start() {
					super.start(), this._model.mainSeries().dataEvents().symbolResolved().subscribe(this, this._initPlotStash), this._initPlotStash()
				}
				stop() {
					super.stop(), this._model.mainSeries().dataEvents().symbolResolved().unsubscribe(this, this._initPlotStash)
				}
				restoreData(e) {
					e.data = e.data.filter((e => e.index !== xe.INVALID_TIME_POINT_INDEX && this.isValid(e.value))), this._transformData(e.data), e.end = e.data.length, super.restoreData(e)
				}
				onClickOutside(e) {
					this._paneView.onClickOutside(e)
				}
				preferNoScale() {
					return !0
				}
				showInObjectTree() {
					return !1
				}
				isSavedInStudyTemplates() {
					return !1
				}
				isRemovedByStudyTemplates() {
					return !1
				}
				removeByRemoveAllStudies() {
					return !1
				}
				isDraggable() {
					return !1
				}
				copiable() {
					return !1
				}
				statusView() {
					return null
				}
				hasStateForAlert() {
					return !1
				}
				isSavedInChart(e) {
					return Boolean(e)
				}
				isSpeciallyZOrderedSource() {
					return !0
				}
				isUserDeletable() {
					return !1
				}
				canHaveChildren() {
					return !1
				}
				isIncludedInAutoScale() {
					return !1
				}
				isCurrencySource() {
					return !1
				}
				isUnitSource() {
					return !1
				}
				_transformData(e) {
					for (let t = e.length - 1; t >= 0; --t) {
						const i = e[t],
							s = i.index !== xe.INVALID_TIME_POINT_INDEX && this.isValid(i.value);
						this._updatePlotStash(i, s)
					}
				}
				_createViews() {
					this._paneViews = [this._paneView], this._priceAxisViews = [], this._dataWindowView || (this._dataWindowView = new Ce.DataWindowView), this._legendView = null, this._statusView || (this._statusView = new Ie.StudyStatusView(this))
				}
				async _showTooltip(e, t) {
					const s = this._model,
						r = this._model.timeScale(),
						o = [r.onScroll(), r.barSpacingChanged(), s.mainSeries().onSymbolIntervalChanged()],
						a = this.onClickOutside.bind(this),
						n = this._paneView.clearLastClicked.bind(this._paneView),
						l = t();
					if (null === l) return;
					const {
						showLollipopTooltip: h
					} = await Promise.all([i.e(8348), i.e(21834), i.e(11675), i.e(75514), i.e(49039)]).then(i.bind(i, 871003));
					h({
						items: l,
						position: e,
						customCloseSubscriptions: o,
						onClickOutside: a,
						onCustomClose: n,
						showScrollFades: !0
					})
				}
				_initPlotStash() {
					this._plotStash = {}
				}
				_updatePlotStash(e, t) {
					if (this._restartRequired || !this._plotStash) return;
					const i = e.value.slice(),
						s = i.shift(),
						r = String(s);
					t ? this._plotStash[r] ? String(this._plotStash[r]) !== String(i) && (this._restartRequired = !0) : this._plotStash[r] = i : this._plotStash[r] && (this._restartRequired = !0)
				}
			}
			const Te = we.sortSourcesPreOrdered.Dividends,
				De = we.sortSourcesPreOrdered.Splits,
				Le = we.sortSourcesPreOrdered.Earnings;
			class Re extends Pe {
				zorder() {
					return Te
				}
				isValid(e) {
					const t = e[2];
					return (0, p.isNumber)(t)
				}
				_createViews() {
					this._paneView = new fe(this._model, this, this._showTooltip.bind(this)), super._createViews()
				}
			}
			class Ve extends Pe {
				zorder() {
					return De
				}
				isValid(e) {
					const t = e[3];
					return (0, p.isNumber)(t)
				}
				_createViews() {
					this._paneView = new ge(this._model, this, this._showTooltip.bind(this)), super._createViews()
				}
			}
			class ke extends Pe {
				constructor() {
					super(...arguments), this._estimatePlotRow = null
				}
				zorder() {
					return Le
				}
				isValid(e) {
					const t = e[3],
						i = e[4];
					return (0, p.isNumber)(t) && (0, p.isNumber)(i)
				}
				restoreData(e) {
					super.restoreData(e);
					let t = null;
					if (e.estimate) t = this._restorePointset(e.estimate);
					else if (e.pointSets && null == e.pointSetsVersion) {
						const i = this._getSymbol();
						if (null !== i) {
							const s = i.split(":")[1].toUpperCase();
							e.pointSets[i] ? t = this._restorePointset(e.pointSets[i]) : e.pointSets[s] && (t = this._restorePointset(e.pointSets[s]))
						}
					} else if (e.pointSets && "1" === e.pointSetsVersion) {
						const i = this._getSymbol();
						if (null !== i) {
							const s = i.split(":")[1].toUpperCase();
							e.pointSets[i] ? t = e.pointSets[i].estimate : e.pointSets[s] && (t = e.pointSets[s].estimate)
						}
					} else null != e.estimatePlotRow && "2" === e.pointSetsVersion && (t = e.estimatePlotRow);
					this._estimatePlotRow = t
				}
				getEstimate() {
					return this._estimatePlotRow
				}
				_createViews() {
					this._paneView = new _e(this._model, this, this._showTooltip.bind(this)), super._createViews()
				}
				_getSymbol() {
					var e, t;
					return null !== (t = null === (e = this._series.symbolInfo()) || void 0 === e ? void 0 : e.base_name[0].toLowerCase()) && void 0 !== t ? t : null
				}
				_restorePointset(e) {
					return {
						index: e.index,
						value: [e.tickmark, void 0, e.estimate, (0, p.isNumber)(e.period) ? e.period : n()(e.period).unix(), (0, p.isNumber)(e.date) ? e.date : n()(e.date).unix()]
					}
				}
			}
			var Ae = i(663090),
				Me = i(717090),
				Ee = i(428139);
			const Ne = (0, u.t)("Contract switch"),
				Be = (0, u.t)("From contract"),
				Fe = (0, u.t)("To contract"),
				Oe = {
					dark: (0, h.getHexColorByName)("color-cold-gray-900"),
					light: (0, h.getHexColorByName)("color-white")
				},
				He = (0, h.getHexColorByName)("color-deep-blue-a200"),
				We = (0, h.getHexColorByName)("color-deep-blue-a400"),
				ze = [{
					name: "iconRollDatesSymbol",
					theme: "dark",
					imageData: URL.createObjectURL(new Blob([Ee.replace("currentColor", He)], {
						type: "image/svg+xml"
					}))
				}, {
					name: "iconRollDatesSymbol",
					theme: "light",
					imageData: URL.createObjectURL(new Blob([Ee.replace("currentColor", We)], {
						type: "image/svg+xml"
					}))
				}, {
					name: "iconRollDatesSymbol",
					theme: "darkHovered",
					imageData: URL.createObjectURL(new Blob([Ee.replace("currentColor", Oe.dark)], {
						type: "image/svg+xml"
					}))
				}, {
					name: "iconRollDatesSymbol",
					theme: "lightHovered",
					imageData: URL.createObjectURL(new Blob([Ee.replace("currentColor", Oe.light)], {
						type: "image/svg+xml"
					}))
				}],
				Ue = new Ae.IconsContainer(ze, 15);

			function Ge(e) {
				return e ? He : We
			}
			const qe = ["F", "G", "H", "J", "K", "M", "N", "Q", "U", "V", "X", "Z"];

			function Ye(e, t) {
				const i = Math.floor(t / 100);
				return `${e}${qe[t-100*i-1]}${i}`
			}
			class $e extends E {
				extraData(e) {
					return {
						date: e[0],
						currentContractCode: e[1],
						nextContractCode: e[2],
						backadjustment: e[3],
						exactTime: e[4]
					}
				}
				createTooltipContent(e) {
					var t;
					const i = [],
						s = null === (t = this._model.mainSeries().symbolInfo()) || void 0 === t ? void 0 : t.root;
					return void 0 !== s && (i.push({
						name: Be,
						value: Ye(s, e.currentContractCode)
					}), i.push({
						name: Fe,
						value: Ye(s, e.nextContractCode)
					})), {
						title: Ne,
						subTitle: i,
						tooltipIcon: Me,
						style: {
							color: Ge(this._model.isDark())
						}
					}
				}
				_showBarLine(e) {
					return super._showBarLine(e) || this._model.mainSeries().properties().childs().showContinuousContractSwitchesBreaks.value()
				}
				_recreateStyles(e) {
					const t = e.isDark(),
						i = Ge(t),
						s = {
							barLine: {
								lineStyle: f.LINESTYLE_DASHED,
								lineWidth: 1,
								strokeStyle: i
							},
							lollipop: {
								width: 23,
								height: 23,
								bottom: 1,
								lineWidth: 1.5,
								importance: "rollDates",
								strokeStyle: i,
								backgroundColor: t ? Oe.dark : Oe.light,
								fillCircle: !0,
								text: {
									label: "",
									strokeStyle: i,
									font: (0, y.makeFont)(12, S.CHART_FONT_FAMILY, "bold")
								}
							}
						},
						r = {
							lollipop: {
								fillStyle: (0, m.generateColor)(i, 85)
							}
						},
						o = {
							lollipop: {
								fillStyle: i
							}
						};
					this._defaultStyle = s, this._hoveredStyle = (0, p.merge)((0, _.deepCopy)(s), r), this._activeStyle = (0, p.merge)((0, _.deepCopy)(s), o), this._defaultStyle.lollipop.image = Ue.getIcon("iconRollDatesSymbol", t ? "dark" : "light").image(), this._hoveredStyle.lollipop.image = this._defaultStyle.lollipop.image, this._activeStyle.lollipop.image = Ue.getIcon("iconRollDatesSymbol", t ? "darkHovered" : "lightHovered").image(), this._stylesCache = null
				}
			}
			class Qe extends Pe {
				zorder() {
					return we.sortSourcesPreOrdered.RollDates
				}
				isValid(e) {
					const t = e[4];
					return (0, p.isNumber)(t)
				}
				_createViews() {
					this._paneView = new $e(this._model, this, this._showTooltip.bind(this)), super._createViews()
				}
			}
			var je = i(320681),
				Xe = i(785584),
				Ze = i(659251);
			class Je extends Ze.NonSeriesStudy {
				startIndex() {
					const e = this.customData();
					if (null == e || null == this._indexes) return null;
					const t = this._indexes[e.startIndex];
					return t !== xe.INVALID_TIME_POINT_INDEX ? t : null
				}
				endIndex() {
					const e = this.customData();
					if (null == e || null == this._indexes) return null;
					const t = this._indexes[e.endIndex];
					return t !== xe.INVALID_TIME_POINT_INDEX ? t : null
				}
				baseLine() {
					const e = this.customData();
					return null != e ? e.baseLine : null
				}
				downLine() {
					const e = this.customData();
					return null != e ? e.downLine : null
				}
				upLine() {
					const e = this.customData();
					return null != e ? e.upLine : null
				}
				pearsons() {
					const e = this.customData();
					return null != e && void 0 !== e.pearsons ? e.pearsons : null
				}
				isVisible() {
					if (!this.properties().childs().visible.value() || !this.isActualInterval()) return !1;
					const e = (0, l.ensureDefined)(this.properties().childs().styles.childs());
					return 0 !== e.upLine.childs().display.value() || 0 !== e.downLine.childs().display.value() || 0 !== e.baseLine.childs().display.value()
				}
				_createViews() {
					super._createViews(), Promise.all([i.e(44572), i.e(20507)]).then(i.bind(i, 349238)).then((({
						LinearRegressionPaneView: e
					}) => {
						this._setPaneViews([new e(this.model(), this)])
					}))
				}
			}
			var Ke = i(230276),
				et = i(559270);
			var tt = i(498424);
			class it extends tt.PriceAxisView {
				constructor(e, t) {
					super(), this._source = e, this._styleId = t
				}
				_updateRendererData(e, t, i) {
					var s;
					e.visible = !1;
					const r = this._source.priceScale(),
						o = this._source.properties().childs();
					if (!r || r.isEmpty() || !o.visible.value()) return;
					const a = null === (s = this._source.properties().childs().graphics.childs().horizlines) || void 0 === s ? void 0 : s.childs()[this._styleId].childs();
					if (!(a && a.visible && a.visible.value() && this._isLabelVisibleAccordinglyToProperties())) return;
					const n = this._source.model().timeScale().logicalRange(),
						l = this._source.firstValue();
					if (null === l || null === n) return;
					const h = {
							price: NaN,
							time: -1 / 0
						},
						u = this._source.graphics().horizlines().get(this._styleId);
					if (void 0 === u) return;
					for (const e of u) {
						if (void 0 === e.level) continue;
						const t = n.contains(e.startIndex, !0);
						t === n.contains(e.endIndex, !0) && 0 !== t || h.time < e.endIndex && (h.time = e.endIndex, h.price = e.level)
					}
					if (isNaN(h.price)) return;
					const d = a.color.value();
					i.background = d, i.textColor = this.generateTextColor(d), i.coordinate = r.priceToCoordinate(h.price, l), e.text = r.formatPrice(h.price, l, !0), e.visible = !0
				}
				_isLabelVisibleAccordinglyToProperties() {
					const e = this._source.model().properties().childs().scalesProperties.childs();
					return (e.showStudyLastValue.value() || e.showFundamentalLastValue.value()) && this._source.properties().childs().showLabelsOnPriceScale.value()
				}
			}
			class st extends r.Study {
				_createGraphicsPriceAxisViews() {
					var e;
					return Object.keys(null !== (e = this.metaInfo().graphics.horizlines) && void 0 !== e ? e : {}).map((e => new it(this, e)))
				}
			}
			class rt extends st {
				priceRange(e, t) {
					let i = !1;
					this.graphics().hhists().forEach(((e, t) => {
						var s;
						i = i || (0, l.ensureDefined)(null === (s = this.properties().childs().graphics.childs().hhists) || void 0 === s ? void 0 : s.childs()[t]).value()
					}));
					const s = function(e, t, i, s) {
						let r = null;
						return e.forEach(((e, s) => {
							e.forEach((e => {
								e.firstBarTime <= i && e.lastBarTime >= t && (null === r ? r = {
									low: {
										l: e.priceLow,
										h: e.priceHigh
									},
									high: {
										h: e.priceHigh
									}
								} : (e.priceLow < r.low.l && (r.low.l = e.priceLow, r.low.h = e.priceHigh), r.high.h = Math.max(r.high.h, e.priceHigh)))
							}))
						})), null === r ? null : s ? new et.PriceRange(r.low.l - .8 * (r.low.h - r.low.l), r.high.h) : new et.PriceRange(r.low.l, r.high.h)
					}(this.graphics().hhists(), e, t, i);
					if (null === s) return null;
					const r = (0, l.ensureNotNull)(this.priceScale());
					return r.isLog() ? new et.PriceRange(r.priceToLogical(s.minValue()), r.priceToLogical(s.maxValue())) : s
				}
			}
			var ot = i(661118),
				at = i(752280),
				nt = i(244276),
				lt = i(624635),
				ht = i(906096),
				ut = i(12270),
				dt = i(523083),
				ct = i(721925);
			class _t {
				constructor(e, t) {
					this._rough = e, this._detailed = t
				}
				forEach(e, t) {
					this._mostDetailedHorizLines().forEach((i => {
						e.call(t, i, i, this)
					}))
				}
				has(e) {
					let t = !1;
					return this._mostDetailedHorizLines().forEach((i => {
						t = t || i === e
					})), t
				}
				get size() {
					return this._rough.size
				} [Symbol.iterator]() {
					const e = this._mostDetailedHorizLines().entries();
					return {
						[Symbol.iterator]() {
							return this
						},
						next() {
							const t = e.next();
							return !0 === t.done ? t : {
								value: t.value[1]
							}
						}
					}
				}
				entries() {
					throw new Error("Not implemented")
				}
				keys() {
					throw new Error("Not implemented")
				}
				values() {
					throw new Error("Not implemented")
				}
				_mostDetailedHorizLines() {
					const e = new Map;
					this._rough.forEach((t => e.set(t.startIndex, t)));
					for (let t = this._detailed.length - 1; t >= 0; t--) {
						this._detailed[t].forEach((t => {
							e.has(t.startIndex) && e.set(t.startIndex, t)
						}))
					}
					return e
				}
			}
			class pt {
				constructor(e, t) {
					this._mergedHorizLinesSet = e, this._roughIterator = t
				} [Symbol.iterator]() {
					return this
				}
				next() {
					const e = this._roughIterator.next();
					if (!0 === e.done) return e;
					const t = e.value[0];
					return {
						value: [t, (0, l.ensureDefined)(this._mergedHorizLinesSet.get(t))]
					}
				}
			}
			class mt {
				constructor(e, t) {
					this._roughHorizLineSets = e, this._detailedHorizLineSets = t
				}
				forEach(e, t) {
					this._roughHorizLineSets.forEach(((i, s) => {
						e.call(t, (0, l.ensureDefined)(this.get(s)), s, this)
					}))
				}
				get(e) {
					const t = this._roughHorizLineSets.get(e);
					if (void 0 !== t) return new _t(t, this._detailedHorizLineSets.map((t => t.get(e))).filter((e => void 0 !== e)))
				}
				has(e) {
					return this._roughHorizLineSets.has(e)
				}
				get size() {
					return this._roughHorizLineSets.size
				} [Symbol.iterator]() {
					return new pt(this, this._roughHorizLineSets.entries())
				}
				entries() {
					throw new Error("Not implemented")
				}
				keys() {
					throw new Error("Not implemented")
				}
				values() {
					throw new Error("Not implemented")
				}
			}
			class yt {
				constructor(e, t) {
					this._rough = e, this._detailed = t
				}
				forEach(e, t) {
					this._rough.forEach(((i, s) => {
						for (const i of this._detailed) {
							const r = i.get(s);
							if (void 0 !== r) return void e.call(t, r, s, this)
						}
						e.call(t, i, s, this)
					}))
				}
				get(e) {
					for (const t of this._detailed) {
						const i = t.get(e);
						if (void 0 !== i) return i
					}
					return this._rough.get(e)
				}
				has(e) {
					for (const t of this._detailed) {
						if (t.has(e)) return !0
					}
					return this._rough.has(e)
				}
				get size() {
					return this._rough.size
				} [Symbol.iterator]() {
					throw new Error("Not implemented")
				}
				entries() {
					throw new Error("Not implemented")
				}
				keys() {
					throw new Error("Not implemented")
				}
				values() {
					throw new Error("Not implemented")
				}
			}
			class gt {
				constructor(e, t) {
					this._graphics = e, this._styleId = t
				}
				forEach(e, t) {
					this._graphics.hhistsByTimePointIndex().forEach((i => {
						i.forEach((i => {
							if (i.styleId === this._styleId) {
								const s = {
									firstBarTime: i.firstBarTime,
									lastBarTime: i.lastBarTime,
									rate: i.rate,
									priceHigh: i.priceHigh,
									priceLow: i.priceLow
								};
								e.call(t, s, s, this)
							}
						}))
					}))
				}
				has(e) {
					let t = !1;
					return this._graphics.hhistsByTimePointIndex().forEach((i => {
						i.forEach((i => {
							i.styleId === this._styleId && i === e && (t = !0)
						}))
					})), t
				}
				get size() {
					let e = 0;
					return this._graphics.hhistsByTimePointIndex().forEach((t => {
						t.forEach((t => {
							t.styleId === this._styleId && e++
						}))
					})), e
				} [Symbol.iterator]() {
					throw new Error("Not implemented")
				}
				entries() {
					throw new Error("Not implemented")
				}
				keys() {
					throw new Error("Not implemented")
				}
				values() {
					throw new Error("Not implemented")
				}
			}
			class vt {
				constructor(e, t) {
					this._graphicsInfo = e, this._graphics = t
				}
				forEach(e, t) {
					if (void 0 === this._graphicsInfo.hhists) return;
					const i = Object.keys(this._graphicsInfo.hhists);
					for (const s of i) e.call(t, (0, l.ensureDefined)(this.get(s)), s, this)
				}
				get(e) {
					if (void 0 !== this._graphicsInfo.hhists) return new gt(this._graphics, e)
				}
				has(e) {
					return void 0 !== this._graphicsInfo.hhists && e in this._graphicsInfo.hhists
				}
				get size() {
					return void 0 === this._graphicsInfo.hhists ? 0 : Object.keys(this._graphicsInfo.hhists).length
				} [Symbol.iterator]() {
					throw new Error("Not implemented")
				}
				entries() {
					throw new Error("Not implemented")
				}
				keys() {
					throw new Error("Not implemented")
				}
				values() {
					throw new Error("Not implemented")
				}
			}
			class St {
				constructor(e, t, i) {
					this._graphicsInfo = e, this._roughStudyGraphics = t, this._detailedStudyGraphics = i
				}
				horizlines() {
					return new mt(this._roughStudyGraphics.horizlines(), this._detailedStudyGraphics.map((e => e.horizlines())))
				}
				vertlines() {
					return this._roughStudyGraphics.vertlines()
				}
				lines() {
					return this._roughStudyGraphics.lines()
				}
				hlines() {
					return this._roughStudyGraphics.hlines()
				}
				textmarks() {
					return this._roughStudyGraphics.textmarks()
				}
				shapemarks() {
					return this._roughStudyGraphics.shapemarks()
				}
				backgrounds() {
					return this._roughStudyGraphics.backgrounds()
				}
				polygons() {
					return this._roughStudyGraphics.polygons()
				}
				trendchannels() {
					return this._roughStudyGraphics.trendchannels()
				}
				hhists() {
					return new vt(this._graphicsInfo, this)
				}
				hhistsByTimePointIndex() {
					return new yt(this._roughStudyGraphics.hhistsByTimePointIndex(), this._detailedStudyGraphics.map((e => e.hhistsByTimePointIndex())))
				}
				dwglabels() {
					return this._roughStudyGraphics.dwglabels()
				}
				dwglines() {
					return this._roughStudyGraphics.dwglines()
				}
				dwgboxes() {
					return this._roughStudyGraphics.dwgboxes()
				}
				dwgtables() {
					return this._roughStudyGraphics.dwgtables()
				}
				dwgtablecells() {
					return this._roughStudyGraphics.dwgtablecells()
				}
				dwglinefills() {
					return this._roughStudyGraphics.dwglinefills()
				}
			}
			var bt = i(194459);
			const ft = "tv-volumebyprice",
				wt = (0, nt.studyIdString)("VbPSessionsRough", ft),
				xt = (0, nt.studyIdString)("VbPSessionsDetailed", ft),
				Ct = (0, nt.studyIdString)("VbPSessionsDetailedAlerts", ft),
				It = Number.MAX_SAFE_INTEGER,
				Pt = (0, u.t)("study package is not available");
			class Tt extends rt {
				constructor(e, t, i, s) {
					super(e, t, i, s), this._isPackageAvailable = Dt(), this._alertsStudyMetaInfo = null, this._roughDataSource = null, this._detailedDataSource = null, this._detailedDataBuffer = new ot.CircularBuffer(7), this._loadedGraphics = null, this._loadedPlots = null, this._mergedGraphics = (0, ct.emptyStudyGraphics)(), this._mergedPlots = this._emptyPlotList(), this._isPackageAvailable || this._setStatus({
						type: ht.StudyStatusType.Error,
						errorDescription: {
							error: Pt
						}
					})
				}
				destroy() {
					null !== this._detailedDataSource && (this._detailedDataSource.dataUpdated().unsubscribe(this, this._onRoughOrDetailedDataUpdated), this._detailedDataSource.dataCleared().unsubscribe(this, this._onRoughOrDetailedDataCleared), this._detailedDataSource.studyStatusChanged().unsubscribe(this, this._onStudyStatusChanged), this._detailedDataSource.destroy(), this._detailedDataSource = null), null !== this._roughDataSource && (this._roughDataSource.dataUpdated().unsubscribe(this, this._onRoughOrDetailedDataUpdated), this._roughDataSource.dataCleared().unsubscribe(this, this._onRoughOrDetailedDataCleared), this._roughDataSource.studyStatusChanged().unsubscribe(this, this._onStudyStatusChanged), this._roughDataSource.destroy(), this._roughDataSource = null)
				}
				data() {
					return this._loadedPlots || this._mergedPlots
				}
				graphics() {
					return this._loadedGraphics || this._mergedGraphics
				}
				clearData() {
					null !== this._roughDataSource && this._roughDataSource.clearData(), null !== this._detailedDataSource && this._detailedDataSource.clearData()
				}
				restoreData(e) {
					this._invalidateLastNonEmptyPlotRowCache(), this._loadedPlots = this._emptyPlotList(), this._loadedPlots.restoreState(e),
						void 0 !== e.graphics && (this._loadedGraphics = (0, ct.loadStudyGraphics)(e.graphics)), this._postProcessGraphics()
				}
				isFailed() {
					return !this._isPackageAvailable || null !== this._roughDataSource && this._roughDataSource.studyStatus().type === ht.StudyStatusType.Error || null !== this._detailedDataSource && this._detailedDataSource.studyStatus().type === ht.StudyStatusType.Error
				}
				isLoading() {
					return null !== this._roughDataSource && this._roughDataSource.studyStatus().type === ht.StudyStatusType.Loading || null !== this._detailedDataSource && this._detailedDataSource.studyStatus().type === ht.StudyStatusType.Loading
				}
				isStarted() {
					return null !== this._roughDataSource && this._roughDataSource.isStarted() || null !== this._detailedDataSource && this._detailedDataSource.isStarted()
				}
				sourceId() {
					throw new Error("Invalid operation")
				}
				idForAlert() {
					return super._collectDepsForAlert().idForAlert
				}
				hasStateForAlert() {
					return super.hasStateForAlert() && null !== this._alertsStudyMetaInfo
				}
				canHaveChildren() {
					return !1
				}
				isChildStudy() {
					return !1
				}
				hasChildren() {
					return !1
				}
				getAllChildren() {
					return []
				}
				processHibernate() {
					this.isVisible() ? (null === this._roughDataSource || this._roughDataSource.isStarted() || (this._roughDataSource.start(), this._onHibernationStateChange.fire(!1)), null === this._detailedDataSource || this._detailedDataSource.isStarted() || this._detailedDataSource.start()) : (null !== this._roughDataSource && this._roughDataSource.isStarted() && (this._roughDataSource.stop(), this._onHibernationStateChange.fire(!0)), null !== this._detailedDataSource && this._detailedDataSource.isStarted() && this._detailedDataSource.stop())
				}
				isHibernated() {
					return !(this.isVisible() || null !== this._roughDataSource && this._roughDataSource.isStarted() || null !== this._detailedDataSource && this._detailedDataSource.isStarted())
				}
				_stopStudyOnServer() {
					var e, t;
					this._chartApi && this._chartApi.isConnected().value() && ((null === (e = this._roughDataSource) || void 0 === e ? void 0 : e.isStarted()) && this._roughDataSource.stop(), (null === (t = this._detailedDataSource) || void 0 === t ? void 0 : t.isStarted()) && this._detailedDataSource.stop())
				}
				async _startAfterSymbolsResolved(e, t) {
					if (this.isStarted() && !this.isRestarting()) return;
					if (this._restarting = !1, this._isPackageAvailable = Dt(), !this._isPackageAvailable) return void this._setStatus({
						type: ht.StudyStatusType.Error,
						errorDescription: {
							error: Pt
						}
					});
					if (!this._allInputsAreValid()) return;
					this._inputs = this.inputs();
					const i = this.model().studyMetaInfoRepository();
					if (null === this._roughDataSource) {
						const e = await i.findById({
							type: "java",
							studyId: wt
						});
						this._roughDataSource = new ut.StudyDataSource(this.model().chartApi(), this.model().mainSeries().seriesSource(), "vbpsessionsrough_", e), this._roughDataSource.studyStatusChanged().subscribe(this, this._onStudyStatusChanged), this._roughDataSource.dataCleared().subscribe(this, this._onRoughOrDetailedDataCleared), this._roughDataSource.dataUpdated().subscribe(this, this._onRoughOrDetailedDataUpdated)
					} else this._roughDataSource.stop();
					if (this._roughDataSource.setInputs(Lt(this._roughDataSource.metaInfo().inputs, this._inputs)), this.processHibernate(), null === this._detailedDataSource) {
						const e = await i.findById({
							type: "java",
							studyId: xt
						});
						this._detailedDataSource = new ut.StudyDataSource(this.model().chartApi(), this.model().mainSeries().seriesSource(), "vbpsessionsdetailed_", e), this._detailedDataSource.studyStatusChanged().subscribe(this, this._onStudyStatusChanged), this._detailedDataSource.dataCleared().subscribe(this, this._onRoughOrDetailedDataCleared), this._detailedDataSource.dataUpdated().subscribe(this, this._onRoughOrDetailedDataUpdated)
					} else this._detailedDataSource.stop();
					this._detailedDataSource.setInputs(Rt(this._inputs)), this.processHibernate(), this._createStudyGraphics(), this._subscribeToSessionId(), this._setStatus(this._statusValueFromDataSources()), this._onStart.fire(), null === this._alertsStudyMetaInfo && (this._alertsStudyMetaInfo = await i.findById({
						type: "java",
						studyId: Ct
					}))
				}
				_changeInputsImpl(e, t) {
					if (null !== this._roughDataSource) {
						if ((0, lt.areStudyInputsEqual)(this._roughDataSource.metaInfo().inputs, t, e)) {
							if (null !== this._detailedDataSource) {
								const t = Rt(e),
									i = (0, lt.rangeDependentStudyInputsToTimeRange)(t);
								if (this._moreDetailedDataRequiredForTimeRange(i)) {
									if (this._detailedDataSource.isActive()) {
										const e = this._detailedDataSource.stopAndStealData();
										if (e.plots.size() > 0 || !(0, ct.isStudyGraphicsEmpty)(e.graphics)) {
											const t = (0, l.ensureNotNull)(this._detailedDataSource.inputs());
											e.plots = this._extractEffectiveDetailedPlotValues(e.plots, t), this._detailedDataBuffer.enqueue({
												lod: Vt(t),
												value: e
											})
										}
									}
									this._detailedDataSource.setInputs(t), this._detailedDataSource.start()
								}
							}
						} else this._roughDataSource.setInputs(Lt(this._roughDataSource.metaInfo().inputs, e)), this._detailedDataBuffer.clear(), null !== this._detailedDataSource && this._detailedDataSource.setInputs(Rt(e));
						null !== this._detailedDataSource && this._createStudyGraphics()
					}
				}
				_collectDepsForAlert() {
					const e = super._collectDepsForAlert();
					if (null === this._alertsStudyMetaInfo) throw new Error("Alerts study metainfo is not ready yet. Have you checked the alert availability using hasStateForAlert()?");
					return {
						...e,
						studyDependencies: e.studyDependencies.map((e => {
							const t = e.study === kt(this.metaInfo());
							return {
								id: e.id,
								inputs: t ? (i = e.inputs, {
									...i,
									subscribeRealtime: !0
								}) : e.inputs,
								study: t && null !== this._alertsStudyMetaInfo ? kt(this._alertsStudyMetaInfo) : e.study
							};
							var i
						}))
					}
				}
				_statusValueFromDataSources() {
					const e = {
						type: ht.StudyStatusType.Undefined
					};
					if (null === this._roughDataSource || null === this._detailedDataSource) return e;
					const t = this._roughDataSource.studyStatus(),
						i = this._detailedDataSource.studyStatus();
					if (t.type === ht.StudyStatusType.Error) return t;
					if (i.type === ht.StudyStatusType.Error) return i;
					if (t.type === ht.StudyStatusType.Loading || i.type === ht.StudyStatusType.Loading) {
						const e = t.type === ht.StudyStatusType.Loading ? t.startTime : 1 / 0,
							s = i.type === ht.StudyStatusType.Loading ? i.startTime : 1 / 0;
						return {
							type: ht.StudyStatusType.Loading,
							startTime: Math.min(e, s)
						}
					}
					return t.type === ht.StudyStatusType.Completed ? {
						type: ht.StudyStatusType.Completed
					} : e
				}
				_emptyPlotList() {
					return new at.PlotList((0, dt.studyPlotFunctionMap)(this.metaInfo()), dt.studyEmptyPlotValuePredicate)
				}
				_createStudyPlots() {
					const e = (0, l.ensureNotNull)(this._roughDataSource),
						t = (0,
							l.ensureNotNull)(this._detailedDataSource);
					this._mergedPlots.clear();
					const i = [];
					i.push({
						lod: It,
						value: e.plots()
					}), this._detailedDataBuffer.forEach((e => {
						i.push({
							lod: e.lod,
							value: e.value.plots
						})
					}));
					const s = (0, l.ensureNotNull)(t.inputs());
					i.push({
						lod: Vt(s),
						value: this._extractEffectiveDetailedPlotValues(t.plots(), s)
					}), i.sort(((e, t) => t.lod - e.lod));
					for (const e of i) e.value.each(((e, t) => {
						for (const e of t)
							if (void 0 === e) return !1;
						return this._mergedPlots.add(e, t), !1
					}));
					this._invalidateLastNonEmptyPlotRowCache()
				}
				_createStudyGraphics() {
					const e = (0, l.ensureNotNull)(this._roughDataSource),
						t = (0, l.ensureNotNull)(this._detailedDataSource),
						i = [];
					this._detailedDataBuffer.forEach((e => {
						i.push({
							lod: e.lod,
							value: e.value.graphics
						})
					})), void 0 !== this._inputs && i.push({
						lod: Vt(this._inputs),
						value: t.graphics()
					}), i.sort(((e, t) => e.lod - t.lod));
					const s = i.map((e => e.value));
					this._mergedGraphics = new St(this.metaInfo().graphics, e.graphics(), s), this._postProcessGraphics()
				}
				_extractEffectiveDetailedPlotValues(e, t) {
					const i = (0, lt.rangeDependentStudyInputsToTimeRange)(t),
						s = this.model().timeScale().timePointToIndex(i.from),
						r = this.model().timeScale().timePointToIndex(i.to);
					return e.size() > 0 ? e.range(s || (0, l.ensureNotNull)(e.firstIndex()), r || (0, l.ensureNotNull)(e.lastIndex())) : this._emptyPlotList()
				}
				_moreDetailedDataRequiredForTimeRange(e) {
					const {
						from: t,
						to: i
					} = e;
					let s = !1;
					return (0, l.ensureNotNull)(this._roughDataSource).graphics().hhistsByTimePointIndex().forEach(((e, r) => {
						if (s) return;
						const o = this.model().timeScale().indexToTimePoint(r);
						if (null === o || o < t || i < o) return;
						const a = i - t;
						let n = !1;
						this._detailedDataBuffer.forEach((e => {
							if (e.lod <= a) {
								e.value.graphics.hhistsByTimePointIndex().has(r) && (n = !0)
							}
						})), n || (s = !0)
					})), s
				}
				_onStudyStatusChanged() {
					this._setStatus(this._statusValueFromDataSources()), (0, l.ensureDefined)(this._statusView).update()
				}
				_onRoughOrDetailedDataCleared() {
					null !== this._roughDataSource && null !== this._detailedDataSource && (this._invalidateLastNonEmptyPlotRowCache(), this._detailedDataBuffer.clear(), this._createStudyPlots(), this._createStudyGraphics(), this.updateAllViews((0, bt.dataSourceChangeEvent)(this.id(), void 0, !0)), this.model().updateSource(this))
				}
				_onRoughOrDetailedDataUpdated(e) {
					null !== this._roughDataSource && null !== this._detailedDataSource && (e.length > 0 && this._createStudyPlots(), this.updateAllViews((0, bt.dataSourceChangeEvent)(this.id())), this.model().updateSource(this))
				}
			}

			function Dt() {
				return void 0 !== window.pro && window.pro.hasPackage(ft)
			}

			function Lt(e, t) {
				const i = {};
				for (const s of e) i[s.id] = t[s.id];
				return i
			}

			function Rt(e) {
				const t = e.last_visible_bar_time - e.first_visible_bar_time;
				return {
					...e,
					first_visible_bar_time: e.first_visible_bar_time - t,
					last_visible_bar_time: e.last_visible_bar_time + t
				}
			}

			function Vt(e) {
				const {
					from: t,
					to: i
				} = (0, lt.rangeDependentStudyInputsToTimeRange)(e);
				return i - t
			}

			function kt(e) {
				return `${e.id}-${e.version}`
			}
			var At = i(819111),
				Mt = i(302359),
				Et = i(582294),
				Nt = i(126026),
				Bt = i(128128),
				Ft = i(147627);
			const Ot = i(611688).enabled("hide_main_series_symbol_from_indicator_legend");
			class Ht extends r.Study {
				constructor(e, t, i, s) {
					super(e, t, i, s), (0,
						l.ensureDefined)(this.properties().childs().styles.childs().vol_ma).childs().display.subscribe(this, (() => this.invalidateTitleCache()))
				}
				base() {
					return 1
				}
				destroy() {
					(0, l.ensureDefined)(this.properties().childs().styles.childs().vol_ma).childs().display.listeners().unsubscribeAll(this), super.destroy()
				}
				_titleInputs() {
					const e = {
						symbolsForDisplay: !0,
						skipHiddenInputs: !0,
						fakeInputsForDisplay: !0,
						asObject: !1,
						skipOptionalEmptySymbolInputs: Ot
					};
					return 0 !== (0, l.ensureDefined)(this.properties().childs().styles.childs().vol_ma).childs().display.value() ? this.inputs(e) : this.inputs({
						...e,
						skippedInputs: ["length"]
					})
				}
			}
			var Wt = i(573033);

			function zt(e, t = "shift", i) {
				return {
					studyConstructor: e,
					colorRotationMode: t,
					colorRotationComparator: i
				}
			}
			const Ut = {
				study_PivotPointsStandard: zt(Mt.study_PivotPointsStandard),
				study_Overlay: zt(Et.study_Overlay, "loop"),
				study_Compare: zt(Nt.StudyCompare, "loop"),
				study_Volume: zt(Ht),
				study_VbPVisible: zt(class extends rt {
					alertCreationAvailable() {
						return !1
					}
				}),
				study_ScriptWithDataOffset: zt(Bt.study_ScriptWithDataOffset)
			}; {
				Ut.study_Earnings = zt(ke), Ut.study_Splits = zt(Ve), Ut.study_Dividends = zt(Re), Ut.study_BarSetContinuousRollDates = zt(Qe);
				const e = (e, t) => (0, Wt.isFundamentalStudyMetaInfo)(t);
				Ut[Wt.fundamentalsPrefix] = zt(je.Fundamental, "loop", e), Ut.study_ElliottWave = zt(Xe.study_ElliottWave), Ut.study_LinearRegression = zt(Je), Ut.study_PivotPointsHighLow = zt(Ke.study_PivotPointsHighLow), Ut.study_VbPSessions = zt(rt), Ut.study_VbPPeriodic = zt(st), Ut.study_VbPSessionsRoughDetailed = zt(Tt), Ut.study_ZigZag = zt(At.study_ZigZag), TradingView.StudyStrategy = zt(o.StudyStrategy).studyConstructor
			}
			for (const e in Ut) Ut.hasOwnProperty(e) && (TradingView[e] = Ut[e].studyConstructor);

			function Gt(e) {
				return e instanceof r.Study
			}

			function qt(e) {
				return e instanceof o.StudyStrategy
			}

			function Yt(e) {
				return e instanceof Ft.StudyStub
			}

			function $t(e) {
				return e instanceof je.Fundamental
			}

			function Qt(e) {
				return e instanceof ke || e instanceof Ve || e instanceof Re
			}

			function jt(e) {
				return e instanceof Qe
			}

			function Xt(e) {
				return Qt(e) || jt(e)
			}

			function Zt(e, t, i, a, n) {
				if (s.StudyMetaInfo.isScriptStrategy(a)) return new o.StudyStrategy(e, t, i, a);
				const l = (0, Wt.studyNameByMetaInfo)(a),
					h = new(l in Ut ? Ut[l].studyConstructor : r.Study)(e, t, i, a);
				return void 0 !== n && h.setId(n), h
			}

			function Jt(e) {
				const t = (0, Wt.studyNameByMetaInfo)(e);
				return t in Ut ? Ut[t].colorRotationMode : void 0 === e.pine || s.StudyMetaInfo.isStandardPine(e.id) ? 1 !== e.plots.length ? "shift" : "loop" : null
			}

			function Kt(e, t) {
				return e.id === t.id && (s = t, ((i = e).pine ? i.pine.version : void 0) === (s.pine ? s.pine.version : void 0));
				var i, s
			}

			function ei(e) {
				const t = (0, Wt.studyNameByMetaInfo)(e);
				if (t in Ut) {
					const e = Ut[t].colorRotationComparator;
					if (void 0 !== e) return e
				}
				return Kt
			}
		},
		12270: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				StudyDataSource: () => p
			});
			var s = i(588537),
				r = i(97639),
				o = i.n(r),
				a = i(752280),
				n = i(695078),
				l = i(476543),
				h = i(523083),
				u = i(211014),
				d = i(183939);
			const c = (0, i(911905).getLogger)("Chart.StudyDataSource");
			var _;
			! function(e) {
				e[e.Idle = 0] = "Idle", e[e.AwaitingConnection = 1] = "AwaitingConnection", e[e.AwaitingParent = 2] = "AwaitingParent",
					e[e.AwaitingFirstDataUpdate = 3] = "AwaitingFirstDataUpdate", e[e.Active = 4] = "Active"
			}(_ || (_ = {}));
			class p {
				constructor(e, t, i, s) {
					this._inputs = null, this._status = _.Idle, this._studyId = null, this._turnaroundCounter = 1, this._studyStatus = {
						type: d.StudyStatusType.Undefined
					}, this._studyStatusChanged = new(o()), this._graphics = new u.LiveStudyGraphics, this._dataCleared = new(o()), this._dataUpdated = new(o()), this._boundOnGatewayIsConnectedChanged = this._onGatewayIsConnectedChanged.bind(this), this._ongoingDataUpdate = Promise.resolve(), this._gateway = e, this._metaInfo = s, this._seriesSource = t, this._turnaroundPrefix = i, this._plots = new a.PlotList((0, h.studyPlotFunctionMap)(s), h.studyEmptyPlotValuePredicate), this._gateway.isConnected().subscribe(this._boundOnGatewayIsConnectedChanged)
				}
				destroy() {
					this.stop(), this._gateway.isConnected().unsubscribe(this._boundOnGatewayIsConnectedChanged), this._dataUpdated.destroy(), this._dataCleared.destroy(), this._studyStatusChanged.destroy()
				}
				metaInfo() {
					return this._metaInfo
				}
				inputs() {
					return this._inputs
				}
				setInputs(e) {
					this._inputs = e, null !== this._studyId && (this._turnaroundCounter++, this._onStudyStatusChangedTo({
						type: d.StudyStatusType.Undefined
					}), this._gateway.modifyStudy(this._studyId, this._turnaround(), e, this._onMessage.bind(this)), this._status === _.Active && this._changeStatusTo(_.AwaitingFirstDataUpdate))
				}
				isStarted() {
					return this._status !== _.Idle
				}
				isActive() {
					return this._status === _.Active
				}
				start() {
					this.isStarted() ? c.logNormal("start: data source is already started, nothing to do") : ((0, s.assert)(null !== this._inputs, "Inputs should be defined when starting a study data source"), this._gateway.isConnected().value() ? this._createStudy() : this._changeStatusTo(_.AwaitingConnection))
				}
				stop() {
					this.isStarted() ? (null !== this._studyId && (this._gateway.removeStudy(this._studyId), this._studyId = null, this._onStudyStatusChangedTo({
						type: d.StudyStatusType.Undefined
					})), this._changeStatusTo(_.Idle)) : c.logNormal("stop: data source is already stopped, nothing to do")
				}
				studyId() {
					return this._studyId
				}
				studyStatus() {
					return this._studyStatus
				}
				studyStatusChanged() {
					return this._studyStatusChanged
				}
				plots() {
					return this._plots
				}
				graphics() {
					return this._graphics
				}
				clearData() {
					this._plots.clear(), this._graphics.clear(), this._dataCleared.fire()
				}
				stopAndStealData() {
					(0, s.assert)(this._status === _.Active, "Couldn't steal data from non-active data source"), this.stop();
					const e = this._plots,
						t = this._graphics.extract();
					return this._plots = new a.PlotList((0, h.studyPlotFunctionMap)(this._metaInfo), h.studyEmptyPlotValuePredicate), {
						plots: e,
						graphics: t
					}
				}
				dataCleared() {
					return this._dataCleared
				}
				dataUpdated() {
					return this._dataUpdated
				}
				moveData(e) {
					this._ongoingDataUpdate = this._ongoingDataUpdate.then((() => {
						this._plots.move(e)
					}))
				}
				pendingUpdatesReady() {
					return this._ongoingDataUpdate
				}
				_changeStatusTo(e) {
					(0, s.assert)(this._status !== e, "Source and destination status should be distinct"), c.logNormal(`Status changed from ${_[this._status]} to ${_[e]}`), this._status = e
				}
				_createStudy() {
					const e = this._seriesSource.instanceId();
					null !== e ? this._createStudyUsingParentId(e) : (this._changeStatusTo(_.AwaitingParent),
						this._seriesSource.dataEvents().completed().subscribe(this, this._onSeriesCompleted, !0))
				}
				_createStudyUsingParentId(e) {
					(0, s.assert)(this._status !== _.Active, 'Status should not be "Active" when creating a study'), (0, s.assert)(this._studyStatus.type === d.StudyStatusType.Undefined, 'Study status should be "Undefined" when creating a study'), (0, s.assert)(null === this._studyId, "Study id should be empty when creating a study"), this._studyId = (0, l.makeNextStudyId)(), this._gateway.createStudy(this._studyId, this._turnaround(), e, this._metaInfo.fullId + ("tv-basicstudies" === this._metaInfo.packageId ? "" : "!"), (0, s.ensureNotNull)(this._inputs), this._onMessage.bind(this)), this._changeStatusTo(_.AwaitingFirstDataUpdate)
				}
				_onGatewayIsConnectedChanged(e) {
					e ? this._onGatewayConnected() : this._onGatewayDisconnected()
				}
				_onGatewayConnected() {
					this._status === _.AwaitingConnection && this._createStudy()
				}
				_onGatewayDisconnected() {
					this._status !== _.Idle && this._status !== _.AwaitingConnection && (this._studyId = null, this._changeStatusTo(_.AwaitingConnection), this._studyStatus.type !== d.StudyStatusType.Undefined && this._onStudyStatusChangedTo({
						type: d.StudyStatusType.Undefined
					})), this._turnaroundCounter = 1
				}
				_onSeriesCompleted() {
					this._status === _.AwaitingParent && this._createStudyUsingParentId((0, s.ensure)(this._seriesSource.instanceId()))
				}
				_onStudyStatusChangedTo(e) {
					const t = this._studyStatus;
					this._studyStatus = e, c.logNormal(`Study status type changed from ${d.StudyStatusType[t.type]} to ${d.StudyStatusType[e.type]}`), this._studyStatusChanged.fire(t, e)
				}
				_onMessage(e) {
					if ("data_update" === e.method) {
						const {
							customId: t,
							turnaround: i,
							plots: r,
							nonseries: o
						} = e.params;
						t === this._studyId && this._checkTurnaround(i) && this._onDataUpdate(r, (0, s.ensureDefined)(o))
					} else if ("study_loading" === e.method) {
						const [t, i, s] = e.params;
						t === this._studyId && this._checkTurnaround(i) && this._onStudyLoading(s)
					} else if ("study_completed" === e.method) {
						const [t, i, s] = e.params;
						t === this._studyId && this._checkTurnaround(i) && this._onStudyCompleted(s)
					} else if ("study_error" === e.method) {
						const [t, i, s, r, o] = e.params;
						t === this._studyId && this._checkTurnaround(i) && this._onStudyError(s, r, o)
					} else "clear_data" === e.method && this._checkTurnaround(e.params.turnaround) && this.clearData()
				}
				_onDataUpdate(e, t) {
					const i = (0, n.unpackNonSeriesData)(t.d);
					return this._ongoingDataUpdate = this._ongoingDataUpdate.then((() => i), (() => i)).then(this._onDataUnpacked.bind(this, e, t.indexes)), this._ongoingDataUpdate
				}
				_onDataUnpacked(e, t, i) {
					this._status !== _.Idle && (this._status === _.AwaitingFirstDataUpdate && (this._changeStatusTo(_.Active), this.clearData()), this._mergePlots(e), null !== i && (i.indexes_replace ? ((0, s.assert)("nochange" !== t), this._graphics.replaceIndexesTo(t)) : ("nochange" !== t && this._graphics.replaceIndexesTo(t), void 0 !== i.graphicsCmds && this._graphics.processCommands(i.graphicsCmds, this._metaInfo.graphics))), this._dataUpdated.fire(e, i, t))
				}
				_onStudyLoading(e) {
					this._onStudyStatusChangedTo({
						type: d.StudyStatusType.Loading,
						startTime: Date.now()
					})
				}
				_onStudyError(e, t, i) {
					this.clearData();
					const s = "string" == typeof e ? {
						error: e.split(":", 2)[0]
					} : e;
					this._onStudyStatusChangedTo({
						type: d.StudyStatusType.Error,
						errorDescription: s
					})
				}
				_onStudyCompleted(e) {
					this._onStudyStatusChangedTo({
						type: d.StudyStatusType.Completed
					})
				}
				_mergePlots(e) {
					this._plots.merge(e)
				}
				_turnaround() {
					return `${this._turnaroundPrefix}${this._turnaroundCounter}`
				}
				_checkTurnaround(e) {
					const t = this._turnaround();
					return e === t || e === this._seriesSource.turnaround() || e === `${this._seriesSource.turnaround()}_${t}`
				}
			}
		},
		147627: (e, t, i) => {
			"use strict";
			i.d(t, {
				StudyStub: () => m
			});
			var s = i(234840),
				r = i(902899),
				o = i(689765),
				a = i(97639),
				n = i.n(a),
				l = i(232567),
				h = i.n(l),
				u = i(920937);
			class d extends u.StudyStatusProviderBase {
				text() {
					return this._source.isActualInterval() ? `${this._source.title()} ${this.sourceStatusText()}` : this._source.title()
				}
			}
			var c = i(906096);
			class _ {
				getItems() {
					return []
				}
				getValues(e) {
					return []
				}
			}
			const p = new(n());
			class m extends r.PriceDataSource {
				constructor(e, t, i) {
					super(e), this._priceStep = .01, this._status = {
						type: c.StudyStatusType.Undefined
					}, this._statusChanged = new(n()), this._formatter = new o.PriceFormatter(100), this._origState = t, this._title = i;
					this._properties = new(h())({
						visible: !0
					}), this._statusView = new s.StudyStatusView(this)
				}
				barColorer() {
					return null
				}
				properties() {
					return this._properties
				}
				statusView() {
					return this._statusView
				}
				legendView() {
					return null
				}
				state(e) {
					return this._origState
				}
				setStatus(e) {
					this._status = e, this._statusChanged.fire()
				}
				formatter() {
					return this._formatter
				}
				name() {
					return this._title
				}
				title() {
					return this._title
				}
				titleInParts() {
					return [this._title]
				}
				isFailed() {
					return this._status.type === c.StudyStatusType.Error
				}
				isLoading() {
					return this._status.type === c.StudyStatusType.Loading
				}
				setFailed(e) {
					this.setStatus({
						type: c.StudyStatusType.Error,
						errorDescription: {
							error: e
						}
					}), this._model.updateSource(this)
				}
				isSymbolInvalid() {
					return !1
				}
				isActualInterval() {
					return !0
				}
				onIsActualIntervalChange() {
					return p
				}
				start() {}
				status() {
					return this._status
				}
				onStatusChanged() {
					return this._statusChanged
				}
				firstValue() {
					return null
				}
				currency() {
					return null
				}
				sessionId() {
					return this._model.mainSeries().sessionId()
				}
				sessionIdChanged() {
					return this._model.mainSeries().sessionIdChanged()
				}
				unit() {
					return null
				}
				symbolSource() {
					return this._model.mainSeries()
				}
				valuesProvider() {
					return new _
				}
				statusProvider(e) {
					return new d(this, this._model.properties().childs().scalesProperties.childs().textColor)
				}
			}
		},
		126026: (e, t, i) => {
			"use strict";
			i.d(t, {
				StudyCompare: () => O
			});
			var s = i(588537),
				r = i(741139),
				o = i(38627),
				a = i(448874),
				n = i(749473),
				l = i(232567),
				h = i.n(l),
				u = i(611688),
				d = i(926281),
				c = i(498424),
				_ = i(943615);
			const p = u.enabled("force_exchange_as_title");
			class m extends c.PriceAxisView {
				constructor(e, t) {
					super(), this._studyCompare = e, this._data = t
				}
				_updateRendererData(e, t, i) {
					e.visible = !1, t.visible = !1;
					const s = this._studyCompare.priceScale(),
						r = this._studyCompare.lastValueData(this._data.plotIndex, !1);
					if (r.noData || null === s || s.isEmpty()) return;
					i.background = r.color, i.textColor = this.generateTextColor(r.color), i.coordinate = r.coordinate, i.floatCoordinate = r.floatCoordinate;
					const o = this._studyCompare.model().properties().childs().scalesProperties.childs();
					o.showSeriesLastValue.value() && (e.text = (0, _.getCurrentModePriceText)(s, r),
						o.seriesLastValueMode.value() !== d.PriceAxisLastValueMode.LastPriceAndPercentageValue ? e.secondLine = "" : e.secondLine = (0, _.getOppositeModePriceText)(s, r), e.visible = !0), t.text = "", o.showSymbolLabels.value() && (t.text = this._paneText(), t.visible = t.text.length > 0)
				}
				_paneText() {
					let e = "";
					const t = this._studyCompare.symbolInfo();
					return p ? e = (0, n.displayedSymbolExchange)(t) : this._studyCompare.model().properties().childs().scalesProperties.childs().showSymbolLabels.value() && (e = (0, n.displayedSymbolName)(t)), e
				}
			}
			var y = i(575932),
				g = i(287597),
				v = i(29084),
				S = i(308170),
				b = i(638456),
				f = i(270617),
				w = i(833485);
			class x extends w.StudyValuesProvider {
				constructor(e, t) {
					super(e, t), this._emptyValues[0].title = e.guiPlotName("")
				}
				_hideValues() {
					return !1
				}
			}
			const C = b.CheckMobile.any();
			class I extends g.StudyDataWindowView {
				constructor(e, t) {
					super(e, t), this._studyCompare = e
				}
				_hideValues() {
					return !1
				}
				_createValuesProvider(e, t) {
					return new x(e, t)
				}
				_currentIndex() {
					const e = this._model.crossHairSource().lockedIndex;
					let t;
					return C && (null === this._model.crossHairSource().pane && void 0 === e || (0, v.isLineToolName)(S.tool.value()) || null !== this._model.lineBeingEdited()) ? t = this._study.data().lastIndex() : (t = this._model.crossHairSource().appliedIndex(), (0, f.isNumber)(t) || (t = this._study.data().lastIndex())), t
				}
			}
			var P = i(736643);
			class T extends I {
				constructor(e, t) {
					super(e, t), this._additional = null, this._showSeriesOHLC = t.properties().childs().paneProperties.childs().legendProperties.childs().showSeriesOHLC, this._showSeriesOHLC.subscribe(this, this.update)
				}
				areValuesVisible() {
					return this._showSeriesOHLC.value()
				}
				destroy() {
					this._showSeriesOHLC.unsubscribeAll(this)
				}
				additional() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._additional
				}
				_updateImpl() {
					{
						const e = (0, P.getDataVendorString)(this._studyCompare.symbolInfo());
						this._additional = e ? (0, y.t)("Data Provided by") + " " + e : null
					}
					super._updateImpl()
				}
			}
			var D = i(234840),
				L = i(651620);
			class R extends L.StudyStatusProvider {
				getSplitTitle() {
					return this._source.titleInParts(!0, void 0, !1, !1)
				}
				text() {
					return this._source.isActualInterval() ? this._source.isFailed() ? `${this._source.title(!0,void 0,!1,!1)}: ${this.sourceStatusText()}` : `${this._source.title(!0,void 0,!1,!1)} ${this.sourceStatusText()}` : this._source.title(!0, void 0, !1, !1)
				}
			}
			var V = i(706342),
				k = i(262325),
				A = i.n(k);
			const M = u.enabled("study_overlay_compare_legend_option"),
				E = u.enabled("force_exchange_as_title"),
				N = u.enabled("uppercase_instrument_names"),
				B = !u.enabled("hide_study_compare_legend_item"),
				F = u.enabled("hide_unresolved_symbols_in_legend");
			class O extends a.Study {
				constructor(e, t, i, s) {
					super(e, function(e) {
							return e.hasChild("currencyId") || e.addChild("currencyId", new(h())(null)), e.hasChild("unitId") || e.addChild("unitId", new(h())(null)), e.addExclusion("currencyId"), e.addExclusion("unitId"), e
						}(t), i, s), this._realignToolsLastParams = null, this.properties().childs().minTick.subscribe(null, (() => this._recreatePriceFormattingDependencies())), this.properties().childs().minTick.subscribe(null, (() => this._model.fullUpdate())), this.properties().childs().currencyId.subscribe(this, this._onCurrencyChanged),
						this.properties().childs().unitId.subscribe(this, this._onUnitChanged), this.properties().merge({
							skipHistogramBaseOnAutoScale: !0
						}), this._symbolResolvingActive = new(A())(!1), this._symbolHibernated = new(A())(!1), e.mainSeries().onIntervalChanged().subscribe(this, (() => e.realignLineTools(this)))
				}
				destroy() {
					this._model.mainSeries().onIntervalChanged().unsubscribeAll(this), super.destroy()
				}
				properties() {
					return this._properties
				}
				createPriceAxisView(e) {
					return new m(this, {
						plotIndex: "compare"
					})
				}
				setSymbolParams(e) {
					this._setSymbolCurrencyUnitInternal(e)
				}
				symbol() {
					return this.properties().childs().inputs.childs().symbol.value()
				}
				setSymbol(e) {
					this.setSymbolParams({
						symbol: e
					})
				}
				symbolInfo() {
					if (!this._resolvedSymbols) return null;
					const e = this.properties().childs().inputs.childs().symbol.value();
					if (!e) return null;
					let t;
					return t = this._model.isSnapshot() ? this._resolvedSymbols.___snapshot || null : this._resolvedSymbols[this._getSymbolForResolve(e)] || null, this._model.isSnapshot() && null === t && (t = (0, r.getObsoleteIdeaSymbolInfo)(this._resolvedSymbols, e, this.currency()), null !== t && (this._resolvedSymbols.___snapshot = t)), t
				}
				symbolResolved() {
					return this.symbolsResolved()
				}
				symbolResolvingActive() {
					return this._symbolResolvingActive
				}
				symbolHibernated() {
					return this._symbolHibernated
				}
				isVisible() {
					const e = super.isVisible();
					return this._symbolHibernated.setValue(!e), e
				}
				symbolSameAsCurrent(e) {
					return (0, V.symbolSameAsCurrent)(e, this.symbol(), this.symbolInfo())
				}
				currency() {
					return this.properties().childs().currencyId.value() || null
				}
				setCurrency(e) {
					this.setSymbolParams({
						currency: e
					})
				}
				isConvertedToOtherCurrency() {
					return (0, n.isConvertedToOtherCurrency)(this.symbolInfo())
				}
				unit() {
					return this.properties().childs().unitId.value() || null
				}
				setUnit(e) {
					this.setSymbolParams({
						unit: e
					})
				}
				isConvertedToOtherUnit() {
					return (0, n.isConvertedToOtherUnit)(this.symbolInfo(), this._model.unitConversionEnabled())
				}
				style() {
					return 2
				}
				setStyle(e) {}
				interval() {
					return this._model.mainSeries().interval()
				}
				setInterval(e) {}
				symbolSource() {
					return this
				}
				state(e, t) {
					const i = super.state(e, t);
					return this._model.unitConversionEnabled() || delete i.state.unitId, e && ((0, s.ensureDefined)(i.data).symbols = {
						___snapshot: this.symbolInfo() || void 0
					}), i
				}
				symbolTitle(e, t) {
					return this.title(!0, {}, !1, e)
				}
				titleInParts(e, t, i, s) {
					const r = this._titleInParts(e, t, i, s).join(", ");
					return [N ? r.toUpperCase() : r]
				}
				tags() {
					const e = this.symbol();
					return e ? [e] : []
				}
				statusView() {
					return B ? super.statusView() : null
				}
				guiPlotName(e) {
					return this.properties().childs().inputs.childs().symbol.value()
				}
				canOverrideMinTick() {
					return !0
				}
				canBeHiddenByGlobalFlag() {
					return !1
				}
				valuesProvider() {
					return new x(this, this.model())
				}
				statusProvider(e) {
					return new R(this, this._model.properties().childs().scalesProperties.childs().textColor)
				}
				measureUnitId() {
					return (0, n.measureUnitId)(this.symbolInfo())
				}
				_createViews() {
					this._legendView || (this._legendView = new T(this, this._model)), this._dataWindowView || (this._dataWindowView = new I(this, this._model)), this._statusView || (this._statusView = new D.StudyStatusView(this)), super._createViews()
				}
				_showLastValueOnPriceScale() {
					return this._model.properties().childs().scalesProperties.childs().showSeriesLastValue.value()
				}
				_onUnitChanged() {
					"alwaysOff" !== (0, o.currencyUnitVisibilityProperty)().value() && this._model.fullUpdate(), this._model.unitConversionEnabled() && this.isStarted() && this._tryChangeInputs(), this._unitChanged.fire()
				}
				_getSymbolObject(e) {
					const t = super._getSymbolObject(e),
						i = this.currency();
					null !== i && (t["currency-id"] = i);
					const s = this.unit();
					return this._model.unitConversionEnabled() && null !== s && (t["unit-id"] = s), t
				}
				_getSymbolForApi(e) {
					return (0, n.symbolForApi)(this._resolvedSymbolsByInput[e] || null, e)
				}
				_onSymbolResolvingStart() {
					super._onSymbolResolvingStart(), this._symbolResolvingActive.setValue(!0)
				}
				_onSymbolError() {
					super._onSymbolError(), this._symbolResolvingActive.setValue(!1)
				}
				_onSymbolResolved(e, t, i) {
					super._onSymbolResolved(e, t, i), this._recreatePriceFormattingDependencies();
					const s = t === this.symbol() ? (0, n.extractSymbolNameFromSymbolInfo)(i, this.symbol()) : null,
						r = (0, n.symbolCurrency)(i),
						o = (0, n.symbolUnit)(i, this._model.unitConversionEnabled());
					this._setSymbolCurrencyUnitInternal({
						symbol: null != s ? s : void 0,
						currency: r,
						unit: o
					}, i), this._symbolResolvingActive.setValue(!1)
				}
				_changeInputsImpl(e, t) {
					super._changeInputsImpl(e, t), this._realignLineToolsIfParamsChanged()
				}
				_createStudyOnServer() {
					super._createStudyOnServer(), this._realignLineToolsIfParamsChanged()
				}
				_tryCreateFormatter() {
					const e = this.symbolInfo();
					return (0, n.createSeriesFormatter)(e, this.properties().childs().minTick.value())
				}
				_titleInParts(e, t, i, s) {
					const r = this.symbolInfo();
					let o;
					if (r) {
						const e = (0, n.getStudySymbolExchange)(r);
						if (E && e) o = e;
						else if (o = r.name, M) switch (this._model.mainSeries().symbolTextSourceProxyProperty().value()) {
							case "description":
								o = r.description;
								break;
							case "ticker-and-description":
								o = `${r.name}, ${r.description}`
						} else if (e && !s) return [o, [e]]
					} else o = F ? "" : this.properties().childs().inputs.childs().symbol.value();
					return [o]
				}
				_setSymbolCurrencyUnitInternal(e, t) {
					const {
						symbol: i,
						currency: s,
						unit: r
					} = e, o = this.properties().childs(), a = o.inputs.childs().symbol.value(), l = o.currencyId.value(), h = o.unitId.value();
					if (void 0 !== i && i !== a && o.inputs.childs().symbol.setValueSilently(i), void 0 !== s && s !== l && o.currencyId.setValueSilently(s), void 0 !== r && r !== h && o.unitId.setValueSilently(r), t) this._resolvedSymbolsByInput[this.symbol()] = t, this._resolvedSymbols[this._getSymbolForResolve(this.symbol())] = t, this._realignToolsLastParams = null;
					else {
						const e = this.symbolInfo();
						null !== e && (o.currencyId.setValueSilently((0, n.symbolCurrency)(e)), o.unitId.setValueSilently((0, n.symbolUnit)(e, this._model.unitConversionEnabled())))
					}
					o.inputs.childs().symbol.value() !== a && o.inputs.childs().symbol.listeners().fire(o.inputs.childs().symbol), o.currencyId.value() !== l && o.currencyId.listeners().fire(o.currencyId), o.unitId.value() !== h && o.unitId.listeners().fire(o.unitId), this._realignLineToolsIfParamsChanged()
				}
				_realignLineToolsIfParamsChanged() {
					const e = this.symbol(),
						t = this.interval(),
						i = this.currency(),
						s = this.unit();
					null !== this._realignToolsLastParams && this._realignToolsLastParams.symbol === e && this._realignToolsLastParams.interval === t && this._realignToolsLastParams.currency === i && this._realignToolsLastParams.unit === s || (this._model.realignLineTools(this), this._realignToolsLastParams = {
						symbol: e,
						interval: t,
						currency: i,
						unit: s
					})
				}
			}
		},
		86161: (e, t, i) => {
			"use strict";
			i.d(t, {
				StudyOverlayBase: () => oe
			});
			var s = i(588537),
				r = i(741139),
				o = i(638456),
				a = i(911905),
				n = i(448874),
				l = i(895405),
				h = i(38627),
				u = i(103653),
				d = i(749473),
				c = i(232567),
				_ = i.n(c),
				p = i(15693),
				m = i(611688),
				y = i(556074),
				g = i(706342),
				v = (i(180372), i(364019)),
				S = i(752280),
				b = i(270617),
				f = i(559270),
				w = i(262325),
				x = i.n(w),
				C = (i(194459), i(234840)),
				I = i(156776),
				P = i(498424),
				T = i(926281),
				D = i(943615);
			const L = m.enabled("force_exchange_as_title");
			class R extends P.PriceAxisView {
				constructor(e) {
					super(), this._source = e
				}
				_updateRendererData(e, t, i) {
					e.visible = !1, t.visible = !1;
					const s = this._source.lastValueData("close", !1);
					if (s.noData) return;
					const r = this._source.model(),
						o = this._source.priceScale();
					if (null === o) return;
					if (!r.isPriceScaleVisible(o)) return;
					i.background = s.color, i.textColor = this.generateTextColor(s.color), i.coordinate = s.coordinate, i.floatCoordinate = s.floatCoordinate;
					const a = this._source.model().properties().childs().scalesProperties.childs();
					a.showSeriesLastValue.value() && (e.text = (0, D.getCurrentModePriceText)(o, s), a.seriesLastValueMode.value() !== T.PriceAxisLastValueMode.LastPriceAndPercentageValue ? e.secondLine = "" : e.secondLine = (0, D.getOppositeModePriceText)(o, s), e.visible = !0), t.text = "", a.showSymbolLabels.value() && (t.text = this._paneText(), t.visible = t.text.length > 0)
				}
				_paneText() {
					let e = "";
					const t = this._source.symbolInfo();
					return L ? e = (0, d.displayedSymbolExchange)(t) : this._source.model().properties().childs().scalesProperties.childs().showSymbolLabels.value() && (e = (0, d.displayedSymbolName)(t)), e
				}
			}
			var V = i(267850);
			class k extends V.PriceLineAxisView {
				constructor(e) {
					super(), this._study = e
				}
				_value() {
					return this._study.lastValueData("", !0)
				}
				_priceLineColor(e) {
					return e
				}
				_lineWidth() {
					return 1
				}
				_isVisible() {
					const e = this._study.model().properties().childs().scalesProperties.childs().showSeriesLastValue.value();
					return this._study.properties().childs().showPriceLine.value() && e
				}
			}
			var A = i(345185),
				M = i(37689);
			class E {
				constructor(e) {
					this._lineRenderer = new M.HorizontalLineRenderer, this._visible = !1, this._source = e
				}
				update() {
					if (this._visible = !1, !this._source.properties().childs().showPriceLine.value()) return;
					const e = this._source.lastValueData("", !0);
					e.noData || (this._visible = !0, this._lineRenderer.setData({
						y: e.coordinate,
						color: e.color,
						linewidth: 1,
						linestyle: A.LINESTYLE_DOTTED,
						visible: this._visible
					}))
				}
				renderer() {
					return this._visible ? this._lineRenderer : null
				}
			}
			var N = i(637030),
				B = i(575932),
				F = i(405075),
				O = i(214729),
				H = i(736643);
			class W extends N.OverlayDataWindowView {
				constructor(e, t) {
					super(e, t), this._additional = null, this._studyOverlay = e, this._backgroundColorSpawn = t.backgroundTopColor().spawn(), this._backgroundColorSpawn.subscribe(this.update.bind(this));
					const i = t.properties().childs().paneProperties.childs().legendProperties.childs();
					this._visibilityProperty = (0,
						O.combineProperty)(((e, t) => e || t), i.showBarChange, i.showSeriesOHLC), this._visibilityProperty.subscribe(this, this.update)
				}
				areValuesVisible() {
					return this._visibilityProperty.value()
				}
				additional() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._additional
				}
				destroy() {
					this._backgroundColorSpawn.destroy(), this._visibilityProperty.destroy()
				}
				_updateImpl() {
					super._updateImpl(); {
						const e = (0, H.getDataVendorString)(this._studyOverlay.symbolInfo());
						this._additional = e ? (0, B.t)("Data Provided by") + " " + e : null
					}
				}
				_createValuesProvider(e, t) {
					return new F.OverlayLegendValuesProvider(e, t)
				}
			}
			var z = i(613648),
				U = i(837778),
				G = i(38080),
				q = i(142426),
				Y = i(328057),
				$ = i(870914),
				Q = i(487765),
				j = i(514628),
				X = i(30347),
				Z = i(289627);
			const J = o.CheckMobile.any() && !0,
				K = m.enabled("uppercase_instrument_names"),
				ee = m.enabled("study_overlay_compare_legend_option"),
				te = (m.enabled("secondary_series_extend_time_scale"), m.enabled("hide_unresolved_symbols_in_legend")),
				ie = !m.enabled("hide_study_overlay_legend_item"),
				se = (0, a.getLogger)("Chart.StudyOverlay");

			function re(e, t) {
				return null == e[t]
			}
			class oe extends n.Study {
				constructor(e, t, i, s) {
					super(e, function(e) {
						return e.hasChild("currencyId") || e.addChild("currencyId", new(_())(null)), e.hasChild("unitId") || e.addChild("unitId", new(_())(null)), e.addExclusion("currencyId"), e.addExclusion("unitId"), e
					}(t), i, s), this._quotesProvider = new y.QuotesProvider, this._seriesSource = null, this._symbolResolvingActive = new(x())(!1), this._symbolHibernated = new(x())(!1), this._styleToRecover = null, this._realignToolsLastParams = null, this._precomputedBarStyles = new WeakMap, this.m_data = new S.PlotList((0, u.seriesPlotFunctionMap)(), re), J && this._quotesProvider.quotesUpdate().subscribe(this, this._onQuotesUpdate);
					const r = this.properties().childs();
					r.currencyId.subscribe(this, this._onCurrencyChanged), r.unitId.subscribe(this, this._onUnitChanged), r.allowExtendTimeScale.subscribe(this, this._onAllowExtendTimeScaleChanged), this._onAllowExtendTimeScaleChanged(), this._model.mainSeries().properties().childs().dividendsAdjustment.subscribe(this, (() => {
						this._tryChangeInputs()
					})), r.style.subscribe(this, this._onChartStyleChanged), r.lineStyle.childs().priceSource.subscribe(this, this._updateBarFunction), r.areaStyle.childs().priceSource.subscribe(this, this._updateBarFunction), r.baselineStyle.childs().priceSource.subscribe(this, this._updateBarFunction), r.columnStyle.childs().priceSource.subscribe(this, this._updateBarFunction), this._updateBarFunction(), this._formatter = null, e.mainSeries().onIntervalChanged().subscribe(this, (() => e.realignLineTools(this)))
				}
				destroy() {
					this._model.mainSeries().properties().childs().dividendsAdjustment.unsubscribeAll(this), this._model.mainSeries().onIntervalChanged().unsubscribeAll(this), super.destroy()
				}
				precomputedBarStyle(e) {
					return this._precomputedBarStyles.get(e)
				}
				setPrecomputedBarStyle(e, t) {
					this._precomputedBarStyles.set(e, t)
				}
				properties() {
					return this._properties
				}
				barColorer() {
					return new Z.SeriesBarColorer(this)
				}
				setSymbolParams(e) {
					this._setSymbolParamsInternal(e)
				}
				symbol() {
					return this.properties().childs().inputs.childs().symbol.value()
				}
				setSymbol(e) {
					this.setSymbolParams({
						symbol: e
					})
				}
				symbolInfo() {
					if (!this._resolvedSymbols) return null;
					const e = this._properties.childs().inputs.childs().symbol.value();
					if (!e) return null;
					let t;
					return t = this._model.isSnapshot() ? this._resolvedSymbols.___snapshot || null : this._resolvedSymbols[this._getSymbolForResolve(e)] || null, this._model.isSnapshot() && null === t && (t = (0, r.getObsoleteIdeaSymbolInfo)(this._resolvedSymbols, e, this.currency()), null !== t && (this._resolvedSymbols.___snapshot = t)), t
				}
				supportsPressedChunks() {
					return !1
				}
				pressedChunks(e, t) {
					throw new Error("Pressed chunks are not supported")
				}
				data() {
					return null === this._seriesSource ? super.data() : this._seriesSource.data().bars()
				}
				symbolResolved() {
					return this.symbolsResolved()
				}
				symbolResolvingActive() {
					return this._symbolResolvingActive
				}
				symbolHibernated() {
					return this._symbolHibernated
				}
				isVisible() {
					const e = super.isVisible();
					return this._symbolHibernated.setValue(!e), e
				}
				symbolSameAsCurrent(e) {
					return (0, g.symbolSameAsCurrent)(e, this.symbol(), this.symbolInfo())
				}
				priceSource() {
					const e = this.properties().childs();
					switch (e.style.value()) {
						case 2:
							return e.lineStyle.childs().priceSource.value();
						case 3:
							return e.areaStyle.childs().priceSource.value();
						case 10:
							return e.baselineStyle.childs().priceSource.value();
						case 13:
							return e.columnStyle.childs().priceSource.value()
					}
					return null
				}
				barFunction() {
					return this._barFunction
				}
				quotes() {
					return this._quotesProvider.quotes()
				}
				currency() {
					return this.properties().childs().currencyId.value() || null
				}
				setCurrency(e) {
					this.setSymbolParams({
						currency: e
					})
				}
				isConvertedToOtherCurrency() {
					return (0, d.isConvertedToOtherCurrency)(this.symbolInfo())
				}
				unit() {
					return this.properties().childs().unitId.value() || null
				}
				setUnit(e) {
					this.setSymbolParams({
						unit: e
					})
				}
				isConvertedToOtherUnit() {
					return (0, d.isConvertedToOtherUnit)(this.symbolInfo(), this._model.unitConversionEnabled())
				}
				style() {
					return this.properties().childs().style.value()
				}
				setStyle(e) {
					this.setSymbolParams({
						style: e
					})
				}
				interval() {
					return this._model.mainSeries().interval()
				}
				setInterval(e) {}
				symbolSource() {
					return this
				}
				state(e, t) {
					const i = super.state(e, t);
					return this._model.unitConversionEnabled() || delete i.state.unitId, e && ((0, s.ensureDefined)(i.data).symbols = {
						___snapshot: this.symbolInfo() || void 0
					}), i
				}
				symbolTitle(e, t) {
					return this.title(!0, {}, !1, e)
				}
				title(e, t, i, s) {
					const r = this._titleInParts(e, t, i, s).join(", ");
					return K ? r.toUpperCase() : r
				}
				titleInParts(e, t, i, s) {
					const r = this._titleInParts(e, t, i, s).join(", ");
					return [K ? r.toUpperCase() : r]
				}
				isStarted() {
					return null === this._seriesSource ? super.isStarted() : this._seriesSource.isStarted()
				}
				sourceId() {
					return null === this._seriesSource ? super.sourceId() : (0, s.ensureNotNull)(this._seriesSource.instanceId())
				}
				moveData(e) {
					null === this._seriesSource ? super.moveData(e) : this._seriesSource.moveData(e)
				}
				firstValue() {
					const e = this._model.timeScale().visibleBarsStrictRange();
					if (null === e) return null;
					const t = e.firstBar();
					if (0 === this.data().size()) return this._ownFirstValue;
					const i = this.data().search(t, S.PlotRowSearchMode.NearestRight, 1);
					return this._ownFirstValue = null !== i ? this._barFunction(i.value, 0) : null, this._ownFirstValue
				}
				lastValueData(e, t, i) {
					const s = {
							noData: !0
						},
						r = this.priceScale();
					if (this._model.timeScale().isEmpty() || null === r || r.isEmpty() || this.data().isEmpty()) return s;
					const o = this._model.timeScale().visibleBarsStrictRange();
					if (null === o) return s;
					const a = this.properties().childs();
					if (!a.visible.value()) return s;
					const n = this.nearestIndex(o.lastBar(), S.PlotRowSearchMode.NearestLeft, 1);
					if (void 0 === n) return s;
					const l = this.firstValue();
					if (null === l) return s;
					const h = this._lastNonEmptyPlotRow(4),
						u = null !== h && o.contains(h.index),
						d = null !== h ? h.value : null,
						c = t || u ? d : this.data().valueAt(n);
					if (null === c) return s;
					const _ = this._barFunction(c);
					if (!(0, b.isNumber)(_)) return s;
					const p = r.priceToCoordinate(_, l);
					let m;
					switch (a.style.value()) {
						case 0:
							m = c[1] <= c[4] ? a.barStyle.childs().upColor.value() : a.barStyle.childs().downColor.value();
							break;
						case 1:
						case 9:
							m = c[1] <= c[4] ? a.candleStyle.childs().upColor.value() : a.candleStyle.childs().downColor.value();
							break;
						case 13:
							m = c[1] <= c[4] ? a.columnStyle.childs().upColor.value() : a.columnStyle.childs().downColor.value();
							break;
						case 2:
							m = a.lineStyle.childs().color.value();
							break;
						case 3:
							m = a.areaStyle.childs().color1.value();
							break;
						case 10: {
							const e = a.baselineStyle.childs();
							m = p < Math.round(r.height() * (Math.abs(100 - e.baseLevelPercentage.value()) / 100)) ? e.topLineColor.value() : e.bottomLineColor.value();
							break
						}
						case 12:
							m = a.hiloStyle.childs().color.value();
							break;
						default:
							throw new Error("Not supported overlay style")
					}
					const y = {
						...r.getFormattedValues(_, l, !0),
						noData: !1,
						floatCoordinate: p,
						coordinate: p,
						color: m
					};
					return i && (y.price = _), y
				}
				priceRange(e, t) {
					if (!(0, b.isInteger)(e)) return se.logDebug("priceRange: incorrect startBar"), null;
					if (!(0, b.isInteger)(t)) return se.logDebug("priceRange: incorrect endBar"), null;
					if (0 === this.data().size()) return null;
					const i = this.priceSource();
					let s;
					s = null !== i ? this.data().minMaxOnRangeCached(e, t, [{
						name: i,
						offset: 0
					}]) : this.data().minMaxOnRangeCached(e, t, [{
						name: "low",
						offset: 0
					}, {
						name: "high",
						offset: 0
					}]);
					const r = null !== s ? new f.PriceRange(s.min, s.max) : null;
					return this._postProcessPriceRange(r)
				}
				bars() {
					return this.data()
				}
				open(e) {
					return (0, s.ensureNotNull)(this.bars().valueAt(e))[1]
				}
				high(e) {
					return (0, s.ensureNotNull)(this.bars().valueAt(e))[2]
				}
				low(e) {
					return (0, s.ensureNotNull)(this.bars().valueAt(e))[3]
				}
				close(e) {
					return (0, s.ensureNotNull)(this.bars().valueAt(e))[4]
				}
				hl2(e) {
					return (this.high(e) + this.low(e)) / 2
				}
				hlc3(e) {
					return (this.high(e) + this.low(e) + this.close(e)) / 3
				}
				ohlc4(e) {
					return (this.open(e) + this.high(e) + this.low(e) + this.close(e)) / 4
				}
				canBeHiddenByGlobalFlag() {
					return !1
				}
				start(e, t) {
					var i;
					this._formatter = null, super.start(e, t), null === (i = this.priceScale()) || void 0 === i || i.updateFormatter(), J && this._setQuotesSymbol(this.symbol())
				}
				stop(e) {
					super.stop(e), this._quotesProvider.setQuotesSessionSymbol(null)
				}
				formatter() {
					return this._formatter || this._recreateFormatter(), (0, s.ensureNotNull)(this._formatter)
				}
				statusView() {
					return ie ? super.statusView() : null
				}
				moveItem(e, t, i) {
					if (10 === this.style() && 0 === t) {
						const t = (0, s.ensureNotNull)(this.priceScale()),
							i = this.properties().childs().baselineStyle,
							r = t.height(),
							o = 100 - e.y / r * 100,
							a = o < 0 ? 0 : Math.round(10 * o) / 10;
						i.childs().baseLevelPercentage.setValue(Math.max(Math.min(a, 100), 0))
					}
				}
				measureUnitId() {
					return (0, d.measureUnitId)(this.symbolInfo())
				}
				_onPropertiesChanged() {
					super._onPropertiesChanged(), this._precomputedBarStyles = new WeakMap
				}
				_tryChangeInputs() {
					var e;
					super._tryChangeInputs(), this._formatter = null, null === (e = this.priceScale()) || void 0 === e || e.updateFormatter()
				}
				_tryCreateFormatter() {
					return (0, d.createSeriesFormatter)(this.symbolInfo(), this.properties().childs().minTick.value())
				}
				_onUnitChanged() {
					"alwaysOff" !== (0, h.currencyUnitVisibilityProperty)().value() && this._model.fullUpdate(), this._model.unitConversionEnabled() && this.isStarted() && this._tryChangeInputs(), this._unitChanged.fire()
				}
				_getSymbolObject(e) {
					const t = super._getSymbolObject(e),
						i = this.currency();
					null !== i && (t["currency-id"] = i);
					const s = this.unit();
					return this._model.unitConversionEnabled() && null !== s && (t["unit-id"] = s), t.adjustment = this._model.mainSeries().properties().childs().dividendsAdjustment.value() ? "dividends" : "splits", t
				}
				_getSymbolForApi(e) {
					return (0, d.symbolForApi)(this._resolvedSymbolsByInput[e] || null, e)
				}
				_onSymbolResolvingStart() {
					super._onSymbolResolvingStart(), this._symbolResolvingActive.setValue(!0)
				}
				_onSymbolError() {
					super._onSymbolError(), this._symbolResolvingActive.setValue(!1)
				}
				_onSymbolResolved(e, t, i) {
					super._onSymbolResolved(e, t, i), this._recreatePriceFormattingDependencies();
					const s = t === this.symbol() ? (0, d.extractSymbolNameFromSymbolInfo)(i, this.symbol()) : null,
						r = (0, d.symbolCurrency)(i),
						o = (0, d.symbolUnit)(i, this._model.unitConversionEnabled());
					if (this._setSymbolParamsInternal({
							symbol: null != s ? s : void 0,
							currency: r,
							unit: o
						}, i), J) {
						const e = this.getSymbolString(this._getSymbolForApi(this.symbol()));
						this._setQuotesSymbol(e)
					}
					this._checkStyle(), this._symbolResolvingActive.setValue(!1)
				}
				_changeInputsImpl(e, t) {
					super._changeInputsImpl(e, t), this._realignLineToolsIfParamsChanged()
				}
				_setQuotesSymbol(e) {
					const t = this.symbolInfo(),
						i = (0, d.extractSymbolNameFromSymbolInfo)(t, e),
						s = i && this.getSymbolString(i);
					this._quotesProvider.setQuotesSessionSymbol(s)
				}
				_createViews() {
					this._priceAxisViews = [];
					const e = new R(this);
					this._priceAxisViewsBase = [e];
					const t = new k(this);
					this._priceLinesAxisViews = [t], this._paneViews = [], this._labelPaneViews = [];
					let i = null,
						r = null;
					switch (this.properties().childs().style.value()) {
						case 0:
							r = new U.SeriesBarsPaneView(this, this._model);
							break;
						case 1:
							r = new G.SeriesCandlesPaneView(this, this._model);
							break;
						case 9:
							r = new Q.SeriesHollowCandlesPaneView(this, this._model);
							break;
						case 13:
							r = new j.SeriesColumnsPaneView(this, this._model);
							break;
						case 2:
							r = new q.SeriesLinePaneView(this, this._model);
							break;
						case 3:
							r = new Y.SeriesAreaPaneView(this, this._model);
							break;
						case 10: {
							r = new $.SeriesBaselinePaneView(this, this._model);
							const e = this.properties().childs().baselineStyle.childs();
							i = new I.SeriesWaterlinePaneView({
								paneHeight: () => (0, s.ensureNotNull)(this.priceScale()).height(),
								color: () => e.baselineColor.value(),
								baseLevelPercentage: () => e.baseLevelPercentage.value()
							});
							break
						}
						case 12:
							r = new X.SeriesHiLoPaneView(this, this._model)
					}
					r && this._paneViews.push(r), null !== i && this._paneViews.push(i),
						this._paneViews.push(new E(this)), this._dataWindowView || (this._dataWindowView = new N.OverlayDataWindowView(this, this._model)), this._legendView || (this._legendView = new W(this, this._model)), this._statusView || (this._statusView = new C.StudyStatusView(this)), this._priceAxisViews = [...this._priceAxisViewsBase], this._labelPaneViews.push(new z.PanePriceAxisView(e, this, this._model))
				}
				_createStudyOnServer() {
					null === this._seriesSource ? super._createStudyOnServer() : this._modifyStudyOnServer((0, s.ensureDefined)(this._inputs)), this._realignLineToolsIfParamsChanged()
				}
				_modifyStudyOnServer(e) {
					null === this._seriesSource ? super._modifyStudyOnServer(e) : (this._seriesSource.modifySeries((0, p.decodeExtendedSymbol)(e.symbol), (0, v.getServerInterval)(this._series.properties().childs().interval.value())), this._seriesSource.isStarted() || this._seriesSource.start())
				}
				_stopStudyOnServer() {
					null === this._seriesSource ? super._stopStudyOnServer() : this._seriesSource.stop()
				}
				_titleInParts(e, t, i, s) {
					const r = this.symbolInfo();
					let o;
					if (r) {
						if (o = r.name, ee) switch (this._model.mainSeries().symbolTextSourceProxyProperty().value()) {
							case "description":
								o = r.description;
								break;
							case "ticker-and-description":
								o = `${r.name}, ${r.description}`
						}
						const e = !s && (0, d.getStudySymbolExchange)(r);
						if (e) return [o, [e]]
					} else o = te ? "" : this.properties().childs().inputs.childs().symbol.value();
					return [o]
				}
				_onAllowExtendTimeScaleChanged() {
					const e = this.isStarted();
					if (e && this.stop(!0), null !== this._seriesSource) {
						const e = this._seriesSource.dataEvents();
						e.seriesError().unsubscribeAll(this), e.loading().unsubscribeAll(this), e.completed().unsubscribeAll(this), e.dataUpdated().unsubscribeAll(this), this._seriesSource.destroy()
					}
					this._seriesSource = null, e && this.start(!0)
				}
				_convertSeriesErrorToStudy(e) {
					return {
						error: e.error,
						ctx: e.ctx,
						solution_id: e.solution_id
					}
				}
				_setSymbolParamsInternal(e, t) {
					const {
						symbol: i,
						currency: s,
						unit: r,
						style: o
					} = e, a = this.properties().childs(), n = a.inputs.childs().symbol.value(), l = a.currencyId.value(), h = a.unitId.value(), u = a.style.value();
					if (void 0 !== i && i !== n && a.inputs.childs().symbol.setValueSilently(i), void 0 !== s && s !== l && a.currencyId.setValueSilently(s), void 0 !== r && r !== h && a.unitId.setValueSilently(r), void 0 !== o && a.style.setValueSilently(o), t) this._resolvedSymbolsByInput[this.symbol()] = t, this._resolvedSymbols[this._getSymbolForResolve(this.symbol())] = t, this._realignToolsLastParams = null;
					else {
						const e = this.symbolInfo();
						null !== e && (a.currencyId.setValueSilently((0, d.symbolCurrency)(e)), a.unitId.setValueSilently((0, d.symbolUnit)(e, this._model.unitConversionEnabled())))
					}
					a.inputs.childs().symbol.value() !== n && a.inputs.childs().symbol.listeners().fire(a.inputs.childs().symbol), a.currencyId.value() !== l && a.currencyId.listeners().fire(a.currencyId), a.unitId.value() !== h && a.unitId.listeners().fire(a.unitId), a.style.value() !== u && a.style.listeners().fire(a.style), this._checkStyle(), this._realignLineToolsIfParamsChanged()
				}
				_updateBarFunction() {
					this._barFunction = (0, l.barFunctionByStyle)(this.style(), this.priceSource())
				}
				_onChartStyleChanged() {
					var e;
					this._updateBarFunction(),
						(null === (e = this._styleToRecover) || void 0 === e ? void 0 : e.originalStyle) !== this.style() && (this._styleToRecover = null)
				}
				_checkStyle() {
					const e = this.style();
					(0, d.isCloseBasedSymbol)(this.symbolInfo()) ? (0, d.isSingleValueBasedStyle)(e) || (this.setStyle(2), this._styleToRecover = {
						correctedStyle: this.style(),
						originalStyle: e
					}) : null !== this._styleToRecover && (this.setStyle(this._styleToRecover.originalStyle), this._styleToRecover = null)
				}
				_realignLineToolsIfParamsChanged() {
					const e = this.symbol(),
						t = this.interval(),
						i = this.currency(),
						s = this.unit();
					null !== this._realignToolsLastParams && this._realignToolsLastParams.symbol === e && this._realignToolsLastParams.interval === t && this._realignToolsLastParams.currency === i && this._realignToolsLastParams.unit === s || (this._model.realignLineTools(this), this._realignToolsLastParams = {
						symbol: e,
						interval: t,
						currency: i,
						unit: s
					})
				}
			}
		},
		949156: (e, t, i) => {
			"use strict";
			i.d(t, {
				StudyStrategy: () => A
			});
			var s = i(588537),
				r = i(262325),
				o = i.n(r),
				a = i(448874),
				n = i(611688),
				l = i(679520),
				h = i(86441),
				u = i(724377),
				d = i(218718),
				c = i(859081),
				_ = i(824112),
				p = i(466915);

			function m(e, t, i) {
				return i ? Math.sign(e) * (Math.round(Math.abs(e)) + t) : Math.round(e) + t
			}
			class y {
				constructor(e, t) {
					this._data = e, this._textWidths = t
				}
				draw(e, t) {
					const i = t.pixelRatio;
					void 0 !== this._textWidths.rendererParams && (0, c.areEqualPaneRenderParams)(this._textWidths.rendererParams, t) || (this._textWidths.rendererParams = t, this._textWidths.width.clear());
					const s = this._data;
					e.lineJoin = "miter", e.miterLimit = Math.round(2 * i), e.strokeStyle = s.bgColor, e.lineWidth = Math.max(2, (0, p.ceiledEven)(2 * i));
					for (const t of s.items) {
						e.beginPath();
						const r = "lower" === t.pos;
						e.save();
						const o = Math.round(s.orderArrow.vMargin * i);
						e.translate(0, r ? o : -o), this._drawOrderArrow(e, t.orderPoint, s.orderArrow, s.exitLineWidth, r, i), e.restore(), e.save(), this._drawPriceArrow(e, t.pricePoint, s.priceArrow, !r, i), e.restore(), e.closePath(), e.stroke(), e.fillStyle = s.exitLineWidth ? s.exitColor : "buy" === t.type ? s.buyColor : s.sellColor, e.fill()
					}
					const r = s.text;
					r.visible && (0, _.drawScaled)(e, i, (() => {
						e.font = r.fontSize + "px " + r.font, e.textAlign = "center", e.textBaseline = "top", e.fillStyle = s.labelColor, e.strokeStyle = s.bgColor, e.lineWidth = Math.min(2, Math.floor(2 * i));
						for (const t of s.items) {
							const i = "lower" === t.pos;
							e.save();
							const o = i ? 1 : -1,
								a = s.orderArrow;
							e.translate(0, (a.height + a.vMargin + s.exitLineWidth) * o);
							const n = i ? r.vMargin : -r.fontSize - r.vMargin,
								l = o * (r.fontSize + r.lineSpacing);
							if (t.label && (e.translate(0, n), e.strokeText(t.label, Math.ceil(t.orderPoint.x), t.orderPoint.y), e.fillText(t.label, Math.ceil(t.orderPoint.x), t.orderPoint.y), this._textWidths.width.has(t.label) || this._textWidths.width.set(t.label, e.measureText(t.label).width)), t.qty) {
								const i = Boolean(t.label) ? l : n;
								e.translate(0, i), e.strokeText(t.qty, Math.ceil(t.orderPoint.x), t.orderPoint.y), e.fillText(t.qty, Math.ceil(t.orderPoint.x), t.orderPoint.y), this._textWidths.width.has(t.qty) || this._textWidths.width.set(t.qty, e.measureText(t.qty).width)
							}
							e.restore()
						}
					}))
				}
				hitTest(e) {
					const t = this._testOrderArrows(e),
						i = !t && this._data.text && this._testText(e);
					return t || i ? new d.HitTestResult(d.HitTestResult.REGULAR) : null
				}
				_drawOrderArrow(e, t, i, s, r, o) {
					let a, n;
					r ? (e.rotate(Math.PI), a = -t.x, n = -t.y) : (a = t.x, n = t.y), n -= i.height + s;
					const l = Math.max(1, Math.floor(o)),
						h = l % 2 ? .5 : 0,
						u = r ? "floor" : "ceil";
					a = m(a * o, h, r), n = Math.round((Math[u](n) + .5) * o), e.translate(a, n);
					const d = (0, p.ceiledEven)(i.width * o) / 2 + h,
						c = (0, p.ceiledEven)(i.tailWidth * o) / 2 + h,
						_ = Math.round(i.tailHeight * o);
					if (e.moveTo(-c, 0), e.lineTo(c, 0), e.lineTo(c, _), e.lineTo(d, _), e.lineTo(0, Math.round(i.height * o)), s) {
						const t = Math.floor(l / 2);
						e.lineTo(d + t, Math.round(i.height * o)), e.lineTo(d + t, Math.round((i.height + s) * o)), e.lineTo(-d - t, Math.round((i.height + s) * o)), e.lineTo(-d - t, Math.round(i.height * o)), e.lineTo(0, Math.round(i.height * o))
					}
					e.lineTo(-d, _), e.lineTo(-c, _), e.lineTo(-c, 0), e.lineTo(c, 0)
				}
				_drawPriceArrow(e, t, i, s, r) {
					let o, a;
					s ? (e.rotate(Math.PI), o = -t.x, a = -t.y) : (o = t.x, a = t.y);
					const n = Math.max(1, Math.floor(r)),
						l = n % 2 ? .5 : 0;
					o = m(o * r, l, s) - n, a = m(a * r, l, s);
					const h = (0, p.ceiledEven)(2 * i.width * r) / 2,
						u = -(Math.round(i.width * r) + l);
					e.translate(o, a), e.moveTo(0, 0), e.lineTo(u, -h), e.lineTo(u, h), e.lineTo(0, 0), e.lineTo(u, -h)
				}
				_testOrderArrows(e) {
					const t = this._data,
						i = t.orderArrow.width / 2;
					for (const s of t.items) {
						const r = s.orderPoint;
						if (e.x < r.x - i || e.x > r.x + i) continue;
						const o = "lower" === s.pos;
						let a = t.orderArrow.height + t.exitLineWidth;
						o || (a = -a);
						const n = r.y + (o ? t.orderArrow.vMargin : -t.orderArrow.vMargin),
							l = Math.min(n, n + a),
							h = Math.max(n, n + a);
						if (!(e.y < l || e.y > h)) return !0
					}
					return !1
				}
				_testText(e) {
					const t = this._data,
						i = t.text;
					if (!i.visible) return !1;
					for (const s of t.items) {
						const r = s.orderPoint,
							o = "lower" === s.pos;
						let a = t.orderArrow.vMargin + t.orderArrow.height + t.exitLineWidth;
						o || (a = -a);
						const n = r.y + a,
							l = (s.label ? 1 : 0) + (s.qty ? 1 : 0);
						let h = i.vMargin + i.fontSize * l + i.lineSpacing * Math.max(0, l - 1);
						o || (h = -h);
						const u = Math.min(n, n + h),
							d = Math.max(n, n + h);
						if (e.y < u || e.y > d) continue;
						const c = s.label && s.qty ? o && e.y < n + i.fontSize || !o && e.y > n - i.fontSize ? s.label : s.qty : s.label || s.qty,
							_ = this._textWidths.width.get(c);
						if (!(void 0 === _ || e.x < r.x - _ / 2 || e.x > r.x + _ / 2)) return !0
					}
					return !1
				}
			}
			var g = i(588427),
				v = i(752280),
				S = i(717611);
			const b = {
				BuyColor: l.colorsPalette["color-tv-blue-500"],
				SellColor: "#FF1744",
				ExitColor: "#D500F9",
				LabelDarkColor: "#B2B5BE",
				LabelLightColor: l.colorsPalette["color-mirage-1"]
			};

			function f(e) {
				return !1 === e.e ? "exit" : e.b ? "entryBuy" : "entrySell"
			}

			function w(e) {
				return e.b ? "buy" : "sell"
			}

			function x(e, t) {
				return t ? !e.b : e.b
			}

			function C(e, t) {
				return x(e, t) ? "lower" : "upper"
			}

			function I(e, t, i) {
				let s = e[t].get(i);
				return void 0 === s && (s = 0, e[t].set(i, s)), s
			}

			function P(e, t, i, r) {
				const o = (0, s.ensureDefined)(e[t].get(i));
				e[t].set(i, o + r)
			}

			function T(e, t) {
				return t && (e.c || e.id || "Untitled") || ""
			}

			function D(e, t) {
				return t && (e.b ? "+" : "-") + e.q || ""
			}

			function L(e, t, i) {
				return (0, s.ensureNotNull)(e.b ? i.low(t) : i.high(t))
			}

			function R(e, t) {
				return ("exit" === f(e) ? 2 : 0) + t.vMargin + t.height
			}
			class V {
				constructor(e, t, i) {
					this._invalidated = !0, this._textWidths = {
						width: new Map
					}, this._study = e, this._series = t, this._model = i, this._orderArrow = {
						vMargin: 11,
						width: 10,
						height: 15,
						tailWidth: 2,
						tailHeight: 10
					}, this._priceArrow = {
						width: 5
					}, this._text = {
						vMargin: 7,
						font: g.CHART_FONT_FAMILY,
						fontSize: 12,
						lineSpacing: 2,
						visible: !0
					}, this._items = {
						entryBuy: [],
						entrySell: [],
						exit: []
					}, this._study.properties().childs().strategy.childs().orders.subscribe(this, this.update)
				}
				update() {
					this._invalidated = !0
				}
				clearItems() {
					this._items.entryBuy = [], this._items.entrySell = [], this._items.exit = []
				}
				renderer(e, t) {
					const i = this._study.properties().childs();
					if (!i.visible.value() || !i.strategy.childs().orders.childs().visible.value()) return null;
					if (this._invalidated && (this._updateImpl(), this._invalidated = !1), this._items.entryBuy.length || this._items.entrySell.length || this._items.exit.length) {
						const e = new S.CompositeRenderer;
						return this._items.entryBuy.length && e.append(this._strategyOrdersRenderer(this._items.entryBuy, !1)), this._items.entrySell.length && e.append(this._strategyOrdersRenderer(this._items.entrySell, !1)), this._items.exit.length && e.append(this._strategyOrdersRenderer(this._items.exit, !0)), e
					}
					return null
				}
				_strategyOrdersRenderer(e, t) {
					const i = this._model.backgroundColor().value(),
						s = "black" === (0, u.rgbToBlackWhiteString)((0, u.parseRgb)(i), 150);
					return new y({
						items: e,
						buyColor: b.BuyColor,
						sellColor: b.SellColor,
						exitColor: b.ExitColor,
						labelColor: s ? b.LabelDarkColor : b.LabelLightColor,
						bgColor: i,
						orderArrow: this._orderArrow,
						exitLineWidth: t ? 2 : 0,
						priceArrow: this._priceArrow,
						text: this._text
					}, this._textWidths)
				}
				_updateImpl() {
					this.clearItems();
					const e = this._study.ordersData();
					if (!e || !e.length) return;
					const t = this._model.timeScale(),
						i = this._series.priceScale(),
						r = t.visibleBarsStrictRange();
					if (t.isEmpty() || i.isEmpty() || null === r) return;
					const o = this._study.barsIndexes(),
						a = this._series.nearestIndex(r.firstBar(), v.PlotRowSearchMode.NearestRight),
						n = this._series.nearestIndex(r.lastBar(), v.PlotRowSearchMode.NearestLeft);
					if (void 0 === a || void 0 === n) return;
					const [l, u] = function(e, t, i, s) {
						const r = [],
							o = [];
						for (let a = 0; a < e.length; ++a) {
							const n = s[a];
							n < t || n > i || (r.push(e[a]), o.push(n))
						}
						return [r, o]
					}(e, a, n, o), [d, c] = this._labelAndQtyVisibility(l.length), _ = d || c, p = this._textHeight(d, c), m = (0, s.ensureNotNull)(this._series.firstValue()), y = i.isInverted(), g = {
						upper: new Map,
						lower: new Map
					};
					for (let e = 0; e < l.length; e++) {
						const s = l[e],
							r = x(s, y),
							o = u[e],
							a = t.indexToCoordinate(o),
							n = L(s, o, this._series);
						let _ = i.priceToCoordinate(n, m);
						const v = C(s, y),
							S = I(g, v, o);
						_ += r ? S : -S;
						P(g, v, o, R(s, this._orderArrow) + p);
						const b = i.priceToCoordinate(s.p, m),
							V = f(s);
						this._items[V].push({
							orderPoint: new h.Point(a, _),
							pricePoint: new h.Point(a, b),
							label: T(s, d),
							qty: D(s, c),
							pos: v,
							type: w(s)
						})
					}
					this._text.visible = _
				}
				_labelAndQtyVisibility(e) {
					const t = this._model.timeScale();
					if (t.barSpacing() < 10 && this._orderArrow.width * e * 2 > t.width()) return [!1, !1];
					const i = this._study.properties().childs().strategy.childs().orders.childs();
					return [i.showLabels.value(), i.showQty.value()]
				}
				_textHeight(e, t) {
					return e || t ? e && t ? 2 * this._text.fontSize + this._text.vMargin + this._text.lineSpacing : this._text.fontSize + this._text.vMargin : 0
				}
			}
			const k = ["strategy_props"];
			class A extends a.Study {
				constructor(e, t, i, s) {
					super(e, t, i, s), this.watchedData = new(o()), this._barsIndexes = [], this._srcBarsIndexes = [], this._reportDataBuffer = null, this._reportData = null, this._activeState = !1, t.childs().visible.subscribe(this, this._processChangeVisibility), this._processChangeVisibility()
				}
				destroy() {
					this.model().removeStrategySource(this, 0), super.destroy()
				}
				properties() {
					return this._properties
				}
				hasStateForAlert() {
					return (0, n.enabled)("alerts")
				}
				inputsForAlertState() {
					const e = this.inputs();
					return (0, s.ensureNotNull)(this._metaInfo).inputs.forEach((t => {
						const i = e[t.id];
						i && t.internalID && (i.internalID = t.internalID)
					})), e
				}
				onData(e) {
					e.method && "data_update" !== e.method && this.watchedData.setValue({
						method: e.method
					}), super.onData(e)
				}
				reportData() {
					return this._reportData
				}
				ordersData() {
					var e, t;
					return null !== (t = null === (e = this._reportData) || void 0 === e ? void 0 : e.filledOrders) && void 0 !== t ? t : null
				}
				barsIndexes() {
					return this._barsIndexes
				}
				clearData() {
					super.clearData(), this._reportDataBuffer = null, this._reportData = null, this._strategyOrdersPaneView && this._strategyOrdersPaneView.clearItems()
				}
				strategyOrdersPaneView() {
					return this.isSourceHidden() ? null : this._strategyOrdersPaneView
				}
				restoreData(e) {
					super.restoreData(e);
					const t = e;
					this.model().addStrategySource(this, 0), t.reportData && t.barsIndexes && (this._reportData = t.reportData, this._barsIndexes = t.barsIndexes, this.watchedData.setValue({
						method: "data_update",
						nonSeriesData: {
							indexes_replace: !1,
							data: {
								report: this._reportData
							}
						}
					})), t.activeState && (this._activeState = !0)
				}
				activeState() {
					return this._activeState
				}
				updateAllViews(e) {
					super.updateAllViews(e), this._strategyOrdersPaneView && this._strategyOrdersPaneView.update()
				}
				state(e, t) {
					const i = super.state(e, t);
					return e && this._reportData && this._barsIndexes && (i.data || (i.data = {}), i.data.reportData = this._reportData, i.data.barsIndexes = this._barsIndexes, i.data.activeState = this.model().activeStrategySource().value() === this), i
				}
				isHibernationAllowed() {
					return !1
				}
				_onDataUpdated(e, t, i) {
					var r, o;
					let a = t && !t.indexes_replace && t.data && t.data.report;
					a ? (t && !t.indexes_replace && t.isUpdate && this._reportDataBuffer && (a = {
						...this._reportDataBuffer,
						...a
					}), this._reportData = {
						...this._reportDataBuffer,
						...a
					}, this._reportDataBuffer = this._reportData, this.watchedData.setValue({
						method: "data_update",
						nonSeriesData: (0, s.ensureNotNull)(t)
					})) : this.watchedData.setValue({
						method: "data_update",
						nonSeriesData: {
							indexes_replace: !1,
							data: {
								report: this._reportDataBuffer
							}
						}
					});
					const n = !(!t || !t.indexes_replace);
					("nochange" !== i && i.length > 0 || (null !== (o = null === (r = this._reportData) || void 0 === r ? void 0 : r.filledOrders.length) && void 0 !== o ? o : 0) !== this._barsIndexes.length) && (a || n) && this._collateBarsIndexes(Array.isArray(i) ? i : this._srcBarsIndexes), super._onDataUpdated(e, t, i)
				}
				_createViews() {
					super._createViews(), this._strategyOrdersPaneView = new V(this, this._series, this._model)
				}
				_titleInputs(e, t) {
					return this.inputs({
						symbolsForDisplay: !0,
						skipHiddenInputs: !0,
						skipFakeInputs: !1,
						fakeInputsForDisplay: !0,
						asObject: !1,
						skippedGroups: k,
						noExchanges: e,
						skipColorInputs: !0,
						skipTimeInputs: !0
					})
				}
				_getTelemetryObjectName() {
					return "strategy"
				}
				_getTelemetryAdditionalData() {
					return {
						symbol: this.series().actualSymbol(),
						resolution: this.series().interval()
					}
				}
				_collateBarsIndexes(e) {
					var t;
					this._srcBarsIndexes = e;
					const i = null === (t = this._reportData) || void 0 === t ? void 0 : t.filledOrders;
					if (i && i.length) {
						this._barsIndexes.length = 0;
						for (let t = 0; t < i.length; t++) this._barsIndexes[t] = e[i[t].tm]
					}
				}
				_processChangeVisibility() {
					this.properties().childs().visible.value() ? this.model().addStrategySource(this, 0) : this.model().removeStrategySource(this, 0)
				}
			}
		},
		785584: (e, t, i) => {
			"use strict";
			var s = i(588537).ensureNotNull,
				r = i(86441).Point,
				o = i(115653).TextRenderer,
				a = i(659251).NonSeriesStudy,
				n = i(821555).TrendLineRenderer,
				l = i(218718).HitTestResult,
				h = i(717611).CompositeRenderer,
				u = i(721386),
				d = i(963985).LineEnd,
				c = i(588427).CHART_FONT_FAMILY;
			class _ {
				constructor(e, t) {
					this._model = e, this._source = t, this._waves = [], this._highlights = [], this._retracements = [], this._invalidated = !0
				}
				update() {
					this._invalidated = !0
				}
				updateImpl() {
					if (this._waves = [], this._highlights = [], this._retracements = [], this._source.customData() && this._source.properties().visible.value()) {
						var e = this._source.customData().waves,
							t = this._source._indexes,
							i = this._model.timeScale(),
							o = this._source.priceScale(),
							a = this._model.mainSeries(),
							n = a.firstBar();
						if (o && !o.isEmpty() && !i.isEmpty() && n && e) {
							for (var l = i.visibleBarsStrictRange(), h = l.lastBar(), u = l.firstBar(), d = ["m0StartIndex", "startIndex", "endIndex", "m2EndIndex", "m3EndIndex"], c = a.firstValue(), p = 0; p < e.length; p++)
								if (e[p]) {
									for (var m = [], y = 0; y < 5; y++) {
										var g = t[e[p][d[y]]];
										if (!isFinite(g)) break;
										m.push(g)
									}
									if (0 !== m.length && !(m[0] > h || m[m.length - 1] < u)) {
										var v = +e[p].size;
										if (isFinite(v)) {
											var S = "level" + v,
												b = this._source.properties()[S];
											if (b.visible.value()) {
												var f = parseInt(e[p].direction, 10),
													w = [];
												w.dir = f, w.prices = [], w.orig_prices = [];
												for (var x = 0; x < m.length; x++) {
													if (void 0 !== m[x]) {
														var C = {};
														if ((V = m[x]) < (n = s(a.bars().first())).index) continue;
														if (C.x = i.indexToCoordinate(V), null === (R = a.bars().valueAt(V))) {
															w.push(void 0), w.prices.push(void 0), w.orig_prices.push(void 0), f = -f;
															continue
														}
														var I, P = 1 === f ? R[TradingView.HIGH_PLOT] : R[TradingView.LOW_PLOT];
														if (w.orig_prices.push(P), w.prices.push(P), C.y = o.priceToCoordinate(P, c), C.label = _._wave5Labels[v][x], C.align = -1 === f ? "top" : "bottom", C.color = b.color.value(), delete C.backgroundColor, w.id = "wave_" + p, this._source === this._model.hoveredSource())(I = this._model.lastHittestData()) && I.wave && I.wave.id === w.id && (C.color = "#FFFFFF", C.backgroundColor = b.color.value());
														C.fontsize = _._fontSizes[v], C._textCache = {
															widths: []
														}, C.wave = w, w.push(C)
													} else w.push(void 0), w.prices.push(void 0);
													f = -f
												}
												w.inds = m, w.dir = f, w.color = b.color.value(), this._waves.push(w)
											}
										}
									}
								} if (this._source === this._model.hoveredSource())
								if (I = this._model.lastHittestData()) {
									m = I.wave.inds, f = -I.wave.dir;
									var T = I.backgroundColor ? I.backgroundColor : I.color,
										D = I.wave.orig_prices,
										L = null;
									for (x = 0; x < m.length; x++) {
										if (void 0 !== m[x]) {
											var R, V = m[x],
												k = i.indexToCoordinate(V);
											if (null === (R = a.bars().valueAt(V))) {
												f = -f;
												continue
											}
											P = D[x];
											var A = o.priceToCoordinate(P, c),
												M = new r(k, A);
											L && this._highlights.push({
												points: [L, M],
												color: T
											}), L = M
										}
										f = -f
									}
									if (void 0 !== D[1] && void 0 !== D[2]) {
										var E = D[1],
											N = D[2],
											B = D[3],
											F = D[0];
										this._retracements.push({
											y: o.priceToCoordinate(E, c),
											x: 0,
											extendLeft: !0,
											extendRight: !0,
											color: T,
											text: "",
											style: CanvasEx.LINESTYLE_SOLID
										}), this._retracements.push({
											y: o.priceToCoordinate(E, c),
											x: 0,
											extendLeft: !0,
											extendRight: !0,
											color: T,
											text: "",
											style: CanvasEx.LINESTYLE_SOLID
										});
										f = N - E;
										if (void 0 !== D[0]) {
											P = E + (O = (F - E) / f) * f, k = i.indexToCoordinate(m[0]);
											this._retracements.push({
												y: o.priceToCoordinate(P, c),
												x: k,
												extendLeft: !1,
												extendRight: !0,
												color: T,
												text: "" + O.toFixed(3),
												style: CanvasEx.LINESTYLE_DASHED
											})
										}
										if (void 0 !== B) {
											var O;
											P = N - (O = (N - B) / f) * f, k = i.indexToCoordinate(m[3]);
											this._retracements.push({
												y: o.priceToCoordinate(P, c),
												x: k,
												extendLeft: !0,
												extendRight: !1,
												color: T,
												text: "" + O.toFixed(3),
												style: CanvasEx.LINESTYLE_DASHED
											})
										}
									}
								}
						}
					}
				}
				renderer() {
					this._invalidated && (this.updateImpl(), this._invalidated = !1);
					for (var e = new h, t = this.CIRCLE_SIZE, i = {}, s = 0; s < this._waves.length; s++)
						for (var a = this._waves[s], _ = 0; _ < a.length; _++) {
							var p = a[_];
							if (void 0 !== p) {
								var m, y;
								"top" === p.align ? (m = p.y + 4, i["top_" + p.x] ? (m += i["top_" + p.x] * t, i["top_" + p.x] = i["top_" + p.x] + 1) : i["top_" + p.x] = 1, y = m + t) : (m = p.y - t - 4, i["bottom_" + p.x] ? (m -= i["bottom_" + p.x] * t, i["bottom_" + p.x] = i["bottom_" + p.x] + 1) : i["bottom_" + p.x] = 1, y = m + t);
								var g = {};
								g.points = [new r(p.x, (m + y) / 2)], g.text = p.label, g.color = p.color, g.backgroundColor = p.backgroundColor, g.font = "Verdana", g.bold = !0, g.offsetX = 0, g.offsetY = 0, g.vertAlign = "middle", g.horzAlign = "center", g.fontsize = p.fontsize;
								var v = new l(l.REGULAR, p);
								e.append(new o(g, v))
							}
						}
					for (s = 0; s < this._highlights.length; s++) {
						var S = this._highlights[s],
							b = {
								points: S.points,
								width: this._model.timeScale().width(),
								height: this._source.priceScale().height(),
								color: u.generateColor(S.color, 50),
								linewidth: 3,
								linestyle: CanvasEx.LINESTYLE_SOLID,
								extendleft: !1,
								extendright: !1,
								leftend: d.Circle,
								rightend: d.Circle
							};
						(f = new n).setData(b), e.append(f)
					}
					for (s = 0; s < this._retracements.length; s++) {
						var f, w = this._retracements[s];
						b = {
							points: [new r(w.x + 1, w.y), new r(w.x, w.y)],
							width: this._model.timeScale().width(),
							height: this._source.priceScale().height(),
							color: u.generateColor(w.color, 50),
							linewidth: 1,
							linestyle: w.style,
							extendleft: w.extendLeft,
							extendright: w.extendRight,
							leftend: d.Normal,
							rightend: d.Normal
						};
						(f = new n).setData(b), e.append(f);
						var x = {
							points: [new r(w.x, w.y)],
							text: this._retracements[s].text,
							backgroundColor: "#606060",
							color: "#FFFFFF",
							vertAlign: "middle",
							horzAlign: "center",
							font: c,
							offsetX: w.extendRight ? -50 : 50,
							offsetY: 2,
							fontsize: 12
						};
						e.append(new o(x))
					}
					return e
				}
			}
			_.prototype.CIRCLE_SIZE = 16, _._wave5Labels = [
				["i", "ii", "iii", "iv", "v"],
				["(i)", "(ii)", "(iii)", "(iv)", "(v)"],
				["((i))", "((ii))", "((iii))", "((iv))", "((v))"],
				["1", "2", "3", "4", "5"],
				["(1)", "(2)", "(3)", "(4)", "(5)"],
				["((1))", "((2))", "((3))", "((4))", "((5))"],
				["I", "II", "III", "IV", "V"],
				["(I)", "(II)", "(III)", "(IV)", "(V)"],
				["((I))", "((II))", "((III))", "((IV))", "((V))"]
			], _._wave3Labels = [
				["a", "b", "c"],
				["A", "B", "C"]
			], _._fontSizes = [10, 10, 10, 11, 11, 11, 12, 12, 12];
			t.study_ElliottWave = class extends a {
				margins() {
					return [.1, .1]
				}
				isVisible() {
					if (!this.properties().visible.value() || !this.isActualInterval()) return !1;
					for (var e = 0; e <= 8; e++)
						if (this.properties()["level" + e].visible.value()) return !0;
					return !1
				}
				_createViews() {
					super._createViews(), this._setPaneViews([new _(this.model(), this)])
				}
			}
		},
		582294: (e, t, i) => {
			"use strict";
			var s = i(405075).OverlayLegendValuesProvider,
				r = i(109776).OverlayStatusProvider,
				o = i(86161).StudyOverlayBase;
			t.study_Overlay = class extends o {
				constructor(e, t, i, s) {
					super(e, t, i, s), this._paneView = null;
					var r = this;
					this.properties().minTick.listeners().subscribe(null, (function() {
						r._recreatePriceFormattingDependencies(), r.updateAllViews(), r._model.fullUpdate()
					}))
				}
				_showLastValueOnPriceScale() {
					return this._model.properties().scalesProperties.showSeriesLastValue.value()
				}
				_onQuotesUpdate(e, t) {
					!this._legendView || void 0 === t.values.change && void 0 === t.values.change_percent || (this._legendView.update(), this._model.updateSource(this))
				}
				destroy() {
					this._quotesProvider.quotesUpdate().unsubscribeAll(this), this._quotesProvider.destroy(), super.destroy()
				}
				tags() {
					var e = [],
						t = this.symbolInfo();
					return t ? e.push(t.name) : this._properties.inputs.symbol.value() && e.push(this._properties.inputs.symbol.value()), e
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(64320), i.e(39261), i.e(60607)]).then(i.bind(i, 906905))).StudyOverlayDefinitionsViewModel
				}
				defaultPlotIdForAlert() {
					return ""
				}
				valuesProvider() {
					return new s(this, this.model())
				}
				statusProvider(e) {
					return new r(this, this.model())
				}
			}
		},
		230276: (e, t, i) => {
			"use strict";
			var s = i(659251).NonSeriesStudy,
				r = i(218718).HitTestResult,
				o = i(717611).CompositeRenderer,
				a = i(380047).ScaledPaneRenderer,
				n = i(588427);
			class l extends a {
				constructor(e, t) {
					super(), this._data = e, this._textCache = t
				}
				_drawImpl(e) {
					e.textBaseline = "bottom", e.font = (this._data.bold ? "bold " : "normal ") + this._data.fontsize + "px " + this._data.font;
					var t = Math.round(e.measureText(this._data.text).width + 4);
					this._textCache.width = t, e.translate(this._data.x + .5, this._data.y), e.strokeStyle = this._data.borderColor, e.fillStyle = this._data.backColor, e.beginPath(), e.moveTo(0, 0), 1 === this._data.type ? (e.lineTo(5, -5), e.lineTo(t / 2, -5), e.lineTo(t / 2, -5 - this._data.fontsize), e.lineTo(-t / 2, -5 - this._data.fontsize), e.lineTo(-t / 2, -5), e.lineTo(-5, -5), e.lineTo(0, 0)) : (e.lineTo(5, 5), e.lineTo(t / 2, 5), e.lineTo(t / 2, 5 + this._data.fontsize), e.lineTo(-t / 2, 5 + this._data.fontsize), e.lineTo(-t / 2, 5), e.lineTo(-5, 5), e.lineTo(0, 0)), e.fill(), e.stroke(), e.fillStyle = this._data.textColor, e.textAlign = "center", e.textBaseline = "middle", 1 === this._data.type ? e.fillText(this._data.text, 0, -5 - this._data.fontsize / 2) : e.fillText(this._data.text, 0, 5 + this._data.fontsize / 2)
				}
				hitTest(e) {
					var t = this._textCache.width,
						i = this._data.fontsize + 15,
						s = this._data.x - t / 2,
						o = this._data.y;
					return 1 === this._data.type && (o -= i), e.x >= s && e.x <= s + t && e.y >= o && e.y <= o + i ? new r(r.REGULAR) : null
				}
			}
			class h {
				constructor(e, t) {
					this._model = e, this._source = t, this._pivots = [], this._textCache = {}, this._invalidated = !0
				}
				update() {
					this._invalidated = !0
				}
				updateImpl() {
					if (this._pivots = [], this._source.customData() && this._source.customData().pivots && this._source.properties().visible.value()) {
						var e = this._source.customData().pivots,
							t = this._source._indexes,
							i = this._model.timeScale(),
							s = this._source.priceScale(),
							r = this._model.mainSeries(),
							o = r.firstValue();
						if (s && !s.isEmpty() && !i.isEmpty() && o)
							for (var a = i.visibleBarsStrictRange(), n = a.firstBar(), l = a.lastBar(), h = 0; h < e.length; h++)
								if (e[h]) {
									var u = t[e[h].index];
									if (!(u < n || u > l)) {
										var d = e[h].type,
											c = r.bars().valueAt(u);
										if (null !== c) {
											var _ = 1 === d ? c[TradingView.HIGH_PLOT] : c[TradingView.LOW_PLOT],
												p = Math.round(i.indexToCoordinate(u)),
												m = s.priceToCoordinate(_, o);
											1 === d ? m -= i.barSpacing() / 6 : m += i.barSpacing() / 6 + 1, m = Math.round(m), this._pivots.push({
												x: p,
												y: m,
												price: s.formatPrice(_, o),
												type: d
											})
										}
									}
								}
					}
				}
				_pixelMargins() {
					return this._source.properties().fontsize.value() + 15
				}
				topPixelMargin() {
					return this._pixelMargins()
				}
				bottomPixelMargin() {
					return this._pixelMargins()
				}
				renderer() {
					if (this._invalidated && (this.updateImpl(), this._invalidated = !1), 0 !== this._pivots.length) {
						for (var e = n.CHART_FONT_FAMILY, t = this._source.properties().fontsize.value(), i = this._source.properties().borderColor.value(), s = this._source.properties().backColor.value(), r = this._source.properties().textColor.value(), a = new o, h = 0; h < this._pivots.length; h++) {
							var u = this._pivots[h],
								d = {
									x: u.x,
									y: u.y,
									type: u.type,
									text: u.price,
									font: e,
									fontsize: t,
									borderColor: i,
									backColor: s,
									textColor: r
								},
								c = h;
							this._textCache[c] || (this._textCache[c] = {}), a.append(new l(d, this._textCache[c]))
						}
						return a
					}
				}
			}
			t.study_PivotPointsHighLow = class extends s {
				isVisible() {
					return this.properties().visible.value() && this.isActualInterval()
				}
				_createViews() {
					super._createViews(), this._setPaneViews([new h(this.model(), this)])
				}
				autoScaleInfo(e, t) {
					return {
						range: this._series.priceRange(e, t),
						topPixelMargin: this._paneViews.length > 0 ? this._paneViews[0].topPixelMargin() : 0,
						bottomPixelMargin: this._paneViews.length > 0 ? this._paneViews[0].bottomPixelMargin() : 0
					}
				}
			}
		},
		128128: (e, t, i) => {
			"use strict";
			var s = i(588537).assert,
				r = i(270617).clone,
				o = i(448874).Study,
				a = i(752280).PlotList,
				n = i(523083).studyPlotFunctionMap,
				l = i(523083).studyEmptyPlotValuePredicate;
			class h {
				constructor(e, t, i) {
					this._strategyPlotIndex = e, this._targetPlotIndex = t, this._startIndex = i
				}
				rebuildData(e) {
					var t = this._targetPlotIndex + 1,
						i = this._strategyPlotIndex + 1,
						s = null,
						r = null;
					e.range(this._startIndex || e.firstIndex(), e.lastIndex()).each((function(o, a) {
						var n = a[t],
							l = a[i] ? Math.round(a[i]) : null;
						if (a[t] = null, a[i] = null, !l || l > 0) return !1;
						var h = o + l,
							u = {
								pointIndex: h,
								value: n
							};
						if (r) {
							if (r.pointIndex !== u.pointIndex) {
								h >= 0 && (e.valueAt(h)[t] = n);
								var d = !1;
								s && (d = s.value <= r.value && r.value <= n || s.value >= r.value && r.value >= n), d ? r.pointIndex >= 0 && (e.valueAt(r.pointIndex)[t] = null) : s = r, r = u
							}
						} else r = u;
						return !1
					}))
				}
			}
			t.study_ScriptWithDataOffset = class extends o {
				constructor(e, t, i, s) {
					super(e, t, i, s), this._underlyingData = new a(n(s), l)
				}
				clearData() {
					super.clearData(), this._underlyingData.clear()
				}
				_mergeData(e) {
					this._invalidateLastNonEmptyPlotRowCache();
					var t = this._underlyingData.firstIndex();
					this._underlyingData.merge(e), t !== this._underlyingData.firstIndex() && (this.m_data = new a(n(this._metaInfo), l));
					var i = this.m_data.lastIndex();
					this._underlyingData.range(i, this._underlyingData.lastIndex()).each(function(e, t) {
						return this.m_data.add(e, r(t)), !1
					}.bind(this)), this._plotsForStrategyProcessing().forEach((function(e) {
						new h(e.strategyIndex, e.targetIndex, i).rebuildData(this.m_data)
					}), this)
				}
				_plotsForStrategyProcessing() {
					var e = [];
					return this._metaInfo.plots.forEach((function(t, i) {
						if ("dataoffset" === t.type) {
							var r = this._metaInfo.plots.findIndex((function(e) {
								return e.id === t.target
							}));
							s(r >= 0, "target plot not found for strategy plot " + t.id);
							var o = {
								strategyIndex: i,
								targetIndex: r
							};
							e.push(o)
						}
					}), this), e
				}
			}
		},
		819111: (e, t, i) => {
			"use strict";
			var s = i(86441).Point,
				r = i(659251).NonSeriesStudy,
				o = i(821555).TrendLineRenderer,
				a = i(218718).HitTestResult,
				n = i(717611).CompositeRenderer,
				l = i(963985).LineEnd;
			class h {
				constructor(e, t) {
					this._model = e, this._source = t, this._pivots = [], this._textCache = {}, this._invalidated = !0
				}
				update() {
					this._invalidated = !0
				}
				updateImpl() {
					if (this._pivots = [], this._source.customData() && this._source.customData().zigzag && this._source.properties().visible.value()) {
						var e = this._source.customData().zigzag,
							t = this._source._indexes,
							i = this._model.timeScale(),
							s = this._source.priceScale(),
							r = this._model.mainSeries(),
							o = r.firstValue();
						if (s && !s.isEmpty() && !i.isEmpty() && o)
							for (var a = 0; a < e.length; a++)
								if (e[a]) {
									var n = t[e[a].index],
										l = e[a].type,
										h = r.bars().valueAt(n);
									if (null !== h) {
										var u = 1 === l ? h[TradingView.HIGH_PLOT] : h[TradingView.LOW_PLOT],
											d = Math.round(i.indexToCoordinate(n)),
											c = s.priceToCoordinate(u, o);
										this._pivots.push({
											x: d,
											y: c
										})
									}
								}
					}
				}
				renderer() {
					this._invalidated && (this.updateImpl(), this._invalidated = !1);
					for (var e = new n, t = this._source.properties().color.value(), i = this._source.properties().linewidth.value(), r = 1; r < this._pivots.length; r++) {
						var h = this._pivots[r],
							u = this._pivots[r - 1],
							d = {
								points: [new s(u.x, u.y), new s(h.x, h.y)],
								width: this._model.timeScale().width(),
								height: this._source.priceScale().height(),
								color: t,
								linewidth: i,
								linestyle: CanvasEx.LINESTYLE_SOLID,
								extendleft: !1,
								extendright: !1,
								leftend: l.Normal,
								rightend: l.Normal
							},
							c = new o;
						c.setData(d), c.setHitTest(new a(a.REGULAR)), e.append(c)
					}
					return e
				}
			}
			t.study_ZigZag = class extends r {
				isVisible() {
					return this.properties().visible.value() && this.isActualInterval()
				}
				_createViews() {
					super._createViews(), this._setPaneViews([new h(this.model(), this)])
				}
			}
		},
		787272: (e, t, i) => {
			"use strict";

			function s(e) {
				return e.charAt(0).toUpperCase() + e.substring(1)
			}
			i.d(t, {
				capitalizeFirstLetter: () => s
			})
		},
		497763: (e, t, i) => {
			"use strict";
			i.d(t, {
				SERIES_COLORS: () => r,
				getColorByIndex: () => o,
				CircularColorsProvider: () => a
			});
			var s = i(679520);
			const r = [s.colorsPalette["color-tv-blue-a200"], s.colorsPalette["color-tan-orange-500"], s.colorsPalette["color-sky-blue-400"], s.colorsPalette["color-deep-blue-a100"], s.colorsPalette["color-banana-yellow-700"], s.colorsPalette["color-grapes-purple-a200"], s.colorsPalette["color-deep-blue-300"], s.colorsPalette["color-berry-pink-200"], s.colorsPalette["color-sky-blue-600"], s.colorsPalette["color-tan-orange-a700"], s.colorsPalette["color-tv-blue-a100"], s.colorsPalette["color-deep-blue-500"], s.colorsPalette["color-tan-orange-a200"], s.colorsPalette["color-grapes-purple-a700"], s.colorsPalette["color-grapes-purple-400"], s.colorsPalette["color-berry-pink-700"], s.colorsPalette["color-sky-blue-a700"], s.colorsPalette["color-berry-pink-a100"], s.colorsPalette["color-berry-pink-a200"]];

			function o(e) {
				const t = r[e % r.length];
				return t || r[0]
			}
			class a {
				constructor() {
					this._symbolsMap = new Map, this._length = r.length, this._lastIndex = 0
				}
				getColor(e) {
					if (this._symbolsMap.has(e)) return this._symbolsMap.get(e);
					let t;
					return this._lastIndex === this._length - 1 ? (this._lastIndex = 0, t = o(this._lastIndex)) : (t = o(this._lastIndex), this._lastIndex++), this._symbolsMap.set(e, t), t
				}
			}
		},
		530254: (e, t, i) => {
			"use strict";
			i.d(t, {
				format: () => u,
				getMetricPrefix: () => d,
				getFractionalDigitsNumber: () => _
			});
			var s = i(588537),
				r = i(960521),
				o = i(701336),
				a = i(591419),
				n = i(143498);
			const l = new Map;
			let h = null;

			function u(e, t, i, s = 2) {
				if (Math.abs(e) >= 1e100) return "â€”";
				if ("volume" === t) return function(e) {
					h || (h = new a.VolumeFormatter);
					return h.format(e)
				}(e);
				if ("percents" === t) return (0, n.forceLTRStrSsr)(c(e, s) + "%");
				const r = i || d(e);
				return (0, n.forceLTRStrSsr)(function(e, t, i) {
					return `${c(e/t.multiplier,i)}${t.symbol}`
				}(e, r, s))
			}

			function d(e) {
				const t = Math.abs(e);
				return t < 995 ? {
					symbol: "",
					multiplier: 1
				} : t < 999995 ? {
					symbol: "K",
					multiplier: 1e3
				} : t < 999999995 ? {
					symbol: "M",
					multiplier: 1e6
				} : t < 999999999995 ? {
					symbol: "B",
					multiplier: 1e9
				} : {
					symbol: "T",
					multiplier: 1e12
				}
			}

			function c(e, t) {
				let i = "";
				return e < 0 && (i = "âˆ’", e = -e), i + function(e) {
					if (l.has(e)) return (0, s.ensureDefined)(l.get(e));
					const t = new o.NumericFormatter(e);
					return l.set(e, t), t
				}(t).format(e)
			}

			function _(e) {
				const t = (0, r.Big)(e);
				return Math.max(t.c.length - t.e - 1, 0)
			}
		},
		436901: (e, t, i) => {
			"use strict";
			i.d(t, {
				DEFAULT_MAX_DATA_ARRAY_LENGTH: () => s,
				FULL_MAX_DATA_ARRAY_LENGTH: () => r
			});
			const s = 5,
				r = 7
		},
		610203: (e, t, i) => {
			"use strict";
			i.d(t, {
				PeriodId: () => s,
				FINANCIALS_SETS: () => u,
				findFinancialsSet: () => d,
				getDataFromQuotes: () => _,
				getPeriodData: () => p,
				getChartSeriesArray: () => m,
				generateTooltipValues: () => y,
				getPeriodsDataFromQuotes: () => g,
				getFinancialsDataFromQuotes: () => v
			});
			var s, r = i(588537),
				o = i(575932),
				a = i(497763),
				n = i(530254),
				l = i(787272),
				h = i(436901);
			! function(e) {
				e.Year = "FY", e.Quarter = "FQ"
			}(s || (s = {}));
			const u = () => [{
				id: "income statements",
				title: (0, o.t)("Income Statement"),
				chartType: "compare",
				marginTitle: (0, o.t)("Profit Margin"),
				fields: ["total_revenue", "net_income"]
			}, {
				id: "balance sheet",
				title: (0, o.t)("Balance Sheet"),
				chartType: "compare",
				marginTitle: (0, o.t)("Debt to Assets"),
				fields: ["total_assets", "total_liabilities"]
			}, {
				id: "cash flow",
				title: (0, o.t)("Cash Flow"),
				chartType: "lines",
				fields: ["cash_f_operating_activities", "cash_f_investing_activities", "cash_f_financing_activities"]
			}];

			function d(e) {
				return u().find((t => t.id === e)) || u()[0]
			}

			function c(e) {
				return {
					total_revenue: (0, o.t)("Revenue"),
					net_income: (0, o.t)("Net income"),
					total_assets: (0, o.t)("Total Assets"),
					total_liabilities: (0, o.t)("Total Liabilities"),
					cash_f_operating_activities: (0, o.t)("Operating"),
					cash_f_investing_activities: (0, o.t)("Investing"),
					cash_f_financing_activities: (0, o.t)("Financing"),
					fiscal_period: "Fiscal Period"
				} [e]
			}

			function _(e, t, i, s = h.DEFAULT_MAX_DATA_ARRAY_LENGTH) {
				const r = i[t];
				if (!r) return [];
				return r[e].slice(0, s).reverse()
			}

			function p(e, t, i = h.DEFAULT_MAX_DATA_ARRAY_LENGTH) {
				const s = e[t];
				if (s) return s.slice(0, i).reverse()
			}

			function m(e, t, i) {
				switch (e.chartType) {
					case "compare":
						const s = e.fields.map(((e, s) => ({
								type: "bar",
								name: c((0, r.ensureDefined)(e)),
								valueType: "numbers",
								values: (0, r.ensureDefined)(_((0, r.ensureDefined)(e), t, (0, r.ensureDefined)(i))),
								defaultColor: (0, a.getColorByIndex)(s),
								showInLegend: !0,
								buildTooltip: y
							}))),
							o = s[0].values.map(((e, t) => 0 === e ? 0 : s[1].values[t] / e * 100));
						return s.push({
							type: "line",
							name: (0, r.ensureDefined)(e.marginTitle),
							valueType: "percents",
							values: o,
							defaultColor: (0, a.getColorByIndex)(6),
							showInLegend: !0,
							buildTooltip: y
						}), s;
					case "lines":
						return e.fields.map(((e, s) => ({
							type: "line",
							name: c((0, r.ensureDefined)(e)),
							valueType: "numbers",
							values: (0, r.ensureDefined)(_((0, r.ensureDefined)(e), t, (0, r.ensureDefined)(i))),
							defaultColor: (0, a.getColorByIndex)(s),
							showInLegend: !0,
							buildTooltip: y
						})));
					default:
						return []
				}
			}

			function y(e, t, i) {
				const s = e.values[i];
				if (null === s) return null;
				const o = (0, n.format)(s, e.valueType);
				return [{
					title: `${(0,l.capitalizeFirstLetter)(e.name.toLowerCase())} ${o}`,
					color: (0, r.ensureDefined)(e.defaultColor)
				}]
			}

			function g(e) {
				const {
					fiscal_period_fy_h: t,
					fiscal_period_fq_h: i
				} = e;
				if (t || i) return {
					[s.Year]: t,
					[s.Quarter]: i
				}
			}

			function v(e) {
				const {
					total_revenue_fy_h: t,
					total_revenue_fq_h: i,
					net_income_fy_h: r,
					net_income_fq_h: o,
					total_assets_fy_h: a,
					total_assets_fq_h: n,
					total_liabilities_fy_h: l,
					total_liabilities_fq_h: h,
					cash_f_operating_activities_fy_h: u,
					cash_f_operating_activities_fq_h: d,
					cash_f_investing_activities_fy_h: c,
					cash_f_investing_activities_fq_h: _,
					cash_f_financing_activities_fy_h: p,
					cash_f_financing_activities_fq_h: m,
					fiscal_period_fy_h: y,
					fiscal_period_fq_h: v
				} = e, S = g(e);
				if (S) {
					const {
						[s.Year]: e, [s.Quarter]: g
					} = S;
					return {
						[s.Year]: e ? {
							total_revenue: t,
							net_income: r,
							total_assets: a,
							total_liabilities: l,
							cash_f_operating_activities: u,
							cash_f_investing_activities: c,
							cash_f_financing_activities: p,
							fiscal_period: y
						} : void 0,
						[s.Quarter]: g ? {
							total_revenue: i,
							net_income: o,
							total_assets: n,
							total_liabilities: h,
							cash_f_operating_activities: d,
							cash_f_investing_activities: _,
							cash_f_financing_activities: m,
							fiscal_period: v
						} : void 0
					}
				}
			}
		},
		988534: (e, t, i) => {
			"use strict";
			i.d(t, {
				FinancialsDialogController: () => o
			});
			var s = i(410685);
			let r;
			class o extends s.DialogRenderer {
				constructor() {
					super(...arguments), this._dialog = null, this._subscribe = e => {
						this._setVisibility(e)
					}
				}
				show(e) {
					this._load(e).then((e => e.show()))
				}
				hide() {
					var e;
					null === (e = this._dialog) || void 0 === e || e.hide()
				}
				static getInstance() {
					return r || (r = new o), r
				}
				_load(e) {
					return Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(91670), i.e(15107), i.e(77301), i.e(80580), i.e(68074), i.e(52498), i.e(63146), i.e(5799), i.e(28111), i.e(55706), i.e(74733), i.e(82520), i.e(31784), i.e(81532), i.e(29462), i.e(82640), i.e(93586), i.e(5423), i.e(28143), i.e(91879), i.e(61429), i.e(43539), i.e(41143), i.e(75514), i.e(97998), i.e(48791), i.e(34216), i.e(10345), i.e(85687), i.e(24878)]).then(i.bind(i, 234155)).then((t => {
						var i, s;
						return null === (i = this._dialog) || void 0 === i || i.hide(), null === (s = this._dialog) || void 0 === s || s.visible().unsubscribe(this._subscribe), this._dialog = new t.FinancialsDialogRenderer(e), this._dialog.visible().subscribe(this._subscribe), this._dialog
					}))
				}
			}
		},
		876322: (e, t, i) => {
			"use strict";
			i.d(t, {
				showFinancialsDialog: () => r
			});
			var s = i(988534);

			function r(e) {
				s.FinancialsDialogController.getInstance().show(e)
			}
		},
		199687: (e, t, i) => {
			"use strict";
			i.d(t, {
				PageId: () => s,
				PAGES: () => a,
				CATEGORIES: () => n,
				PERIODS: () => l,
				DEFAULT_PERIOD: () => h
			});
			var s, r = i(575932),
				o = i(610203);
			! function(e) {
				e.Overview = "overview", e.Statements = "statements", e.Dividends = "dividends", e.Earnings = "earnings"
			}(s || (s = {}));
			const a = [{
					id: s.Overview,
					title: (0, r.t)("Overview")
				}, {
					id: s.Statements,
					title: (0, r.t)("Statements")
				}, {
					id: s.Dividends,
					title: (0, r.t)("Dividends")
				}, {
					id: s.Earnings,
					title: (0, r.t)("Earnings")
				}],
				n = [{
					id: "income statements",
					title: (0, r.t)("Income statement")
				}, {
					id: "balance sheet",
					title: (0, r.t)("Balance sheet")
				}, {
					id: "cash flow",
					title: (0, r.t)("Cash flow")
				}, {
					id: "statistics",
					title: (0, r.t)("Statistics")
				}],
				l = () => [{
					id: o.PeriodId.Year,
					title: (0, r.t)("Annual")
				}, {
					id: o.PeriodId.Quarter,
					title: (0, r.t)("Quarterly")
				}],
				h = l()[0].id
		},
		788600: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" width="25" height="25"><circle fill="none" stroke="currentColor" stroke-width="1.5" cx="12.5" cy="12.5" r="11.75"/><path fill="currentColor" d="M11.16 18H8.78V7.28c1.52-.06 2.47-.08 2.86-.08a5 5 0 0 1 3.72 1.37 4.9 4.9 0 0 1 1.37 3.64c0 3.86-1.85 5.79-5.57 5.79zm-.48-9.06v7.32c.31.03.64.05 1 .05a2.7 2.7 0 0 0 2.26-1.05c.54-.7.82-1.67.82-2.93 0-2.3-1.07-3.44-3.2-3.44-.21 0-.5.02-.88.05z"/></svg>'
		},
		261820: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><rect width="21.5" height="21.5" fill="none" stroke="currentColor" stroke-width="1.5" rx="1.25" x=".75" y=".75"/><path fill="currentColor" d="M10.23 7.96v2.51h3.55v1.62h-3.55v3.22h4.87V17H8.33V6.27h6.85v1.7h-4.95z"/></svg>'
		},
		777566: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 25" width="24" height="25"><path fill="none" stroke="currentColor" stroke-width="1.5" d="M10.85 23.72c.4.25.9.25 1.3 0l9.5-5.82c.37-.22.6-.63.6-1.06V2c0-.69-.56-1.25-1.25-1.25H2C1.31.75.75 1.31.75 2v14.84c0 .43.23.84.6 1.06l9.5 5.82z"/><path fill="currentColor" d="M10.23 7.96v2.51h3.55v1.62h-3.55v3.22h4.87V17H8.33V6.27h6.85v1.7h-4.95z"/></svg>'
		},
		385442: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 25" width="24" height="25"><path fill="none" stroke="currentColor" stroke-width="1.5" d="M10.87 1.23c.39-.22.87-.22 1.26 0l9.5 5.52c.38.23.62.64.62 1.08V23c0 .69-.56 1.25-1.25 1.25H2c-.69 0-1.25-.56-1.25-1.25V7.83c0-.44.24-.85.62-1.08l9.5-5.52z"/><path fill="currentColor" d="M10.23 9.96v2.51h3.55v1.62h-3.55v3.22h4.87V19H8.33V8.27h6.85v1.7h-4.95z"/></svg>'
		},
		428139: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11 15" width="15" height="15" fill="none"><path stroke="currentColor" stroke-width="1.4" d="m4.29 3.06 1.08-.05a4.8 4.8 0 0 1 3.86 7.64M4.3 3.06l2.06 2.06M4.29 3.06 6.35 1M6.73 12.41l-1.09.06a4.8 4.8 0 0 1-3.86-7.65m4.95 7.6-2.07-2.07m2.07 2.06-2.07 2.06"/></svg>'
		},
		717090: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" width="25" height="25" fill="none"><circle fill="none" stroke="currentColor" stroke-width="1.5" cx="12.5" cy="12.5" r="11.75"/><path stroke="currentColor" stroke-width="1.5" d="m11.27 7.37 1.24-.06a5.53 5.53 0 0 1 4.46 8.8m-5.7-8.74 2.37 2.38m-2.37-2.38L13.64 5M14.08 18.15l-1.25.06a5.53 5.53 0 0 1-4.46-8.8m5.7 8.74-2.37-2.37m2.38 2.37-2.38 2.38"/></svg>'
		},
		274469: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" width="25" height="25"><circle fill="none" stroke="currentColor" stroke-width="1.5" cx="12.5" cy="12.5" r="11.75"/><path fill="currentColor" d="M9.25 17.4l.7-1.7c.75.53 1.5.8 2.22.8 1.12 0 1.68-.4 1.68-1.18 0-.37-.13-.72-.4-1.05-.26-.33-.8-.7-1.63-1.11a8.18 8.18 0 0 1-1.66-1.02 2.82 2.82 0 0 1-.89-2.17c0-.83.3-1.52.9-2.06.62-.55 1.4-.82 2.35-.82 1.24 0 2.15.23 2.73.7l-.57 1.63a3.58 3.58 0 0 0-2.12-.71c-.44 0-.78.11-1.03.35a1.2 1.2 0 0 0-.36.9c0 .61.69 1.25 2.05 1.92.72.35 1.23.67 1.55.97.32.3.56.64.73 1.03.16.4.24.83.24 1.31 0 .87-.34 1.59-1.03 2.15a4.2 4.2 0 0 1-2.75.84c-1 0-1.9-.26-2.71-.77z"/></svg>'
		},
		627086: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M12.57 5.5h-.07a3.5 3.5 0 1 0 .07 7A4.98 4.98 0 0 1 4 9a5 5 0 0 1 8.57-3.5z"/></svg>'
		},
		323373: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M12.22 11.78A3.47 3.47 0 0 0 9 6.98a3.48 3.48 0 0 0-3.22 4.8 6.97 6.97 0 0 1 6.44 0zM4.18 9.83L2.1 9.28l.33-1.24 2.07.55-.33 1.24zM6.38 6.36l-.9-1.94 1.16-.54.9 1.94-1.16.54zM10.46 5.82l.9-1.94 1.16.54-.9 1.94-1.16-.54zM13.49 8.6l2.07-.56.33 1.24-2.07.55-.33-1.24z"/></svg>'
		}
	}
]);