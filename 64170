(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
	[64170], {
		90974: e => {
			e.exports = {
				"css-value-chart-controls-bar-height-with-border": "calc(38px + 1px)",
				"css-value-chart-controls-bar-border": "1px"
			}
		},
		959029: e => {
			e.exports = {
				"tv-transition--fade-in": "tv-transition--fade-in-rOskCXSz",
				"tv-transition--fade-out": "tv-transition--fade-out-rOskCXSz",
				"tv-transition--slide-out": "tv-transition--slide-out-rOskCXSz"
			}
		},
		488473: e => {
			e.exports = {}
		},
		942885: e => {
			e.exports = {
				css_value_currency_label_radius: "4",
				css_wrapper_margin: "1",
				css_row_left_right_margin: "3",
				css_row_left_right_padding: "6",
				css_first_row_top_padding: "4",
				css_fade_height: "10",
				"price-axis-currency-label-wrapper": "price-axis-currency-label-wrapper-SfCx6ur0",
				"price-axis-currency-label": "price-axis-currency-label-SfCx6ur0",
				hidden: "hidden-SfCx6ur0",
				row: "row-SfCx6ur0",
				"price-axis-currency-label-fade": "price-axis-currency-label-fade-SfCx6ur0",
				"price-axis-currency-label-text": "price-axis-currency-label-text-SfCx6ur0",
				"price-axis-currency-label-arrow-down": "price-axis-currency-label-arrow-down-SfCx6ur0"
			}
		},
		232729: e => {
			e.exports = {
				labelwidth: "19px",
				labelheight: "19px",
				bordersize: "2px",
				bottommargin: "5px",
				gearheight: "15px",
				gearwidth: "15px",
				"price-axis-stub": "price-axis-stub-eYu3weXF",
				wrapper: "wrapper-eYu3weXF",
				label: "label-eYu3weXF",
				symbol: "symbol-eYu3weXF",
				gear: "gear-eYu3weXF",
				"fixed-gear": "fixed-gear-eYu3weXF",
				"fixed-symbol": "fixed-symbol-eYu3weXF"
			}
		},
		891148: e => {
			e.exports = {}
		},
		244680: e => {
			e.exports = {}
		},
		10048: e => {
			e.exports = {
				chartsSplitter: "chartsSplitter-_LZ9aQoF",
				hovered: "hovered-_LZ9aQoF",
				"i-active": "i-active-_LZ9aQoF"
			}
		},
		750081: e => {
			e.exports = {
				"css-value-pane-controls-padding-left": "1px",
				"css-value-pane-controls-padding-right": "5px"
			}
		},
		33624: e => {
			e.exports = {
				paneSeparator: "paneSeparator-ZR_yhubO",
				handle: "handle-ZR_yhubO",
				hovered: "hovered-ZR_yhubO",
				active: "active-ZR_yhubO"
			}
		},
		690981: e => {
			e.exports = {
				"css-value-small-size": "18px",
				"css-value-medium-size": "22px",
				"css-value-large-size": "28px",
				"css-value-border-radius-small-size": "9px",
				"css-value-border-radius-medium-size": "11px",
				"css-value-border-radius-large-size": "8px",
				statuses: "statuses-sRKQyF_z",
				statusItem: "statusItem-sRKQyF_z",
				small: "small-sRKQyF_z",
				medium: "medium-sRKQyF_z",
				large: "large-sRKQyF_z",
				blinking: "blinking-sRKQyF_z",
				oneWidgetsVisible: "oneWidgetsVisible-sRKQyF_z",
				twoWidgetsVisible: "twoWidgetsVisible-sRKQyF_z",
				threeWidgetsVisible: "threeWidgetsVisible-sRKQyF_z",
				"blinking-animation": "blinking-animation-sRKQyF_z",
				marketStatusOpen: "marketStatusOpen-sRKQyF_z",
				marketStatusClose: "marketStatusClose-sRKQyF_z",
				marketStatusPre: "marketStatusPre-sRKQyF_z",
				marketStatusPost: "marketStatusPost-sRKQyF_z",
				marketStatusHoliday: "marketStatusHoliday-sRKQyF_z",
				invalidSymbol: "invalidSymbol-sRKQyF_z",
				replayMode: "replayMode-sRKQyF_z",
				notAccurate: "notAccurate-sRKQyF_z",
				delay: "delay-sRKQyF_z",
				eod: "eod-sRKQyF_z",
				dataProblemHigh: "dataProblemHigh-sRKQyF_z",
				dataProblemLow: "dataProblemLow-sRKQyF_z"
			}
		},
		995850: (e, t, i) => {
			"use strict";
			var s = i(168647),
				o = i(725977),
				r = i(911905).getLogger("Common.CollectionObserver"),
				n = s.Collection.extend({
					initialize: function(e, t) {
						if (this._observableCollection = t.observableCollection, this._validator = t.validator, this._syncEvents = o.isArray(t.syncEvents) ? t.syncEvents : [], this._syncEvents.push("reset"), this._syncEvents = o.uniq(this._syncEvents), this._observableCollection)
							if (this._observableCollection instanceof s.Collection) {
								"function" == typeof t.comparator && (this.comparator = t.comparator), this.comparator || "function" != typeof this._observableCollection.comparator || (this.comparator = this._observableCollection.comparator), this._observableCollection.on("add", this.onAdd, this), this._observableCollection.on("remove", this.remove, this);
								for (var i = this._syncEvents.length - 1; i >= 0; i--) this._observableCollection.on(this._syncEvents[i], this.syncCollections, this);
								e && e.length && this.add(e)
							} else r.logError("'observableCollection' need to be Backbone.Collection");
						else r.logError("'observableCollection' option required")
					},
					syncCollections: function() {
						var e = this._validator;
						e && this.reset(o.filter(this._observableCollection.models, e))
					},
					onAdd: function(e, t, i) {
						var o = this._validator;
						if (!o || o(e)) {
							var r = t instanceof s.Collection ? i : t;
							this.add(e, r)
						}
					},
					destroy: function() {
						this._observableCollection.off("add", this.onAdd, this), this._observableCollection.off("remove", this.remove, this);
						for (var e = this._syncEvents.length - 1; e >= 0; e--) this._observableCollection.off(this._syncEvents[e], this.syncCollections, this)
					}
				});
			e.exports = n
		},
		888667: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				availableTimezones: () => l,
				timezoneIsAvailable: () => c,
				timezoneTitle: () => h
			});
			var s = i(575932),
				o = i(684304);
			const r = [{
					id: "Etc/UTC",
					title: (0, s.t)("UTC")
				}, {
					id: "exchange",
					title: (0, s.t)("Exchange")
				}],
				n = [{
					id: "Africa/Cairo",
					title: (0, s.t)("Cairo"),
					offset: 0
				}, {
					id: "Africa/Johannesburg",
					title: (0, s.t)("Johannesburg"),
					offset: 0
				}, {
					id: "Africa/Lagos",
					title: (0, s.t)("Lagos"),
					offset: 0
				}, {
					id: "America/Argentina/Buenos_Aires",
					title: (0, s.t)("Buenos Aires"),
					offset: 0
				}, {
					id: "America/Bogota",
					title: (0, s.t)("Bogota"),
					offset: 0
				}, {
					id: "America/Caracas",
					title: (0, s.t)("Caracas"),
					offset: 0
				}, {
					id: "America/Chicago",
					title: (0, s.t)("Chicago"),
					offset: 0
				}, {
					id: "America/El_Salvador",
					title: (0, s.t)("San Salvador"),
					offset: 0
				}, {
					id: "America/Juneau",
					title: (0, s.t)("Juneau"),
					offset: 0
				}, {
					id: "America/Lima",
					title: (0, s.t)("Lima"),
					offset: 0
				}, {
					id: "America/Los_Angeles",
					title: (0, s.t)("Los Angeles"),
					offset: 0
				}, {
					id: "America/Mexico_City",
					title: (0, s.t)("Mexico City"),
					offset: 0
				}, {
					id: "America/New_York",
					title: (0, s.t)("New York"),
					offset: 0
				}, {
					id: "America/Phoenix",
					title: (0, s.t)("Phoenix"),
					offset: 0
				}, {
					id: "America/Santiago",
					title: (0, s.t)("Santiago"),
					offset: 0
				}, {
					id: "America/Sao_Paulo",
					title: (0, s.t)("Sao Paulo"),
					offset: 0
				}, {
					id: "America/Toronto",
					title: (0, s.t)("Toronto"),
					offset: 0
				}, {
					id: "America/Vancouver",
					title: (0, s.t)("Vancouver"),
					offset: 0
				}, {
					id: "US/Mountain",
					title: (0, s.t)("Denver"),
					offset: 0
				}, {
					id: "Asia/Almaty",
					title: (0, s.t)("Almaty"),
					offset: 0
				}, {
					id: "Asia/Ashkhabad",
					title: (0, s.t)("Ashgabat"),
					offset: 0
				}, {
					id: "Asia/Bahrain",
					title: (0, s.t)("Bahrain"),
					offset: 0
				}, {
					id: "Asia/Bangkok",
					title: (0, s.t)("Bangkok"),
					offset: 0
				}, {
					id: "Asia/Chongqing",
					title: (0, s.t)("Chongqing"),
					offset: 0
				}, {
					id: "Asia/Dubai",
					title: (0, s.t)("Dubai"),
					offset: 0
				}, {
					id: "Asia/Ho_Chi_Minh",
					title: (0, s.t)("Ho Chi Minh"),
					offset: 0
				}, {
					id: "Asia/Hong_Kong",
					title: (0, s.t)("Hong Kong"),
					offset: 0
				}, {
					id: "Asia/Jakarta",
					title: (0, s.t)("Jakarta"),
					offset: 0
				}, {
					id: "Asia/Jerusalem",
					title: (0, s.t)("Jerusalem"),
					offset: 0
				}, {
					id: "Asia/Karachi",
					title: (0, s.t)("Karachi"),
					offset: 0
				}, {
					id: "Asia/Kolkata",
					title: (0, s.t)("Kolkata"),
					offset: 0
				}, {
					id: "Asia/Kuwait",
					title: (0, s.t)("Kuwait"),
					offset: 0
				}, {
					id: "Asia/Manila",
					title: (0, s.t)("Manila"),
					offset: 0
				}, {
					id: "Asia/Muscat",
					title: (0, s.t)("Muscat"),
					offset: 0
				}, {
					id: "Asia/Qatar",
					title: (0, s.t)("Qatar"),
					offset: 0
				}, {
					id: "Asia/Riyadh",
					title: (0, s.t)("Riyadh"),
					offset: 0
				}, {
					id: "Asia/Seoul",
					title: (0, s.t)("Seoul"),
					offset: 0
				}, {
					id: "Asia/Shanghai",
					title: (0, s.t)("Shanghai"),
					offset: 0
				}, {
					id: "Asia/Singapore",
					title: (0, s.t)("Singapore"),
					offset: 0
				}, {
					id: "Asia/Taipei",
					title: (0, s.t)("Taipei"),
					offset: 0
				}, {
					id: "Asia/Tehran",
					title: (0, s.t)("Tehran"),
					offset: 0
				}, {
					id: "Asia/Tokyo",
					title: (0, s.t)("Tokyo"),
					offset: 0
				}, {
					id: "Atlantic/Reykjavik",
					title: (0, s.t)("Reykjavik"),
					offset: 0
				}, {
					id: "Australia/Adelaide",
					title: (0, s.t)("Adelaide"),
					offset: 0
				}, {
					id: "Australia/Brisbane",
					title: (0, s.t)("Brisbane"),
					offset: 0
				}, {
					id: "Australia/Perth",
					title: (0, s.t)("Perth"),
					offset: 0
				}, {
					id: "Australia/Sydney",
					title: (0, s.t)("Sydney"),
					offset: 0
				}, {
					id: "Europe/Amsterdam",
					title: (0, s.t)("Amsterdam"),
					offset: 0
				}, {
					id: "Europe/Athens",
					title: (0, s.t)("Athens"),
					offset: 0
				}, {
					id: "Europe/Belgrade",
					title: (0, s.t)("Belgrade"),
					offset: 0
				}, {
					id: "Europe/Berlin",
					title: (0, s.t)("Berlin"),
					offset: 0
				}, {
					id: "Europe/Bratislava",
					title: (0, s.t)("Bratislava"),
					offset: 0
				}, {
					id: "Europe/Brussels",
					title: (0, s.t)("Brussels"),
					offset: 0
				}, {
					id: "Europe/Bucharest",
					title: (0, s.t)("Bucharest"),
					offset: 0
				}, {
					id: "Europe/Budapest",
					title: (0, s.t)("Budapest"),
					offset: 0
				}, {
					id: "Europe/Copenhagen",
					title: (0, s.t)("Copenhagen"),
					offset: 0
				}, {
					id: "Europe/Dublin",
					title: (0, s.t)("Dublin"),
					offset: 0
				}, {
					id: "Europe/Helsinki",
					title: (0, s.t)("Helsinki"),
					offset: 0
				}, {
					id: "Europe/Istanbul",
					title: (0, s.t)("Istanbul"),
					offset: 0
				}, {
					id: "Europe/Lisbon",
					title: (0, s.t)("Lisbon"),
					offset: 0
				}, {
					id: "Europe/London",
					title: (0, s.t)("London"),
					offset: 0
				}, {
					id: "Europe/Luxembourg",
					title: (0, s.t)("Luxembourg"),
					offset: 0
				}, {
					id: "Europe/Madrid",
					title: (0, s.t)("Madrid"),
					offset: 0
				}, {
					id: "Europe/Malta",
					title: (0, s.t)("Malta"),
					offset: 0
				}, {
					id: "Europe/Moscow",
					title: (0, s.t)("Moscow"),
					offset: 0
				}, {
					id: "Europe/Oslo",
					title: (0, s.t)("Oslo"),
					offset: 0
				}, {
					id: "Europe/Paris",
					title: (0, s.t)("Paris"),
					offset: 0
				}, {
					id: "Europe/Riga",
					title: (0, s.t)("Riga"),
					offset: 0
				}, {
					id: "Europe/Rome",
					title: (0, s.t)("Rome"),
					offset: 0
				}, {
					id: "Europe/Stockholm",
					title: (0, s.t)("Stockholm"),
					offset: 0
				}, {
					id: "Europe/Tallinn",
					title: (0, s.t)("Tallinn"),
					offset: 0
				}, {
					id: "Europe/Vilnius",
					title: (0, s.t)("Vilnius"),
					offset: 0
				}, {
					id: "Europe/Warsaw",
					title: (0, s.t)("Warsaw"),
					offset: 0
				}, {
					id: "Europe/Zurich",
					title: (0, s.t)("Zurich"),
					offset: 0
				}, {
					id: "Pacific/Auckland",
					title: (0, s.t)("New Zealand"),
					offset: 0
				}, {
					id: "Pacific/Chatham",
					title: (0, s.t)("Chatham Islands"),
					offset: 0
				}, {
					id: "Pacific/Fakaofo",
					title: (0, s.t)("Tokelau"),
					offset: 0
				}, {
					id: "Pacific/Honolulu",
					title: (0, s.t)("Honolulu"),
					offset: 0
				}, {
					id: "Pacific/Norfolk",
					title: (0, s.t)("Norfolk Island"),
					offset: 0
				}],
				a = n.map((({
					id: e,
					title: t
				}) => {
					const {
						string: i,
						offset: s
					} = (0, o.parseTzOffset)(e);
					return {
						id: e,
						offset: s,
						title: `(${i}) ${t}`
					}
				})).sort(((e, t) => {
					const i = e.offset - t.offset;
					return 0 !== i ? i : e.title.localeCompare(t.title)
				})),
				l = r.concat(a);

			function c(e) {
				for (let t = 0; t < l.length; t++)
					if (e === l[t].id) return !0;
				return !1
			}

			function h(e) {
				for (const {
						id: t,
						title: i
					} of n)
					if (t === e) {
						return `${i} (${(0,o.parseTzOffset)(e).string})`
					} return e
			}
		},
		905038: (e, t, i) => {
			"use strict";

			function s(e) {
				const t = {};
				return {
					promise: new Promise(((i, s) => {
						e.subscribe(t, i, !0)
					})),
					destroy: () => {
						e.unsubscribeAll(t)
					}
				}
			}
			i.d(t, {
				delegateToPromise: () => s
			})
		},
		684304: (e, t, i) => {
			"use strict";
			i.d(t, {
				parseTzOffset: () => o
			});
			var s = i(393987);

			function o(e, t = Date.now()) {
				const i = (0, s.get_timezone)(e).offset_utc(t);
				let o = "";
				const r = i / 1e3 / 60 / 60;
				r % 1 && (o = ":" + r % 1 * 60);
				let n = "";
				return n = r > 0 ? "+" + (r - r % 1) + o : 0 === r ? "" : String(r - r % 1 + o), {
					offset: i,
					string: "UTC" + n
				}
			}
		},
		500099: (e, t, i) => {
			"use strict";
			i.d(t, {
				defaultContextMenuOptions: () => ti,
				createActionAddAlert: () => si,
				createActionTrade: () => ri,
				createPasteAction: () => ni,
				createActionCopyPrice: () => ai,
				createMTPredictorActions: () => li,
				createLinesAction: () => ci,
				createSyncDrawingActions: () => hi,
				ActionsProvider: () => di
			});
			var s = i(588537),
				o = i(911905),
				r = i(960521),
				n = i(270617),
				a = i(611688),
				l = i(829770),
				c = i(127085),
				h = i(617376),
				d = i(140662),
				u = i(697455),
				_ = i(345848),
				m = i(256160),
				p = i(295786),
				g = i(588746),
				S = i(659251),
				v = i(333412),
				f = i(110933),
				b = i(240025),
				y = i(68446),
				C = i(139344),
				w = i(731113),
				T = i(805048),
				P = i(366156),
				M = i(648684),
				x = i(286649),
				I = i(171670),
				A = i(983019),
				k = i(381554),
				L = i(108218),
				E = i(921270),
				D = i(320681),
				N = i(711496),
				B = i(44777),
				O = i(125226),
				R = i(470316),
				V = i(104436),
				W = i(582294),
				F = i(126026),
				z = i(749473),
				U = i(891075),
				H = i(20870),
				G = i(540968),
				j = i(992179),
				q = i(97985),
				K = i(575932),
				Y = i(277036),
				X = i(308170);
			const Z = (0, o.getLogger)("Chart.ActionsProvider"),
				$ = new Y.TranslatedString("show alert label lines", (0, K.t)("show alert label lines")),
				Q = new Y.TranslatedString("hide alert label lines", (0, K.t)("hide alert label lines")),
				J = new Y.TranslatedString("change visibility", (0, K.t)("change visibility")),
				ee = new Y.TranslatedString("pin to scale {label}", (0, K.t)("pin to scale {label}")),
				te = new Y.TranslatedString("pin to right scale", (0, K.t)("pin to right scale")),
				ie = new Y.TranslatedString("pin to left scale", (0, K.t)("pin to left scale")),
				se = new Y.TranslatedString("change earnings visibility", (0, K.t)("change earnings visibility")),
				oe = new Y.TranslatedString("change dividends visibility", (0, K.t)("change dividends visibility")),
				re = new Y.TranslatedString("change splits visibility", (0, K.t)("change splits visibility")),
				ne = new Y.TranslatedString("change continuous contract switch visibility", (0, K.t)("change continuous contract switch visibility")),
				ae = new Y.TranslatedString("show all ideas", (0, K.t)("show all ideas")),
				le = new Y.TranslatedString("show ideas of followed users", (0, K.t)("show ideas of followed users")),
				ce = new Y.TranslatedString("show my ideas only", (0, K.t)("show my ideas only")),
				he = new Y.TranslatedString("change events visibility on chart", (0, K.t)("change events visibility on chart")),
				de = new Y.TranslatedString("add this symbol to entire layout", (0,
					K.t)("add this symbol to entire layout")),
				ue = new Y.TranslatedString("add this indicator to entire layout", (0, K.t)("add this indicator to entire layout")),
				_e = new Y.TranslatedString("add this strategy to entire layout", (0, K.t)("add this strategy to entire layout")),
				me = new Y.TranslatedString("add this financial metric to entire layout", (0, K.t)("add this financial metric to entire layout")),
				pe = new Y.TranslatedString("apply drawing template", (0, K.t)("apply drawing template")),
				ge = new Y.TranslatedString("lock objects", (0, K.t)("lock objects")),
				Se = new Y.TranslatedString("unlock objects", (0, K.t)("unlock objects")),
				ve = (0, K.t)("Add alert"),
				fe = (0, K.t)("Add alert on {series}"),
				be = (0, K.t)("Add alert on {drawing}"),
				ye = (0, q.appendEllipsis)((0, K.t)("Edit {title} alert")),
				Ce = (0, K.t)("Extend alert lines"),
				we = (0, K.t)("Trade"),
				Te = (0, q.appendEllipsis)((0, K.t)("Create limit order")),
				Pe = (0, K.t)("Show"),
				Me = (0, K.t)("Hide"),
				xe = (0, K.t)("MTPredictor"),
				Ie = (0, K.t)("Apply Manual Risk/Reward"),
				Ae = (0, K.t)("Apply Manual Decision Point"),
				ke = (0, K.t)("Analyze Trade Setup"),
				Le = (0, K.t)("Apply Elliott Wave"),
				Ee = (0, K.t)("Apply Elliott Wave Intermediate"),
				De = (0, K.t)("Apply Elliott Wave Major"),
				Ne = (0, K.t)("Apply Elliott Wave Minor"),
				Be = (0, K.t)("Apply WPT Up Wave"),
				Oe = (0, K.t)("Up Wave 1 or A"),
				Re = (0, K.t)("Up Wave 2 or B"),
				Ve = (0, K.t)("Up Wave C"),
				We = (0, K.t)("Up Wave 3"),
				Fe = (0, K.t)("Up Wave 4"),
				ze = (0, K.t)("Up Wave 5"),
				Ue = (0, K.t)("Apply WPT Down Wave"),
				He = (0, K.t)("Down Wave 1 or A"),
				Ge = (0, K.t)("Down Wave 2 or B"),
				je = (0, K.t)("Down Wave C"),
				qe = (0, K.t)("Down Wave 3"),
				Ke = (0, K.t)("Down Wave 4"),
				Ye = (0, K.t)("Down Wave 5"),
				Xe = (0, K.t)("Pinned to scale {label} (hidden)"),
				Ze = (0, K.t)("Pinned to right scale (hidden)"),
				$e = (0, K.t)("Pin to scale {label} (hidden)"),
				Qe = (0, K.t)("Pin to right scale (hidden)"),
				Je = (0, K.t)("Pinned to scale {label}"),
				et = (0, K.t)("Pinned to right scale"),
				tt = (0, K.t)("Pin to scale {label}"),
				it = (0, K.t)("Pin to right scale"),
				st = (0, K.t)("Pinned to left scale (hidden)"),
				ot = (0, K.t)("Pin to left scale (hidden)"),
				rt = (0, K.t)("Pinned to left scale"),
				nt = (0, K.t)("Pin to left scale"),
				at = (0, K.t)("Pin to new left scale"),
				lt = (0, K.t)("Pin to new right scale"),
				ct = (0, K.t)("Pin to scale (now {label})"),
				ht = (0, K.t)("Pin to scale (now no scale)"),
				dt = (0, K.t)("Pin to scale (now left)"),
				ut = (0, K.t)("Pin to scale (now right)"),
				_t = (0, K.t)("No scale (fullscreen)"),
				mt = (0, K.t)("Move to"),
				pt = (0, K.t)("Existing pane above"),
				gt = (0, K.t)("New pane above"),
				St = (0, K.t)("Existing pane below"),
				vt = (0, K.t)("New pane below"),
				ft = (0, K.t)("Bring to front"),
				bt = (0, K.t)("Send to back"),
				yt = (0, K.t)("Bring forward"),
				Ct = (0, K.t)("Send backward"),
				wt = (0, K.t)("Visual order"),
				Tt = (0, K.t)("Lines"),
				Pt = (0, q.appendEllipsis)((0, K.t)("Add indicator/strategy on {studyTitle}")),
				Mt = (0, q.appendEllipsis)((0, K.t)("Add financial metric for {instrumentName}")),
				xt = (0, q.appendEllipsis)((0, K.t)("Settings")),
				It = (0, K.t)("Apply default"),
				At = (0, q.appendEllipsis)((0, K.t)("Save as")),
				kt = (0, K.t)("Copy"),
				Lt = (0, K.t)("Clone"),
				Et = (0, K.t)("Template"),
				Dt = (0, K.t)("Go to {lineToolName}"),
				Nt = (0, K.t)("Unlock"),
				Bt = (0, K.t)("Lock"),
				Ot = (0,
					K.t)("Show earnings"),
				Rt = (0, K.t)("Show dividends"),
				Vt = (0, K.t)("Show splits"),
				Wt = (0, K.t)("Show continuous contract switch"),
				Ft = (0, K.t)("Show all ideas"),
				zt = (0, K.t)("Show ideas of followed users"),
				Ut = (0, K.t)("Show my ideas only"),
				Ht = (0, q.appendEllipsis)((0, K.t)("Settings")),
				Gt = (0, K.t)("Hide events on chart"),
				jt = (0, K.t)("Add this symbol to entire layout"),
				qt = (0, K.t)("Add this indicator to entire layout"),
				Kt = (0, K.t)("Add this strategy to entire layout"),
				Yt = (0, K.t)("Add this financial metric to entire layout"),
				Xt = (0, K.t)("No sync"),
				Zt = (0, K.t)("Sync in layout"),
				$t = (0, K.t)("Sync globally"),
				Qt = (0, q.appendEllipsis)((0, K.t)("Symbol info")),
				Jt = (0, K.t)("Paste"),
				ei = (0, K.t)("Copy price"),
				ti = {
					general: !0,
					mainSeries: !0,
					mainSeriesTrade: !1,
					esdStudies: !0,
					studies: !0,
					fundamentals: !0,
					lineTools: !0,
					publishedCharts: !0,
					ordersAndPositions: !0,
					alerts: !0,
					chartEvents: !0,
					objectTree: !0,
					gotoLineTool: !1
				};

			function ii(e) {
				return (0, j.isSymbolSource)(e) ? e.symbolTitle(!0, !0) : e.title(!0)
			}

			function si(e, t) {
				const i = e.model().model();
				if (i.isInReplay()) return null;
				if (i.mainSeries().isConvertedToOtherCurrency() || i.mainSeries().isConvertedToOtherUnit()) return null;
				let o = {},
					r = ve,
					n = null;
				const a = void 0 !== t.series ? oi(t.series, i.mainSeries()) : t.e ? oi((0, s.ensureNotNull)((0, s.ensureDefined)(t.pane).mainDataSource()), i.mainSeries(), t.e.localY) : t.drawing ? function(e) {
					const t = (0, s.ensureNotNull)(e.ownerSource()).symbolSource();
					if (t && (t.isConvertedToOtherCurrency() || t.isConvertedToOtherUnit())) return null;
					return {
						label: be.format({
							drawing: e.title()
						}),
						trackEventLabel: "ContextMenuDrawing",
						alertEditorOptions: {
							drawing: e
						}
					}
				}(t.drawing) : null;
				return a && (o = a.alertEditorOptions, r = a.label, n = a.trackEventLabel), r = (0, q.appendEllipsis)(r), new g.TVActionAsync((() => (o.series ? (0, E.hasUserAccessToDataSource)(o.series) : Promise.resolve(!0)).then((e => {
					const t = {
						label: r,
						icon: k,
						statName: "AddAlert"
					};
					return e ? {
						...t,
						shortcutHint: (0, R.humanReadableHash)(R.Modifiers.Alt + 65),
						onExecute: () => {
							null !== n && ((0, _.trackEvent)("GUI", "CreateAlert", n), n = null), window.runOrSignIn((() => {
								(0, p.invokeAlertEditorWithOnlineSeries)({
									...o,
									dataSourceHub: i,
									actionSource: "pane_context_menu_add_alert"
								})
							}), {
								source: "Alert add from pane context menu",
								sourceMeta: "Chart"
							})
						}
					} : {
						...t,
						disabled: !0
					}
				}))))
			}

			function oi(e, t, i) {
				const s = e.symbolSource();
				if (s && (s.isConvertedToOtherCurrency() || s.isConvertedToOtherUnit())) return null;
				let o, r = (0, d.isStudy)(e) ? fe.format({
					series: ii(e)
				}) : ve;
				const n = (0, d.isStudy)(e) ? "ContextMenuStudy" : e === t ? "ContextMenuSeries" : null,
					a = e.priceScale() || t.priceScale(),
					l = e.firstValue();
				if (void 0 !== i && null !== l) o = a.coordinateToPrice(i, l);
				else if (e === t) o = t.lastValueData(4, !0, !0).price;
				else if ((0, d.isStudy)(e)) {
					const t = e.defaultPlotIdForAlert();
					o = null === t ? void 0 : e.lastValueData(t, !0, !0).price
				}
				return void 0 !== o && (r += " (" + a.formatter().format(o) + ")"), {
					label: r,
					trackEventLabel: n,
					alertEditorOptions: {
						series: e,
						value: o
					}
				}
			}

			function ri(e, t, i) {
				if (e.model().isInReplay()) return null;
				const s = e.model().mainSeries();
				return s.isConvertedToOtherCurrency() || s.isConvertedToOtherUnit() ? null : new l.ActionAsync("Trading.TradeFromChart", (() => {
					const t = new Promise(((t, s) => {
						const o = (0, f.tradingService)();
						if (null === o || 0 === o.brokersList().length) return void t({
							label: we,
							disabled: !0
						});
						const r = e.model().mainSeries();
						let n;
						i && (n = i.localY), (0, b.createTradeContext)(r, n).then((e => {
							try {
								return o.chartContextMenuActions(e)
							} catch (e) {
								return Z.logError(e.message), []
							}
						})).then((e => {
							0 !== e.length ? t({
								name: "trade",
								label: we,
								subItems: e,
								statName: "Trading"
							}) : t({
								label: we,
								disabled: !0
							})
						})).catch((() => {
							s("Unable to get Trade Context")
						}))
					}));
					return (0, y.makeTimeLimited)(t, 2e3, "Action trade not received")
				}))
			}

			function ni(e, t) {
				return !t.isEmpty() && a.enabled("datasource_copypaste") ? new l.Action({
					actionId: "Chart.Clipboard.PasteSource",
					label: Jt.trim(),
					shortcutHint: (0, R.humanReadableHash)(R.Modifiers.Mod + 86),
					statName: "Paste",
					onExecute: () => e.chartWidgetCollection().clipboard.uiRequestPaste(t)
				}) : null
			}

			function ai(e, t) {
				var i, s, o;
				const r = e.defaultPriceScale(),
					n = void 0 !== t ? r.coordinateToPrice(t, null !== (s = null === (i = e.mainDataSource()) || void 0 === i ? void 0 : i.firstValue()) && void 0 !== s ? s : 0) : e.model().mainSeries().lastValueData(4, !0, !0).price,
					a = null === (o = e.mainDataSource()) || void 0 === o ? void 0 : o.formatter();
				if (void 0 === n || !a) return null;
				const c = a.format(n);
				return new l.Action({
					actionId: "Chart.Clipboard.CopyPrice",
					label: `${ei} (${c})`,
					statName: "CopyPrice",
					onExecute: () => window.navigator.clipboard.writeText(c)
				})
			}

			function li(e, t, i, o) {
				const r = (r, n, a) => new g.TVAction({
					label: r,
					onExecute: () => {
						const r = e.model(),
							l = r.model().timeScale(),
							c = t.defaultPriceScale();
						if (!l.isEmpty() && !c.isEmpty())
							if (a && void 0 !== i && void 0 !== o) {
								const e = (0, s.ensureNotNull)((0, s.ensureNotNull)(t.mainDataSource()).firstValue()),
									a = c.coordinateToPrice(i, e),
									h = Math.round(l.coordinateToIndex(o));
								r.createLineTool({
									pane: t,
									point: {
										index: h,
										price: a
									},
									linetool: n
								})
							} else X.tool.setValue(n)
					}
				});
				return new g.TVAction({
					label: xe,
					subItems: [r(Ie, "LineStudyMtpRiskReward", !1), r(Ae, "LineStudyMtpDecisionPoint", !0), r(ke, "LineStudyMtpAnalysis", !0), new g.TVAction({
						label: Le,
						subItems: [r(Ee, "LineStudyMtpElliotWaveMain", !0), r(De, "LineStudyMtpElliotWaveMajor", !0), r(Ne, "LineStudyMtpElliotWaveMinor", !0)]
					}), new g.TVAction({
						label: Be,
						subItems: [r(Oe, "LineStudyMtpUpWave1OrA", !1), r(Re, "LineStudyMtpUpWave2OrB", !1), r(Ve, "LineStudyMtpUpWaveC", !1), r(We, "LineStudyMtpUpWave3", !1), r(Fe, "LineStudyMtpUpWave4", !1), r(ze, "LineStudyMtpUpWave5", !1)]
					}), new g.TVAction({
						label: Ue,
						subItems: [r(He, "LineStudyMtpDownWave1OrA", !1), r(Ge, "LineStudyMtpDownWave2OrB", !1), r(je, "LineStudyMtpDownWaveC", !1), r(qe, "LineStudyMtpDownWave3", !1), r(Ke, "LineStudyMtpDownWave4", !1), r(Ye, "LineStudyMtpDownWave5", !1)]
					})]
				})
			}

			function ci(e) {
				const t = e.actions(),
					i = [t.showPriceLine];
				return i.push(t.showSeriesPrevCloseLine), i.push(t.showPrePostMarketPriceLine), i.push(t.showHighLowPriceLines), e.model().model().hasCustomSource("bidask") && i.push(t.showBidAskLines), new l.Action({
					actionId: "Chart.Lines",
					label: Tt,
					statName: "Lines",
					subItems: i
				})
			}

			function hi(e, t) {
				const i = []; {
					if (X.isToolCreatingNow.value()) return i;
					const s = () => {
							var t;
							return null !== (t = e.chartWidgetCollection().activeChartWidget.value()) && void 0 !== t ? t : e
						},
						o = () => t.some((e => e.isSynchronizable()));
					if ((0, O.isFeatureEnabled)("save_shared_line_tools")) {
						if (!o()) return i;
						let s = t[0].sharingMode().value();
						s = t.every((e => e.sharingMode().value() === s)) ? s : null;
						const r = e.model();
						i.push(new l.Separator, new g.TVAction({
							label: Xt,
							statName: "NoSyncDrawing",
							checkable: !0,
							checked: 0 === s,
							onExecute: e => {
								e.isChecked() && r.shareLineTools(t, 0)
							}
						}), new g.TVAction({
							label: Zt,
							statName: "SyncDrawingInLayout",
							checkable: !0,
							checked: 1 === s,
							onExecute: e => {
								e.isChecked() && r.shareLineTools(t, 1)
							}
						}), new g.TVAction({
							label: $t,
							statName: "SyncDrawingGlobally",
							checkable: !0,
							checked: 2 === s,
							onExecute: e => {
								e.isChecked() && r.shareLineTools(t, 2)
							}
						}))
					} else if (a.enabled("support_multicharts") && e.isMultipleLayout()) {
						if (!o()) return i;
						const e = t.every((e => !!e.linkKey().value()));
						i.push(new l.Separator, new l.Action({
							actionId: "Chart.LineTool.NoSync",
							label: Xt,
							statName: "NoSyncDrawing",
							checkable: !0,
							checked: !e,
							onExecute: e => {
								e.isChecked() && s().unlinkSelectedLine()
							}
						}), new l.Action({
							actionId: "Chart.LineTool.SyncInLayout",
							label: Zt,
							statName: "SyncDrawingInLayout",
							checkable: !0,
							checked: e,
							onExecute: e => {
								e.isChecked() && s().copyLineToOtherCharts()
							}
						}))
					}
				}
				return i
			}
			class di {
				constructor(e, t) {
					this._chartWidget = e, this._options = (0, n.merge)((0, n.clone)(ti), t || {})
				}
				async contextMenuActionsForSources(e, t, i) {
					const s = e[0],
						o = this._options;
					if (s === this._chartWidget.model().mainSeries() && o.mainSeries) return this._contextMenuActionsForSeries(s, t);
					if ((0, d.isESDStudy)(s) && o.esdStudies) return this._contextMenuActionsForESD();
					if ((0, d.isRollDatesStudy)(s)) return this._contextMenuActionsForRollDates();
					if ((0, d.isStudy)(s) && o.studies) return this._contextMenuActionsForStudy(s);
					if (s instanceof M.PublishedChartsTimeline && o.publishedCharts) return this._contextMenuActionsForPublishedTimeline(s);
					if ((s instanceof C.LineToolOrder || s instanceof w.LineToolPosition) && o.ordersAndPositions) return this._contextMenuActionsForTradingDrawings(s);
					if ((0, I.isAlertLabel)(s) && s.alert().id && o.alerts) return this._contextMenuActionsForAlertLabel(s.alert(), i);
					if ((0, G.isLineTool)(s) && o.lineTools) {
						const t = e.filter(G.isLineTool);
						return this._contextMenuActionsForLineTool(t)
					}
					return s instanceof A.ChartEventsSource && o.chartEvents ? this._contextMenuActionsForChartEvents(s) : []
				}
				_isReadOnly() {
					return this._chartWidget.readOnly()
				}
				_createActionHide(e) {
					return new l.Action({
						actionId: "Chart.SelectedObject.Hide",
						label: Me,
						icon: i(484959),
						statName: "HideSelectedObject",
						onExecute: this._chartWidget.hideDataSources.bind(this._chartWidget, [e])
					})
				}
				_createActionShow(e) {
					const t = new l.Action({
							actionId: "Chart.SelectedObject.Show",
							checkable: !0,
							label: Pe,
							icon: i(416911),
							statName: "ToggleShow"
						}),
						s = new c.ActionBinder(t, e.properties().visible, this._chartWidget.model(), J);
					return t.setBinding(s), s.setValue(e.properties().visible.value()), t
				}
				_createActionScale(e) {
					const t = (0, s.ensureNotNull)(e.priceScale()),
						o = this._chartWidget.model().model(),
						r = (0,
							s.ensureNotNull)(o.paneForSource(e)),
						n = r.priceScalePosition(t),
						a = ("left" === n ? r.leftPriceScales() : r.rightPriceScales()).indexOf(t),
						c = o.priceScaleSlotsCount().totallySlots < 2 ? "dontneedname" : "needname",
						d = "overlay" === n ? "" : (0, h.getPriceAxisNameInfo)(n, a).label,
						u = ct.format({
							label: d
						}),
						_ = {
							"left-needname": u,
							"left-dontneedname": dt,
							"right-needname": u,
							"right-dontneedname": ut,
							"overlay-needname": ht,
							"overlay-dontneedname": ht
						} [n + "-" + c];
					return new l.Action({
						actionId: "Chart.Source.ChangePriceScale",
						label: _,
						icon: i(225191),
						subItems: this._createActionScaleItems(e)
					})
				}
				_createActionScaleDetach(e, t, i, o) {
					const r = this._chartWidget.model().model(),
						n = (0, s.ensureNotNull)(r.paneForSource(e));
					if (!n.canCreateNewPriceScale()) return null;
					const a = (0, s.ensureNotNull)(e.priceScale()),
						c = a.canDetachSource(e),
						d = n.priceScalePosition(a),
						u = c || d !== t;
					if (!u) return null;
					const _ = r.priceScaleSlotsCount(),
						m = {
							left: {
								labelled: tt,
								sided: at
							},
							right: {
								labelled: tt,
								sided: lt
							}
						},
						p = "left" === t ? n.leftPriceScales().length : n.rightPriceScales().length,
						g = _[t] > p ? "labelled" : "sided",
						S = (0, h.getPriceAxisNameInfo)(t, p).label,
						v = m[t][g].format({
							label: S
						});
					return new l.Action({
						actionId: "Chart.Source.ChangePriceScale",
						checkable: !1,
						disabled: !u,
						label: v,
						statName: o,
						payload: e,
						onExecute: i
					})
				}
				_onDetachLeft(e) {
					const t = e.getPayload(),
						i = this._chartWidget.model().model(),
						o = (0, s.ensureNotNull)(i.paneForSource(t));
					this._chartWidget.model().detachToLeft(t, o)
				}
				_onDetachRight(e) {
					const t = e.getPayload(),
						i = this._chartWidget.model().model(),
						o = (0, s.ensureNotNull)(i.paneForSource(t));
					this._chartWidget.model().detachToRight(t, o)
				}
				_createActionScaleDetachLeft(e) {
					return this._createActionScaleDetach(e, "left", this._onDetachLeft.bind(this), "ToggleScaleLeft")
				}
				_createActionScaleDetachRight(e) {
					return this._createActionScaleDetach(e, "right", this._onDetachRight.bind(this), "ToggleScaleRight")
				}
				_onMoveToScale(e) {
					const t = e.getPayload();
					if (t.datasource.priceScale() === t.priceScale) return;
					const i = this._chartWidget.model().model(),
						o = (0, s.ensureNotNull)(i.paneForSource(t.datasource));
					this._chartWidget.model().moveToScale(t.datasource, o, t.priceScale, t.undoText)
				}
				_createMoveToScaleAction(e, t, i, s) {
					const o = e.priceScale() === t;
					return new l.Action({
						actionId: "Chart.Source.MoveToOtherScale",
						checkable: !0,
						checked: o,
						label: i,
						statName: "ToggleScale",
						payload: {
							datasource: e,
							priceScale: t,
							undoText: s
						},
						onExecute: this._onMoveToScale.bind(this)
					})
				}
				_onNoScale(e) {
					const t = e.getPayload().datasource,
						i = this._chartWidget.model().model(),
						o = (0, s.ensureNotNull)(i.paneForSource(t));
					o.isOverlay(t) || this._chartWidget.model().detachNoScale(t, o)
				}
				_createActionNoScale(e) {
					const t = this._chartWidget.model().model(),
						i = (0, s.ensureNotNull)(t.paneForSource(e)),
						o = i.actionNoScaleIsEnabled(e);
					return new l.Action({
						actionId: "Chart.Source.MoveToNoScale",
						checkable: !0,
						checked: i.isOverlay(e),
						label: _t,
						disabled: !o,
						statName: "ToggleNoScale",
						payload: {
							datasource: e
						},
						onExecute: this._onNoScale.bind(this)
					})
				}
				_createActionScaleItems(e) {
					const t = [],
						i = this._chartWidget.model().model(),
						o = (0,
							s.ensureNotNull)(i.paneForSource(e)),
						r = i.priceScaleSlotsCount().totallySlots > 1,
						n = o.rightPriceScales(),
						a = o.leftPriceScales(),
						c = this._createActionScaleDetachRight(e),
						d = this._createActionScaleDetachLeft(e),
						u = n.length + a.length + (null === c ? 0 : 1) + (null === d ? 0 : 1) > 2,
						_ = {
							right: {
								hidden: {
									checked: {
										labelled: Xe,
										sided: Ze
									},
									unchecked: {
										labelled: $e,
										sided: Qe
									}
								},
								visible: {
									checked: {
										labelled: Je,
										sided: et
									},
									unchecked: {
										labelled: tt,
										sided: it
									}
								}
							},
							left: {
								hidden: {
									checked: {
										labelled: Xe,
										sided: st
									},
									unchecked: {
										labelled: $e,
										sided: ot
									}
								},
								visible: {
									checked: {
										labelled: Je,
										sided: rt
									},
									unchecked: {
										labelled: tt,
										sided: nt
									}
								}
							}
						},
						m = {
							right: te,
							left: ie
						},
						p = {
							left: o.visibleLeftPriceScales(),
							right: o.visibleRightPriceScales()
						},
						g = (t, i) => {
							const s = ("right" === i ? n : a)[t],
								o = p[i].includes(s) ? "visible" : "hidden",
								l = e.priceScale() === s ? "checked" : "unchecked",
								c = r ? "labelled" : "sided",
								d = _[i],
								u = (0, h.getPriceAxisNameInfo)(i, t).label;
							return {
								actionText: d[o][l][c].format({
									label: u
								}),
								undoText: r ? ee.format({
									label: u
								}) : m[i]
							}
						};
					t.push(...n.map(((t, i) => {
						const s = g(i, "right");
						return this._createMoveToScaleAction(e, t, s.actionText, s.undoText)
					}))), null !== c && t.push(c);
					u && (n.length > 0 || null !== c) && t.push(new l.Separator);
					t.push(...a.map(((t, i) => {
						const s = g(i, "left");
						return this._createMoveToScaleAction(e, t, s.actionText, s.undoText)
					}))), null !== d && t.push(d);
					u && (a.length > 0 || null !== d) && t.push(new l.Separator);
					return t.push(this._createActionNoScale(e)), t
				}
				_createVisualOrderAction(e) {
					const t = this._chartWidget.model(),
						s = t.availableZOrderOperations(e),
						o = [new l.Action({
							actionId: "Chart.Source.VisualOrder.BringToFront",
							label: ft,
							statName: "BringToFront",
							disabled: !s.bringToFrontEnabled,
							onExecute: () => t.bringToFront(e)
						}), new l.Action({
							actionId: "Chart.Source.VisualOrder.SendToBack",
							label: bt,
							statName: "SendToBack",
							disabled: !s.sendToBackEnabled,
							onExecute: () => t.sendToBack(e)
						}), new l.Action({
							actionId: "Chart.Source.VisualOrder.BringForward",
							label: yt,
							statName: "BringForward",
							disabled: !s.bringForwardEnabled,
							onExecute: () => t.bringForward(e)
						}), new l.Action({
							actionId: "Chart.Source.VisualOrder.SendBackward",
							label: Ct,
							statName: "SendBackward",
							disabled: !s.sendBackwardEnabled,
							onExecute: () => t.sendBackward(e)
						})];
					return new l.Action({
						actionId: "Chart.Source.VisualOrder",
						label: wt,
						icon: i(677067),
						statName: "VisualOrder",
						subItems: o
					})
				}
				_createActionMergeUp(e) {
					const t = this._chartWidget.model();
					return t.model().isMergeUpAvailableForSource(e) ? new l.Action({
						actionId: "Chart.Source.MergeUp",
						label: pt,
						statName: "MergeUp",
						onExecute: () => t.mergeSourceUp(e)
					}) : null
				}
				_createActionUnmergeUp(e) {
					const t = this._chartWidget.model();
					return t.model().isUnmergeAvailableForSource(e) ? new l.Action({
						actionId: "Chart.Source.UnmergeUp",
						label: gt,
						statName: "UnmergeUp",
						onExecute: () => t.unmergeSourceUp(e)
					}) : null
				}
				_createActionMergeDown(e) {
					const t = this._chartWidget.model();
					return t.model().isMergeDownAvailableForSource(e) ? new l.Action({
						actionId: "Chart.Source.MergeDown",
						label: St,
						statName: "MergeDown",
						onExecute: () => t.mergeSourceDown(e)
					}) : null
				}
				_createActionUnmergeDown(e) {
					const t = this._chartWidget.model();
					return t.model().isUnmergeAvailableForSource(e) ? new l.Action({
						actionId: "Chart.Source.UnmergeDown",
						label: vt,
						statName: "UnmergeDown",
						onExecute: () => t.unmergeSourceDown(e)
					}) : null
				}
				_mergeContentMenuItems(e) {
					return [this._createActionMergeUp(e), this._createActionUnmergeUp(e), this._createActionMergeDown(e), this._createActionUnmergeDown(e)].filter(n.notNull)
				}
				_createActionMove(e) {
					const t = this._mergeContentMenuItems(e);
					return t.length > 0 ? new l.Action({
						actionId: "Chart.Source.MoveToPane",
						label: mt,
						icon: i(854190),
						subItems: t
					}) : null
				}
				_contextMenuActionsForSeries(e, t) {
					var i;
					const o = [],
						r = e.properties().childs().visible.value(),
						n = this._chartWidget.model().model(),
						c = (0, s.ensureNotNull)(n.paneForSource(e)),
						h = this._chartWidget.actions();
					if (this._isReadOnly()) o.push(r ? this._createActionHide(e) : this._createActionShow(e)), o.push(new l.Separator), o.push(this._createActionScale(e));
					else {
						if (e.alertCreationAvailable()) {
							const t = si(this._chartWidget, {
								series: e
							});
							null !== t && o.push(t)
						}
						if (o.push(this._createActionAddChildStudy(e)), this._options.fundamentals) {
							const t = this._createActionAddFundamentals(e);
							null !== t && o.push(t)
						}
						if (this._options.mainSeriesTrade) {
							const e = ri(this._chartWidget);
							null !== e && o.push(e)
						}
						o.length > 0 && !(o[o.length - 1] instanceof l.Separator) && o.push(new l.Separator), a.enabled("symbol_info") && o.push(h.showSymbolInfoDialog);
						const d = n.mainSeries().symbolInfo();
						if (h.showFinancials && null !== d && (0, N.hasMoreFinancialsButton)(d.type, d.typespecs) && o.push(h.showFinancials), o.length > 0 && !(o[o.length - 1] instanceof l.Separator) && o.push(new l.Separator), !c.isEmpty() && a.enabled("datasource_copypaste")) {
							const e = ai(c, t && "localY" in t ? t.localY : void 0),
								i = ni(this._chartWidget, c);
							(e || i) && (e && o.push(e), i && o.push(i), o.push(new l.Separator))
						}
						o.push(this._createVisualOrderAction([e]));
						const u = this._createActionMove(e);
						null !== u && o.push(u), o.push(this._createActionScale(e)), o.push(r ? this._createActionHide(e) : this._createActionShow(e)), o.push(new l.Separator), o.push(ci(this._chartWidget)), o.push(new l.Separator);
						Boolean(null === (i = window.widgetbar) || void 0 === i ? void 0 : i.widget("watchlist")) && h.addToWatchlist && o.push(h.addToWatchlist), a.enabled("text_notes") && o.push(h.addToTextNotes), o[o.length - 1] instanceof l.Separator || o.push(new l.Separator), window.pro && window.pro.hasPackage("mtp-mtpredictor") && o.push((0, s.ensureNotNull)(li(this._chartWidget, c)), new l.Separator), a.enabled("show_chart_property_page") && !this._chartWidget.onWidget() && o.push(h.mainSeriesPropertiesAction), o[o.length - 1] instanceof l.Separator && o.pop()
					}
					return o
				}
				_createActionAddChildStudy(e) {
					const t = this._chartWidget.model().model();
					return new g.TVAction({
						label: Pt.format({
							studyTitle: ii(e)
						}),
						icon: i(706862),
						statName: "ApplyIndicator",
						onExecute: () => {
							const i = this._chartWidget.showIndicators((0, d.isStudy)(e) ? e : void 0);
							if (i && (0, d.isStudy)(e)) {
								const e = () => {
										(0, _.trackEvent)("SOS", "Apply SOS", "Apply by RC menu")
									},
									s = t.studyInserted();
								s.subscribe(this, e), i.visible().subscribe((t => {
									t || s.unsubscribe(this, e)
								}), {
									once: !0
								})
							}
						}
					})
				}
				_createActionAddFundamentals(e) {
					{
						const t = e.symbolInfo();
						if (null !== t && "forex" !== t.type && !(0, z.isCryptoSymbol)(t)) return new g.TVAction({
							label: Mt.format({
								instrumentName: ii(e)
							}),
							icon: i(428026),
							statName: "ApplyFundamental",
							onExecute: () => {
								this._chartWidget.showFundamentals(e !== this._chartWidget.model().mainSeries() ? e : void 0)
							}
						})
					}
					return null
				}
				_createActionShowSymbolInfoDialog(e, t) {
					const s = this._chartWidget.model().model();
					return new l.Action({
						actionId: "Chart.Dialogs.ShowSymbolInfo",
						label: Qt,
						icon: i(437924),
						checkable: !1,
						statName: "SymbolInfo",
						onExecute: () => {
							const i = e.symbol(),
								o = {
									symbolInfo: e.symbolInfo(),
									unitDescription: e => t.description(e),
									dateFormatter: s.dateTimeFormatter()
								};
							(0, U.showSymbolInfoDialog)(i, o)
						}
					})
				}
				_createActionShowProperties(e) {
					return new l.Action({
						actionId: "Chart.Indicator.ShowSettingsDialog",
						label: xt,
						icon: i(951983),
						statName: "EditSelectedObject",
						onExecute: () => this._chartWidget.showSourceProperties(e)
					})
				}
				_contextMenuActionsForStudy(e) {
					const t = this._chartWidget.actions(),
						i = e.properties().childs().visible.value(),
						s = [];
					if (!e.userEditEnabled()) return s;
					if (this._chartWidget.readOnly()) s.push(i ? this._createActionHide(e) : this._createActionShow(e)), s.push(new l.Separator), e.constructor instanceof S.NonSeriesStudy || s.push(this._createActionScale(e));
					else {
						if (e.alertCreationAvailable()) {
							const t = si(this._chartWidget, {
								series: e
							});
							null !== t && s.push(t)
						}
						if (a.enabled("study_on_study") && e.canHaveChildren() && s.push(this._createActionAddChildStudy(e)), (e instanceof F.StudyCompare || e instanceof W.study_Overlay) && this._options.fundamentals) {
							const t = this._createActionAddFundamentals(e);
							null !== t && s.push(t)
						}
						const o = this._createApplyToEntireLayoutCommand(e);
						if (null !== o && s.push(o), s.length > 0 && !(s[s.length - 1] instanceof l.Separator) && s.push(new l.Separator), a.enabled("symbol_info") && (e instanceof F.StudyCompare || e instanceof W.study_Overlay) && null !== e.symbolInfo() && (s.push(this._createActionShowSymbolInfoDialog(e, this._chartWidget.model().model().availableUnits())), s.push(new l.Separator)), s.push(this._createVisualOrderAction([e])), !(e.constructor instanceof S.NonSeriesStudy)) {
							const t = this._createActionMove(e);
							null !== t && s.push(t), s.push(this._createActionScale(e))
						}
						s.push(new l.Separator);
						const r = e.metaInfo();
						if (!(0, d.isFundamentalStudy)(e) && r.pine && t.viewSourceCode && (s.push(t.viewSourceCode), s.push(new l.Separator), t.viewSourceCode.update({
								disabled: !1
							}), (0, P.isAuthToGetPineSourceCode)(r.scriptIdPart, r.pine.version).done((e => {
								e || t.viewSourceCode.update({
									disabled: !0
								})
							})).fail((e => {
								Z.logError("Failed isAuthToGetPineSourceCode, reason: " + e)
							}))), e.copiable()) {
							const t = new l.Action({
								actionId: "Chart.Clipboard.CopySource",
								label: kt,
								shortcutHint: (0, R.humanReadableHash)(R.Modifiers.Mod + 67),
								statName: "Copy",
								onExecute: () => {
									this._chartWidget.chartWidgetCollection().clipboard.uiRequestCopy([e])
								}
							});
							s.push(t)
						}
						s.push(i ? this._createActionHide(e) : this._createActionShow(e)), s.push(t.studyRemove), this._chartWidget.onWidget() || (s.push(new l.Separator), this._options.objectTree && t.paneObjectTree && s.push(t.paneObjectTree)), s.push(new l.Separator), a.enabled("property_pages") && new v.MetaInfoHelper(r).hasUserEditableOptions() && s.push(this._createActionShowProperties(e)), s[s.length - 1] instanceof l.Separator && s.pop()
					}
					return s
				}
				_createEditAlertDrawingAction(e) {
					return new g.TVAction({
						label: ye.format({
							title: e.title()
						}),
						icon: L,
						statName: "EditAlert",
						onExecute: () => {
							window.runOrSignIn((() => {
								e.editAlert("pane_context_menu_edit_alert")
							}), {
								source: "Alert edit from pane context menu"
							})
						}
					})
				}
				_createLineToolTemplateAction(e) {
					{
						const t = this._chartWidget.model(),
							s = i => {
								t.applyLineToolTemplate(e, i, pe)
							};
						return new l.ActionAsync("Chart.LineTool.Templates", (async () => {
							const {
								LinetoolTemplatesList: o
							} = await Promise.all([i.e(29594), i.e(91622), i.e(3177)]).then(i.bind(i, 157668)), r = new o(e.toolname, s), n = [], a = new l.Action({
								actionId: "Chart.LineTool.Templates.SaveAs",
								label: At,
								statName: "SaveAs",
								onExecute: () => {
									r.showSaveDialog((t => {
										const i = JSON.stringify(e.template());
										r.saveTemplate(t, i)
									}))
								}
							});
							n.push(a);
							const c = new l.Action({
								actionId: "Chart.LineTool.Templates.ApplyDefaults",
								label: It,
								statName: "ApplyDefault",
								onExecute: () => {
									t.restorePropertiesForSource(e), window.lineToolPropertiesToolbar.onSourceChanged([e])
								}
							});
							return n.push(c), new Promise((e => {
								r.templatesLoaded().then((() => {
									var e;
									const t = null !== (e = r.getData()) && void 0 !== e ? e : [];
									t.length > 0 && n.push(new l.Separator), t.forEach(((e, t) => {
										const i = new l.Action({
											actionId: "Chart.LineTool.Templates.Apply",
											label: e,
											statName: "ApplyTemplate",
											onExecute: () => r.loadTemplate(e),
											toolbox: {
												type: V.ToolboxType.Delete,
												action: () => {
													r.deleteAction(e)
												}
											},
											showToolboxOnHover: !0
										});
										n.push(i)
									}))
								}), (e => {
									Z.logWarn(e)
								})).then((() => {
									e({
										label: Et,
										statName: "Template",
										subItems: n
									})
								}))
							}))
						}))
					}
				}
				_createActionToggleLockLineTools(e) {
					const t = e[0].properties().frozen.value(),
						s = t ? Nt : Bt;
					return new l.Action({
						actionId: "Chart.SelectedObject.ToggleLocked",
						label: s,
						statName: "ToggleLockSelectedObject",
						checkable: !0,
						icon: i(t ? 397874 : 902872),
						onExecute: () => {
							if (1 === e.length) this._chartWidget.toggleLockSelectedObject();
							else {
								const i = t ? Se : ge,
									s = this._chartWidget.model();
								s.withMacro(i, (() => {
									e.forEach((e => {
										s.setProperty(e.properties().frozen, !t, i)
									}))
								}))
							}
						}
					})
				}
				async _contextMenuActionsForLineTool(e) {
					const t = [],
						o = this._chartWidget.actions(),
						n = this._chartWidget.model().model(),
						c = () => {
							t.push(this._createVisualOrderAction(e))
						},
						h = () => {
							const s = e.filter((e => e.cloneable()));
							if (s.length > 0) {
								const e = new l.Action({
									actionId: "Chart.LineTool.Clone",
									label: Lt,
									icon: i(201457),
									shortcutHint: (0, R.humanReadableModifiers)(R.Modifiers.Mod) + "Drag",
									statName: "Clone",
									onExecute: () => this._chartWidget.model().cloneLineTools(s, !1)
								}, "Clone");
								t.push(e)
							}
							return !!s.length
						},
						d = () => {
							const i = e.filter((e => e.copiable()));
							if (i.length > 0) {
								const e = new l.Action({
									actionId: "Chart.Clipboard.CopyLineTools",
									label: kt,
									shortcutHint: (0, R.humanReadableHash)(R.Modifiers.Mod + 67),
									statName: "Copy",
									onExecute: () => this._chartWidget.chartWidgetCollection().clipboard.uiRequestCopy(i)
								}, "Copy");
								t.push(e)
							}
							return !!i.length
						},
						u = () => {
							const i = hi(this._chartWidget, e);
							return t.push(...i), i.length > 0
						},
						_ = async e => {
							if (this._chartWidget.model().isInReplay()) return;
							const i = e.getOrderTemplate();
							if (null === i) return;
							const o = (0, f.tradingService)();
							if (null !== o) {
								const e = o.activeBroker();
								if (e && 1 === e.connectionStatus() && e.metainfo().configFlags.supportLimitOrders) {
									const o = n.mainSeries();
									i.symbol = o.proSymbol();
									if ((await e.isTradable(i.symbol)).tradable) {
										const {
											qty: {
												step: o
											}
										} = await e.symbolInfo(i.symbol);
										i.qty = function(e, t) {
											return (0, r.Big)(e).div(t).round(void 0, 0).mul(t).toNumber()
										}(i.qty, o), t.push(new l.Separator), t.push(function(e) {
											const t = (0, s.ensureNotNull)((0, f.tradingService)());
											return new l.Action({
												actionId: "Chart.LineTool.CreateLimitOrderFromState",
												label: Te,
												statName: "CreateLimitOrder",
												onExecute: () => {
													t.trackEvent("Chart Context Menu", "RiskRewardCreateLimitOrder"), (0, s.ensureNotNull)(t.brokerCommandsUI()).placeOrder(e)
												}
											})
										}(i))
									}
								} else null === e && (t.push(new l.Separator), t.push((0, s.ensureNotNull)(function() {
									const e = (0, s.ensureNotNull)((0, f.tradingService)());
									return new g.TVAction({
										label: Te,
										statName: "ShowSelectBrokerNotification",
										onExecute: () => {
											var t;
											(0, B.isMobileTradingAvailable)() && !(null === (t = window.TradingView.bottomWidgetBar) || void 0 === t ? void 0 : t.isVisible().value()) ? e.toggleTradingPanelPopup(): e.toggleTradingWidget(), e.onNeedSelectBroker.fire()
										}
									})
								}())))
							}
						}, m = e => {
							const i = new l.Action({
								actionId: "Chart.ScrollToLineTool",
								label: Dt.format({
									lineToolName: e.title()
								}),
								statName: "GoToLineTool",
								checkable: !1,
								onExecute: async () => this._chartWidget.model().scrollToLineTool(e)
							});
							t.push(i)
						}, p = e => {
							const t = this._chartWidget.model().model().lineToolsGroupModel(),
								i = e.map((e => t.groupForLineTool(e)));
							return new Set(i).size <= 1
						};
					if (1 === e.length) {
						const i = e[0];
						if (this._chartWidget.readOnly()) t.push(o.lineHide);
						else if (i.userEditEnabled()) {
							if (a.enabled("alerts") && !this._chartWidget.onWidget())
								if (i.hasAlert && i.hasAlert.value()) t.push(this._createEditAlertDrawingAction(i)), t.push(new l.Separator);
								else if (i.canHasAlert()) {
								const e = si(this._chartWidget, {
									drawing: i
								});
								null !== e && (t.push(e), t.push(new l.Separator))
							} {
								const e = this._createLineToolTemplateAction(i);
								null !== e && t.push(e)
							}
							c(), this._options.objectTree && o.paneObjectTree && t.push(o.paneObjectTree), await _(i), t.push(new l.Separator);
							let e = h();
							e = d() || e, e = u() || e, e && t.push(new l.Separator), t.push(this._createActionToggleLockLineTools([i])), t.push(o.lineHide), t.push(o.lineRemove), i.points().length > 0 && this._options.gotoLineTool && (t.push(new l.Separator), m(i));
							const s = await this._chartWidget.propertiesDefinitionsForSource(i);
							if (a.enabled("property_pages") && null !== s && (t.push(new l.Separator), t.push(o.format)), i.additionalActions) {
								t.push(new l.Separator);
								const e = i.additionalActions(this._chartWidget.model());
								t.push(...e)
							}
						}
					} else this._options.objectTree && o.paneObjectTree && t.push(o.paneObjectTree), p(e) && c(), t.length > 0 && t.push(new l.Separator), h(), d(), u(), t.push(new l.Separator), t.push(this._createActionToggleLockLineTools(e)), t.push(o.lineHide), t.push(o.lineRemove), a.enabled("property_pages") && (t.push(new l.Separator), t.push(o.format));
					return t
				}
				_createEarningsShow() {
					const e = this._chartWidget.model().mainSeries().properties().childs().esdShowEarnings;
					return new g.TVAction({
						label: Ot,
						checkable: !0,
						checked: e.value(),
						name: "ToggleShowEarnings",
						statName: "ToggleShowEarnings",
						onExecute: t => this._chartWidget.model().setProperty(e, t.isChecked(), se)
					})
				}
				_createRollDatesShow() {
					const e = this._chartWidget.model().mainSeries().properties().childs().showContinuousContractSwitches;
					return new g.TVAction({
						label: Wt,
						checkable: !0,
						checked: e.value(),
						name: "ToggleShowContractSwitches",
						statName: "ToggleShowContractSwitches",
						onExecute: t => this._chartWidget.model().setProperty(e, t.isChecked(), ne)
					})
				}
				_createDividendsShow() {
					const e = this._chartWidget.model().mainSeries().properties().childs().esdShowDividends;
					return new g.TVAction({
						label: Rt,
						checkable: !0,
						checked: e.value(),
						name: "ToggleShowDividends",
						statName: "ToggleShowDividends",
						onExecute: t => this._chartWidget.model().setProperty(e, t.isChecked(), oe)
					})
				}
				_createSplitsShow() {
					const e = this._chartWidget.model().mainSeries().properties().childs().esdShowSplits;
					return new g.TVAction({
						checkable: !0,
						label: Vt,
						checked: e.value(),
						name: "ToggleShowSplits",
						statName: "ToggleShowSplits",
						onExecute: t => this._chartWidget.model().setProperty(e, t.isChecked(), re)
					})
				}
				_contextMenuActionsForESD() {
					const e = [];
					return this._chartWidget.readOnly() || e.push((0, s.ensureNotNull)(this._createDividendsShow()), (0, s.ensureNotNull)(this._createSplitsShow()), (0, s.ensureNotNull)(this._createEarningsShow())), e
				}
				_contextMenuActionsForRollDates() {
					const e = [];
					return this._chartWidget.readOnly() || e.push((0, s.ensureNotNull)(this._createRollDatesShow())), e
				}
				_contextMenuActionsForPublishedTimeline(e) {
					const t = this._chartWidget.actions(),
						i = [];
					if (i.push(t.lineHide), window.is_authenticated) {
						const t = e.properties().childs().filter,
							s = new g.TVAction({
								checked: t.value() === x.PublishedChartsFilter.None,
								checkable: !0,
								label: Ft,
								name: "ToggleAllIdeas",
								statName: "ToggleAllIdeas",
								onExecute: () => this._chartWidget.model().setProperty(t, x.PublishedChartsFilter.None, ae)
							}),
							o = new g.TVAction({
								checked: t.value() === x.PublishedChartsFilter.Following,
								checkable: !0,
								label: zt,
								name: "ToggleIdeasOfPeopleAndUser",
								statName: "ToggleIdeasOfPeopleAndUser",
								onExecute: () => this._chartWidget.model().setProperty(t, x.PublishedChartsFilter.Following, le)
							}),
							r = new g.TVAction({
								checked: t.value() === x.PublishedChartsFilter.Private,
								checkable: !0,
								label: Ut,
								name: "ToggleUserIdeas",
								statName: "ToggleUserIdeas",
								onExecute: () => this._chartWidget.model().setProperty(t, x.PublishedChartsFilter.Private, ce)
							});
						i.push(new l.Separator, s, o, r)
					}
					return i
				}
				_contextMenuActionsForTradingDrawings(e) {
					return e.contextMenuItems()
				}
				_createAlertToggleHorzLineLabelAction(e) {
					const t = (0, m.getSettingsProperty)().childs().line.childs().visible,
						i = t.value() ? Q : $,
						s = t.value() ? "turn_off_line" : "turn_on_line";
					return new g.TVAction({
						checkable: !0,
						label: Ce,
						checked: t.value(),
						statName: "ToggleExtendAlertLine",
						onExecute: () => ((0, _.trackEvent)("chart_alert", s, e), this._chartWidget.model().setProperty(t, !t.value(), i))
					})
				}
				_contextMenuActionsForAlertLabel(e, t) {
					const i = `chart_alert_context_menu_${null!=t?t:"line"}`,
						s = "chart_alert",
						o = [];
					return e.get("active") ? o.push(T.ActionCreators.stopAlert(e, (() => {
							(0, _.trackEvent)(s, "stop", i)
						}))) : o.push(T.ActionCreators.restartAlert(e, "alert_label_context_menu_restart")), o.push(T.ActionCreators.editAlert(e, "alert_label_context_menu_edit", void 0, (() => {
							(0, _.trackEvent)(s, "edit", i)
						}))),
						o.push(T.ActionCreators.deleteAlert(e, (() => {
							(0, _.trackEvent)(s, "delete", i)
						}))), o.push(new l.Separator), o.push(this._createAlertToggleHorzLineLabelAction(i)), o
				}
				_contextMenuActionsForChartEvents(e) {
					const t = [];
					if (a.enabled("property_pages")) {
						const e = new g.TVAction({
							label: Ht,
							statName: "Format",
							onExecute: () => this._chartWidget.showGeneralChartProperties(u.TabNames.eventsAndAlerts)
						});
						t.push(e)
					}
					const i = new g.TVAction({
						label: Gt,
						name: "HideEvents",
						statName: "HideEvents",
						onExecute: () => this._chartWidget.model().setProperty(e.properties().childs().visible, !1, he)
					});
					return t.push(i), t
				}
				_createApplyToEntireLayoutCommand(e) {
					if (!this._chartWidget.chartWidgetCollection().applyIndicatorsToAllChartsAvailable()) return null;
					const t = this._chartWidget.model().model();
					if (e.parentSource() !== t.mainSeries()) return null;
					const i = (0, s.ensureNotNull)(t.paneForSource(e)),
						o = t.paneForSource(t.mainSeries()) === i,
						r = e instanceof F.StudyCompare && e.priceScale() === t.mainSeries().priceScale() && (0, s.ensureNotNull)(e.priceScale()).isPercentage(),
						n = o ? void 0 : t.panes().indexOf(i);
					let a = qt,
						c = ue,
						h = "AddStudyToEntireLayout";
					return (0, j.isSymbolSource)(e) && (a = jt, c = de, h = "AddSymbolToEntireLayout"), (0, d.isStudyStrategy)(e) && (a = Kt, c = _e, h = "AddStrategyToEntireLayout"), e instanceof D.Fundamental && (a = Yt, c = me, h = "AddFundamentalToEntireLayout"), new l.Action({
						actionId: "Chart.AddIndicatorToAllCharts",
						label: a,
						statName: h,
						onExecute: () => {
							const i = (0, s.ensureNotNull)((0, H.clipboardDataForSources)(t.id(), [e])),
								a = this._chartWidget.chartWidgetCollection(),
								l = {
									isOnMainPane: o,
									asCompare: r,
									paneIndex: n
								};
							a.applyIndicatorToAllCharts(this._chartWidget, i, l, c)
						}
					}, "applyStudyToEntireLayout")
				}
			}
		},
		20870: (e, t, i) => {
			"use strict";
			i.d(t, {
				clipboardDataForSources: () => n
			});
			var s = i(588537),
				o = i(140662),
				r = i(540968);

			function n(e, t) {
				if (1 === t.length && (0, o.isStudy)(t[0])) {
					const e = t[0];
					return {
						title: e.title(),
						sources: [{
							source: (0, s.ensureNotNull)(e.state()),
							type: "study"
						}]
					}
				}
				const i = {
					sources: [],
					title: ""
				};
				return i.sources = t.filter((e => e.copiable() && (0, r.isLineTool)(e))).map((t => {
					const i = {
						type: "drawing",
						geometry: t.geometry(),
						source: {
							...t.state(!1),
							points: t.normalizedPoints()
						},
						modelId: e
					};
					return delete i.source.alertId, i
				})), i.sources.length > 0 ? (1 === i.sources.length ? i.title = t[0].title && t[0].title() : i.title = "Drawings", i) : null
			}
		},
		125082: (e, t, i) => {
			"use strict";
			i.d(t, {
				shiftPressed: () => _,
				modifierPressed: () => m,
				globalEnvironmentState: () => p,
				ChartHotkeysListener: () => g
			});
			var s = i(398835),
				o = i(470316),
				r = i(515312),
				n = i(262325),
				a = i.n(n),
				l = i(443527);
			const c = new(a())(Boolean(s.pressedKeys.value() & o.Modifiers.Shift)),
				h = new(a())(Boolean(s.pressedKeys.value() & o.Modifiers.Mod)),
				d = new(a())(Boolean(s.pressedKeys.value() & o.Modifiers.Alt)),
				u = [o.Modifiers.None, o.Modifiers.Alt, o.Modifiers.Mod, o.Modifiers.Alt + o.Modifiers.Shift];

			function _() {
				return c
			}

			function m() {
				return h
			}

			function p() {
				return new l.EnvironmentState({
					altKey: d.value(),
					ctrlKey: m().value(),
					metaKey: m().value(),
					shiftKey: _().value()
				})
			}
			s.pressedKeys.subscribe((e => {
				c.setValue(Boolean(e & o.Modifiers.Shift)), h.setValue(Boolean(e & o.Modifiers.Mod)), d.setValue(Boolean(e & o.Modifiers.Alt))
			}));
			class g {
				constructor(e, t) {
					this._pressedKeyCode = null, this._boundKeydownHandler = null, this._boundKeyupHandler = null, this._chartWidget = e, this._parent = t, this._boundKeydownHandler = this._keydownHandler.bind(this), this._boundKeyupHandler = this._keyupHandler.bind(this), this._parent.ownerDocument.addEventListener("keydown", this._boundKeydownHandler), this._parent.ownerDocument.addEventListener("keyup", this._boundKeyupHandler)
				}
				destroy() {
					null !== this._boundKeydownHandler && (this._parent.ownerDocument.removeEventListener("keydown", this._boundKeydownHandler), this._boundKeydownHandler = null), null !== this._boundKeyupHandler && (this._parent.ownerDocument.removeEventListener("keyup", this._boundKeyupHandler), this._boundKeyupHandler = null)
				}
				_keydownHandler(e) {
					this._chartWidget.hasModel() && window.document.activeElement === window.document.body && this._chartWidget.isActive() && (this._handleMoveDrawingsKeyDown(e) || this._handleScrollKeyDown(e) || this._handleZoomKeyDown(e)) && e.preventDefault()
				}
				_keyupHandler(e) {
					this._chartWidget.hasModel() && this._handleScrollKeyUp(e)
				}
				_handleMoveDrawingsKeyDown(e) {
					const t = 255 & (0, o.hashFromEvent)(e),
						i = this._chartWidget.model();
					switch (t) {
						case 37:
							return i.moveSelectedToolsLeft();
						case 39:
							return i.moveSelectedToolsRight();
						case 38:
							return i.moveSelectedToolsUp();
						case 40:
							return i.moveSelectedToolsDown()
					}
					return !1
				}
				_handleScrollKeyDown(e) {
					if (null !== this._pressedKeyCode) return !1;
					const t = (0, o.hashFromEvent)(e),
						i = 255 & t,
						s = (0, o.modifiersFromEvent)(e);
					let n;
					if (37 === i) n = 1;
					else {
						if (39 !== i) return !1;
						n = -1
					}
					return !(o.isMacKeyboard && s === o.Modifiers.Mod || !u.includes(s)) && (!(0, r.isNativeUIInteraction)(t, e.target) && (this._pressedKeyCode = i, s === o.Modifiers.None ? this._chartWidget.scrollHelper().moveByBar(n) : s === o.Modifiers.Alt || s === o.Modifiers.Mod ? this._chartWidget.scrollHelper().move(n) : -1 === n ? this._chartWidget.model().timeScale().scrollToRealtime(!0) : this._chartWidget.model().timeScale().scrollToFirstBar(), !0))
				}
				_handleScrollKeyUp(e) {
					if (null === this._pressedKeyCode) return !1;
					const t = (0, o.hashFromEvent)(e);
					if ((0, r.isNativeUIInteraction)(t, e.target)) return !1;
					return (255 & t) === this._pressedKeyCode && (this._pressedKeyCode = null, this._chartWidget.scrollHelper().stopMove(), !0)
				}
				_handleZoomKeyDown(e) {
					const t = (0, o.hashFromEvent)(e),
						i = 255 & t;
					if ((0, o.modifiersFromEvent)(e) !== o.Modifiers.Mod || (0, r.isNativeUIInteraction)(t, e.target)) return !1;
					const s = this._chartWidget.model();
					if (38 === i) s.zoomIn();
					else {
						if (40 !== i) return !1;
						s.zoomOut()
					}
					return !0
				}
			}
		},
		557865: (e, t, i) => {
			"use strict";
			i.d(t, {
				ChartWidgetBase: () => cs
			});
			var s = i(588537),
				o = i(575932),
				r = i(911905),
				n = i(228243),
				a = i(62802),
				l = i(638456),
				c = i(579917),
				h = i(251954),
				d = i(333126),
				u = i(941285),
				_ = i(270617),
				m = i(344435),
				p = i(232252);
			var g = i(540968),
				S = i(140662),
				v = i(346090),
				f = i(388230),
				b = i(316230),
				y = i(410864),
				C = i(86441),
				w = i(679520),
				T = i(277036),
				P = i(420808),
				M = i(198796),
				x = i(218718),
				I = i(781995),
				A = i(443527),
				k = i(831845),
				L = i(308170),
				E = i(761233),
				D = i(483306),
				N = i(830484),
				B = i(824112),
				O = i(164149),
				R = i(208214),
				V = i(440135),
				W = i(832164),
				F = i(232729),
				z = i(588427);
			const U = parseInt(F.labelheight),
				H = parseInt(F.bottommargin);

			function G(e) {
				return e / 11
			}
			class j {
				constructor() {
					this._wrapper = document.createElement("div"), this._element = document.createElement("div"), this._labelElement = document.createElement("div"), this._gearElement = document.createElement("div"), this._currentScale = 1, this._info = null, this._mode = "auto", this._wrapper.appendChild(this._element), this._wrapper.classList.add(F.wrapper), this._element.classList.add(F.label), this._labelElement.className = F.symbol, this._element.appendChild(this._labelElement), this._gearElement.className = F.gear, this._gearElement.innerHTML = W, this._element.appendChild(this._gearElement)
				}
				getElement() {
					return this._wrapper
				}
				setMode(e) {
					this._mode !== e && (this._mode = e)
				}
				align(e, t) {
					const i = G(t);
					Math.abs(i - this._currentScale) > .1 && (this._currentScale = i, Math.abs(this._currentScale - 1) > .1 ? this._element.style.transform = `scale(${this._currentScale})` : (this._currentScale = 1, this._element.style.transform = ""))
				}
				drawLabelForScreenshot(e, t) {
					if (null === this._info || "gear" === this._mode) return;
					const i = (0, R.makeFont)(t.fontSize, z.CHART_FONT_FAMILY);
					e.fillStyle = V.themes[t.theme].getThemedColor("color-price-axis-label-back"), e.globalAlpha = .5, e.beginPath();
					const s = G(t.fontSize) * U / 2,
						o = (0, C.point)(t.offset + t.width / 2, t.height / 2);
					e.arc(o.x, o.y, s, 0, 2 * Math.PI, !0), e.fill(), e.globalAlpha = 1, e.fillStyle = V.themes[t.theme].getThemedColor("color-price-axis-label-text"), e.textAlign = "center", e.font = i, e.textBaseline = "middle", e.fillText(this._info.label, o.x, o.y)
				}
				setAxisNameInfo(e) {
					this._info = e, null !== e && (this._labelElement.textContent = e.label)
				}
				static height(e) {
					return (U + H) * e
				}
			}
			var q = i(97639),
				K = i.n(q),
				Y = i(1891),
				X = i(499994);
			const Z = {
				enableTooltip: !0,
				showLabels: !0,
				enableMenu: !0,
				enableHighlight: !0
			};
			class $ {
				constructor(e, t, i, s, o, r = null) {
					this._invalidated = !0, this._size = new B.Size(0, 0), this._offset = 0, this._axisInfo = null, this._onLabelHovered = new(K()), this._highlighted = !1, this._labelMode = "auto", this._fixedLabelMode = null, this._canvasConfiguredHandler = () => this.update(), this._timeAxisWidget = r, this._isLeft = "left" === e, this._rendererOptionsProvider = s.rendererOptionsProvider, this._sourcesTitlesProvider = s.sourcesTitlesProvider, this._contextMenuItemsProvider = s.contextMenuItemsProvider, this._backgroundBasedTheme = s.backgroundBasedTheme, this._getBackgroundTopColor = s.getBackgroundTopColor, this._getBackgroundBottomColor = s.getBackgroundBottomColor, this._showHorizontalBorder = Boolean(s.showHorizontalBorder), this._properties = t, this._axisInfo = i, this._labelOptions = {
							...Z,
							...o
						}, this._properties.lineColor.subscribe(this, this._onPropertyChanged), this._cell = document.createElement("div"), this._cell.classList.add(F["price-axis-stub"]), this._labelOptions.enableTooltip && this._cell.classList.add("apply-common-tooltip"), this._cell.style.width = "25px", this._cell.style.height = "100%", this._cell.style.position = "absolute", this._cell.style.left = "0", this._cell.style.overflow = "hidden", this._labelOptions.showLabels ? (this._label = new j, this._label.setAxisNameInfo(this._axisInfo), this._cell.appendChild(this._label.getElement()), this._labelOptions.enableTooltip && (0, X.setTooltipData)(this._cell, "text", (e => this._tooltipContent()))) : this._label = null,
						this._mouseEventHandler = new N.MouseEventHandler(this._cell, this, {
							treatHorzTouchDragAsPageScroll: !0,
							treatVertTouchDragAsPageScroll: !0
						}), this._canvasBinding = (0, B.createBoundCanvas)(this._cell, new B.Size(16, 16)), this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
					const n = this._canvasBinding.canvasElement;
					n.style.position = "absolute", n.style.left = "0", n.style.top = "0"
				}
				destroy() {
					this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler), this._canvasBinding.dispose(), this._properties.lineColor.unsubscribe(this, this._onPropertyChanged), this._mouseEventHandler.destroy()
				}
				mouseEnterEvent(e) {
					this._mouseOrTouchEnterEvent(e)
				}
				touchStartEvent(e) {
					this._mouseOrTouchEnterEvent(e)
				}
				mouseLeaveEvent(e) {
					this._mouseOrTouchLeaveEvent(e)
				}
				touchEndEvent(e) {
					this._mouseOrTouchLeaveEvent(e)
				}
				mouseClickEvent(e) {
					this._mouseClickOrTapEvent(e)
				}
				tapEvent(e) {
					this._mouseClickOrTapEvent(e)
				}
				update() {
					this._invalidated = !0
				}
				getElement() {
					return this._cell
				}
				onLabelHovered() {
					return this._onLabelHovered
				}
				setSizeAndOffset(e, t) {
					if (e.w < 0 || e.h < 0) throw new Error("Try to set invalid size to PriceAxisStub " + JSON.stringify(e));
					this._size.equals(e) || (this._size = e, this._canvasBinding.resizeCanvasElement({
						width: e.w,
						height: e.h
					}), this._cell.style.width = `${e.w}px`, this._cell.style.minWidth = `${e.w}px`, this._cell.style.height = `${e.h}px`, this._invalidated = !0), this._offset !== t && (this._offset = t, this._cell.style.left = `${t}px`)
				}
				paint(e) {
					if (e < f.InvalidationLevel.Light && !this._invalidated) return;
					if (0 === this._size.w || 0 === this._size.h) return;
					this._invalidated = !1, this._canvasBinding.applySuggestedBitmapSize();
					const t = (0, B.getBindingPixelRatio)(this._canvasBinding),
						i = (0, B.getContext2D)(this._canvasBinding.canvasElement);
					this._drawBackground(i, t), this._drawVerticalBorder(i, t), this._showHorizontalBorder && this._drawHorizontalBorder(i, t)
				}
				getWidth() {
					return this._size.w
				}
				getImage() {
					const e = (0, B.createDisconnectedCanvas)(document, this._size),
						t = (0, B.getPrescaledContext2D)(e),
						i = this._getBackgroundTopColor(),
						s = this._getBackgroundBottomColor();
					return i === s ? (0, B.clearRect)(t, 0, 0, this._size.w, this._size.h, i) : (0, O.clearRectWithGradient)(t, 0, 0, this._size.w, this._size.h, i, s), t.drawImage(this._canvasBinding.canvasElement, 0, 0, this._size.w, this._size.h), null !== this._label && this._label.drawLabelForScreenshot(t, {
						offset: 0,
						width: this._size.w,
						height: this._size.h,
						fontSize: this._properties.fontSize.value(),
						theme: this._backgroundBasedTheme.value()
					}), e
				}
				setLabelMode(e) {
					e !== this._labelMode && (this._labelMode = e, null !== this._label && this._label.setMode(e), this._cell.classList.toggle(F["fixed-gear"], "gear" === e), this._cell.classList.toggle(F["fixed-symbol"], "symbol" === e), this._cell.classList.toggle("apply-common-tooltip", "symbol" !== e && this._labelOptions.enableTooltip))
				}
				_setHighlighted(e) {
					this._labelOptions.enableHighlight && (this._onLabelHovered.fire("stubButton", e), this._highlighted !== e && (this._highlighted = e, this._invalidated = !0))
				}
				_onPropertyChanged() {
					this._invalidated = !0
				}
				_drawVerticalBorder(e, t) {
					const i = this._size.w;
					e.save(),
						e.fillStyle = this._properties.lineColor.value();
					const s = Math.max(1, Math.floor(this._rendererOptionsProvider.options().borderSize * t)),
						o = this._isLeft ? Math.floor(i * t) - s : 0,
						r = Math.ceil(this._size.h * t);
					e.fillRect(o, 0, s, r + 1), e.restore()
				}
				_drawHorizontalBorder(e, t) {
					var i, s;
					e.save(), e.fillStyle = null !== (s = null === (i = this._timeAxisWidget) || void 0 === i ? void 0 : i.lineColor()) && void 0 !== s ? s : this._properties.lineColor.value();
					const o = Math.max(1, Math.floor(this._rendererOptionsProvider.options().borderSize * t)),
						r = Math.ceil(this._size.w * t),
						n = this._isLeft ? 0 : o;
					e.fillRect(n, 0, r - o, o), e.restore()
				}
				_drawBackground(e, t) {
					const i = Math.ceil(t * this._size.w),
						s = Math.ceil(t * this._size.h),
						o = this._getBackgroundTopColor(),
						r = this._getBackgroundBottomColor();
					if (o === r ? (0, B.clearRect)(e, 0, 0, i + 1, s + 1, o) : (0, O.clearRectWithGradient)(e, 0, 0, i + 1, s + 1, o, r), this._highlighted) {
						const t = V.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight");
						(0, B.fillRect)(e, 0, 0, i + 1, s + 1, t), e.globalAlpha = 1
					}
				}
				_tooltipContent() {
					return this._sourcesTitlesProvider().join("\n")
				}
				_mouseOrTouchEnterEvent(e) {
					null !== this._label && "symbol" !== this._labelMode && this._labelOptions.enableHighlight && this._setHighlighted(!0)
				}
				_mouseOrTouchLeaveEvent(e) {
					"symbol" !== this._labelMode && this._setHighlighted(!1)
				}
				_mouseClickOrTapEvent(e) {
					if (e.preventDefault(), null !== this._fixedLabelMode || "symbol" === this._labelMode || !this._labelOptions.enableMenu || !this._labelOptions.showLabels) return void Y.ContextMenuManager.hideAll();
					this._fixedLabelMode = this._labelMode, this.setLabelMode("gear");
					const t = this._cell.getBoundingClientRect();
					Y.ContextMenuManager.showMenu(this._contextMenuItemsProvider(), {
						clientX: this._isLeft ? t.left : t.right,
						clientY: t.top,
						attachToXBy: this._isLeft ? "left" : "right",
						attachToYBy: "bottom"
					}, {
						statName: "PriceScaleLabelContextMenu",
						doNotCloseOn: this.getElement()
					}, {
						menuName: "PriceScaleLabelContextMenu"
					}, (() => {
						this.setLabelMode((0, s.ensureNotNull)(this._fixedLabelMode)), this._fixedLabelMode = null
					}))
				}
			}
			var Q = i(617376);
			class J {
				constructor(e, t, i, s, o, r = null) {
					this._axises = [], this._stubs = [], this._size = new B.Size(0, 0), this._onLabelHovered = new(K()), this._scalesProperties = e, this._priceAxisWidgetFactory = i, this._timeAxisWidget = r, this._rendererOptionsProvider = s.rendererOptionsProvider, this._titlesProvider = s.titlesProvider, this._stubContextMenuProvider = s.stubContextMenuProvider, this._backgroundBasedTheme = s.backgroundBasedTheme, this._getBackgroundTopColor = s.getBackgroundTopColor, this._getBackgroundBottomColor = s.getBackgroundBottomColor, this._showHorisontalBorder = Boolean(s.showHorizontalBorder), this._labelsOptions = {
						...Z,
						...o
					};
					const n = this._scalesProperties.childs();
					this._stubProperties = {
						lineColor: n.lineColor,
						fontSize: n.fontSize
					}, this._side = t, this._cell = document.createElement("td"), this._cell.classList.add("chart-markup-table", "price-axis-container"), this._cell.style.width = "25px", this._cell.style.position = "relative"
				}
				destroy() {
					this.setScales([], 0, 0, 0)
				}
				onLabelHovered() {
					return this._onLabelHovered
				}
				setScales(e, t, i, o) {
					for (; e.length > this._axises.length && this._axises.length < t;) {
						const e = (0,
								Q.getPriceAxisNameInfo)(this._side, this._axises.length),
							t = this._priceAxisWidgetFactory(this._side, this._rendererOptionsProvider, this._scalesProperties, e, this._backgroundBasedTheme);
						this._axises.push(t), this._cell.appendChild(t.getElement())
					}
					for (; e.length < this._axises.length;) {
						const e = (0, s.ensureDefined)(this._axises.pop());
						this._cell.removeChild(e.getElement()), e.destroy()
					}
					for (let t = 0; t < this._axises.length; ++t) this._axises[t].setPriceScale(e[t]);
					const r = t - e.length,
						n = Math.max(0, r);
					for (; this._stubs.length > n;) {
						const e = (0, s.ensureDefined)(this._stubs.pop());
						e.onLabelHovered().unsubscribeAll(this), this._cell.removeChild(e.getElement()), e.destroy()
					}
					for (; this._stubs.length < r;) {
						const e = this._labelsOptions.showLabels ? (0, Q.getPriceAxisNameInfo)(this._side, this._stubs.length) : null,
							t = new $(this._side, this._stubProperties, e, this._stubParams(this._stubs.length), this._labelsOptions, this._timeAxisWidget);
						t.onLabelHovered().subscribe(this, ((t, i) => {
							this._labelsOptions.showLabels && this._labelsOptions.enableHighlight && this._onLabelHovered.fire({
								owner: t,
								axis: (0, s.ensureNotNull)(e)
							}, i)
						})), this._stubs.push(t), this._cell.appendChild(t.getElement())
					}
					const a = this._labelsOptions.enableMenu;
					1 === o ? this._stubs.forEach(((e, t) => e.setLabelMode(a ? "gear" : "symbol"))) : this._stubs.forEach(((e, t) => e.setLabelMode(t < i && a ? "auto" : "symbol")))
				}
				getElement() {
					return this._cell
				}
				updateCurrencyLabels() {
					return this._axises.forEach((e => e.updateCurrencyLabel()))
				}
				optimalWidths() {
					return this._axises.map((e => e.optimalWidth()))
				}
				setSizes(e, t) {
					this._size = new B.Size(t.reduce(((e, t) => e + t), 0), e), this._cell.style.width = this._size.w + "px", this._cell.style.minWidth = this._size.w + "px", this._cell.style.height = this._size.h + "px", t.length !== this._axises.length + this._stubs.length && (0, s.assert)(t.length === this._axises.length + this._stubs.length, "Widgets count should be the same as widths one");
					let i = 0;
					this._forEachWidgetFromLeft(((s, o) => {
						const r = t[o];
						s.setSizeAndOffset(new B.Size(r, e), i), i += r
					}))
				}
				update() {
					this._axises.forEach((e => e.update())), this._stubs.forEach((e => e.update()))
				}
				paint(e) {
					this._axises.forEach(((t, i) => t.paint(e(i)))), this._stubs.forEach(((t, i) => t.paint(e(i))))
				}
				paintStubs(e) {
					this._stubs.forEach((t => t.paint(e)))
				}
				restoreDefaultCursor() {
					this._axises.forEach((e => e.restoreDefaultCursor()))
				}
				getWidth() {
					return this._size.w
				}
				findAxisWidgetForScale(e) {
					const t = this._axises.find((t => t.priceScale() === e));
					return void 0 === t ? null : t
				}
				getScreenshotData() {
					const e = this._getImage();
					return {
						canvas: e,
						content: e.toDataURL(),
						contentHeight: this._size.h,
						contentWidth: this._size.w
					}
				}
				getImage() {
					return this._getImage()
				}
				slotsCount() {
					return this._axises.length + this._stubs.length
				}
				highlightPriceAxisByLabel(e) {
					this._axises.forEach((t => {
						const i = t.axisInfo();
						t.setHighlighted(null !== i && i.equals(e))
					}))
				}
				axes() {
					return this._axises
				}
				_stubParams(e) {
					return {
						rendererOptionsProvider: this._rendererOptionsProvider,
						backgroundBasedTheme: this._backgroundBasedTheme,
						sourcesTitlesProvider: () => this._titlesProvider(this._side, e),
						contextMenuItemsProvider: () => this._stubContextMenuProvider(this._side, e),
						getBackgroundTopColor: this._getBackgroundTopColor,
						getBackgroundBottomColor: this._getBackgroundBottomColor,
						showHorizontalBorder: this._showHorisontalBorder
					}
				}
				_getImage() {
					const e = (0, B.createDisconnectedCanvas)(document, this._size),
						t = (0, B.getPrescaledContext2D)(e);
					let i = 0;
					return this._forEachWidgetFromLeft(((e, s) => {
						const o = e.getWidth();
						0 !== o && (t.drawImage(e.getImage(), i, 0, o, this._size.h), i += o)
					})), e
				}
				_forEachWidgetFromLeft(e) {
					const t = [...this._axises, ...this._stubs],
						i = "left" === this._side,
						s = i ? -1 : t.length,
						o = i ? -1 : 1;
					for (let r = i ? t.length - 1 : 0; r !== s; r += o) e(t[r], r, t)
				}
			}
			var ee = i(72461),
				te = i(171670),
				ie = i(405222),
				se = i(345848),
				oe = i(724377),
				re = i(721386),
				ne = i(909740),
				ae = i(61499),
				le = i(466915),
				ce = i(855824),
				he = i(942885);
			const de = (0, w.getHexColorByName)("color-white"),
				ue = (0, w.getHexColorByName)("color-cold-gray-100"),
				_e = (0, re.applyTransparency)((0, w.getHexColorByName)("color-white"), 60),
				me = (0, w.getHexColorByName)("color-cold-gray-800"),
				pe = (0, re.applyTransparency)((0, w.getHexColorByName)("color-black"), 60);

			function ge(e) {
				const t = (0, re.isHexColor)(e) ? e.toLowerCase() : (0, oe.rgbToHexString)((0, oe.parseRgb)(e));
				return ne.watchedTheme.value() === ae.StdTheme.Light ? t === de ? ue : _e : "#181c27" === t ? me : pe
			}
			class Se {
				constructor() {
					this._width = null, this._currencyInfo = null, this._unitInfo = null, this._measureUnitIdInfo = null, this._fontSize = 0, this._backgroundColor = "", this._hoverColor = "", this._fadeEndColor = "", this._hoveredLabel = null, this._currencyAndUnitLabelsWrapper = document.createElement("div"), this._currencyAndUnitLabelsWrapper.className = he["price-axis-currency-label-wrapper"], this._controlsContainer = document.createElement("div"), this._controlsContainer.className = he["price-axis-currency-label"], this._currencyAndUnitLabelsWrapper.appendChild(this._controlsContainer), this._currencyLabelDiv = document.createElement("div"), this._currencyLabelDiv.className = he.row, this._currencyLabelDiv.classList.add("apply-common-tooltip"), (0, X.setTooltipData)(this._currencyLabelDiv, "text", (e => this._currencyTooltipContent())), this._currencyText = document.createElement("span"), this._currencyText.className = he["price-axis-currency-label-text"], this._currencyLabelDiv.appendChild(this._currencyText), this._currencyArrowDown = document.createElement("span"), this._currencyArrowDown.className = he["price-axis-currency-label-arrow-down"], this._currencyArrowDown.innerHTML = ce, this._currencyLabelDiv.appendChild(this._currencyArrowDown), this._measureUnitIdLabelDiv = document.createElement("div"), this._measureUnitIdLabelDiv.className = he.row, this._measureUnitIdLabelDiv.classList.add("apply-common-tooltip"), this._measureUnitIdLabelDiv.classList.add("readonly"), (0, X.setTooltipData)(this._measureUnitIdLabelDiv, "text", (e => this._measureUnitIdTooltipContent())), this._measureUnitIdText = document.createElement("span"), this._measureUnitIdText.className = he["price-axis-currency-label-text"], this._measureUnitIdLabelDiv.appendChild(this._measureUnitIdText), this._unitLabelDiv = document.createElement("div"), this._unitLabelDiv.className = he.row, this._unitLabelDiv.classList.add("apply-common-tooltip"), (0,
						X.setTooltipData)(this._unitLabelDiv, "text", (e => this._unitTooltipContent())), this._unitText = document.createElement("span"), this._unitText.className = he["price-axis-currency-label-text"], this._unitLabelDiv.appendChild(this._unitText), this._unitArrowDown = document.createElement("span"), this._unitArrowDown.className = he["price-axis-currency-label-arrow-down"], this._unitArrowDown.innerHTML = ce, this._unitLabelDiv.appendChild(this._unitArrowDown), this._controlsContainer.appendChild(this._currencyLabelDiv), this._controlsContainer.appendChild(this._measureUnitIdLabelDiv), this._controlsContainer.appendChild(this._unitLabelDiv), this._fadeDiv = document.createElement("div"), this._fadeDiv.className = he["price-axis-currency-label-fade"], this._currencyAndUnitLabelsWrapper.appendChild(this._fadeDiv);
					const e = e => {
						null !== this._hoveredLabel && this._hoveredLabel !== e && (this._hoveredLabel.style.background = ""), e && e.classList.contains("readonly") || (this._hoveredLabel = e, "" === this._hoverColor && (this._hoverColor = ge(this._backgroundColor)), null !== e && (e.style.background = this._hoverColor))
					};
					this._currencyLabelDiv.addEventListener("mouseover", (() => e(this._currencyLabelDiv))), this._currencyLabelDiv.addEventListener("mouseout", (() => e(null))), this._unitLabelDiv.addEventListener("mouseover", (() => e(this._unitLabelDiv))), this._unitLabelDiv.addEventListener("mouseout", (() => e(null))), this.disableCurrency(), this.disableUnit()
				}
				element() {
					return this._currencyAndUnitLabelsWrapper
				}
				currencyLabelElement() {
					return this._currencyLabelDiv
				}
				unitLabelElement() {
					return this._unitLabelDiv
				}
				measureUnitIdLabelElement() {
					return this._measureUnitIdLabelDiv
				}
				isEnabled() {
					return this.currencyLabelEnabled() || this.unitLabelEnabled() || this.measureUnitIdLableEnabled()
				}
				width() {
					if (null !== this._width) return this._width;
					let e = 0;
					if (this.currencyLabelEnabled()) {
						const t = this._currencyText.getBoundingClientRect(),
							i = this._currencyArrowDown.getBoundingClientRect();
						e = Math.max(e, t.width + i.width + 2 * this._textMarginAndPadding())
					}
					if (this.measureUnitIdLableEnabled()) {
						const t = this._measureUnitIdText.getBoundingClientRect();
						e = Math.max(e, t.width + 2 * this._textMarginAndPadding())
					}
					if (this.unitLabelEnabled()) {
						const t = this._unitText.getBoundingClientRect(),
							i = this._unitArrowDown.getBoundingClientRect();
						e = Math.max(e, t.width + i.width + 2 * this._textMarginAndPadding())
					}
					return this._width = e
				}
				drawLabel(e, t, i) {
					var s, o, r;
					if (!this.isEnabled()) return;
					const n = [];
					n.push(this.currencyLabelEnabled() && null !== (s = this._currencyText.textContent) && void 0 !== s ? s : ""), n.push(this.measureUnitIdLableEnabled() && null !== (o = this._measureUnitIdText.textContent) && void 0 !== o ? o : ""), n.push(this.unitLabelEnabled() && null !== (r = this._unitText.textContent) && void 0 !== r ? r : ""), e.font = (0, R.makeFont)(this._fontSize, z.CHART_FONT_FAMILY);
					const a = new ie.TextWidthCache,
						l = n.map((t => "" === t ? 0 : a.yMidCorrection(e, t))),
						c = Math.round(Number(he.css_wrapper_margin) * i),
						h = (0, le.ceiledEven)(t * i) - 2 * c,
						d = Math.round(this.labelBottom() * i);
					e.fillStyle = this._backgroundColor, e.fillRect(c, 0, h, d);
					const u = Math.round(Number(he.css_fade_height) * i),
						_ = e.createLinearGradient(0, d, 0, d + u);
					_.addColorStop(0, this._backgroundColor), _.addColorStop(1, this._fadeEndColor), e.fillStyle = _;
					const m = Math.round(Number(he.css_value_currency_label_radius) * i);
					(0, O.drawRoundRect)(e, c, d, h, u, [0, 0, m, m]), e.fill(), e.fillStyle = this._controlsContainer.style.color, e.textBaseline = "middle", e.textAlign = "left";
					const p = Math.round(Number(he.css_first_row_top_padding) * i),
						g = Math.round(this._textMarginAndPadding() * i) + c,
						S = this._oneLineHeight() / 2 * i;
					let v = p + S;
					n.forEach(((t, s) => {
						"" !== t && ((0, B.drawScaled)(e, i, (() => e.fillText(t, g / i, (v + l[s]) / i))), v = Math.ceil(v + 2 * S))
					}))
				}
				setHidden(e) {
					this._controlsContainer.classList.toggle(he.hidden, e), this._fadeDiv.classList.toggle(he.hidden, e)
				}
				enableCurrency() {
					this._currencyLabelDiv.classList.remove("js-hidden"), this._width = null, this._updateVisibility()
				}
				disableCurrency() {
					this._currencyLabelDiv.classList.add("js-hidden"), this._width = null, this._updateVisibility()
				}
				enableUnit() {
					this._unitLabelDiv.classList.remove("js-hidden"), this._width = null, this._updateVisibility()
				}
				disableUnit() {
					this._unitLabelDiv.classList.add("js-hidden"), this._width = null, this._updateVisibility()
				}
				enableMeasureUnitId() {
					this._measureUnitIdLabelDiv.classList.remove("js-hidden"), this._width = null, this._updateVisibility()
				}
				disableMeasureUnitId() {
					this._measureUnitIdLabelDiv.classList.add("js-hidden"), this._width = null, this._updateVisibility()
				}
				currencyLabelEnabled() {
					return !this._currencyLabelDiv.classList.contains("js-hidden")
				}
				unitLabelEnabled() {
					return !this._unitLabelDiv.classList.contains("js-hidden")
				}
				measureUnitIdLableEnabled() {
					return !this._measureUnitIdLabelDiv.classList.contains("js-hidden")
				}
				currencyConversionAvailable() {
					return !this._currencyLabelDiv.classList.contains("readonly")
				}
				unitConversionAvailable() {
					return !this._unitLabelDiv.classList.contains("readonly")
				}
				setCurrencyInfo(e) {
					if (this._currencyInfo === e) return !1;
					this._currencyInfo = e;
					const t = null === e.selectedCurrency ? (0, o.t)("Mixed") : (0, s.ensureDefined)(e.displayedValues.get(e.selectedCurrency));
					return this._currencyText.textContent !== t && (this._currencyText.textContent = t, this._width = null), this._currencyArrowDown.classList.contains("js-hidden") !== e.readOnly && (this._currencyArrowDown.classList.toggle("js-hidden", e.readOnly), this._currencyLabelDiv.classList.toggle("readonly", e.readOnly), this._width = null), !0
				}
				setUnitInfo(e) {
					if (null !== this._unitInfo && this._unitInfo.selectedUnit === e.selectedUnit && 0 === this._unitInfo.availableGroups.size == (0 === e.availableGroups.size) && this._unitInfo.originalUnits.size === e.originalUnits.size) return this._unitInfo = e, !1;
					this._unitInfo = e;
					const t = null === e.selectedUnit ? (0, o.t)("Mixed") : (0, s.ensureDefined)(e.names.get(e.selectedUnit));
					return this._unitText.textContent !== t && (this._unitText.textContent = t, this._width = null), this._unitArrowDown.classList.contains("js-hidden") !== (0 === e.availableGroups.size) && (this._unitArrowDown.classList.toggle("js-hidden", 0 === e.availableGroups.size), this._unitLabelDiv.classList.toggle("readonly", 0 === e.availableGroups.size), this._width = null), !0
				}
				setMeasureUnitIdInfo(e) {
					if (this._measureUnitIdInfo === e) return !1;
					this._measureUnitIdInfo = e;
					const t = null === e.selectedMeasureUnitId ? (0, o.t)("Mixed") : (0, s.ensureDefined)(e.names.get(e.selectedMeasureUnitId));
					return this._measureUnitIdText.textContent !== t && (this._measureUnitIdText.textContent = t, this._width = null), this._measureUnitIdLabelDiv.classList.contains("js-hidden") !== (0 === e.names.size) && (this._measureUnitIdLabelDiv.classList.toggle("js-hidden", 0 === e.names.size), this._width = null), !0
				}
				updateColors(e, t) {
					this._controlsContainer.style.color = t, this._backgroundColor !== e && (this._backgroundColor = e, this._fadeEndColor = (0, re.applyTransparency)(e, 100), this._hoverColor = ge(e)), this._controlsContainer.style.background = this._backgroundColor, null !== this._hoveredLabel && (this._hoveredLabel.style.background = this._hoverColor), this._fadeDiv.style.background = `linear-gradient(${this._backgroundColor}, ${this._fadeEndColor})`
				}
				currencyInfo() {
					return this._currencyInfo
				}
				unitInfo() {
					return this._unitInfo
				}
				measureUnitIdInfo() {
					return this._measureUnitIdInfo
				}
				setFontSize(e) {
					this._fontSize !== e && (this._fontSize = e, this._currencyLabelDiv.style.fontSize = e + "px", this._measureUnitIdLabelDiv.style.fontSize = e + "px", this._unitLabelDiv.style.fontSize = e + "px", this._width = null, this._setLineHeight(this._oneLineHeight()))
				}
				labelBottom() {
					const e = this._oneLineHeight();
					let t = (this.currencyLabelEnabled() ? e : 0) + (this.measureUnitIdLableEnabled() ? e : 0) + (this.unitLabelEnabled() ? e : 0);
					return t > 0 && (t += Number(he.css_first_row_top_padding)), t
				}
				_textMarginAndPadding() {
					return Number(he.css_row_left_right_margin) + Number(he.css_row_left_right_padding)
				}
				_currencyTooltipContent() {
					const e = this._currencyInfo;
					return null === e ? "" : null === e.selectedCurrency ? Array.from(e.currencies).map((t => (0, s.ensureDefined)(e.displayedValues.get(t)))).join(", ") : e.displayedValues.get(e.selectedCurrency) || ""
				}
				_unitTooltipContent() {
					const e = this._unitInfo;
					return null === e ? "" : null === e.selectedUnit ? Array.from(e.units).map((t => (0, s.ensureDefined)(e.names.get(t)))).join(", ") : e.descriptions.get(e.selectedUnit) || ""
				}
				_measureUnitIdTooltipContent() {
					const e = this._measureUnitIdInfo;
					return null === e ? "" : null === e.selectedMeasureUnitId ? Array.from(e.measureUnitIds).map((t => (0, s.ensureDefined)(e.names.get(t)))).join(", ") : e.descriptions.get(e.selectedMeasureUnitId) || ""
				}
				_setLineHeight(e) {
					this._currencyLabelDiv.style.lineHeight = e + "px", this._measureUnitIdLabelDiv.style.lineHeight = e + "px", this._unitLabelDiv.style.lineHeight = e + "px"
				}
				_updateVisibility() {
					const e = this.isEnabled();
					this._currencyAndUnitLabelsWrapper.classList.toggle("js-hidden", !e), this._fadeDiv.classList.toggle("js-hidden", !e)
				}
				_oneLineHeight() {
					return 7 + this._fontSize
				}
			}
			async function ve(e, t, s, o) {
				const {
					UnitConversionRenderer: r
				} = await Promise.all([i.e(90519), i.e(8348), i.e(90926), i.e(8834), i.e(3086), i.e(30063), i.e(95468), i.e(80580), i.e(68074), i.e(52498), i.e(29331), i.e(5799), i.e(52019), i.e(11812), i.e(44177), i.e(1551), i.e(75514), i.e(92697), i.e(32704)]).then(i.bind(i, 300203));
				return new r(e, s, t, o)
			}

			function fe(e, t) {
				let {
					deltaX: i,
					deltaY: s
				} = e;
				switch (i /= 100, s /= 100, t.deltaMode) {
					case t.DOM_DELTA_PAGE:
						i *= 120, s *= 120;
						break;
					case t.DOM_DELTA_LINE:
						i *= 32, s *= 32
				}
				return {
					deltaX: i,
					deltaY: s
				}
			}
			class be {
				constructor() {
					this._totalDeltaX = 0, this._totalDeltaY = 0, this._prevWheelTime = 0
				}
				processWheel(e) {
					e.timeStamp - this._prevWheelTime > 100 && this._reset(), this._totalDeltaX += e.deltaX, this._totalDeltaY += e.deltaY, this._prevWheelTime = e.timeStamp;
					const t = {
						deltaX: e.deltaX,
						deltaY: e.deltaY
					};
					return 0 === this._totalDeltaX || 0 === this._totalDeltaY || (Math.abs(this._totalDeltaX) >= Math.abs(3 * this._totalDeltaY) && (t.deltaY = 0), Math.abs(this._totalDeltaY) >= Math.abs(3 * this._totalDeltaX) && (t.deltaX = 0)), fe(t, e)
				}
				_reset() {
					this._totalDeltaX = 0, this._totalDeltaY = 0
				}
			}
			var ye = i(470316),
				Ce = i(127085),
				we = i(396484),
				Te = i(611688),
				Pe = i(500099),
				Me = i(829770),
				xe = i(38627),
				Ie = i(139267);
			i(891148);
			const Ae = new T.TranslatedString("change no overlapping labels", (0, o.t)("change no overlapping labels")),
				ke = (0, o.t)("Merge all scales into one"),
				Le = (0, o.t)("Labels"),
				Ee = (0, o.t)("Currencies"),
				De = (0, o.t)("Units"),
				Ne = (0, o.t)("Reset price scale"),
				Be = (0, o.t)("Auto (fits data to screen)"),
				Oe = (0, o.t)("Percent", {
					context: "scale_menu"
				}),
				Re = (0, o.t)("Indexed to 100", {
					context: "scale_menu"
				}),
				Ve = (0, o.t)("Logarithmic", {
					context: "scale_menu"
				}),
				We = (0, o.t)("Regular", {
					context: "scale_menu"
				}),
				Fe = (0, o.t)("No overlapping labels", {
					context: "scale_menu"
				}),
				ze = (0, o.t)("Invert scale", {
					context: "scale_menu"
				});
			const Ue = function(e) {
					const t = new we.LimitedPrecisionNumericFormatter(e);
					return (e, i) => (0, _.isNumber)(i) && !e.isLog() ? t.format(i) : ""
				}(4),
				He = {
					contextMenuEnabled: !0,
					currencyConversionEnabled: !1,
					unitConversionEnabled: !1,
					countdownEnabled: !0,
					contextMenu: {
						general: !0,
						source: !0
					},
					pressedMouseMoveScale: !0,
					mouseWheelScale: !0,
					pinchScale: !0,
					croppedTickMarks: !0
				};
			class Ge {
				constructor(e, t, i, s, o, r, n, a, l) {
					this._actions = null, this._priceScale = null, this._widthCache = new ie.TextWidthCache(1e3), this._color = null, this._fontSize = null, this._currencyFontSize = 0, this._currencyLabelWidth = null, this._isVisible = !0, this._updateTimeout = null, this._currencyMenu = null, this._unitMenu = null, this._prevOptimalWidth = 0, this._size = new B.Size(-1, -1), this._currentCursorClassName = "", this._destroyed = !1, this._highlighted = !1, this._mouseWheelHelper = null, this._dragScaleActive = !1, this._offset = NaN, this._pinching = !1, this._lastHittestResult = null, this._recalcCurrencyAndUnitVisibility = () => {
							if (null === this._currencyLabel) return;
							let e = !0;
							switch ((0, xe.currencyUnitVisibilityProperty)().value()) {
								case "alwaysOff":
									e = !1;
									break;
								case "visibleOnMouseOver":
									const t = this._chart.anyPriceAxisHovered().value(),
										i = null !== this._currencyMenu && this._currencyMenu.isOpened(),
										s = null !== this._unitMenu && this._unitMenu.isOpened();
									e = t || i || s
							}
							this._currencyLabel.setHidden(!e)
						}, this._chart = e, this._pane = t, this._undoModel = i, this._properties = s, this._isLeft = "left" === r, this._options = (0, _.merge)((0, _.clone)(He), n), this._rendererOptionsProvider = o, this._backgroundBasedTheme = l, this._cell = document.createElement("div"), this._cell.className = "price-axis", this._cell.style.width = "25px", this._cell.style.left = "0", this._canvasConfiguredHandler = () => {
							this._undoModel.model().lightUpdate()
						}, this._canvasBinding = (0, B.createBoundCanvas)(this._cell, new B.Size(16, 16)),
						this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
					const c = this._canvasBinding.canvasElement;
					c.style.position = "absolute", c.style.zIndex = "1", c.style.left = "0", c.style.top = "0", this._topCanvasBinding = (0, B.createBoundCanvas)(this._cell, new B.Size(16, 16)), this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
					const h = this._topCanvasBinding.canvasElement;
					h.style.position = "absolute", h.style.zIndex = "2", h.style.left = "0", h.style.top = "0", this._mouseEventHandler = new N.MouseEventHandler(this._cell, this, {
						treatVertTouchDragAsPageScroll: !1,
						treatHorzTouchDragAsPageScroll: !0
					}), this._options.currencyConversionEnabled || this._options.unitConversionEnabled ? (this._currencyLabel = new Se, this._cell.appendChild(this._currencyLabel.element())) : this._currencyLabel = null, this._properties.childs().fontSize.subscribe(this, this._onFontSizeChanged), this._options.mouseWheelScale && (this._mouseWheelHelper = new be, this._cell.addEventListener("wheel", this._onMousewheel.bind(this), {
						passive: !1
					})), this._axisInfo = a, this._offset = 0, this.restoreDefaultCursor(), (0, xe.currencyUnitVisibilityProperty)().subscribe(this, this._recalcCurrencyAndUnitVisibility), this._chart.anyPriceAxisHovered().subscribe(this._recalcCurrencyAndUnitVisibility), this._recalcCurrencyAndUnitVisibility(), this.update()
				}
				getContextMenuActions() {
					this._initActions();
					const e = (0, s.ensureNotNull)(this._actions),
						t = this._chart.actions(),
						i = [];
					return i.push(e.reset, new Me.Separator, this._autoScaleAction()), this._isMainSeriesAxis() && i.push(this._lockScaleAction()), i.push(t.scaleSeriesOnly, this._invertAction(), new Me.Separator, this._regularScaleAction(), this._percentageAction(), this._indexedTo100Action(), this._logAction(), new Me.Separator), l.CheckMobile.any() || (i.push(this._createMergeScalesAction()), i.push(new Me.Separator)), Te.enabled("fundamental_widget") || i.push(new Me.Action({
						actionId: "Chart.PriceScale.Labels",
						label: Le,
						subItems: [t.showSymbolLabelsAction, t.showSeriesLastValue, t.showSeriesPrevCloseValue, t.showPrePostMarketPriceLabel, t.showHighLowPriceLabels, Te.enabled("show_average_close_price_line_and_label") ? t.showAverageClosePriceLabel : null, this._undoModel.model().hasCustomSource("bidask") && t.showBidAskLabels, t.showStudyPlotNamesAction, t.showStudyLastValue, e.alignLabels].filter(Boolean)
					})), i.push((0, Pe.createLinesAction)(this._chart)), this._options.countdownEnabled && i.push(t.showCountdown), this._undoModel.crossHairSource().isMenuEnabled() && i.push(t.addPlusButton), !(0, l.onWidget)() && Te.enabled("show_chart_property_page") && Te.enabled("chart_property_page_scales") && t.scalesProperties && i.push(new Me.Separator, t.scalesProperties), i
				}
				getElement() {
					return this._cell
				}
				onOptimalWidthNeedToBeRecalculated(e) {
					const t = this.optimalWidth();
					(this._prevOptimalWidth < t || e) && null === this._updateTimeout && (this._updateTimeout = setTimeout((() => {
						this._undoModel.model().fullUpdate(), this._updateTimeout = null
					}), 100)), this._prevOptimalWidth = t
				}
				optimalWidth() {
					var e;
					if (!this.isVisible()) return 0;
					let t = 0;
					const i = this.rendererOptions();
					if (this._pane.hasState()) {
						const i = (0, B.getContext2D)(this._canvasBinding.canvasElement);
						(0, ee.setFont)(i, this.baseFont());
						const s = this.backLabels(!0);
						for (let e = s.length; e--;) {
							if (!s[e].isAxisLabelVisible()) continue;
							const o = this._widthCache.measureText(i, s[e].text());
							t = Math.max(t, o);
							const r = s[e].secondLineText();
							r && (t = Math.max(t, this._widthCache.measureText(i, r)));
							const n = s[e].thirdLineText();
							n && (t = Math.max(t, this._widthCache.measureText(i, n)))
						}
						const o = this.priceScale(),
							r = o.marks();
						r.length > 0 && (t = Math.max(t, this._widthCache.measureText(i, r[0].label), this._widthCache.measureText(i, r[r.length - 1].label)));
						const n = (null === (e = o.mainSource()) || void 0 === e ? void 0 : e.firstValue()) || null;
						if (null !== n) {
							const e = o.coordinateToPrice(1, n),
								s = o.coordinateToPrice(this._size.h - 2, n);
							t = Math.max(t, this._widthCache.measureText(i, o.formatPrice(Math.floor(Math.min(e, s)) + .11111111111111, n)), this._widthCache.measureText(i, o.formatPrice(Math.ceil(Math.max(e, s)) - .11111111111111, n)))
						}
					}
					let o = 0;
					this._isCurrencyLabelEnabled() && (null === this._currencyLabelWidth && (this._currencyLabelWidth = (0, s.ensureNotNull)(this._currencyLabel).width()), o = Math.round(this._currencyLabelWidth));
					const r = t || 34;
					let n = Math.max(o, Math.ceil(i.borderSize + i.offsetSize + i.paddingInner + i.paddingOuter + r + 4));
					return n += n % 2, n
				}
				backLabels(e) {
					const t = [],
						i = this._grouppedSources(),
						s = s => {
							for (const o of s) {
								if (!e && i.topLevelSources.has(o)) continue;
								const s = o.priceAxisViews(this._pane.state(), this.priceScale());
								if (s)
									for (const e of s) t.push(e)
							}
						};
					return s(i.sources), s(this._pane.state().customSources()), t
				}
				setSizeAndOffset(e, t) {
					if (e.w < 0 || e.h < 0) throw new Error("Try to set invalid size to PriceAxisWidget " + JSON.stringify(e));
					this._size.equals(e) || (this._size = e, this._canvasBinding.resizeCanvasElement({
						width: e.w,
						height: e.h
					}), this._topCanvasBinding.resizeCanvasElement({
						width: e.w,
						height: e.h
					}), this._cell.style.width = e.w + "px", this._cell.style.height = e.h + "px", this._cell.style.minWidth = e.w + "px"), this._offset !== t && (this._offset = t, this._cell.style.left = t + "px")
				}
				getWidth() {
					return this._size.w
				}
				getImage() {
					const e = this._size,
						t = (0, B.createDisconnectedCanvas)(document, e);
					return (0, B.getPrescaledContext2D)(t).drawImage(this._canvasBinding.canvasElement, 0, 0, e.w, e.h), null !== this._currencyLabel && this._currencyLabel.isEnabled() && this._currencyLabel.drawLabel((0, B.getContext2D)(t), e.w, (0, B.getCanvasDevicePixelRatio)(t)), t
				}
				update() {}
				paint(e) {
					if (!this._isVisible || 0 === this._size.w || 0 === this._size.h) return;
					if (e === f.InvalidationLevel.None) return;
					const t = this._pane.state(),
						i = !t.maximized().value() && t.collapsed().value();
					if (this._canvasBinding.applySuggestedBitmapSize(), this._topCanvasBinding.applySuggestedBitmapSize(), e > f.InvalidationLevel.Cursor) {
						const e = (0, B.getContext2D)(this._canvasBinding.canvasElement),
							t = (0, B.getBindingPixelRatio)(this._canvasBinding);
						i || this._alignLabels(), this._drawBackground(e, t), this._drawBorder(e, t), this._pane.hasState() && (this.updateCurrencyLabel(), i || (this._drawTickMarks(e, t), this._drawBackLabels(e, t)))
					}
					if (this._pane.hasState() && !i) {
						const e = (0, B.getContext2D)(this._topCanvasBinding.canvasElement),
							t = (0,
								B.getBindingPixelRatio)(this._topCanvasBinding);
						e.clearRect(0, 0, Math.ceil(this._size.w * t) + 1, Math.ceil(this._size.h * t) + 1), this._drawCrossHairLabel(e, t)
					}
				}
				restoreDefaultCursor() {
					this._setCursor("")
				}
				priceScale() {
					return (0, s.ensureNotNull)(this._priceScale)
				}
				setPriceScale(e) {
					this._priceScale !== e && (null !== this._priceScale && (this._priceScale.onMarksChanged().unsubscribe(this, this.onOptimalWidthNeedToBeRecalculated), this._priceScale.modeChanged().unsubscribeAll(this)), this._priceScale = e, null !== e && (e.onMarksChanged().subscribe(this, this.onOptimalWidthNeedToBeRecalculated), e.modeChanged().subscribe(this, (() => this.onOptimalWidthNeedToBeRecalculated(!0)))))
				}
				isVisible() {
					return this._isVisible
				}
				setVisible(e) {
					(e = !!e) !== this._isVisible && (this._cell.style.display = e ? "table-cell" : "none", this._isVisible = e)
				}
				destroy() {
					null !== this._currencyMenu && (this._currencyMenu.close(), this._currencyMenu = null), null !== this._unitMenu && (this._unitMenu.close(), this._unitMenu = null), this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler), this._topCanvasBinding.dispose(), this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler), this._canvasBinding.dispose(), null !== this._priceScale && (this._priceScale.onMarksChanged().unsubscribe(this, this.onOptimalWidthNeedToBeRecalculated), this._priceScale.modeChanged().unsubscribeAll(this)), this._priceScale = null, this._updateTimeout && (clearTimeout(this._updateTimeout), this._updateTimeout = null), this._mouseEventHandler.destroy(), this._properties.childs().fontSize.unsubscribe(this, this._onFontSizeChanged), null !== this._actions && this._actions.reset && this._actions.reset.destroy(), (0, xe.currencyUnitVisibilityProperty)().unsubscribeAll(this), this._chart.anyPriceAxisHovered().unsubscribe(this._recalcCurrencyAndUnitVisibility), this._chart.setPriceAxisHovered(this, !1), this._destroyed = !0
				}
				axisInfo() {
					return this._axisInfo
				}
				setHighlighted(e) {
					this._highlighted = e
				}
				backgroundColor() {
					return this._pane.state().model().backgroundColor().value()
				}
				backgroundTopColor() {
					return this._pane.state().model().backgroundTopColor().value()
				}
				lineColor() {
					return this._properties.childs().lineColor.value()
				}
				textColor() {
					return this._properties.childs().textColor.value()
				}
				fontSize() {
					return this._properties.childs().fontSize.value()
				}
				baseFont() {
					return (0, R.makeFont)(this.fontSize(), z.CHART_FONT_FAMILY, "")
				}
				rendererOptions() {
					let e = this._rendererOptionsProvider.options();
					return this._color === e.color && this._fontSize === e.fontSize || (this._color = e.color), this._fontSize !== e.fontSize && (this._widthCache.reset(), this._fontSize = e.fontSize, this._currencyLabelWidth = null, this._currencyFontSize = 0, this._updateCurrencyLabelFont(), this.onOptimalWidthNeedToBeRecalculated()), this._hasAlertLabel() && (e = Object.assign({}, e, {
						paddingInner: Math.max(e.paddingInner, te.ALERT_LABEL_WIDTH)
					})), e
				}
				mouseEnterEvent(e) {
					this._chart.setPriceAxisHovered(this, !0), this._mouseEnterOrTouchStartEvent(e)
				}
				mouseMoveEvent(e) {
					this._mouseOrTouchMoveEvent(e)
				}
				mouseDownEvent(e) {
					this._mouseDownOrTouchStartEvent(e)
				}
				touchStartEvent(e) {
					this._mouseOrTouchMoveEvent(e),
						this._mouseEnterOrTouchStartEvent(e), this._mouseDownOrTouchStartEvent(e)
				}
				pressedMouseMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				touchMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				pinchStartEvent() {}
				pinchEvent(e, t, i) {
					if (this._zoomAvailable() && this._options.pinchScale) {
						if (this._dragScaleActive && this._finishScale(), !this._pinching) return this._pinching = !0, void this._undoModel.startTwoPointsScalePrice(this._pane.state(), this.priceScale(), t.y, i.y);
						this._undoModel.twoPointsScalePriceTo(this._pane.state(), this.priceScale(), t.y, i.y)
					}
				}
				pinchEndEvent() {
					this._pinching = !1, this._undoModel.endTwoPointsScalePrice(this._pane.state(), this.priceScale())
				}
				mouseDownOutsideEvent() {
					this._finishScale()
				}
				mouseUpEvent(e) {
					this._mouseUpOrTouchEndEvent(e)
				}
				touchEndEvent(e) {
					this._mouseLeaveOrTouchEndEvent(e), this._mouseUpOrTouchEndEvent(e)
				}
				mouseClickEvent(e) {
					this._mouseClickOrTapEvent(e)
				}
				tapEvent(e) {
					this._mouseClickOrTapEvent(e)
				}
				mouseLeaveEvent(e) {
					this._chart.setPriceAxisHovered(this, !1), this._mouseLeaveOrTouchEndEvent(e)
				}
				mouseDoubleClickEvent(e) {
					this._mouseDoubleClickOrDoubleTapEvent(e)
				}
				doubleTapEvent(e) {
					this._mouseDoubleClickOrDoubleTapEvent(e)
				}
				contextMenuEvent(e) {
					this._contextMenuOrTouchContextMenuEvent(e)
				}
				touchContextMenuEvent(e) {
					this._contextMenuOrTouchContextMenuEvent(e)
				}
				dataSourceAtPoint(e, t) {
					const i = this._pane.state();
					if (!i.maximized().value() && i.collapsed().value()) return null;
					const s = this._grouppedSources(),
						o = [...s.sources, ...s.topLevelSources, ...i.customSources()];
					let r = null,
						n = null;
					if (!this._priceScale) return null;
					const a = (e, t) => {
							var i;
							const s = null !== (i = null == n ? void 0 : n.result()) && void 0 !== i ? i : 0;
							e.result() > s && (n = e, r = t)
						},
						l = new C.Point(e, t);
					for (let e = o.length - 1; e >= 0; --e) {
						const t = o[e],
							s = t.priceAxisViews(i, this._priceScale);
						if (s && 0 !== s.length)
							for (let e = s.length - 1; e >= 0; --e) {
								const i = s[e].renderer();
								if (void 0 !== i.hitTest) {
									const e = i.hitTest(l, this._size.w, this._isLeft ? "left" : "right");
									null !== e && a(e, t)
								}
							}
					}
					return this._lastHittestResult = n, r
				}
				reset() {
					const e = this._pane.state(),
						t = this.priceScale();
					this._undoModel.resetPriceScale(e, t), this.onOptimalWidthNeedToBeRecalculated(!0)
				}
				sizeReady() {
					return this.getWidth() >= this.optimalWidth() && null === this._updateTimeout
				}
				updateCurrencyLabel() {
					if (null === this._currencyLabel) return;
					let e = !1;
					if (this._options.currencyConversionEnabled) {
						const t = this.priceScale().currency(this._undoModel.model().availableCurrencies());
						null === t || "alwaysOff" === (0, xe.currencyUnitVisibilityProperty)().value() ? (e = this._currencyLabel.currencyLabelEnabled(), this._currencyLabel.disableCurrency()) : (e = !this._currencyLabel.currencyLabelEnabled(), this._currencyLabel.enableCurrency(), this._currencyLabel.updateColors(this.backgroundTopColor(), this.textColor()), e = this._currencyLabel.setCurrencyInfo(t) || e)
					}
					if (this._options.unitConversionEnabled) {
						const t = "alwaysOff" === (0, xe.currencyUnitVisibilityProperty)().value(),
							i = this._undoModel.model().availableUnits(),
							s = this.priceScale().unit(i);
						null === s || t ? (e = e || this._currencyLabel.unitLabelEnabled(), this._currencyLabel.disableUnit()) : (e = e || !this._currencyLabel.unitLabelEnabled(),
							this._currencyLabel.enableUnit(), this._currencyLabel.updateColors(this.backgroundTopColor(), this.textColor()), e = this._currencyLabel.setUnitInfo(s) || e);
						const o = this.priceScale().measureUnitId(i);
						null === o || t ? (e = e || this._currencyLabel.measureUnitIdLableEnabled(), this._currencyLabel.disableMeasureUnitId()) : (e = e || !this._currencyLabel.measureUnitIdLableEnabled(), this._currencyLabel.enableMeasureUnitId(), this._currencyLabel.updateColors(this.backgroundTopColor(), this.textColor()), e = this._currencyLabel.setMeasureUnitIdInfo(o) || e)
					}
					this._updateCurrencyLabelFont(), e && (this._currencyLabelWidth = null)
				}
				_grouppedSources() {
					var e;
					const t = this._pane,
						i = t.state().model(),
						s = this._sameSideSources().slice(),
						o = t.state(),
						r = this.priceScale(),
						n = new Set,
						a = null !== (e = i.lineBeingEdited()) && void 0 !== e ? e : i.lineBeingCreated();
					a && n.add(a);
					const l = i.customSourceBeingMoved();
					null !== l && n.add(l), i.sourcesBeingMoved().forEach((e => n.add(e))), i.selection().allSources().forEach((e => n.add(e)));
					const c = i.hoveredSource();
					null !== c && n.add(c);
					if (r === o.defaultPriceScale()) {
						const e = this._pane.state().dataSources();
						for (const t of e) o.isOverlay(t) && s.push(t)
					}
					return {
						sources: s,
						topLevelSources: n
					}
				}
				_isCurrencyLabelEnabled() {
					return null !== this._currencyLabel && this._currencyLabel.isEnabled()
				}
				_updateCurrencyLabelFont() {
					if (null === this._currencyLabel) return;
					const e = this.fontSize();
					e !== this._currencyFontSize && (this._currencyLabel.setFontSize(e), this._currencyFontSize = e, this._currencyLabelWidth = null, this.onOptimalWidthNeedToBeRecalculated())
				}
				_alignLabels() {
					const e = this._size.h;
					let t = e / 2;
					const i = [],
						s = this.priceScale(),
						o = s.orderedSources().slice(),
						r = this._pane.state(),
						n = this.rendererOptions();
					if (s === r.defaultPriceScale()) {
						const e = r.priceDataSources();
						for (let t = 0; t < e.length; t++) r.isOverlay(e[t]) && o.push(e[t])
					}
					const a = s.mainSource();
					for (const l of [o, r.customSources()])
						for (let o = 0; o < l.length; ++o) {
							const c = l[o],
								h = c.priceAxisViews(r, s);
							if (h) {
								const s = h.filter((t => {
									if (t.ignoreAlignment() || !t.isVisible()) return !1;
									const i = t.height(n),
										s = t.floatCoordinate();
									return s > -i && s < e + i
								}));
								if (!s.length) continue;
								i.push(...s), a === c && (t = s[0].floatCoordinate())
							}
						}
					const l = i.filter((e => e.floatCoordinate() <= t)),
						c = i.filter((e => e.floatCoordinate() > t));
					l.sort(((e, t) => t.floatCoordinate() - e.floatCoordinate())), l.length > 0 && c.length > 0 && c.push(l[0]), c.sort(((e, t) => e.floatCoordinate() - t.floatCoordinate()));
					for (const e of i) e.setFixedCoordinate(e.coordinate());
					if (s.properties().childs().alignLabels.value()) {
						for (let e = 1; e < l.length; e++) {
							const t = l[e],
								i = l[e - 1],
								s = t.height(n),
								o = t.coordinate(),
								r = i.getFixedCoordinate();
							o > r - s && t.setFixedCoordinate(r - s)
						}
						for (let e = 1; e < c.length; e++) {
							const t = c[e],
								i = c[e - 1],
								s = i.height(n),
								o = t.coordinate(),
								r = i.getFixedCoordinate();
							o < r + s && t.setFixedCoordinate(r + s)
						}
					}
				}
				_drawTickMarks(e, t) {
					const i = this.priceScale().marks();
					e.save(), (0, ee.setFont)(e, this.baseFont());
					const o = this.rendererOptions(),
						r = this._isLeft ? Math.floor((this._size.w - o.offsetSize) * t) : 0,
						n = this._isLeft ? Math.round(r - o.paddingInner * t) : Math.round(r + (o.offsetSize + o.paddingInner) * t),
						a = this.fontSize(),
						l = this._isCurrencyLabelEnabled() ? (0,
							s.ensureNotNull)(this._currencyLabel).labelBottom() : 0,
						c = i.map((t => {
							if (this._options.croppedTickMarks) return {
								visible: !0,
								yCorrection: this._widthCache.yMidCorrection(e, t.label)
							};
							const i = t.coord - a / 2,
								s = t.coord + a / 2,
								o = !(s > this._size.h || i < l);
							return {
								visible: !(s > this._size.h || i < l),
								yCorrection: o ? this._widthCache.yMidCorrection(e, t.label) : 0
							}
						}));
					e.fillStyle = this.textColor(), e.textAlign = this._isLeft ? "right" : "left", e.textBaseline = "middle", (0, B.drawScaled)(e, t, (() => {
						for (let s = i.length; s--;) {
							if (!c[s].visible) continue;
							const o = i[s];
							e.fillText(o.label, n / t, o.coord + c[s].yCorrection)
						}
					})), e.restore()
				}
				_hasAlertLabel() {
					return this.priceScale().dataSources().some((e => (0, te.isAlertLabel)(e)))
				}
				async _showCurrenciesContextMenu() {
					if (null !== this._currencyMenu && this._currencyMenu.isOpened()) return void this._currencyMenu.close();
					(0, se.trackEvent)("GUI", "Currency conversion");
					const {
						currencyActions: e
					} = await Promise.all([i.e(90519), i.e(8348), i.e(90926), i.e(8834), i.e(3086), i.e(30063), i.e(95468), i.e(80580), i.e(68074), i.e(52498), i.e(29331), i.e(5799), i.e(52019), i.e(11812), i.e(44177), i.e(1551), i.e(75514), i.e(92697), i.e(32704)]).then(i.bind(i, 300999)), t = await ve(Ee, (() => e(this._undoModel, (0, s.ensureNotNull)(this._currencyLabel).currencyInfo(), this.priceScale())), (0, s.ensureNotNull)(this._currencyLabel).currencyLabelElement(), (() => this._recalcCurrencyAndUnitVisibility()));
					this._destroyed ? t.close() : this._currencyMenu = t
				}
				async _showUnitsContextMenu() {
					if (null !== this._unitMenu && this._unitMenu.isOpened()) return void this._unitMenu.close();
					(0, se.trackEvent)("GUI", "Unit conversion");
					const {
						unitActions: e
					} = await Promise.all([i.e(90519), i.e(8348), i.e(90926), i.e(8834), i.e(3086), i.e(30063), i.e(95468), i.e(80580), i.e(68074), i.e(52498), i.e(29331), i.e(5799), i.e(52019), i.e(11812), i.e(44177), i.e(1551), i.e(75514), i.e(92697), i.e(32704)]).then(i.bind(i, 362274)), t = await ve(De, (() => e(this._undoModel, (0, s.ensureNotNull)(this._currencyLabel).unitInfo(), this.priceScale())), (0, s.ensureNotNull)(this._currencyLabel).unitLabelElement(), (() => this._recalcCurrencyAndUnitVisibility()));
					this._destroyed ? t.close() : this._unitMenu = t
				}
				_onFontSizeChanged() {
					this._currencyLabelWidth = null, this._currencyFontSize = 0, this._updateCurrencyLabelFont(), this.onOptimalWidthNeedToBeRecalculated()
				}
				_mouseOrTouchMoveEvent(e) {
					if (!this._priceScale) return;
					this.dataSourceAtPoint(e.localX, e.localY) ? this._setCursorClassName("pointer") : this._setResizeCursor()
				}
				_mouseDownOrTouchStartEvent(e) {
					this._zoomAvailable() && this._options.pressedMouseMoveScale && !this._pinching && (this._dragScaleActive = !0, this._undoModel.startScalePrice(this._pane.state(), this.priceScale(), e.localY))
				}
				_mouseEnterOrTouchStartEvent(e) {
					this._setResizeCursor()
				}
				_pressedMouseOrTouchMoveEvent(e) {
					if (this._dragScaleActive) {
						const t = this.priceScale();
						this._undoModel.scalePriceTo(this._pane.state(), t, e.localY)
					}
				}
				_mouseUpOrTouchEndEvent(e) {
					this._finishScale()
				}
				_finishScale() {
					this._dragScaleActive && (this._undoModel.endScalePrice(this._pane.state(), this.priceScale()), this.restoreDefaultCursor(), this._dragScaleActive = !1)
				}
				_mouseClickOrTapEvent(e) {
					if (this._currencyLabel) {
						if (this._currencyLabel.currencyConversionAvailable() && this._currencyLabel.currencyLabelElement().contains(e.target)) return void this._showCurrenciesContextMenu();
						if (this._currencyLabel.unitConversionAvailable() && this._currencyLabel.unitLabelElement().contains(e.target)) return void this._showUnitsContextMenu()
					}
					const t = this.dataSourceAtPoint(e.localX, e.localY);
					t && this._undoModel.selectionMacro((e => {
						e.selection().isSelected(t) || (e.clearSelection(), e.addSourceToSelection(t))
					}))
				}
				_mouseLeaveOrTouchEndEvent(e) {
					this._setCursorClassName("")
				}
				_mouseDoubleClickOrDoubleTapEvent(e) {
					var t;
					const i = this.dataSourceAtPoint(e.localX, e.localY);
					i ? this._pane.processDoubleClickOnSource(i, null !== (t = this._lastHittestResult) && void 0 !== t ? t : void 0, {
						origin: "price_scale"
					}) : (this.reset(), (0, se.trackEvent)("GUI", "Double click price scale"))
				}
				_contextMenuOrTouchContextMenuEvent(e) {
					if (this._options.contextMenuEnabled) {
						const t = this.dataSourceAtPoint(e.localX, e.localY);
						if (null !== t && this._options.contextMenu.source) {
							return void this._undoModel.model().selectionMacro((i => {
								i.selection().isSelected(t) || (i.clearSelection(), i.addSourceToSelection(t)), this._pane.showContextMenuForSelection(e, {
									origin: "price_scale"
								})
							}))
						}
						this._options.contextMenu.general && Y.ContextMenuManager.showMenu(this.getContextMenuActions(), e, {
							statName: "PriceScaleContextMenu"
						}, {
							menuName: "PriceScaleContextMenu"
						})
					}
				}
				_setResizeCursor() {
					const e = this.priceScale();
					e.isPercentage() || e.isIndexedTo100() ? this._setCursorClassName("") : this._zoomAvailable() && (this._options.pressedMouseMoveScale || this._options.mouseWheelScale) && this._setCursorClassName("ns-resize")
				}
				_setCursorClassName(e) {
					let t = "";
					e && (t = "price-axis--cursor-" + e), this._currentCursorClassName !== t && (this._currentCursorClassName && this._cell.classList.remove(this._currentCursorClassName), t && this._cell.classList.add(t), this._currentCursorClassName = t)
				}
				_zoomAvailable() {
					return !this.priceScale().isEmpty() && this._undoModel.model().zoomEnabled()
				}
				_onMousewheel(e) {
					if (!this._zoomAvailable() || !this._options.mouseWheelScale) return;
					const t = (0, s.ensureNotNull)(this._mouseWheelHelper).processWheel(e).deltaY;
					if (0 === t) return;
					e.cancelable && e.preventDefault();
					const i = this._undoModel,
						o = this._pane.state(),
						r = this.priceScale(),
						n = this._cell.getBoundingClientRect(),
						a = e.clientY - n.top,
						l = a + 15 * t;
					i.startScalePrice(o, this.priceScale(), a, !0), i.scalePriceTo(o, r, l), i.endScalePrice(o, r), e.stopPropagation()
				}
				_drawCrossHairLabel(e, t) {
					var i, s;
					e.save();
					const o = this._pane.state(),
						r = o.model(),
						n = this.priceScale(),
						a = [],
						l = this.priceScale() === o.defaultPriceScale(),
						c = null !== (i = r.lineBeingEdited()) && void 0 !== i ? i : r.lineBeingCreated();
					if (c && (c.priceScale() === n || l && o.isOverlay(c))) {
						const e = c.priceAxisViews(o, n);
						e && e.length && a.push(e)
					}
					const h = r.customSourceBeingMoved();
					this._addViewsOrMaxMin(null === h ? [] : [h], a), this._addViewsOrMaxMin(r.sourcesBeingMoved(), a), this._addViewsOrMaxMin(r.selection().allSources(), a);
					const d = r.hoveredSource();
					if (d) {
						const e = o.customSources().includes(d) ? n : d.priceScale();
						if (!r.selection().isSelected(d) && (this._isFromSameSide(e) || l && o.isOverlay(d))) {
							const e = null === (s = r.hoveredSource()) || void 0 === s ? void 0 : s.priceAxisViews(o, n);
							e && e.length && a.push(e)
						}
					}
					const u = r.crossHairSource().priceAxisViews(o, n);
					u && u.length && a.push(u);
					const _ = this.rendererOptions(),
						m = this._isLeft ? "right" : "left";
					a.forEach((i => {
						i.forEach((i => {
							e.save(), i.renderer().draw(e, _, this._widthCache, this._size.w, this._size.h, m, t), e.restore()
						}))
					})), e.restore()
				}
				_drawBackground(e, t) {
					const i = Math.ceil(this._size.w * t),
						s = Math.ceil(this._size.h * t),
						o = this.backgroundTopColor(),
						r = this.backgroundColor();
					if (o === r ? (0, B.clearRect)(e, 0, 0, i + 1, s + 1, this.backgroundColor()) : (0, O.clearRectWithGradient)(e, 0, 0, i + 1, s + 1, o, r), this._highlighted) {
						e.globalAlpha = .5;
						const t = V.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight");
						(0, B.fillRect)(e, 0, 0, i + 1, s + 1, t), e.globalAlpha = 1
					}
					const n = this._pane.state().model(),
						a = this.priceScale(),
						l = n.selection().lineDataSources().filter((e => e.priceScale() === a)).reduce(((e, t) => {
							const i = t.priceAxisPoints();
							return 0 === i.length ? e : e.concat(i)
						}), []);
					l.length > 0 && this._hightlightBackground(e, l, this.priceScale().mainSource(), t);
					const c = n.crossHairSource();
					c.startMeasurePoint() && this._hightlightBackground(e, c.measurePoints(), this.priceScale().mainSource(), t)
				}
				_drawBorder(e, t) {
					e.save(), e.fillStyle = this.lineColor();
					const i = Math.max(1, Math.floor(this.rendererOptions().borderSize * t)),
						s = this._isLeft ? Math.floor(this._size.w * t) - i : 0;
					e.fillRect(s, 0, i, Math.ceil(this._size.h * t) + 1), e.restore()
				}
				_drawBackLabels(e, t) {
					e.save();
					const i = this.backLabels(),
						s = this.rendererOptions(),
						o = this._isLeft ? "right" : "left";
					for (const r of i) r.isAxisLabelVisible() && (e.save(), r.renderer().draw(e, s, this._widthCache, this._size.w, this._size.h, o, t), e.restore());
					e.restore()
				}
				_hightlightBackground(e, t, i, s) {
					if (!i) return;
					const o = i.firstValue();
					if (null === o) return;
					let r = t[0].price,
						n = t[0].price;
					for (let e = 1; e < t.length; e++) r = Math.min(r, t[e].price), n = Math.max(n, t[e].price);
					const a = this.priceScale(),
						l = Math.floor(a.priceToCoordinate(r, o) * s),
						c = Math.ceil(a.priceToCoordinate(n, o) * s);
					(0, B.fillRect)(e, Math.floor(s), l, Math.ceil((this._size.w - 1) * s) + 1, c - l, this._properties.childs().axisHighlightColor.value())
				}
				_addViewsOrMaxMin(e, t) {
					const i = this._pane.state(),
						s = this.priceScale();
					if (s !== i.defaultPriceScale() && (e = e.filter((e => i.isOverlay(e) || this._isFromSameSide(e.priceScale())))), 0 !== e.length)
						if (1 === e.length) {
							const o = e[0].priceAxisViews(i, s);
							o && o.length && t.push(o)
						} else t.push(this._minMaxViews(e))
				}
				_minMaxViews(e) {
					const t = this._pane.state(),
						i = this.priceScale(),
						s = [];
					let o = 1 / 0,
						r = -1 / 0,
						n = null,
						a = null;
					for (const s of e) {
						const e = s.priceAxisViews(t, i);
						if (e && e.length)
							for (let t = 0; t < e.length; t++) {
								const i = e[t],
									s = i.coordinate();
								s >= r && (r = s, a = i), s <= o && (o = s, n = i)
							}
					}
					return a && s.push(a), n && s.push(n), s
				}
				_isFromSameSide(e) {
					return null !== e && (this._isLeft ? this._pane.state().leftPriceScales() : this._pane.state().rightPriceScales()).includes(e)
				}
				_sameSideSources() {
					const e = this._pane.state().sourcesByGroup();
					return this._isLeft ? e.leftPriceScalesSources() : e.rightPriceScalesSources()
				}
				_initActions() {
					if (!this._pane.hasState() || null !== this._actions) return;
					const e = this._undoModel,
						t = new Me.Action({
							actionId: "Chart.PriceScale.Reset",
							label: Ne,
							icon: Ie,
							shortcutHint: (0, ye.humanReadableHash)(ye.Modifiers.Alt + 82),
							statName: "ResetScale",
							onExecute: () => this.reset()
						}),
						i = new Me.Action({
							actionId: "Chart.PriceScale.ToggleAutoScale",
							label: Be,
							checkable: !0,
							checked: !0,
							statName: "ToggleAutoScale",
							onExecute: () => {
								e.togglePriceScaleAutoScaleMode(this.priceScale()), this._updateScalesActions()
							}
						}),
						s = new Me.Action({
							actionId: "Chart.PriceScale.TogglePercentage",
							label: Oe,
							checkable: !0,
							checked: this.priceScale().isPercentage(),
							statName: "TogglePercantage",
							onExecute: () => {
								e.togglePriceScalePercentageScaleMode(this.priceScale()), this._updateScalesActions()
							}
						}),
						o = new Me.Action({
							actionId: "Chart.PriceScale.ToggleIndexedTo100",
							label: Re,
							checkable: !0,
							checked: this.priceScale().isIndexedTo100(),
							statName: "ToggleIndexedTo100",
							onExecute: () => {
								e.togglePriceScaleIndexedTo100ScaleMode(this.priceScale()), this._updateScalesActions()
							}
						}),
						r = new Me.Action({
							actionId: "Chart.PriceScale.ToggleLogarithmic",
							label: Ve,
							checkable: !0,
							checked: this.priceScale().isLog(),
							statName: "ToggleLogScale",
							onExecute: () => {
								e.togglePriceScaleLogScaleMode(this.priceScale()), this._updateScalesActions()
							}
						}),
						n = new Me.Action({
							actionId: "Chart.PriceScale.ToggleRegular",
							label: We,
							checkable: !0,
							checked: this.priceScale().isRegular(),
							statName: "ToggleRegularScale",
							onExecute: () => {
								e.setPriceScaleRegularScaleMode(this.priceScale()), this._updateScalesActions()
							}
						}),
						a = new Me.Action({
							actionId: "Chart.PriceScale.Labels.ToggleNoOverlappingLabelsVisibility",
							label: Fe,
							checkable: !0,
							checked: this.priceScale().properties().childs().alignLabels.value(),
							statName: "TogglePreciseLabels"
						});
					a.setBinding(new Ce.ActionBinder(a, this.priceScale().properties().childs().alignLabels, e, Ae));
					const l = new Me.Action({
						actionId: "Chart.PriceScale.ToggleInvertScale",
						label: ze,
						checkable: !0,
						checked: this.priceScale().isInverted(),
						statName: "Invert Scale",
						onExecute: () => {
							e.invertPriceScale(this.priceScale()), this._updateScalesActions()
						}
					});
					this._actions = {
						reset: t,
						setAutoScale: i,
						setPercentage: s,
						setIndexedTo100: o,
						setLog: r,
						setRegular: n,
						alignLabels: a,
						invertScale: l
					}, this._updateScalesActions()
				}
				_logAction() {
					return this._isMainSeriesAxis() ? this._chart.actions().logSeriesScale : (0, s.ensureNotNull)(this._actions).setLog
				}
				_percentageAction() {
					return this._isMainSeriesAxis() ? this._chart.actions().percentSeriesScale : (0, s.ensureNotNull)(this._actions).setPercentage
				}
				_indexedTo100Action() {
					return this._isMainSeriesAxis() ? this._chart.actions().indexedTo100SeriesScale : (0, s.ensureNotNull)(this._actions).setIndexedTo100
				}
				_autoScaleAction() {
					return this._isMainSeriesAxis() ? this._chart.actions().autoSeriesScale : (0, s.ensureNotNull)(this._actions).setAutoScale
				}
				_regularScaleAction() {
					return this._isMainSeriesAxis() ? this._chart.actions().regularSeriesScale : (0, s.ensureNotNull)(this._actions).setRegular
				}
				_lockScaleAction() {
					const e = this._chart.actions().lockSeriesScale,
						t = Ue(this.priceScale(), this._undoModel.model().mainSeriesScaleRatio());
					return e.update({
						hint: t
					}), e
				}
				_invertAction() {
					return this._isMainSeriesAxis() ? this._chart.actions().invertSeriesScale : (0,
						s.ensureNotNull)(this._actions).invertScale
				}
				_isMainSeriesAxis() {
					return this.priceScale().hasMainSeries()
				}
				_updateScalesActions() {
					const e = this.priceScale(),
						t = this._isMainSeriesAxis(),
						i = (0, s.ensureNotNull)(e.mainSource()).properties(),
						o = t && e.isLockScale(),
						r = t && 6 === i.style.value(),
						n = (0, s.ensureNotNull)(this._actions);
					n.setRegular.update({
						checked: e.isRegular(),
						disabled: o || r
					}), n.setPercentage.update({
						checked: e.isPercentage(),
						disabled: o || r
					}), n.setIndexedTo100.update({
						checked: e.isIndexedTo100(),
						disabled: o || r
					}), n.setLog.update({
						checked: e.isLog(),
						disabled: o || r
					}), n.setAutoScale.update({
						checked: e.isAutoScale(),
						disabled: e.properties().childs().autoScaleDisabled.value()
					})
				}
				_createMergeScalesAction() {
					const e = this._chart.actions(),
						t = this._undoModel.model().priceScaleSlotsCount();
					if (t.left + t.right === 1) return 0 === t.left ? e.moveScaleToLeft : e.moveScaleToRight;
					const i = [];
					return i.push(e.mergeLeftScalesAction), i.push(e.mergeRightScalesAction), new Me.Action({
						actionId: "Chart.PriceScale.MergeAllScales",
						label: ke,
						subItems: i
					})
				}
				_setCursor(e) {
					let t = "";
					"grabbing" !== e && "ns-resize" !== e || (t = "price-axis--cursor-" + e), this._currentCursorClassName !== t && (this._currentCursorClassName && this._cell.classList.remove(this._currentCursorClassName), t && this._cell.classList.add(t), this._currentCursorClassName = t, this._cell.style.cursor)
				}
			}
			var je = i(312820),
				qe = i(262325),
				Ke = i.n(qe),
				Ye = i(558e3),
				Xe = i(433904),
				Ze = i(902899),
				$e = i(920358),
				Qe = i(194946),
				Je = i(846778),
				et = i(984610),
				tt = i(29084),
				it = i(697455),
				st = i(87511),
				ot = i(309103);
			async function rt() {
				return (await Promise.all([i.e(81735), i.e(75514), i.e(20139)]).then(i.bind(i, 254543))).ErrorCardRenderer
			}
			var nt = i(298438),
				at = i(125082);

			function lt(e) {
				return "startMoving" in e && "move" in e && "endMoving" in e && "convertYCoordinateToPriceForMoving" in e
			}
			var ct = i(404703),
				ht = i(951713),
				dt = i(194459),
				ut = i(359663),
				_t = i(750081);
			i(488473);
			const mt = parseInt(_t["css-value-pane-controls-padding-left"]),
				pt = parseInt(_t["css-value-pane-controls-padding-right"]),
				gt = (0, w.getHexColorByName)("color-cold-gray-700"),
				St = (0, w.getHexColorByName)("color-cold-gray-400"),
				vt = new T.TranslatedString("scroll", (0, o.t)("scroll")),
				ft = (0, o.t)("Lock vertical cursor line by time"),
				bt = (0, o.t)("Couldn't copy");

			function yt(e) {
				return !(null === e || !(0, S.isStudy)(e)) && "Volume@tv-basicstudies" === e.metaInfo().id
			}

			function Ct(e, t, i) {
				e.drawBackground && e.drawBackground(t, i)
			}

			function wt(e, t, i) {
				e.draw(t, i)
			}

			function Tt(e, t) {
				return e.paneViews(t)
			}

			function Pt(e, t) {
				return e.topPaneViews()
			}

			function Mt(e, t) {
				return e.labelPaneViews(t)
			}

			function xt(e, t) {
				const i = e.strategyOrdersPaneView();
				return null === i ? null : [i]
			}

			function It(e, t) {
				return null === e || null === e.hittest || e.source !== t ? null : e.hittest.data()
			}

			function At(e, t, i, s, o) {
				var r, n;
				const a = null !== (n = null === (r = e.hittest) || void 0 === r ? void 0 : r.result()) && void 0 !== n ? n : 0;
				t.result() > a && (e.hittest = t, e.source = i, e.renderer = s, e.isCustom = o)
			}
			const kt = {
					contextMenuEnabled: !0,
					contextMenu: Pe.defaultContextMenuOptions,
					priceScaleContextMenuEnabled: !0,
					legendWidgetEnabled: !0,
					controlsEnabled: !0,
					propertyPagesEnabled: !0,
					sourceSelectionEnabled: !0,
					countdownEnabled: !0
				},
				Lt = new Map([
					[x.AreaName.Text, "Text"],
					[x.AreaName.Style, "Style"]
				]),
				Et = !Te.enabled("display_legend_on_all_charts");
			let Dt = null;

			function Nt(e, t) {
				return !(0, x.shouldDefaultActionBeExecuted)(e, t, "pressedMouseMoveHandler", "touchMoveHandler")
			}
			class Bt {
				constructor(e, t, i, o) {
					this._legendWidget = null, this._paneControls = null, this._isDestroyed = !1, this._trackCrosshairOnlyAfterLongTap = (0, P.lastMouseOrTouchEventInfo)().isTouch, this._startTrackPoint = null, this._exitTrackingModeOnNextTry = !1, this._startMoveSourceParams = null, this._startChangeLineToolParams = null, this._preventSourceChange = !1, this._clonningAtMoveLineTools = null, this._startCloningPoint = null, this._size = new B.Size(0, 0), this._themedTopColor = null, this._initCrossHairPosition = null, this._firstZoomPoint = null, this._editDialog = null, this._processing = !1, this._touchMove = !1, this._startTouchPoint = null, this._isSelecting = !1, this._prevHoveredHittest = null, this._contextMenuX = 0, this._contextMenuY = 0, this._startScrollingPos = null, this._isScrolling = !1, this._scrollPriceScale = null, this._scrollXAnimation = null, this._scrollYAnimation = null, this._prevPinchScale = 1, this._pinching = !1, this._wasPinched = !1, this._longTap = !1, this._contextMenuOpenedOnLastTap = !1, this._paneControlsResizeObserver = null, this._lastClickedSource = null, this._customLegendWidgetsFactoryMap = new Map, this._prevMoveEventPosition = null, this._onMagnetStateChangedListener = this._onMagnetStateChanged.bind(this), this._onShiftKeyStateChangedListener = this._onShiftKeyStateChanged.bind(this), this._currentCursorClassName = "", this._lastFinishedToolId = null, this._needResetMeasureLater = !1, this._currentChangingLineToolHitTest = null, this._currentMovingHitTest = null, this._prevTooltipData = null, this._errorRenderer = null, this._highlightedPriceAxis = new(Ke())({
						owner: "",
						axis: null
					}), this._visuallyCollapsed = new(Ke())(!1), this._endOfSeriesDataBanner = null, this._showEndOfSeriesDataBanner = new ut.FeatureToggleWatchedValue("show_end_of_data_message", !1), this._canvasConfiguredHandler = () => this._state && this._chartModel().lightUpdate(), this._updateVisuallyCollapsed = () => {
						this._visuallyCollapsed.setValue(!this.state().maximized().value() && this.state().collapsed().value())
					}, this._chart = e, this._state = t, this._options = (0, _.merge)((0, _.clone)(kt), i), this._paneWidgetsSharedState = o, this._state && this._subscribeToState();
					const r = {
						contextMenuEnabled: this._options.priceScaleContextMenuEnabled,
						pressedMouseMoveScale: this._options.handleScale.axisPressedMouseMove.price,
						mouseWheelScale: this._options.handleScale.mouseWheel,
						currencyConversionEnabled: this._options.currencyConversionEnabled,
						unitConversionEnabled: this._options.unitConversionEnabled,
						countdownEnabled: this._options.countdownEnabled,
						croppedTickMarks: this._options.croppedTickMarks
					};
					void 0 !== this._options.priceScaleContextMenu && (r.contextMenu = this._options.priceScaleContextMenu);
					const n = (e, t, i, s, o) => new Ge(this._chart, this, this._chartUndoModel(), i, t, e, r, s, o),
						a = e.properties().childs().scalesProperties,
						l = this._chartModel().rendererOptionsProvider(),
						c = {
							backgroundBasedTheme: e.backgroundBasedTheme(),
							rendererOptionsProvider: l,
							getBackgroundTopColor: () => this._chartModel().backgroundTopColor().value(),
							getBackgroundBottomColor: () => this._chartModel().backgroundColor().value()
						},
						h = {
							showLabels: !1
						};
					this._lhsPriceAxisesContainer = new J(a, "left", n, c, h), this._rhsPriceAxisesContainer = new J(a, "right", n, c, h), this._paneCell = document.createElement("td"), this._paneCell.classList.add("chart-markup-table", "pane"), this._div = document.createElement("div"), this._div.classList.add("chart-gui-wrapper"), this._div.setAttribute("data-name", "pane-widget-chart-gui-wrapper"), this._paneCell.appendChild(this._div), this._canvasBinding = (0, B.createBoundCanvas)(this._div, new B.Size(16, 16)), this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
					const d = this._canvasBinding.canvasElement;
					d.style.position = "absolute", d.style.left = "0", d.style.top = "0", this._topCanvasBinding = (0, B.createBoundCanvas)(this._div, new B.Size(16, 16)), this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
					const u = this._topCanvasBinding.canvasElement;
					u.style.position = "absolute", u.style.left = "0", u.style.top = "0", this._rowElement = document.createElement("tr"), this._rowElement.appendChild(this._lhsPriceAxisesContainer.getElement()), this._rowElement.appendChild(this._paneCell), this._rowElement.appendChild(this._rhsPriceAxisesContainer.getElement()), this._options.legendWidgetEnabled && (this._options.customLegendWidgetFactories && (this._customLegendWidgetsFactoryMap = this._options.customLegendWidgetFactories), this._loadAndCreateLegendWidget()), this._state && !this._chart.readOnly() && this._options.controlsEnabled && this._loadAndCreatePaneControlsWidget(), (0, nt.magnetEnabled)().subscribe(this._onMagnetStateChangedListener), (0, at.shiftPressed)().subscribe(this._onShiftKeyStateChangedListener), this._paneCell.addEventListener("dragover", (e => {
						e.dataTransfer && Array.from(e.dataTransfer.files).some(Qe.blobImageFilter) && e.preventDefault()
					})), this._paneCell.addEventListener("drop", (e => {
						if (window.user.id && e.dataTransfer && this._state) {
							const t = Array.from(e.dataTransfer.files).find(Qe.blobImageFilter);
							if (t) {
								e.preventDefault();
								const i = (0, Qe.uploadImage)(t),
									o = URL.createObjectURL(t);
								this._chartUndoModel().pasteImageAsLineTool(i, o, this._state), i.catch((e => {
									this._chart.chartWidgetCollection().getToasts().then((t => {
										(0, s.ensureNotNull)(t).showSimpleToast({
											title: bt,
											text: e.message,
											role: "alert",
											intent: y.ToastIntent.Warning
										})
									}))
								}))
							}
						}
					})), this.setCursorForTool(), this._mouseEventHandler = new N.MouseEventHandler(this._topCanvasBinding.canvasElement, this, {
						treatVertTouchDragAsPageScroll: !this._options.handleScroll.vertTouchDrag,
						treatHorzTouchDragAsPageScroll: !this._options.handleScroll.horzTouchDrag
					}), this._prevHoveredHittest = null, this._highlightedPriceAxis.subscribe((e => this._highlightPriceAxisByLabel(e.axis))), this._prevPinchScale = 0, this._isDestroyed = !1
				}
				destroy() {
					var e;
					this._showEndOfSeriesDataBanner.destroy(), this._chart.onPaneWidgetDestroyed(this), this._customLegendWidgetsFactoryMap.clear(), this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
						this._topCanvasBinding.dispose(), this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler), this._canvasBinding.dispose(), this._legendWidget && (this._legendWidget.destroy(), this._legendWidget = null), null !== this._paneControlsResizeObserver && this._paneControlsResizeObserver.disconnect(), null !== this._paneControls && (this._paneControls.destroy(), this._paneControls = null), this._lhsPriceAxisesContainer.destroy(), this._rhsPriceAxisesContainer.destroy(), this.hasState() && this._unsubscribeFromState(), (0, nt.magnetEnabled)().unsubscribe(this._onMagnetStateChangedListener), (0, at.shiftPressed)().unsubscribe(this._onShiftKeyStateChangedListener), this._paneWidgetsSharedState.onPaneDestroyed(this), this._errorRenderer && this._errorRenderer.then((e => {
							e.destroy(), this._errorRenderer = null
						})), this._prevHoveredHittest = null, this._mouseEventHandler.destroy(), null === (e = this._rowElement.parentElement) || void 0 === e || e.removeChild(this._rowElement), this._isDestroyed = !0
				}
				size() {
					return this._size
				}
				setSize(e) {
					(0, s.assert)(e.w >= 0 && e.h >= 0, `Try to set invalid size to PaneWidget ${JSON.stringify(e)}`), this._size.equals(e) || (this._size = e, this._canvasBinding.resizeCanvasElement({
						width: e.w,
						height: e.h
					}), this._topCanvasBinding.resizeCanvasElement({
						width: e.w,
						height: e.h
					}), this._paneCell.style.width = e.w + "px", this._paneCell.style.height = e.h + "px", this._div.style.width = e.w + "px", this._div.style.height = e.h + "px", this._rowElement.classList.toggle("js-hidden", 0 === e.h), null !== this._legendWidget && this._legendWidget.updateWidgetModeBySize(e), null !== this._paneControls && this._paneControls.updateWidgetModeByWidth(e.w))
				}
				width() {
					return this._size.w
				}
				height() {
					return this._size.h
				}
				backgroundColor() {
					return this._chartModel().backgroundColor().value()
				}
				highlightedPriceAxis() {
					return this._highlightedPriceAxis
				}
				processDoubleClickOnSource(e, t, i) {
					(0, te.isAlertLabel)(e) ? (0, $e.getPriceAlertsDispatcher)().then((t => {
						var s;
						(0, se.trackEvent)("chart_alert", "edit", `double_click_on_${null!==(s=null==i?void 0:i.origin)&&void 0!==s?s:"line"}`), t.openEditDialog(e.alert(), {
							actionSource: "alert_label_double_click"
						})
					})): (0, k.isDataSource)(e) && e.id() !== this._lastFinishedToolId && this._showEditDialogForSource(e, t)
				}
				stretchFactor() {
					return this._state ? this._state.stretchFactor() : 0
				}
				setStretchFactor(e) {
					this.hasState() && this.state().setStretchFactor(e)
				}
				setCursorForTool(e, t, i) {
					if (t && t.mod() && e) return void this._setCursorClassName("pointer");
					if (void 0 !== i) {
						switch (i) {
							case st.PaneCursorType.VerticalResize:
								this._setCursorClassName("ns-resize");
								break;
							case st.PaneCursorType.HorizontalResize:
								this._setCursorClassName("ew-resize");
								break;
							case st.PaneCursorType.DiagonalNeSwResize:
								this._setCursorClassName("nesw-resize");
								break;
							case st.PaneCursorType.DiagonalNwSeResize:
								this._setCursorClassName("nwse-resize");
								break;
							case st.PaneCursorType.Default:
								this._setCursorClassName("default");
								break;
							case st.PaneCursorType.Pointer:
								this._setCursorClassName("pointer");
								break;
							case st.PaneCursorType.Grabbing:
								this._setCursorClassName("grabbing")
						}
						return
					}
					const s = L.tool.value();
					if ((0, L.toolIsCursor)(s)) {
						if (null !== this._paneWidgetsSharedState.draggingSource() || this._isScrolling || this._chartUndoModel() && this._chartUndoModel().model().sourcesBeingMoved().length) return void this._setCursorClassName("grabbing");
						if (e && this._options.sourceSelectionEnabled) return void this._setCursorClassName("pointer")
					}
					if ("eraser" === s) return void this._setCursorClassName("eraser");
					if ("zoom" === s) return void this._setCursorClassName("zoom-in");
					const o = L.cursorTool.value();
					"dot" !== o ? "arrow" !== o ? this._setCursorClassName("") : this._setCursorClassName("default") : this._setCursorClassName("dot")
				}
				showContextMenuForSelection(e, t) {
					const i = this._chartUndoModel().selection();
					if (i.isEmpty()) return;
					const s = i.dataSources().filter((e => e.hasContextMenu()));
					this.showContextMenuForSources(s, e, void 0, t)
				}
				async showContextMenuForSources(e, t, i, s) {
					var o;
					if (!e.length) return Promise.resolve(null);
					const r = e[0],
						n = (0, _.merge)((0, _.clone)(this._options.contextMenu), i || {}),
						a = new Pe.ActionsProvider(this._chart, n);
					if (r === this._chartUndoModel().crossHairSource()) return r.handleContextMenuEvent(t), Promise.resolve(null); {
						const i = await a.contextMenuActionsForSources(e, t, null == s ? void 0 : s.origin);
						if (0 === i.length) return Promise.resolve(null); {
							let e;
							return e = r instanceof ct.Series ? {
								menuName: "ObjectTreeContextMenu",
								detail: {
									type: "series",
									id: r.instanceId()
								}
							} : (0, g.isLineTool)(r) ? {
								menuName: "ObjectTreeContextMenu",
								detail: {
									type: "shape",
									id: null !== (o = null == r ? void 0 : r.id()) && void 0 !== o ? o : null
								}
							} : {
								menuName: "ObjectTreeContextMenu",
								detail: {
									type: "study",
									id: (null == r ? void 0 : r.id()) || null
								}
							}, Y.ContextMenuManager.createMenu(i, void 0, e).then((e => (e.show(t), e)))
						}
					}
				}
				leftPriceAxisesContainer() {
					return this._lhsPriceAxisesContainer
				}
				rightPriceAxisesContainer() {
					return this._rhsPriceAxisesContainer
				}
				setPriceAxisSizes(e, t, i) {
					this._priceAxisesContainer(e).setSizes(t, i)
				}
				state() {
					return (0, s.ensureNotNull)(this._state)
				}
				hasState() {
					return null !== this._state
				}
				setState(e) {
					this._state !== e && (this.hasState() && this._unsubscribeFromState(), this._state = e, this.hasState() && (this._subscribeToState(), this.updatePriceAxisWidgets()))
				}
				getScreenshotData(e) {
					const t = [],
						i = [];
					let s, o = [];
					const r = this.state().sourcesByGroup().priceSources().slice().reverse(),
						n = this._chart.properties().childs().paneProperties.childs().legendProperties.childs();
					for (const a of r) {
						const r = a.statusView();
						if ((0, S.isStudy)(a) && (n.showLegend.value() || (null == e ? void 0 : e.showCollapsedStudies))) {
							const s = n.showStudyTitles.value(),
								o = !0;
							if (a.properties().childs().visible.value() && r && o) {
								t.push(s ? a.statusProvider(null == e ? void 0 : e.status).text() : "");
								const o = a.valuesProvider().getValues(null);
								i.push(o)
							}
						} else a === this._chartModel().mainSeries() && r && n.showSeriesTitle.value() && (s = a.statusProvider((null == e ? void 0 : e.status) || {}).text(), o = a.valuesProvider().getValues(null))
					}
					return {
						type: "pane",
						leftAxis: this._lhsPriceAxisesContainer.getScreenshotData(),
						rightAxis: this._rhsPriceAxisesContainer.getScreenshotData(),
						content: this._canvasBinding.canvasElement.toDataURL(),
						canvas: this._canvasBinding.canvasElement,
						contentWidth: this._size.w,
						contentHeight: this._size.h,
						studies: t,
						studiesValues: i,
						containsMainSeries: this.containsMainSeries(),
						mainSeriesText: s,
						mainSeriesValues: o
					}
				}
				updatePriceAxisWidgets() {
					if (!this.hasState()) return;
					const e = this._chartModel(),
						t = e.paneForSource(e.mainSeries());
					if (!t) return;
					const i = e.priceScaleSlotsCount(),
						s = this.state(),
						o = s.visibleLeftPriceScales(),
						r = s.visibleRightPriceScales();
					this._lhsPriceAxisesContainer.setScales(o, i.left, t.leftPriceScales().length, i.left + i.right), this._rhsPriceAxisesContainer.setScales(r, i.right, t.rightPriceScales().length, i.left + i.right)
				}
				update() {
					this.hasState() && (this._lhsPriceAxisesContainer.update(), this._rhsPriceAxisesContainer.update(), null !== this._legendWidget && this._legendWidget.update(), this.updateControls())
				}
				updateStatusWidget(e) {
					this.hasState() && null !== this._legendWidget && (e.legendWidgetLayoutInvalidated() ? this._legendWidget.updateLayout() : this._legendWidget.update())
				}
				updateControls() {
					this.hasState() && null !== this._paneControls && this._paneControls.update()
				}
				updateThemedColors(e) {
					this._themedTopColor = e.topColor, this._updateByThemedColors()
				}
				statusWidget() {
					return this._legendWidget
				}
				getElement() {
					return this._rowElement
				}
				canvasElement() {
					return this._canvasBinding.canvasElement
				}
				hasCanvas(e) {
					return this._canvasBinding.canvasElement === e || this._topCanvasBinding.canvasElement === e
				}
				pinchStartEvent() {
					null === this._paneWidgetsSharedState.scrollingPane() && null === this._paneWidgetsSharedState.pinchingPane() && (this._onTouchEvent(), this._options.handleScale.pinch && (this._terminateActiveAnimations(), this._prevPinchScale = 1, this._pinching = !0, this._wasPinched = !0, this._paneWidgetsSharedState.setPinchingPane(this)))
				}
				pinchEvent(e, t, i, s) {
					if (null !== this._paneWidgetsSharedState.scrollingPane() || this._paneWidgetsSharedState.pinchingPane() !== this) return;
					if (this._onTouchEvent(), !this._options.handleScale.pinch) return;
					const o = 10 * (s - this._prevPinchScale);
					this._prevPinchScale = s, this._chartModel().zoomTime(e.x, o, !0), this._prevPinchScale = s
				}
				pinchEndEvent() {
					null === this._paneWidgetsSharedState.scrollingPane() && this._paneWidgetsSharedState.pinchingPane() === this && (this._onTouchEvent(), this._pinching = !1, this._paneWidgetsSharedState.setPinchingPane(null))
				}
				mouseClickEvent(e) {
					this._onMouseEvent(), this._mouseClickOrTapEvent(e)
				}
				tapEvent(e) {
					this._preventTouchEventsExceptPinch() || (this._onTouchEvent(), this._mouseClickOrTapEvent(e))
				}
				mouseDownEvent(e) {
					this._onMouseEvent(), this.hasState() && this._mouseDownOrTouchStartEvent(e, (0, s.ensureNotNull)(this._dataSourceAtPoint(e.localX, e.localY)))
				}
				touchStartEvent(e) {
					if (this._paneWidgetsSharedState.startTouch(this), this._preventTouchEventsExceptPinch()) return;
					const t = !this._trackCrosshairOnlyAfterLongTap && null !== Dt && Dt.stateId === this.state().id() && Math.abs(Dt.x - e.localX) + Math.abs(Dt.y - e.localY) < 5;
					this._onTouchEvent(), this._chart.setActivePaneWidget(this);
					const i = (0, s.ensureNotNull)(this._dataSourceAtPoint(e.localX, e.localY));
					if (t) {
						const t = this._chartModel().crossHairSource();
						i.source === t || 0 !== t.selectPointMode().value() ? this.startTrackingMode(new C.Point(e.localX, e.localY), new C.Point(e.localX, e.localY)) : !this._chart.readOnly() && ((0,
							g.isLineTool)(i.source) && i.source.userEditEnabled() || (0, te.isAlertLabel)(i.source)) && this._chartUndoModel().selectionMacro((e => {
							var t;
							e.clearSelection(), e.addSourceToSelection(i.source, null === (t = i.hittest) || void 0 === t ? void 0 : t.data())
						}))
					}
					this._mouseDownOrTouchStartEvent(e, i), this._mouseOrTouchMoveEvent(e)
				}
				mouseUpEvent(e) {
					this._onMouseEvent(), this._mouseUpOrTouchEndEvent(e)
				}
				touchEndEvent(e) {
					this._paneWidgetsSharedState.endTouch(this), this._preventTouchEventsExceptPinch() || (this._onTouchEvent(), this._mouseOrTouchLeaveEvent(e), this._mouseUpOrTouchEndEvent(e))
				}
				mouseMoveEvent(e) {
					this._onMouseEvent(), this._mouseOrTouchMoveEvent(e)
				}
				pressedMouseMoveEvent(e) {
					this._onMouseEvent(), this._pressedMouseOrTouchMoveEvent(e)
				}
				touchMoveEvent(e) {
					this._preventTouchEventsExceptPinch() || (this._onTouchEvent(), this._pressedMouseOrTouchMoveEvent(e))
				}
				mouseLeaveEvent(e) {
					this._onMouseEvent(), this._mouseOrTouchLeaveEvent(e)
				}
				mouseDoubleClickEvent(e) {
					this._onMouseEvent(), this._mouseDoubleClickOrDoubleTapEvent(e)
				}
				wheelClickEvent(e) {
					var t, i;
					if (this._chart.readOnly()) return;
					const o = this._dataSourceAtPoint(e.localX, e.localY);
					if (null === o || o.isCustom || null === o.source) return;
					if (((null === (t = o.hittest) || void 0 === t ? void 0 : t.result()) || 0) <= x.HitTestResult.MOVEPOINT_BACKGROUND) return;
					const r = new A.EnvironmentState(e),
						n = null === (i = o.hittest) || void 0 === i ? void 0 : i.eraseMarker();
					if (r.mod() && void 0 !== n && o.source.processErase) return void o.source.processErase(this._chartUndoModel(), n);
					const a = this._chartUndoModel();
					a.selection().isSelected(o.source) || a.selectionMacro((e => {
						e.clearSelection();
						const t = (0, s.ensureNotNull)(o.source);
						e.addSourceToSelection(t, It(o, t))
					})), this._chart.removeSelectedSources()
				}
				doubleTapEvent(e) {
					this._preventTouchEventsExceptPinch() || (this._onTouchEvent(), this._mouseDoubleClickOrDoubleTapEvent(e))
				}
				longTapEvent(e) {
					if (null === this._state || this._preventTouchEventsExceptPinch()) return;
					if (this._onTouchEvent(), this._longTap = !0, null !== this._startTrackPoint || !this._trackingModeShouldBeActive()) return;
					const t = this._chartModel().selection();
					if (!t.isEmpty()) {
						const i = (0, s.ensureNotNull)(this._dataSourceAtPoint(e.localX, e.localY));
						if (null !== i.source && t.isSelected(i.source)) return
					}
					this.startTrackingMode(new C.Point(e.localX, e.localY), new C.Point(e.localX, e.localY), new A.EnvironmentState(e))
				}
				mouseEnterEvent(e) {
					this._onMouseEvent(), this.hasState() && (this._chart.setActivePaneWidget(this), this._setCursorPosition(e.localX, e.localY, new A.EnvironmentState(e)))
				}
				contextMenuEvent(e) {
					this._onMouseEvent(), this._contextMenuEvent(e)
				}
				touchContextMenuEvent(e) {
					this._preventTouchEventsExceptPinch() || (this._onTouchEvent(), this._contextMenuEvent(e))
				}
				mouseDownOutsideEvent() {
					this._processOutsideClick({
						hittest: null,
						isCustom: !1,
						renderer: null,
						source: null
					})
				}
				cancelZoom() {
					this._chartModel().crossHairSource().clearSelection(), this._firstZoomPoint = null, this._preventCrossHairMove() && this._clearCursorPosition()
				}
				startTrackingMode(e, t, i) {
					this._startChangeLineToolParams = null, this._startMoveSourceParams = null, this._currentChangingLineToolHitTest = null, this._currentMovingHitTest = null,
						this._chartUndoModel().selectionMacro((e => e.clearSelection())), this._startTrackPoint = e, this._exitTrackingModeOnNextTry = !1, this._setCursorPosition(t.x, t.y, i), this._initCrossHairPosition = this._chartModel().crossHairSource().currentPoint()
				}
				setDragToAnotherPaneCursor() {
					this._setCursorClassName("grabbing")
				}
				cloneLineTools(e, t) {
					return this._chartUndoModel().cloneLineTools(e, t)
				}
				exitTrackingMode() {
					null !== this._state && null !== this._startTrackPoint && (this._exitTrackingModeOnNextTry = !0, this._tryExitTrackingMode())
				}
				trackingModeEnabled() {
					return null !== this._state && null !== this._startTrackPoint
				}
				addCustomWidgetToLegend(e, t) {
					this._options.legendWidgetEnabled && (this._customLegendWidgetsFactoryMap.set(e, t), null !== this._legendWidget && this._legendWidget.addCustomWidgetToLegend(e, t))
				}
				containsMainSeries() {
					return !!this.hasState() && this.state().containsMainSeries()
				}
				paint(e, t) {
					if (!this._chartUndoModel() || !this.hasState() || 0 === this._size.w || 0 === this._size.h) return;
					this._canvasBinding.applySuggestedBitmapSize(), this._topCanvasBinding.applySuggestedBitmapSize(), this._state && (e.priceScaleSideMaxLevel("left") > f.InvalidationLevel.Cursor || e.priceScaleSideMaxLevel("right") > f.InvalidationLevel.Cursor) && (this._recalculatePriceScales((0, dt.viewportChangeEvent)()), null !== Dt && Dt.stateId === this.state().id() && this._setCursorPosition(Dt.x, Dt.y, Dt.envState));
					const i = e.fullInvalidation();
					if (i > f.InvalidationLevel.Cursor && null !== Dt && Dt.stateId === this.state().id()) {
						const e = this._dataSourceAtPoint(Dt.x, Dt.y);
						null !== e && this._updateHoveredSource(e, (0, at.globalEnvironmentState)())
					}
					if (this._lhsPriceAxisesContainer.paint(e.getterForPriceScaleInvalidationLevelBySide("left")), this._rhsPriceAxisesContainer.paint(e.getterForPriceScaleInvalidationLevelBySide("right")), i === f.InvalidationLevel.None) return;
					const o = this._state && (this._state.maximized().value() || !this._state.collapsed().value());
					if (i > f.InvalidationLevel.Cursor) {
						const e = (0, s.ensureNotNull)(this._canvasBinding.canvasElement.getContext("2d"));
						e.setTransform(1, 0, 0, 1, 0, 0);
						const i = this._canvasRenderParams();
						this._drawBackground(e, i), o && this._drawSources(e, i, t)
					}
					if (null !== this._state) {
						const e = (0, s.ensureNotNull)(this._topCanvasBinding.canvasElement.getContext("2d"));
						e.setTransform(1, 0, 0, 1, 0, 0);
						const t = this._topCanvasRenderParams();
						e.clearRect(0, 0, Math.ceil(this._size.w * t.pixelRatio), Math.ceil(this._size.h * t.pixelRatio)), o && this._drawSeriesTopViews(e, t), this._drawCrossHair(e, t), o && this._drawActiveLineTools(e, t)
					}
					this._updateEndOfSeriesBanner()
				}
				cancelCreatingLineTool() {
					const e = this._chartUndoModel(),
						t = this._chartUndoModel().lineBeingCreated();
					if (t)
						if (t.pointsCount() <= 0 && !(0, tt.isLineDrawnWithPressedButton)(t.toolname)) {
							const i = t.points();
							if (i.length > 2) {
								const s = i[i.length - 2];
								e.continueCreatingLine(s), this._finishTool(t)
							} else e.cancelCreatingLine()
						} else e.cancelCreatingLine();
					null !== this._firstZoomPoint && this.cancelZoom(), this.setCursorForTool()
				}
				drawRightThere(e) {
					if ((0, g.isLineToolName)(e) && this.hasState()) {
						const t = this._chartUndoModel(),
							i = t.crossHairSource(),
							s = t.model().magnet().align(i.price, i.index, this.state());
						t.createLineTool({
							pane: this.state(),
							point: {
								index: i.index,
								price: s
							},
							linetool: e
						})
					}
				}
				cancelMeasuring() {
					this._chartUndoModel().crossHairSource().clearMeasure(), (0, L.resetToCursor)(), this.setCursorForTool()
				}
				async setErrorMessage(e) {
					var t, i, s;
					e && !this._errorRenderer && (this._errorRenderer = this._createErrorBlock()), null === (t = await this._errorRenderer) || void 0 === t || t.update({
						message: null == e ? void 0 : e.message,
						icon: (null === (i = this._state) || void 0 === i ? void 0 : i.containsMainSeries()) || (null === (s = this._state) || void 0 === s ? void 0 : s.maximized().value()) ? null == e ? void 0 : e.icon : void 0,
						backgroundColor: `linear-gradient(${this._chartModel().backgroundTopColor().value()}, ${this._chartModel().backgroundColor().value()})`,
						textColor: this._chartModel().isDark() ? St : gt
					})
				}
				collapsedHeight() {
					var e, t;
					return Math.max(Math.ceil(null !== (t = null === (e = this._paneControls) || void 0 === e ? void 0 : e.bottomWithMargin()) && void 0 !== t ? t : 0), 33)
				}
				_topCanvasRenderParams() {
					return {
						pixelRatio: (0, B.getBindingPixelRatio)(this._topCanvasBinding),
						physicalWidth: this._topCanvasBinding.canvasElement.width,
						physicalHeight: this._topCanvasBinding.canvasElement.height,
						cssWidth: this._chartModel().timeScale().width(),
						cssHeight: this.height()
					}
				}
				_canvasRenderParams() {
					return {
						pixelRatio: (0, B.getBindingPixelRatio)(this._canvasBinding),
						physicalWidth: this._canvasBinding.canvasElement.width,
						physicalHeight: this._canvasBinding.canvasElement.height,
						cssWidth: this._chartModel().timeScale().width(),
						cssHeight: this.height()
					}
				}
				_tryExitTrackingMode(e) {
					this._exitTrackingModeOnNextTry && (this._startTrackPoint = null, e || this._clearCursorPosition())
				}
				_tryStartMeasure(e, t, i, s, o) {
					return !(!(0, L.toolIsMeasure)(L.tool.value()) || t.startMeasurePoint()) && (e.isTouch || this._preventCrossHairMove() || this._setCursorPosition(e.localX, e.localY, i), s = this._chartModel().magnet().align(s, o, this.state()), t.startMeasuring({
						price: s,
						index: o
					}, this.state()), !0)
				}
				_tryFinishMeasure(e, t) {
					if (t.startMeasurePoint() && !t.endMeasurePoint()) {
						let i = t.price;
						const s = t.index;
						return i = this._chartModel().magnet().align(i, s, this.state()), t.finishMeasure({
							price: i,
							index: s
						}), e.isTouch ? (0, L.resetToCursor)() : this._needResetMeasureLater = !0, this._preventCrossHairMove() && this._clearCursorPosition(), !0
					}
					return !1
				}
				_tryStartZoom(e, t, i, s) {
					const o = this._chart.model().model().zoomEnabled();
					if ("zoom" === L.tool.value() && o) {
						const o = this._chartUndoModel(),
							r = o.timeScale().indexToCoordinate(i) - .5 * o.timeScale().barSpacing();
						return this._firstZoomPoint = {
							price: t,
							index: i,
							x: r,
							y: e.localY
						}, this._preventCrossHairMove() || this._setCursorPosition(e.localX, e.localY, s), this._chartModel().crossHairSource().startSelection(this.state()), !0
					}
					return !1
				}
				_finishZoom(e) {
					const t = this.state(),
						i = t.defaultPriceScale(),
						o = (0, s.ensureNotNull)(t.mainDataSource()).firstValue(),
						r = i.coordinateToPrice(e.localY, (0, s.ensureNotNull)(o)),
						n = this._chartUndoModel(),
						a = Math.round(n.timeScale().coordinateToIndex(e.localX)),
						l = (0, s.ensureNotNull)(this._firstZoomPoint);
					a !== l.index && n.zoomToViewport(l.index, a, l.price, r, t), this._chartModel().crossHairSource().clearSelection(), this._firstZoomPoint = null, (0, L.resetToCursor)(),
						this._preventCrossHairMove() && this._clearCursorPosition()
				}
				_tryFinishZoom(e) {
					return null !== this._firstZoomPoint && (this._finishZoom(e), !0)
				}
				_tryHandleEraserMouseDown(e, t) {
					if (e.source && "eraser" === L.tool.value() && !e.isCustom && (!(i = e.source) || !i.customization || !i.customization.disableErasing)) {
						const i = this._chartUndoModel();
						if (null !== e.hittest && ((0, g.isLineTool)(e.source) || (0, S.isStudy)(e.source))) {
							const s = e.hittest.eraseMarker();
							return t.mod() && void 0 !== s && e.source.processErase ? e.source.processErase(i, s) : i.removeSource(e.source, !1), !0
						}
					}
					var i;
					return !1
				}
				_tryStartChangingLineTool(e, t, i, o) {
					var r, n;
					if (e.isTouch && null !== this._startTrackPoint) return !1;
					const a = t.hittest;
					if ((!e.isTouch || !this._preventSourceChange) && a && (0, g.isLineTool)(t.source) && a.result() === x.HitTestResult.CHANGEPOINT) {
						const l = this._chartUndoModel(),
							c = (0, s.ensure)(null === (r = this.state().mainDataSource()) || void 0 === r ? void 0 : r.firstValue()),
							h = (0, s.ensureNotNull)(t.source.priceScale()).coordinateToPrice(e.localY, c);
						l.selectionMacro((e => {
							e.clearSelection(), e.addSourceToSelection(t.source, a.data())
						}));
						const d = l.model().magnet().align(h, o, this.state()),
							u = null === (n = a.data()) || void 0 === n ? void 0 : n.pointIndex;
						return this._startChangeLineToolParams = {
							source: t.source,
							startPoint: {
								index: o,
								price: d
							},
							screenPoint: {
								x: e.localX,
								y: e.localY
							},
							pointIndex: u,
							envState: i
						}, !0
					}
					return this._startChangeLineToolParams = null, !1
				}
				_tryStartCloning(e, t, i, s) {
					if (i.mod()) {
						const t = this._chartUndoModel().selection().dataSources().filter((e => e.cloneable()));
						if (s && s.cloneable() && t.push(s), t.length > 0) return this._clonningAtMoveLineTools = t.map((e => e.id())), this._startCloningPoint = new C.Point(e.localX, e.localY), !0
					}
					return !1
				}
				_tryFinishClonning(e, t, i) {
					const o = this._chartUndoModel(),
						r = this._chartModel();
					if (t.mod() && this._clonningAtMoveLineTools) {
						const n = new C.Point(e.localX, e.localY),
							a = (0, s.ensureNotNull)(this._startCloningPoint).subtract(n).length(),
							l = [];
						for (const e of this._clonningAtMoveLineTools) {
							const t = r.dataSourceForId(e);
							null !== t && l.push(t)
						}
						if (0 === l.length) return !1;
						if (a > 8) {
							const r = this.cloneLineTools(l, !0).map((e => (0, s.ensureNotNull)(o.model().dataSourceForId(e))));
							o.selectionMacro((e => {
								e.clearSelection();
								let t = null;
								r.forEach((s => {
									null === t && (t = It(i, s)), e.addSourceToSelection(s, t)
								}))
							}));
							const n = new C.Point(e.localX, e.localY),
								a = (0, s.ensureNotNull)(r[0].priceScale()),
								c = (0, s.ensureNotNull)(this.state().mainDataSource()).firstValue(),
								h = {
									index: o.timeScale().coordinateToIndex(e.localX),
									price: a.coordinateToPrice(e.localY, (0, s.ensureNotNull)(c))
								};
							o.startMovingSources(r, {
								logical: h,
								screen: n
							}, null, t), this._clonningAtMoveLineTools = null, this._startCloningPoint = null
						}
						return !0
					}
					return !1
				}
				_mouseDownEventForLineTool(e, t, i, o) {
					var r, n;
					const a = L.tool.value();
					if (!this.hasState() || (0, tt.isLineToolDrawWithoutPoints)(a)) return;
					const l = this._chartUndoModel();
					let c = !1,
						h = null;
					(0, L.hideAllDrawings)().value() && (0, ht.toggleHideMode)(), (0, L.lockDrawings)().setValue(!1), e.isTouch && !e.stylus && ((0, g.isLineToolName)(a) && !(0, tt.isLineDrawnWithPressedButton)(a) || l.lineBeingCreated()) && this._initToolCreationModeParams(e);
					const d = l.lineBeingCreated();
					if (d && !(0, tt.isLineDrawnWithPressedButton)(d.toolname)) {
						const a = (0, s.ensure)(null === (r = d.ownerSource()) || void 0 === r ? void 0 : r.firstValue());
						if (e.isTouch && !e.stylus) {
							if (!this._startTouchPoint) {
								this._startTouchPoint = new C.Point(e.pageX, e.pageY);
								const t = d.points(),
									i = t[t.length - 1],
									o = l.timeScale().indexToCoordinate(i.index),
									r = (0, s.ensureNotNull)(d.priceScale()).priceToCoordinate(i.price, a);
								return void(this._initCrossHairPosition = new C.Point(o, r))
							}
						} else if (!e.isTouch) {
							h = d;
							const r = l.model().paneForSource(d);
							if (r !== this._state && null !== r) {
								const i = this._externalPaneXCoord(r, e.localX),
									o = this._externalPaneYCoord(r, e.localY);
								c = l.continueCreatingLine({
									index: Math.round(l.timeScale().coordinateToIndex(i)),
									price: (0, s.ensure)(null === (n = d.priceScale()) || void 0 === n ? void 0 : n.coordinateToPrice(o, a))
								}, t)
							} else {
								const e = l.model().magnet().align(o, i, this.state());
								c = l.continueCreatingLine({
									index: i,
									price: e
								}, t)
							}
						}
					} else if (!e.isTouch || e.stylus || (0, tt.isLineDrawnWithPressedButton)(a)) {
						const e = {
							index: i,
							price: l.model().magnet().align(o, i, this.state())
						};
						h = l.createLineTool({
							pane: this.state(),
							point: e,
							linetool: a
						}), l.lineBeingCreated() || (c = !0)
					}
					const u = (0, s.ensureNotNull)(this._dataSourceAtPoint(e.localX, e.localY));
					h && l.selectionMacro((e => {
						var t;
						return e.addSourceToSelection((0, s.ensureNotNull)(h), null === (t = u.hittest) || void 0 === t ? void 0 : t.data())
					})), c && h && (this._finishTool(h, u), e.preventDefault())
				}
				_handleSelectionMouseDownAndGetJustDeselectedSource(e, t, i) {
					const s = this._chartUndoModel();
					let o = null;
					if (null === t.source || t.source.isSelectionEnabled()) {
						let r = e.isTouch ? Boolean(t.hittest && t.hittest.result() >= x.HitTestResult.MOVEPOINT_BACKGROUND) : Boolean(t.hittest && t.hittest.result() > x.HitTestResult.MOVEPOINT_BACKGROUND);
						this._preventSourceChange && (r = !1), s.selectionMacro((e => {
							var s;
							r && t.source ? (i.mod() || e.selection().isSelected(t.source) || e.clearSelection(), i.mod() && e.selection().isSelected(t.source) ? (o = t.source, e.removeSourceFromSelection(t.source)) : e.addSourceToSelection(t.source, null === (s = t.hittest) || void 0 === s ? void 0 : s.data()), e.selection().allSources().length > 1 && (0, se.trackEvent)("GUI", "Multiselect", "Click Select")) : i.mod() || e.clearSelection()
						}))
					}
					return o
				}
				_processMouseMoveWhileZoom(e, t) {
					this._preventCrossHairMove() || this._setCursorPosition(e.localX, e.localY, t)
				}
				_updateCommonTooltip(e, t) {
					let i = null;
					if (null !== e && null !== e.hittest) {
						const t = e.hittest.data();
						t && (i = t.tooltip || null)
					}
					if (null === this._prevTooltipData && null === i) return;
					if (null === i || "" === i.text) return this._prevTooltipData = null, void(0, ot.hide)(t);
					if (this._prevTooltipData && (0, b.default)(i, this._prevTooltipData)) return;
					this._prevTooltipData = i;
					const s = (0, _.clone)(i);
					if (void 0 !== s.rect) {
						const e = this._paneCell.getBoundingClientRect();
						s.rect.x += e.left, s.rect.y += e.top
					}(0, ot.show)(s)
				}
				_setCursorPositionOnExternalPane(e, t, i, s) {
					t = this._externalPaneXCoord(e, t), i = this._externalPaneYCoord(e, i);
					this._chart.paneByState(e)._setCursorPosition(t, i, s)
				}
				_setCursorPosition(e, t, i) {
					this._updateLastCrosshairPosition(e, t, i), this._chartModel().setAndSaveCurrentPosition(this._correctXCoord(e), this._correctYCoord(t), this.state(), i)
				}
				_updateLastCrosshairPosition(e, t, i) {
					const s = this.state().id();
					Dt = {
						x: e,
						y: t,
						envState: i,
						stateId: s
					}
				}
				_setCursorClassName(e) {
					let t = "";
					e && (t = "pane--cursor-" + e), this._currentCursorClassName !== t && (this._currentCursorClassName && this._paneCell.classList.remove(this._currentCursorClassName), t && this._paneCell.classList.add(t), this._currentCursorClassName = t, this._paneCell.style.cursor)
				}
				_processMouseUpOrTouchEndHandler(e) {
					var t;
					null === (t = (0, s.ensureNotNull)(this._dataSourceAtPoint(e.localX, e.localY)).hittest) || void 0 === t || t.tryCallMouseUpOrTouchEndHandler(e)
				}
				_crossHairShouldBeVisible() {
					const e = this._chartModel().crossHairSource();
					return (0, g.isLineToolName)(L.tool.value()) || (0, L.toolIsMeasure)(L.tool.value()) || e.startMeasurePoint() && !e.endMeasurePoint() || null !== this._firstZoomPoint || null !== this._chartModel().lineBeingEdited() || null !== this._chartModel().lineBeingCreated()
				}
				_clearCursorPosition() {
					Dt = null, this._chartModel().clearCurrentPosition()
				}
				_dataSourceAtPoint(e, t) {
					if (!this.hasState()) return null;
					const i = {
							source: null,
							hittest: null,
							isCustom: !1,
							renderer: null
						},
						s = this._chartUndoModel();
					if ((0, g.isLineToolName)(L.tool.value()) || null !== s.lineBeingCreated()) return i;
					if (this._currentChangingLineToolHitTest) return this._currentChangingLineToolHitTest;
					if (this._currentMovingHitTest) return this._currentMovingHitTest;
					const o = this.state(),
						r = o.height(),
						n = o.width(),
						a = At.bind(null, i),
						l = this._canvasRenderParams(),
						c = new C.Point(e, t);
					if (!this.state().maximized().value() && this.state().collapsed().value() || (0, P.lastMouseOrTouchEventInfo)().isTouch && (L.isPointSelectedNow.value() || null !== this._startTrackPoint)) return this._hitTestSources(l, [s.crossHairSource()], c, a, !1), i;
					const h = o.sourcesByGroup(),
						d = s.selection();
					this._hitTestSources(l, d.dataSources(), c, a, !1), this._hitTestSources(l, d.customSources(), c, a, !0);
					const u = new Set(d.allSources().map((e => e.id())));
					this._hitTestSources(l, [s.crossHairSource()], c, a, !1, u), this._hitTestSources(l, o.customSources(I.CustomSourceLayer.Topmost), c, a, !0, u), this._hitTestSources(l, h.tradingSources(), c, a, !1, u), this._hitTestSources(l, o.customSources(I.CustomSourceLayer.Foreground), c, a, !0, u);
					const _ = [...this._chartModel().multiPaneSources(o), ...h.hitTestSources()];
					if (this._hitTestSources(l, _, c, a, !1, u), this.containsMainSeries()) {
						const e = s.barsMarksSources();
						for (let t = 0; t < e.length; ++t) {
							const s = e[t],
								a = s.paneViews(o) || [];
							let h, d;
							for (let e = 0; e < a.length; e++) h = a[e].renderer(r, n), null !== h && (d = h.hitTest(c, l), d && At(i, d, s, h, !1))
						}
						const t = s.activeStrategySource().value();
						if (null !== t) {
							const e = t.strategyOrdersPaneView();
							if (null !== e) {
								const s = e.renderer(r, n);
								if (null !== s) {
									const e = s.hitTest(c, l);
									e && At(i, e, t, s, !1)
								}
							}
						}
					}
					return null === i.source && this._hitTestSources(l, o.customSources(I.CustomSourceLayer.Background), c, a, !0, u), i
				}
				_hitTestSources(e, t, i, o, r, n) {
					const a = (0, s.ensureNotNull)(this._state),
						l = a.height(),
						c = a.width();
					for (let s = t.length - 1; s >= 0; --s) {
						const h = t[s];
						if (void 0 !== n && n.has(h.id())) continue;
						const d = h.paneViews(a);
						if (null !== d && 0 !== d.length)
							for (let t = d.length - 1; t >= 0; --t) {
								const s = d[t].renderer(l, c);
								if (s && s.hitTest) {
									const t = s.hitTest(i, e);
									null !== t && o(t, h, s, r)
								}
							}
					}
				}
				_tryStartMovingLineTool(e, t, i, o) {
					var r, n;
					if (null === t.source || !t.source.movable() || null !== this._startTrackPoint) return !1;
					if (!this._preventSourceChange) {
						const a = this._chartUndoModel(),
							l = (0, s.ensureNotNull)((0, s.ensureNotNull)(this._state).mainDataSource()).firstValue(),
							c = (0, s.ensureNotNull)(t.source.priceScale()).coordinateToPrice(e.localY, (0, s.ensureNotNull)(l));
						let h = (t.source.isSelectionEnabled() ? a.selection().allSources() : [t.source]).filter(lt);
						const d = h.filter(g.isLineTool);
						h = d.length > 0 ? d : h.includes(t.source) ? [t.source] : [h[0]];
						const u = new C.Point(e.localX, e.localY),
							_ = {
								index: o,
								price: c
							},
							m = null === (n = null === (r = t.hittest) || void 0 === r ? void 0 : r.data()) || void 0 === n ? void 0 : n.activeItem;
						return this._startMoveSourceParams = {
							source: h,
							startPoint: {
								logical: _,
								screen: u
							},
							activeItem: void 0 === m ? null : m,
							envState: i
						}, !0
					}
					return this._startMoveSourceParams = null, !1
				}
				_chartModel() {
					return this._chart.model().model()
				}
				_chartUndoModel() {
					return this._chart.model()
				}
				_externalPaneXCoord(e, t) {
					t += this._div.getBoundingClientRect().left + document.body.scrollLeft;
					const i = (0, s.ensureNotNull)(this._chart.paneByState(e)),
						o = i._div.getBoundingClientRect().left + document.body.scrollLeft;
					return i._correctXCoord(t - o)
				}
				_externalPaneYCoord(e, t) {
					t += this._div.getBoundingClientRect().top + document.body.scrollTop;
					const i = (0, s.ensureNotNull)(this._chart.paneByState(e)),
						o = i._div.getBoundingClientRect().top + document.body.scrollTop;
					return i._correctYCoord(t - o)
				}
				_correctXCoord(e) {
					return Math.max(0, Math.min(e, this._size.w - 1))
				}
				_correctYCoord(e) {
					return Math.max(0, Math.min(e, this._size.h - 1))
				}
				_processScroll(e) {
					if (!this._chart.model().model().scrollEnabled()) return;
					const t = Date.now();
					this._startScrollingPos || this._preventScroll() || (this._startScrollingPos = {
						x: e.clientX,
						y: e.clientY,
						timestamp: t,
						localX: e.localX,
						localY: e.localY
					}), null !== this._scrollXAnimation && this._scrollXAnimation.addPosition(e.localX, t), null !== this._scrollYAnimation && this._scrollYAnimation.addPosition(e.localY, t);
					const i = this._chartUndoModel();
					let s = this.state().defaultPriceScale();
					if (this._startScrollingPos && !this._isScrolling && (this._startScrollingPos.x !== e.clientX || this._startScrollingPos.y !== e.clientY)) return i.beginUndoMacro(vt, !0), null === this._scrollXAnimation && this._options.useKineticScroll && (this._scrollXAnimation = new je.KineticAnimation(.2, 7, .997, 15), this._scrollXAnimation.addPosition(this._startScrollingPos.localX, this._startScrollingPos.timestamp), this._scrollXAnimation.addPosition(e.localX, t)), this._scrollYAnimation, i.selection().isEmpty() || (s = i.selection().allSources()[0].priceScale()), null === s || s.isEmpty() || (this._scrollPriceScale = s, i.startScrollPrice(this.state(), s, e.localY)), i.startScrollTime(e.localX), this._isScrolling = !0, this.setCursorForTool(), void this._paneWidgetsSharedState.setScrollingPane(this);
					this._isScrolling && (null !== this._scrollPriceScale && i.scrollPriceTo(this.state(), this._scrollPriceScale, e.localY), i.scrollTimeTo(e.localX))
				}
				_finishScroll() {
					const e = this._chartUndoModel();
					e.endScrollTime(),
						null !== this._scrollPriceScale && e.endScrollPrice(this.state(), this._scrollPriceScale), e.endUndoMacro(), this._isScrolling = !1, this._startScrollingPos = null, this._scrollPriceScale = null, this.setCursorForTool(), this._paneWidgetsSharedState.setScrollingPane(null)
				}
				_endScroll(e) {
					if (!this._isScrolling) return !1;
					const t = this._isScrolling && this._scrollUndoCommandInStack();
					if (this._isScrolling) {
						const i = Date.now();
						null !== this._scrollXAnimation && this._scrollXAnimation.start(e.localX, i), null !== this._scrollYAnimation && this._scrollYAnimation.start(e.localY, i);
						const s = this._chartUndoModel(),
							o = null === this._scrollXAnimation || this._scrollXAnimation.finished(i),
							r = null === this._scrollYAnimation || this._scrollYAnimation.finished(i);
						if (o && r) return this._finishScroll(), t;
						o ? (s.endScrollTime(), this._paneWidgetsSharedState.setScrollingPane(null)) : r && (this._scrollPriceScale && s.endScrollPrice(this.state(), this._scrollPriceScale), this._scrollPriceScale = null);
						const n = s.timeScale(),
							a = this._scrollXAnimation,
							l = this._scrollYAnimation,
							c = () => {
								if ((null === a || a.terminated()) && (null === l || l.terminated())) return;
								const e = Date.now();
								let t = null === a || a.finished(e);
								const i = null === l || l.finished(e);
								if (null !== a && !a.terminated()) {
									const i = n.rightOffset();
									s.scrollTimeTo(a.getPosition(e)), i === n.rightOffset() && (t = !0, this._scrollXAnimation = null)
								}
								null === l || l.terminated() || null === this._scrollPriceScale || s.scrollPriceTo(this.state(), this._scrollPriceScale, l.getPosition(e)), t && i ? this._finishScroll() : requestAnimationFrame(c)
							};
						requestAnimationFrame(c)
					}
					return t
				}
				_terminateActiveAnimations() {
					const e = Date.now(),
						t = null === this._scrollXAnimation || this._scrollXAnimation.finished(e),
						i = null === this._scrollYAnimation || this._scrollYAnimation.finished(e);
					null === this._scrollXAnimation && null === this._scrollYAnimation || t && i || this._finishScroll(), null !== this._scrollXAnimation && (this._scrollXAnimation.terminate(), this._scrollXAnimation = null), null !== this._scrollYAnimation && (this._scrollYAnimation.terminate(), this._scrollYAnimation = null)
				}
				_preventScroll() {
					return this._trackCrosshairOnlyAfterLongTap && this._longTap || this._contextMenuOpenedOnLastTap || (0, g.isLineToolName)(L.tool.value()) || Boolean(this._chartUndoModel().lineBeingCreated()) || null !== this._startTrackPoint
				}
				_isSelectPointModeEnabled() {
					return 0 !== this._chartUndoModel().crossHairSource().selectPointMode().value()
				}
				_preventCrossHairMove() {
					return !!this._trackCrosshairOnlyAfterLongTap && (null === this._chart.trackingModePaneWidget() && (!!this._contextMenuOpenedOnLastTap || !this._crossHairShouldBeVisible() && null === this._startTrackPoint))
				}
				_finishTool(e, t = null) {
					const i = this._chartUndoModel(),
						s = L.tool.value();
					if ((0, L.resetToCursor)(), this._preventCrossHairMove() && this._clearCursorPosition(), i.selectionMacro((i => {
							i.addSourceToSelection(e, It(t, e))
						})), (0, tt.isTextToolName)(s)) {
						const t = i.createUndoCheckpoint();
						this._chart.showChartPropertiesForSource(e, it.TabNames.text, void 0, t).then((e => {
							if ("LineToolText" === s) {
								const t = !Boolean(a.getBool("hint.pasteText"));
								null !== e && t && e.visible().subscribe((() => {
									(0,
										Je.showPasteLineToolHint)(this._chart.chartWidgetCollection().getContainer(), "hint.pasteText")
								}), {
									once: !0
								})
							}
						}))
					}
					this._lastFinishedToolId = e.id(), (0, h.emit)("drawing_event", e.id(), "create"), (0, et.trackDrawingCreated)(e)
				}
				_alignSourcesThatBeingMoved(e, t, i, s) {
					const o = this._chartUndoModel(),
						r = o.timeScale().coordinateToIndex(t);
					o.model().sourcesBeingMoved().forEach((e => {
						var n, a;
						let l = r,
							c = e.convertYCoordinateToPriceForMoving(i, this.state().mainDataSource());
						if (null !== c) {
							if ((0, S.isStudy)(e)) {
								const e = o.mainSeries(),
									t = e.bars().firstIndex(),
									i = e.bars().lastIndex();
								null !== t && null !== i && (l = Math.min(Math.max(r, t), i)), c = this._chartModel().magnet().align(c, r, this.state())
							}
							null !== this._currentMovingHitTest && void 0 !== (null === (a = null === (n = this._currentMovingHitTest.hittest) || void 0 === n ? void 0 : n.data()) || void 0 === a ? void 0 : a.cursorType) || this.setCursorForTool(), o.moveSources({
								screen: new C.Point(t, i),
								logical: {
									index: l,
									price: c
								}
							}, s)
						}
					}))
				}
				_resetMeasureIfRequired() {
					this._needResetMeasureLater && ((0, L.resetToCursor)(), this._needResetMeasureLater = !1)
				}
				_drawBackground(e, t) {
					const i = Math.ceil(t.pixelRatio * this._size.w),
						s = Math.ceil(t.pixelRatio * this._size.h),
						o = this._chartModel(),
						r = o.backgroundTopColor().value(),
						n = o.backgroundColor().value();
					r === n ? (0, B.clearRect)(e, 0, 0, i + 1, s + 1, n) : (0, O.clearRectWithGradient)(e, 0, 0, i + 1, s + 1, r, n)
				}
				_drawWatermark(e, t) {
					const i = this._chartModel().watermarkSource();
					if (null === i) return;
					const s = this.state();
					if (!s.containsMainSeries()) return;
					const o = i.paneViews(),
						r = s.height(),
						n = s.width();
					for (const i of o) {
						e.save();
						const s = i.renderer(r, n);
						s && s.draw(e, t), e.restore()
					}
				}
				_drawCrossHair(e, t) {
					const i = this._chartUndoModel().crossHairSource();
					!i.visible && (0, L.lockTimeAxis)().value() && (i.setLockedPosition((0, s.ensureNotNull)(this._state)), i.updateAllViews((0, dt.dataSourceChangeEvent)(i.id()))), this._drawSourceImpl(e, t, Tt, wt, i)
				}
				_drawActiveLineTools(e, t) {
					const i = this._chartModel(),
						s = [i.lineBeingCreated(), i.lineBeingEdited(), ...i.sourcesBeingMoved(), i.customSourceBeingMoved()].filter((e => !!e));
					for (const o of s) {
						(i.paneForSource(o) === this.state() || (0, k.isDataSource)(o) && o.isMultiPaneEnabled()) && this._drawSourceImpl(e, t, Tt, wt, o)
					}
				}
				_drawSeriesTopViews(e, t) {
					this.state().containsMainSeries() && this._drawSourceImpl(e, t, Pt, wt, this._chartUndoModel().mainSeries())
				}
				_drawSources(e, t, i) {
					const s = this.state(),
						o = s.model(),
						r = s.sourcesByGroup(),
						n = r.tradingSources(),
						a = [...o.multiPaneSources(s), ...r.generalSources()],
						l = r.phantomSources(),
						c = s.customSources(I.CustomSourceLayer.Background).slice(),
						h = s.customSources(I.CustomSourceLayer.Foreground).slice(),
						d = s.customSources(I.CustomSourceLayer.Topmost).slice();
					this._drawSourceImpl(e, t, Tt, wt, o.gridSource()), this._drawWatermark(e, t);
					for (const i of c) this._drawSourceImpl(e, t, Tt, Ct, i);
					for (const i of a) this._drawSourceImpl(e, t, Tt, Ct, i);
					for (const i of h) this._drawSourceImpl(e, t, Tt, Ct, i);
					for (const i of l) this._drawSourceImpl(e, t, Tt, Ct, i);
					const u = new Set;
					[o.lineBeingCreated(), o.lineBeingEdited(), ...o.sourcesBeingMoved(), o.customSourceBeingMoved()].filter(_.notNull).forEach((e => u.add(e.id())));
					let m = o.hoveredSource();
					null !== m && (yt(m) || u.has(m.id()) || (0, k.isDataSource)(m) && !a.includes(m) ? m = null : u.add(m.id()));
					const p = o.selection().allSources().filter((e => !((0, k.isDataSource)(e) && !a.includes(e)) && (!u.has(e.id()) && !yt(e))));
					p.forEach((e => u.add(e.id()))); {
						for (const i of c) this._drawSourceImpl(e, t, Tt, wt, i, u);
						for (const i of a) this._drawSourceImpl(e, t, Tt, wt, i, u);
						for (const i of h) this._drawSourceImpl(e, t, Tt, wt, i, u);
						const i = o.activeStrategySource().value();
						i && this.containsMainSeries() && this._drawSourceImpl(e, t, xt, wt, i)
					}
					for (const i of n) this._drawSourceImpl(e, t, Tt, Ct, i);
					for (const i of d) this._drawSourceImpl(e, t, Tt, Ct, i);
					for (const i of a) this._drawSourceImpl(e, t, Mt, wt, i, u);
					for (const i of h) this._drawSourceImpl(e, t, Mt, wt, i, u);
					this._drawBarsMarks(e, t, i);
					for (const i of n) this._drawSourceImpl(e, t, Tt, wt, i, u);
					for (const i of d) this._drawSourceImpl(e, t, Tt, wt, i, u);
					for (const i of p) this._drawSourceImpl(e, t, Tt, wt, i);
					for (const i of p) this._drawSourceImpl(e, t, Mt, wt, i);
					m && (this._drawSourceImpl(e, t, Tt, wt, m), this._drawSourceImpl(e, t, Mt, wt, m));
					for (const i of l) this._drawSourceImpl(e, t, Tt, wt, i, u)
				}
				_drawSourceImpl(e, t, i, s, o, r) {
					if (r && r.has(o.id())) return;
					const n = this.state(),
						a = n.height(),
						l = n.width(),
						c = i(o, this.state());
					if (c)
						for (const i of c) {
							const o = i.renderer(a, l);
							o && (e.save(), s(o, e, t), e.restore())
						}
				}
				_drawBarsMarks(e, t, i) {
					if (this.containsMainSeries() && !i) {
						const i = this._chartUndoModel().barsMarksSources();
						for (const s of i) this._drawSourceImpl(e, t, Tt, wt, s)
					}
				}
				_updateByThemedColors() {
					null !== this._legendWidget && this._legendWidget.updateThemedColors(this._themedTopColor), null !== this._paneControls && this._paneControls.updateThemedColors(this._themedTopColor)
				}
				_scrollUndoCommandInStack() {
					const e = this._chartUndoModel().undoHistory().undoStack();
					if (e.isEmpty()) return !1;
					const t = e.head();
					if (!(t instanceof E.UndoMacroCommand)) return !1;
					if (t.isEmpty()) return !1;
					const i = t.commands()[0];
					return i instanceof Xe.PriceScaleChangeUndoCommand || i instanceof Ye.TimeScaleChangeUndoCommand
				}
				_onStateDestroyed() {
					this.setState(null)
				}
				_onDataSourcesCollectionChanged() {
					this._startMoveSourceParams = null
				}
				_processMouseEnterLeaveMoveHandlers(e, t) {
					var i, s, o, r;
					null !== this._prevHoveredHittest && this._prevHoveredHittest.renderer !== e.renderer && ((0, x.tryCallHandler)(t, null === (s = null === (i = this._prevHoveredHittest.hittest) || void 0 === i ? void 0 : i.data()) || void 0 === s ? void 0 : s.mouseLeaveHandler), this._prevHoveredHittest = null), t.isTouch || (e.hittest && (null === (o = this._prevHoveredHittest) || void 0 === o ? void 0 : o.renderer) !== e.renderer && (e.hittest.tryCallMouseEnterHandler(t), this._prevHoveredHittest = e), null === (r = e.hittest) || void 0 === r || r.tryCallMouseMoveHandler(t))
				}
				_startChangeOrMoveLineToolIfNeeded() {
					if (null !== this._startChangeLineToolParams) {
						const e = this._startChangeLineToolParams;
						this._chartUndoModel().startChangingLinetool(e.source, e.startPoint, e.pointIndex, e.envState)
					}
					if (null !== this._startMoveSourceParams) {
						const e = this._startMoveSourceParams;
						this._chartUndoModel().startMovingSources(e.source, e.startPoint, e.activeItem, e.envState)
					}
					this._startMoveSourceParams = null, this._startChangeLineToolParams = null
				}
				_trackingModeShouldBeActive() {
					return !(!this._trackCrosshairOnlyAfterLongTap || this._contextMenuOpenedOnLastTap || this._crossHairShouldBeVisible()) && this._longTap
				}
				_processOutsideClick(e) {
					let t = null;
					const i = this._chartModel();
					if (e.source && (t = e.isCustom ? i.customSourceName(e.source) : e.source.id()), null !== this._lastClickedSource && this._lastClickedSource.id !== t) {
						const e = this._lastClickedSource.id;
						let t = this._lastClickedSource.isCustom ? i.customSourceForName(e) : i.dataSourceForId(e);
						null !== t || this._lastClickedSource.isCustom || (t = this._chartUndoModel().barMarksSourceForId(e)), null !== t && t.onClickOutside && (t.onClickOutside(), this._chartModel().updateSource(t))
					}
					this._lastClickedSource = null !== t ? {
						id: t,
						isCustom: e.isCustom
					} : null
				}
				_mouseClickOrTapEvent(e) {
					var t, i, o;
					if (!this.hasState()) return;
					const r = this._dataSourceAtPoint(e.localX, e.localY),
						n = r && r.source,
						a = this._chartUndoModel(),
						l = Boolean(null === (i = null === (t = null == r ? void 0 : r.hittest) || void 0 === t ? void 0 : t.data()) || void 0 === i ? void 0 : i.hideCrosshairLinesOnHover);
					this._processOutsideClick((0, s.ensureNotNull)(r)), !this._isSelectPointModeEnabled() || l || e.isTouch && this.trackingModeEnabled() && !this._exitTrackingModeOnNextTry || a.crossHairSource().trySelectCurrentPoint(), (null === (o = null == r ? void 0 : r.hittest) || void 0 === o ? void 0 : o.tryCallClickOrTapHandler(e)) && a.model().updateSource((0, s.ensureNotNull)(n)), !e.isTouch || this._isSelectPointModeEnabled() || r && r.source === a.crossHairSource() || this._tryExitTrackingMode(), n instanceof D.BarsMarksContainer && r && r.hittest && r.hittest.data() && n.onClicked((0, s.ensureNotNull)(r.hittest).data()), n && (0, g.isLineTool)(n) && this._lastFinishedToolId !== n.id() && (0, h.emit)("drawing_event", n.id(), "click"), this._resetMeasureIfRequired()
				}
				_mouseDownOrTouchStartEvent(e, t) {
					var i, o, r, n, a, l, c, d;
					if (e.isTouch && (this._longTap = !1, this._exitTrackingModeOnNextTry = null !== this._startTrackPoint, this._paneWidgetsSharedState.clearDraggingSource()), this._contextMenuOpenedOnLastTap = !1, this._lastFinishedToolId = null, this._terminateActiveAnimations(), e.isTouch && this._switchTrackingModeFromAnotherPaneIfNeeded(e), document.activeElement !== document.body && document.activeElement !== document.documentElement) document.activeElement && document.activeElement.blur ? document.activeElement.blur() : document.body.focus();
					else {
						const e = document.getSelection();
						null !== e && e.removeAllRanges()
					}(0, h.emit)("mouse_down", {
						clientX: e.clientX,
						clientY: e.clientY,
						pageX: e.pageX,
						pageY: e.pageY,
						screenX: e.screenX,
						screenY: e.screenY
					}), this._updateCommonTooltip(null);
					const u = this._chartUndoModel(),
						_ = new A.EnvironmentState(e);
					u.mainSeries().clearGotoDateResult();
					const m = this.state().defaultPriceScale();
					if (m.isEmpty() || u.timeScale().isEmpty()) return;
					const p = u.crossHairSource();
					if (!e.isTouch && !(0, tt.isLineDrawnWithPressedButton)(L.tool.value())) {
						const t = u.lineBeingCreated(),
							i = null !== t ? u.model().paneForSource(t) : null;
						null !== i && i !== this._state ? this._setCursorPositionOnExternalPane(i, e.localX, e.localY, _) : this._setCursorPosition(e.localX, e.localY, _)
					}
					e.isTouch && (0, g.isLineToolName)(L.tool.value()) && ((0,
						tt.isLineDrawnWithPressedButton)(L.tool.value()) || null !== p.pane ? (0, tt.isLineDrawnWithPressedButton)(L.tool.value()) && this._clearCursorPosition() : this._chart.updateCrossHairPositionIfNeeded());
					const S = (0, s.ensureNotNull)(this.state().mainDataSource()).firstValue();
					if (null === S) return void(this._chart.readOnly() || (this._handleSelectionMouseDownAndGetJustDeselectedSource(e, t, _), t.source && (0, Ze.isPriceDataSource)(t.source) && t.source.isDraggable() && this._paneWidgetsSharedState.trySetDraggingSource(t.source, this)));
					let v = m.coordinateToPrice(e.localY, S),
						f = this._chartModel().timeScale().coordinateToIndex(e.localX);
					if (p.startMeasurePoint() && p.endMeasurePoint() && p.clearMeasure(), _.shift() && !(null === (r = null === (o = null === (i = t.hittest) || void 0 === i ? void 0 : i.data()) || void 0 === o ? void 0 : o.hasOwnShortcutsBehaviourFor) || void 0 === r ? void 0 : r.shiftKey) && (0, L.toolIsCursor)(L.tool.value()) && u.selection().isEmpty() && L.tool.setValue("measure"), (e.isTouch && !e.stylus || !this._tryStartMeasure(e, p, _, v, f)) && (e.isTouch && !e.stylus || !this._tryFinishMeasure(e, p)) && !this._tryFinishZoom(e) && !this._tryStartZoom(e, v, f, _)) {
						if (e.isTouch && (null !== this._startTrackPoint ? (this._initCrossHairPosition = p.currentPoint(), this._startTrackPoint = new C.Point(e.localX, e.localY)) : this._isSelectPointModeEnabled() && null === this._chart.trackingModePaneWidget() && this.startTrackingMode(new C.Point(e.localX, e.localY), new C.Point(e.localX, e.localY), new A.EnvironmentState(e))), e.isTouch && (this._preventSourceChange = null === t.source || !u.selection().isSelected(t.source)), !this._isSelectPointModeEnabled() && !this._isScrolling) {
							if (e.isTouch && !e.stylus && ((0, L.toolIsMeasure)(L.tool.value()) || null !== p.measurePane().value())) return void this._initToolCreationModeParams(e);
							if ((0, g.isLineToolName)(L.tool.value()) || u.lineBeingCreated()) return _.shift() || u.selectionMacro((e => e.clearSelection())), void this._mouseDownEventForLineTool(e, _, f, v)
						}
						if (null === (n = t.hittest) || void 0 === n || n.tryCallMouseDownOrTouchStartHandler(e), !this._chart.readOnly()) {
							const i = this._handleSelectionMouseDownAndGetJustDeselectedSource(e, t, _);
							if (t.hittest && t.source && !this._preventSourceChange) {
								const i = t.hittest.data();
								if (t.isCustom) {
									if (t.hittest.hasPressedMoveHandler(e)) return u.model().setMovingCustomSource(t.source, i), this._currentMovingHitTest = t, void u.selectionMacro((e => {
										e.clearSelection(), e.addSourceToSelection((0, s.ensureNotNull)(t.source), (0, s.ensureNotNull)(i))
									}))
								} else if ((null == i ? void 0 : i.areaName) === x.AreaName.SourceItemMove) {
									const o = null == i ? void 0 : i.activeItem;
									if (void 0 !== o) return u.startCustomMoving(t.source, o, e), this._currentMovingHitTest = t, void u.selectionMacro((e => {
										e.clearSelection(), e.addSourceToSelection((0, s.ensureNotNull)(t.source), (0, s.ensureNotNull)(i))
									}))
								}
							}
							if (this._tryHandleEraserMouseDown(t, _)) return;
							const o = t.source && (0, g.isLineTool)(t.source) && t.source.isLocked && t.source.isLocked();
							if (!((0, L.lockDrawings)().value() || o) && !t.isCustom) {
								if (t.source && !t.source.userEditEnabled()) return;
								const s = null === (l = null === (a = t.hittest) || void 0 === a ? void 0 : a.data()) || void 0 === l ? void 0 : l.snappingPrice,
									o = null === (d = null === (c = t.hittest) || void 0 === c ? void 0 : c.data()) || void 0 === d ? void 0 : d.snappingIndex;
								let r = e.localY,
									n = e.localX;
								if (void 0 !== s && (r = m.priceToCoordinate(s, S), v = s), void 0 !== o && (n = this._chartModel().timeScale().indexToCoordinate(o), f = o), r === e.localY && n === e.localX || (e = {
										...e,
										localY: r,
										localX: n
									}, this._setCursorPosition(e.localX, e.localY, _)), this._tryStartChangingLineTool(e, t, _, f)) return void(this._currentChangingLineToolHitTest = t);
								if (this._currentChangingLineToolHitTest = null, t.hittest && ((b = t.hittest.result()) === x.HitTestResult.MOVEPOINT || b === x.HitTestResult.MOVEPOINT_BACKGROUND && (0, P.lastMouseOrTouchEventInfo)().isTouch)) {
									if (this._tryStartCloning(e, t, _, i)) return;
									if (this._tryStartMovingLineTool(e, t, _, f)) return void(this._currentMovingHitTest = t);
									this._currentMovingHitTest = null
								}
							}
							if (t.source && (0, Ze.isPriceDataSource)(t.source) && t.source.isDraggable() && this._paneWidgetsSharedState.trySetDraggingSource(t.source, this)) return
						}
						var b;
						t && t.hittest && t.hittest.result() === x.HitTestResult.REGULAR || (this._processing = !0)
					}
				}
				_mouseUpOrTouchEndEvent(e) {
					var t, i;
					if (!this.hasState()) return;
					const o = e.isTouch && null !== this._startTrackPoint,
						r = e.isTouch && this._wasPinched;
					e.isTouch && (this._wasPinched = !1, this._longTap = !1), this._startMoveSourceParams = null, this._startChangeLineToolParams = null, this._currentChangingLineToolHitTest = null, this._currentMovingHitTest = null;
					const n = this._chartUndoModel(),
						a = n.model().customSourceMovingHitTestData();
					null !== a || n.customMoveBeingProcessed() || this._processMouseUpOrTouchEndHandler(e), this._isSelecting = !1;
					const l = n.model(),
						c = l.crossHairSource(),
						d = this._dataSourceAtPoint(e.localX, e.localY),
						u = null == d ? void 0 : d.hittest;
					if (c.selection() && null === this._firstZoomPoint) {
						const e = this.state().lineToolsForArea(c.selection());
						n.selectionMacro((t => {
							let i = null;
							e.forEach((e => {
								null === i && (i = It(d, e)), t.addSourceToSelection(e, i)
							}))
						})), c.clearSelection(), (0, se.trackEvent)("GUI", "Multiselect", "Area Select")
					}(0, h.emit)("mouse_up", {
						clientX: e.clientX,
						clientY: e.clientY,
						pageX: e.pageX,
						pageY: e.pageY,
						screenX: e.screenX,
						screenY: e.screenY
					});
					const _ = e.isTouch && this._touchMove;
					e.isTouch && (this._touchMove = !1);
					const m = new A.EnvironmentState(e),
						p = L.tool.value();
					if (e.isTouch && ((0, L.toolIsMeasure)(p) || null !== c.measurePane().value())) {
						if (!_ && !e.stylus && null === c.measurePane().value() && c.pane !== this._state) return void this._setCursorPosition(e.localX, e.localY);
						if (!_ && !e.stylus && this._tryStartMeasure(e, c, m, c.price, c.index)) return;
						if ((!_ || e.stylus) && this._tryFinishMeasure(e, c)) return
					}
					if (e.isTouch && !_ && !(0, tt.isLineDrawnWithPressedButton)(p) && (0, g.isLineToolName)(p) && !n.lineBeingCreated()) {
						if (this._chart.justActivated()) return;
						if (c.pane !== this._state) return void this._setCursorPosition(e.localX, e.localY, m);
						const i = c.currentPoint(),
							o = this.state().defaultPriceScale(),
							r = (0, s.ensure)(null === (t = this.state().mainDataSource()) || void 0 === t ? void 0 : t.firstValue()),
							a = {
								index: Math.round(n.timeScale().coordinateToIndex(i.x)),
								price: o.coordinateToPrice(i.y, r)
							},
							l = (0,
								s.ensureNotNull)(n.createLineTool({
								pane: this.state(),
								point: a,
								linetool: p
							}));
						return n.selectionMacro((e => {
							e.addSourceToSelection(l)
						})), n.lineBeingCreated() || (this._finishTool(l, d), e.preventDefault()), void(this._startTouchPoint = null)
					}
					const S = n.lineBeingCreated();
					if (S && !(0, tt.isLineDrawnWithPressedButton)(S.toolname) && e.isTouch && (this._startTouchPoint || e.stylus)) {
						if (this._startTouchPoint = null, !_ || e.stylus) {
							const t = S.points()[S.points().length - 1],
								i = n.continueCreatingLine({
									index: t.index,
									price: t.price
								}, new A.EnvironmentState(e));
							this._initCrossHairPosition = null, i && (this._finishTool(S, d), e.preventDefault())
						}
						return
					}
					if (null !== this._firstZoomPoint && this._firstZoomPoint.draggingMode) return void this._finishZoom(e);
					if (this._processing = !1, n.customMoveBeingProcessed()) return void n.endCustomMoving();
					if (null !== a && (a.beingMoved && ((0, x.tryCallHandler)(e, a.mouseUpHandler, a.touchEndHandler), this.setCursorForTool()), l.setMovingCustomSource(null, null), Nt(e, a))) return;
					if (l.lineBeingEdited()) return n.endChangingLinetool(!1), void(this._preventCrossHairMove() && this._clearCursorPosition());
					if ((0, tt.isLineDrawnWithPressedButton)(p) && !this._isSelectPointModeEnabled()) {
						const t = n.lineBeingCreated();
						null !== t && ((0, et.trackDrawingCreated)(t), t.finish());
						const o = this.state().defaultPriceScale();
						if (o.isEmpty()) return;
						if (!t) return;
						const r = (0, s.ensure)(null === (i = t.ownerSource()) || void 0 === i ? void 0 : i.firstValue()),
							a = o.coordinateToPrice(e.localY, r),
							l = {
								index: Math.round(n.timeScale().coordinateToIndex(e.localX)),
								price: a
							};
						return void n.continueCreatingLine(l)
					}
					if (l.sourcesBeingMoved().length) return n.endMovingSource(!1, !1), l.sourcesBeingMoved().filter(g.isLineTool).forEach((e => {
						this.setCursorForTool(e)
					})), void l.invalidate(f.InvalidationMask.cursor());
					if (!this._chart.readOnly()) {
						const t = e.localX >= 0 && e.localX < this._size.w;
						if ((!d || d.source !== c) && t) {
							const t = n.timeScale().coordinateToIndex(e.localX);
							l.onSyncScrollNeeded(t)
						}
					}
					const v = this._isScrolling,
						b = this._endScroll(e),
						y = this._paneWidgetsSharedState.draggingSource();
					if (null !== y) {
						const t = e.target,
							i = this._chart.paneByCanvas(t);
						i && i !== this && (b && n.undoHistory().undo(), n.mergeToPane(y, i.state()));
						if (this._chart.timeAxisByCanvas(t))
							if (l.isUnmergeAvailableForSource(y)) b && n.undoHistory().undo(), n.unmergeToNewBottomPane(y);
							else {
								const e = l.panes(),
									t = (0, s.ensureNotNull)(l.paneForSource(y)),
									i = e.indexOf(t);
								i !== e.length - 1 && (b && n.undoHistory().undo(), t.maximized().value() && this._chart.toggleMaximizePane(null), n.movePane(i, e.length - 1))
							} this._paneWidgetsSharedState.clearDraggingSource();
						const o = this._chart.getTimeScale();
						o && o.restoreDefaultCursor();
						const r = this._chart.paneWidgets();
						for (let e = 0; e < r.length; e++) {
							const t = r[e];
							t === this && d && !d.isCustom ? t.setCursorForTool(d.source || void 0) : t.setCursorForTool(), t.leftPriceAxisesContainer().restoreDefaultCursor(), t.rightPriceAxisesContainer().restoreDefaultCursor()
						}
					}
					this._chart.readOnly() || o || m.mod() || v || r || null !== this._lastFinishedToolId || d && d.source && (u && u.result() > x.HitTestResult.MOVEPOINT_BACKGROUND || (0, P.lastMouseOrTouchEventInfo)().isTouch) && n.selectionMacro((e => {
						e.clearSelection();
						const t = (0, s.ensureNotNull)(d.source);
						e.addSourceToSelection(t, It(d, t))
					})), e.isTouch && (this._touchMove = !1)
				}
				_mouseOrTouchMoveEvent(e) {
					if (!this.hasState()) return;
					this._resetMeasureIfRequired();
					const t = (0, s.ensureNotNull)(this._dataSourceAtPoint(e.localX, e.localY));
					this._processMouseEnterLeaveMoveHandlers(t, e);
					const i = this._chartUndoModel();
					if (!i) return;
					const o = e.localX,
						r = e.localY;
					this._prevMoveEventPosition = new C.Point(o, r);
					const n = new A.EnvironmentState(e);
					if (null === this._firstZoomPoint) {
						if (this._updateHoveredSource(t, n, e), !e.isTouch && i.lineBeingCreated()) {
							const e = i.lineBeingCreated(),
								t = null === e ? null : i.model().paneForSource(e);
							if (null !== t && t !== this._state) return void this._setCursorPositionOnExternalPane(t, o, r, n)
						}
						e.isTouch || this._setCursorPosition(o, r, n)
					} else this._processMouseMoveWhileZoom(e, n)
				}
				_pressedMouseOrTouchMoveEvent(e) {
					var t;
					if (!this.hasState() || this._pinching || e.isTouch && this._contextMenuOpenedOnLastTap) return;
					this._resetMeasureIfRequired(), this._startChangeOrMoveLineToolIfNeeded(), e.isTouch && (this._touchMove = !0, this._preventSourceChange = !1);
					const i = new A.EnvironmentState(e),
						o = this._chartUndoModel(),
						r = o.crossHairSource(),
						n = e.localX,
						a = e.localY;
					if (this._prevMoveEventPosition = new C.Point(n, a), null !== this._firstZoomPoint) return this._processMouseMoveWhileZoom(e), void(this._firstZoomPoint.draggingMode = !0);
					const l = L.tool.value();
					if (e.isTouch && this._startTouchPoint && (0, g.isLineToolName)(l) && !(0, tt.isLineDrawnWithPressedButton)(l) && !o.lineBeingCreated() && !this._isSelectPointModeEnabled()) return void this._updateCrosshairPositionInToolCreationMode(e, this.state());
					const c = r.measurePane().value();
					if (e.isTouch && (this._startTouchPoint || e.stylus) && ((0, L.toolIsMeasure)(l) || null !== c)) return void(e.stylus ? this._setCursorPosition(e.localX, e.localY, new A.EnvironmentState(e)) : this._updateCrosshairPositionInToolCreationMode(e, c || this.state()));
					const h = o.lineBeingCreated();
					if (e.isTouch && !e.stylus && h && !(0, tt.isLineDrawnWithPressedButton)(h.toolname)) {
						if (this._startTouchPoint) {
							const t = (0, s.ensureNotNull)(o.lineBeingCreated()),
								i = (0, s.ensureNotNull)(o.model().paneForSource(t));
							this._updateCrosshairPositionInToolCreationMode(e, i)
						}
						return
					}
					if (e.isTouch && null !== this._startTrackPoint) {
						this._exitTrackingModeOnNextTry = !1;
						const e = (0, s.ensureNotNull)(this._initCrossHairPosition),
							t = new C.Point(n, a).subtract(this._startTrackPoint),
							o = e.add(t);
						this._setCursorPosition(o.x, o.y, i)
					} else e.isTouch && this._preventCrossHairMove() || this._setCursorPosition(n, a, i);
					const d = this._isSelectPointModeEnabled();
					if ((0, g.isLineToolName)(l) && !(0, tt.isLineDrawnWithPressedButton)(l) && !d && !i.mod()) return;
					if ((0, tt.isLineDrawnWithPressedButton)(l) && !d) {
						const i = this.state().defaultPriceScale();
						if (i.isEmpty()) return;
						const r = o.lineBeingCreated();
						if (!r) return;
						const n = new C.Point(e.localX, e.localY),
							a = (0, s.ensure)(null === (t = r.ownerSource()) || void 0 === t ? void 0 : t.firstValue());
						return n.price = i.coordinateToPrice(e.localY, a), n.index = Math.round(o.timeScale().coordinateToIndex(e.localX)), void o.continueCreatingLine(n)
					}
					if (null !== this._paneWidgetsSharedState.draggingSource()) {
						const t = e.target,
							i = this._chart.paneByCanvas(t);
						i && (i !== this ? i.setDragToAnotherPaneCursor() : i.setCursorForTool());
						const s = this._chart.timeAxisByCanvas(t);
						s && s.setCursor("grabbing")
					}
					if (o.timeScale().isEmpty()) return;
					const u = this._options.handleScroll;
					if ((!u.pressedMouseMove || e.isTouch) && (!u.horzTouchDrag && !u.vertTouchDrag || !e.isTouch)) return;
					if (o.customMoveBeingProcessed()) return void o.processCustomMove(e);
					const _ = o.model().customSourceMovingHitTestData();
					if (null !== _ && (this._updateCommonTooltip(null, !0), o.model().processingCustomSourceMove(), (0, x.tryCallHandler)(e, _.pressedMouseMoveHandler, _.touchMoveHandler), Nt(e, _))) return;
					if (o.model().lineBeingEdited()) return void this._setCursorPosition(n, a, i);
					if (o.model().sourcesBeingMoved().length) return void this._alignSourcesThatBeingMoved(o.model().sourcesBeingMoved(), e.localX, e.localY, i);
					const m = this._dataSourceAtPoint(e.localX, e.localY);
					if (this._tryFinishClonning(e, new A.EnvironmentState(e), m)) return;
					const p = (0, L.toolIsMeasure)(l) || r.startMeasurePoint() && r.endMeasurePoint();
					this._chart.readOnly() || !i.mod() || (0, g.isLineToolName)(l) || p || d ? (this._processScroll(e), this._preventScroll() && !this._preventCrossHairMove() && null === this._startTrackPoint && this._setCursorPosition(e.localX, e.localY, new A.EnvironmentState(e))) : this._isSelecting || (r.startSelection(this.state()), this._isSelecting = !0)
				}
				_mouseOrTouchLeaveEvent(e) {
					var t, i;
					if (!this.hasState()) return;
					const s = this._chartUndoModel();
					if (!s) return;
					const o = s.crossHairSource();
					e.isTouch || null !== o.measurePane().value() && null === o.endMeasurePoint() || this._clearCursorPosition(), s.model().setHoveredSource(null, null), null !== this._prevHoveredHittest && ((0, x.tryCallHandler)(e, null === (i = null === (t = this._prevHoveredHittest.hittest) || void 0 === t ? void 0 : t.data()) || void 0 === i ? void 0 : i.mouseLeaveHandler), this._prevHoveredHittest = null), this._updateCommonTooltip(null), this._chart.unsetActivePaneWidget()
				}
				_mouseDoubleClickOrDoubleTapEvent(e) {
					var t;
					if (!this.hasState()) return;
					const i = !this._chart.readOnly() && !(0, g.isLineToolName)(L.tool.value()) && (0, s.ensureNotNull)(this._dataSourceAtPoint(e.localX, e.localY)) || null;
					if (null === i) return;
					if (i.isCustom) return void(null === (t = i.hittest) || void 0 === t || t.tryCallDblClickOrDblTapHandler(e));
					let o = i.hittest && i.source || null;
					o && i.hittest && i.hittest.result() <= x.HitTestResult.MOVEPOINT_BACKGROUND && !e.isTouch && (o = null), o && !o.isSelectionEnabled() && (o = null);
					const r = this.state();
					o ? this.processDoubleClickOnSource(o, i.hittest ? i.hittest : void 0) : this._chart.readOnly() || (0, g.isLineToolName)(L.tool.value()) || this._chartUndoModel().lineBeingCreated() || !this._chartUndoModel().selection().isEmpty() || (new A.EnvironmentState(e).mod() && !r.maximized().value() ? (r.collapsed().value() || this._chartModel().paneCollapsingAvailable().value()) && this._chart.toggleCollapsedPane(this) : this._chart.toggleMaximizePane(this))
				}
				_contextMenuEvent(e) {
					var t;
					const i = this._chartUndoModel();
					if (i.crossHairSource().startMeasurePoint() && !this._trackCrosshairOnlyAfterLongTap) return i.crossHairSource().clearMeasure(), void(0, L.resetToCursor)(!0);
					if (this._pinching) return;
					if (null === this._firstZoomPoint || this._trackCrosshairOnlyAfterLongTap || this.cancelZoom(), !(0, L.toolIsCursor)(L.tool.value()) || this._isSelectPointModeEnabled()) {
						if (e.isTouch) return;
						return (0, L.resetToCursor)(!0), this.setCursorForTool(), void(i.lineBeingCreated() && i.cancelCreatingLine())
					}
					if (!this._options.contextMenuEnabled) return;
					const s = this._dataSourceAtPoint(e.localX, e.localY),
						o = s ? s.source : null;
					if (e.isTouch && null !== this._startTrackPoint) {
						if (this._preventSourceChange) return;
						this._clearCursorPosition()
					}
					e.isTouch && (this._contextMenuOpenedOnLastTap = !0, this._startTrackPoint = null), this._contextMenuX = e.localX, this._contextMenuY = e.localY;
					const r = s && s.hittest ? s.hittest.result() : 0,
						n = r >= x.HitTestResult.REGULAR || r >= x.HitTestResult.MOVEPOINT_BACKGROUND && e.isTouch;
					this._chart.updateActions(), i.selectionMacro((t => {
						null !== o && n ? t.selection().isSelected(o) || (t.clearSelection(), t.addSourceToSelection(o, It(s, o))) : (this._options.contextMenu.general && this._showContextMenu(e), t.clearSelection())
					})), s && n && null !== o && ((0, k.isDataSource)(o) && o.hasContextMenu() ? o.isSelectionEnabled() ? this.showContextMenuForSelection(e) : this.showContextMenuForSources([o], e) : null === (t = s.hittest) || void 0 === t || t.tryCallContextMenuHandler(e))
				}
				_onMouseEvent() {
					this._preventSourceChange = !1, this._startTrackPoint = null, this._trackCrosshairOnlyAfterLongTap = !1
				}
				_onTouchEvent() {
					this._trackCrosshairOnlyAfterLongTap = !0
				}
				_switchTrackingModeFromAnotherPaneIfNeeded(e) {
					const t = this._chart.trackingModePaneWidget();
					if (null !== t && t !== this) {
						const i = this._chartModel().crossHairSource().currentPoint();
						t._exitTrackingModeOnNextTry = !0, t._tryExitTrackingMode(!0), this.startTrackingMode(new C.Point(e.localX, e.localY), new C.Point(i.x, e.localY), new A.EnvironmentState(e))
					}
				}
				_showContextMenu(e) {
					const t = e => e instanceof Me.Separator,
						i = this._customActions(),
						s = this._initActions(e).filter((e => null !== e));
					i.remove.forEach((e => {
						for (let t = 0; t < s.length; t++) {
							const i = s[t];
							if (i instanceof Me.Action && i.getLabel() === e) {
								s.splice(t, 1);
								break
							}
						}
					}));
					const o = i.top.concat(s).concat(i.bottom);
					for (let e = o.length - 1; e > 0; e--) t(o[e]) && t(o[e - 1]) && o.splice(e, 1);
					o.length && t(o[0]) && o.splice(0, 1), o.length && t(o[o.length - 1]) && o.splice(o.length - 1, 1), Y.ContextMenuManager.showMenu(o, e, {
						statName: "ChartContextMenu"
					}, {
						menuName: "ChartContextMenu"
					})
				}
				_initActions(e) {
					var t, i;
					const o = this._chart.actions(),
						r = [];
					if (r.push(o.chartReset), r.push(new Me.Separator), !this.state().isEmpty() && Te.enabled("datasource_copypaste")) {
						const t = (0, Pe.createActionCopyPrice)(this.state(), e.localY),
							i = (0, Pe.createPasteAction)(this._chart, this.state());
						(t || i) && (t && r.push(t), i && r.push(i), r.push(new Me.Separator))
					}
					if (Te.enabled("alerts") && (r.length && r.push(new Me.Separator), (0, s.ensureNotNull)(this.state().mainDataSource()).alertCreationAvailable())) {
						const t = (0, Pe.createActionAddAlert)(this._chart, {
							e,
							pane: this.state()
						});
						null !== t && r.push(t)
					}
					this._options.contextMenu.mainSeriesTrade && this.containsMainSeries() && r.push((0, Pe.createActionTrade)(this._chart, this.state(), e)), r[r.length - 1] instanceof Me.Separator || r.push(new Me.Separator);
					return Boolean(null === (t = window.widgetbar) || void 0 === t ? void 0 : t.widget("watchlist")) && o.addToWatchlist && r.push(o.addToWatchlist), Te.enabled("text_notes") && r.push(o.addToTextNotes), r[r.length - 1] instanceof Me.Separator || r.push(new Me.Separator), o.moveChartAction && !o.moveChartAction.isDisabled() && r.push(o.moveChartAction, new Me.Separator), r.push(this._createLockTimeAxisAction(e)), r.push(new Me.Separator), o.paneObjectTree && r.push(o.paneObjectTree), r.push((0, Pe.createLinesAction)(this._chart)), !Te.enabled("charting_library_base") && o.applyColorTheme && r.push(o.applyColorTheme), r[r.length - 1] instanceof Me.Separator || r.push(new Me.Separator), this._chart.applyIndicatorsToAllChartsAvailable() && (r.push(o.applyStudiesToAllCharts), r.push(new Me.Separator)), r.push(o.paneRemoveAllDrawingTools), r.push(o.paneRemoveAllStudies), r.push(new Me.Separator), (null === (i = window.pro) || void 0 === i ? void 0 : i.hasPackage("mtp-mtpredictor")) && this.state().containsMainSeries() && r.push((0, Pe.createMTPredictorActions)(this._chart, this.state(), this._contextMenuX, this._contextMenuY), new Me.Separator), Te.enabled("show_chart_property_page") && r.push(o.chartProperties), r[r.length - 1] instanceof Me.Separator && r.pop(), r
				}
				_loadAndCreateLegendWidget() {
					Promise.all([i.e(90519), i.e(5979), i.e(21834), i.e(44155), i.e(24384), i.e(35015), i.e(2036), i.e(64746), i.e(64300), i.e(75514), i.e(93921), i.e(91622), i.e(59255), i.e(5093)]).then(i.bind(i, 460331)).then((e => {
						if (this._isDestroyed) return;
						const t = e.LegendWidget,
							i = (0, M.deepExtend)({}, this._options.legendWidget);
						i.canShowSourceCode = !this._chart.onWidget() && !l.CheckMobile.any(), i.readOnlyMode = i.readOnlyMode || this._chart.readOnly(), i.statusesWidgets = {
							sourceStatusesEnabled: this._options.sourceStatusesWidgetEnabled,
							sourceStatuses: this._options.sourceStatusesWidget || {},
							marketStatusEnabled: this._options.marketStatusWidgetEnabled,
							dataUpdateModeEnabled: this._options.chartWarningWidgetEnabled,
							dataUpdateMode: this._options.chartWarningWidget || {},
							dataProblemEnabled: this._options.dataProblemWidgetEnabled
						};
						const o = (0, m.combine)(((e, t) => Et && this._chart !== e && !t), this._chart.chartWidgetCollection().activeChartWidget, this._chart.chartWidgetCollection().lock.crosshair),
							r = (0, m.combine)(((e, t) => null !== e ? e === this._state : (0, L.toolIsMeasure)(t)), this._chartModel().crossHairSource().measurePane(), L.tool);
						this._legendWidget = new t(this._chartUndoModel(), this, this._chart.backgroundTopTheme().spawn(), o, this._visuallyCollapsed.spawn(), r, i, {
								showContextMenuForSelection: this.showContextMenuForSelection.bind(this),
								showContextMenuForSources: this.showContextMenuForSources.bind(this),
								updateActions: this._chart.updateActions.bind(this._chart),
								showChartPropertiesForSource: this._chart.showChartPropertiesForSource.bind(this._chart),
								showGeneralChartProperties: this._chart.showGeneralChartProperties.bind(this._chart),
								showObjectsTreeDialog: this._chart.showObjectsTreeDialog.bind(this._chart)
							}), this._div.appendChild(this._legendWidget.getElement()), this._legendWidget.updateLayout(), this._legendWidget.updateWidgetModeBySize(this._size),
							this._legendWidget.updateThemedColors(this._themedTopColor);
						for (const e of Array.from(this._customLegendWidgetsFactoryMap.keys())) this._legendWidget.addCustomWidgetToLegend(e, (0, s.ensureDefined)(this._customLegendWidgetsFactoryMap.get(e)))
					}))
				}
				_loadAndCreatePaneControlsWidget() {
					Promise.all([Promise.all([i.e(90519), i.e(5979), i.e(21834), i.e(44155), i.e(24384), i.e(35015), i.e(2036), i.e(64746), i.e(64300), i.e(75514), i.e(93921), i.e(91622), i.e(59255), i.e(5093)]).then(i.bind(i, 840619)), Promise.all([i.e(90519), i.e(5979), i.e(21834), i.e(44155), i.e(24384), i.e(35015), i.e(2036), i.e(64746), i.e(64300), i.e(75514), i.e(93921), i.e(91622), i.e(59255), i.e(5093)]).then(i.bind(i, 159255))]).then((([e, t]) => {
						var i;
						if (this._isDestroyed) return;
						const s = e.PaneControlsWidget;
						this._paneControls = new s(this._chartUndoModel(), this, {
							backgroundThemeName: this._chart.backgroundTopTheme()
						}, {
							toggleMaximizePane: this._chart.toggleMaximizePane.bind(this._chart),
							toggleCollapsedPane: this._chart.toggleCollapsedPane.bind(this._chart)
						}, this._div), this._paneControls.updateWidgetModeByWidth(this._size.w), this._paneControls.updateThemedColors(this._themedTopColor), this._paneControlsResizeObserver = new t.default(this._handleRestrictLegendWidth.bind(this)), this._paneControlsResizeObserver.observe(this._paneControls.getElement()), (null === (i = this._state) || void 0 === i ? void 0 : i.collapsed().value()) && this._chartModel().fullUpdate()
					}))
				}
				_handleRestrictLegendWidth(e) {
					if (null === this._legendWidget || null === this._paneControls) return;
					const t = e[e.length - 1].contentRect.width,
						i = 0 === t ? 0 : t + mt + pt;
					this._legendWidget.addMargin(i)
				}
				_onMagnetStateChanged() {
					this._chart.isActive() && (this._isSelectPointModeEnabled() || this._isToolActionActiveOnPane(!0)) && this._chartModel().crossHairSource().visible && this._updateLineToolUsingMagnetOrShift()
				}
				_onShiftKeyStateChanged() {
					this._chart.isActive() && this._isToolActionActiveOnPane(!1) && this._chartModel().crossHairSource().visible && this._updateLineToolUsingMagnetOrShift(A.EnvironmentState.create((0, at.shiftPressed)().value()))
				}
				_isToolActionActiveOnPane(e) {
					const t = this._chartModel(),
						i = t.lineBeingCreated() || t.lineBeingEdited() || t.sourcesBeingMoved().length > 0 && t.sourcesBeingMoved()[0];
					return i ? t.paneForSource(i) === this._state : e && (0, g.isLineToolName)(L.tool.value()) && t.crossHairSource().pane === this._state
				}
				_updateLineToolUsingMagnetOrShift(e) {
					if (null === this._prevMoveEventPosition) return;
					const {
						x: t,
						y: i
					} = this._prevMoveEventPosition, s = this._chartModel().sourcesBeingMoved();
					s.length > 0 ? (L.isStudyEditingNow.value() && this._setCursorPosition(t, i, e), this._alignSourcesThatBeingMoved(s, t, i, e)) : this._setCursorPosition(t, i, e)
				}
				_showEditDialogForSource(e, t) {
					if (this._options.propertyPagesEnabled && e.userEditEnabled())
						if (e === this._chartUndoModel().mainSeries()) this._chart.showGeneralChartProperties(it.TabNames.symbol);
						else if ((0, g.isLineTool)(e) || (0, S.isStudy)(e)) {
						let i;
						const s = null == t ? void 0 : t.data();
						if (null != s) {
							const e = s.areaName;
							void 0 !== e && (i = Lt.get(e))
						}
						this._chart.showChartPropertiesForSource(e, i).then((e => {
							this._editDialog = e
						}))
					}
				}
				_initToolCreationModeParams(e) {
					this._startTouchPoint = new C.Point(e.pageX, e.pageY), this._initCrossHairPosition = this._chartModel().crossHairSource().currentPoint()
				}
				_updateCrosshairPositionInToolCreationMode(e, t) {
					if (t !== this._state) {
						const i = this._chart.paneByState(t);
						return i._startTouchPoint = this._startTouchPoint, i._initCrossHairPosition = this._initCrossHairPosition, void i._updateCrosshairPositionInToolCreationMode(e, t)
					}
					const i = this._chartModel().crossHairSource();
					this._chart.justActivated() && (this._initCrossHairPosition = i.currentPoint());
					const o = e.pageX,
						r = e.pageY,
						n = (0, s.ensureNotNull)(this._initCrossHairPosition),
						a = new C.Point(o, r).subtract((0, s.ensureNotNull)(this._startTouchPoint)),
						l = n.add(a);
					this._setCursorPosition(l.x, l.y, new A.EnvironmentState(e))
				}
				_priceAxisesContainer(e) {
					return "left" === e ? this._lhsPriceAxisesContainer : this._rhsPriceAxisesContainer
				}
				_recalculatePriceScales(e) {
					const t = this.state();
					for (const i of t.leftPriceScales()) t.recalculatePriceScale(i, e);
					for (const i of t.rightPriceScales()) t.recalculatePriceScale(i, e);
					for (const i of t.sourcesByGroup().overlayPriceScaleSources())(0, g.isLineTool)(i) || t.recalculatePriceScale(i.priceScale(), e)
				}
				_createLockTimeAxisAction(e) {
					const t = (0, L.lockTimeAxis)().value();
					return new Me.Action({
						actionId: "Chart.Crosshair.LockVerticalCursor",
						label: ft,
						statName: "LockCursorInTime",
						checkable: !0,
						checked: t,
						onExecute: () => this._toggleLockTimeAxis(e.localX, !t)
					})
				}
				_toggleLockTimeAxis(e, t) {
					if (t) {
						const t = this._chartUndoModel().timeScale(),
							i = t.coordinateToIndex(e),
							s = t.points().roughTime(i);
						null !== s && L.lockTimeAxisTime.setValue(s)
					}(0, L.lockTimeAxis)().setValue(t)
				}
				_preventTouchEventsExceptPinch() {
					return this._paneWidgetsSharedState.hasTouchesOnOtherPanes(this) || null !== this._paneWidgetsSharedState.pinchingPane()
				}
				_updateHoveredSource(e, t, i) {
					var s, o, r;
					const n = this._chartUndoModel(),
						a = n.model();
					let l = !1;
					const c = e && e.source,
						h = this._chart.readOnly();
					if (h && !(0, g.isLineTool)(e.source) || this._editDialog && this._editDialog.visible().value()) h && (a.setHoveredSource(null, null), this.setCursorForTool());
					else {
						const d = L.tool.value();
						let u = null;
						if (!this._processing && ((0, L.toolIsCursor)(d) || "eraser" === d && !h || t.mod() || !n.lineBeingCreated())) {
							const {
								hittest: t
							} = e;
							l = Boolean(null === (s = null == t ? void 0 : t.data()) || void 0 === s ? void 0 : s.hideCrosshairLinesOnHover), t && t.result() > x.HitTestResult.MOVEPOINT_BACKGROUND ? (u = c, !(null == c ? void 0 : c.isHoveredEnabled()) || "eraser" === d && c === n.mainSeries() ? a.setHoveredSource(null, null) : a.setHoveredSource(c, null == t ? void 0 : t.data())) : a.setHoveredSource(null, null)
						}
						h ? this.setCursorForTool(u, t, st.PaneCursorType.Default) : this._options.sourceSelectionEnabled && (this._isSelectPointModeEnabled() ? this._setCursorClassName("pointer") : this.setCursorForTool(u, t, null === (r = null === (o = null == e ? void 0 : e.hittest) || void 0 === o ? void 0 : o.data()) || void 0 === r ? void 0 : r.cursorType));
						const _ = a.customSourceBeingMoved(),
							m = null !== _ ? [_] : a.sourcesBeingMoved(),
							p = e.source;
						if ((!m.length || null !== p && -1 === m.indexOf(p)) && this._updateCommonTooltip(e), !h && null !== e.hittest && i && e.hittest.hasPressedMoveHandler(i)) {
							switch ((e.hittest.data() || {}).cursorType) {
								case st.PaneCursorType.VerticalResize:
									this._setCursorClassName("ns-resize");
									break;
								case st.PaneCursorType.HorizontalResize:
									this._setCursorClassName("we-resize");
									break;
								case st.PaneCursorType.DiagonalNeSwResize:
									this._setCursorClassName("nesw-resize");
									break;
								case st.PaneCursorType.DiagonalNwSeResize:
									this._setCursorClassName("nwse-resize")
							}
						}
					}
					this._preventCrossHairMove() && this._clearCursorPosition(), a.crossHairSource().setLinesShouldBeHidden(l)
				}
				async _createErrorBlock() {
					const e = new(await rt());
					return this._div.insertBefore(e.container, this._topCanvasBinding.canvasElement.nextSibling), e
				}
				_customActions() {
					const e = {
							top: [],
							bottom: [],
							remove: []
						},
						t = this._chartUndoModel().timeScale(),
						i = this._state && this._state.defaultPriceScale();
					if (!Te.enabled("custom_items_in_context_menu")) return e;
					const o = t.isEmpty() ? void 0 : t.indexToUserTime(t.coordinateToIndex(this._contextMenuX));
					let r;
					if (i && !i.isEmpty()) {
						const e = (0, s.ensureNotNull)(this.state().mainDataSource()).firstValue();
						r = i.coordinateToPrice(this._contextMenuY, (0, s.ensureNotNull)(e))
					}
					return (0, h.emit)("onContextMenu", {
						unixtime: null != o ? o.getTime() / 1e3 : void 0,
						price: r,
						callback: t => {
							[...t].forEach((t => {
								if (t.text)
									if (t.text.length > 1 && "-" === t.text[0]) e.remove.push(t.text.slice(1));
									else {
										let i;
										i = "-" === t.text ? new Me.Separator : new Me.Action({
											actionId: "Chart.ExternalActionId",
											label: t.text,
											onExecute: t.click
										}), t.position && "top" === t.position ? e.top.push(i) : e.bottom.push(i)
									}
							}))
						}
					}), e
				}
				_highlightPriceAxisByLabel(e) {
					this._lhsPriceAxisesContainer.highlightPriceAxisByLabel(e), this._rhsPriceAxisesContainer.highlightPriceAxisByLabel(e)
				}
				_subscribeToState() {
					const e = this.state();
					e.onDestroyed().subscribe(this, this._onStateDestroyed, !0), e.dataSourcesCollectionChanged().subscribe(this, this._onDataSourcesCollectionChanged), e.maximized().subscribe(this._updateVisuallyCollapsed), e.collapsed().subscribe(this._updateVisuallyCollapsed)
				}
				_unsubscribeFromState() {
					const e = this.state();
					e.onDestroyed().unsubscribeAll(this), e.dataSourcesCollectionChanged().unsubscribeAll(this), e.maximized().unsubscribe(this._updateVisuallyCollapsed), e.collapsed().unsubscribe(this._updateVisuallyCollapsed)
				}
				async _updateEndOfSeriesBanner() {
					var e, t, o, r; {
						const n = () => {
								var e, t;
								const i = this._state;
								if (!i || !this._showEndOfSeriesDataBanner.value()) return null === (e = this._endOfSeriesDataBanner) || void 0 === e || e.setVisible(!1), null;
								if (!this._chart.isActive()) return null;
								const s = i.model().mainSeries();
								if (!s) return null;
								if (!i.isMainPane()) return null;
								if (2 === s.status() || s.requestMoreDataAvailable()) return null === (t = this._endOfSeriesDataBanner) || void 0 === t || t.setVisible(!1), null;
								const o = s.bars().firstIndex();
								return null === o ? null : {
									state: i,
									series: s,
									firstIndex: o
								}
							},
							a = () => {
								if (this._legendWidget) {
									const e = this._legendWidget.getElement().getBoundingClientRect();
									return e.bottom - e.top
								}
								return 0
							};
						let l = n();
						if (!l) return void(null === (e = this._endOfSeriesDataBanner) || void 0 === e || e.setVisible(!1));
						l.series.doNotShowLastAvailableBar(!1);
						const c = l.series.endOfDataType(),
							h = (0,
								s.ensureNotNull)(this._state).model().timeScale().indexToCoordinate(l.firstIndex) - l.state.model().timeScale().barSpacing();
						if (!this._endOfSeriesDataBanner && !Te.enabled("widget")) {
							const e = await Promise.all([i.e(10146), i.e(50307), i.e(75514), i.e(66849)]).then(i.bind(i, 535570));
							if (l = n(), !l) return;
							this._endOfSeriesDataBanner || (this._endOfSeriesDataBanner = new e.EndOfSeriesBanner, this._div.appendChild(this._endOfSeriesDataBanner.element()))
						}
						const d = a();
						null === (t = this._endOfSeriesDataBanner) || void 0 === t || t.setVisible(!0), null === (o = this._endOfSeriesDataBanner) || void 0 === o || o.update(l.state, d, h, c);
						const u = null === (r = this._endOfSeriesDataBanner) || void 0 === r ? void 0 : r.currentSize();
						l.series.doNotShowLastAvailableBar(null !== u && 0 !== u)
					}
				}
			}
			var Ot = i(33624);
			class Rt {
				constructor(e, t, i) {
					this._handleEl = null, this._resizeInfo = null, this._colorCache = {
						lineColor: "",
						backgroundColor: "",
						color: ""
					}, this._chart = e, this._topPaneIndex = t, this._bottomPaneIndex = i, this._row = document.createElement("tr"), this._cell = document.createElement("td"), this._row.appendChild(this._cell), this._cell.classList.add(Ot.paneSeparator), this._cell.setAttribute("colspan", "3"), this._cell.style.background = this._color(), this.adjustSize(), this._cell.addEventListener("click", (() => {}));
					const s = document.createElement("div");
					s.classList.add(Ot.handle), this._cell.appendChild(s), this._mouseEventHandler = new N.MouseEventHandler(s, this, {
						treatVertTouchDragAsPageScroll: !1,
						treatHorzTouchDragAsPageScroll: !0
					}), this._handleEl = s
				}
				destroy() {
					this._mouseEventHandler.destroy(), this._row.parentElement && this._row.parentElement.removeChild(this._row)
				}
				getElement() {
					return this._row
				}
				hide() {
					this._row.classList.add("js-hidden")
				}
				show() {
					this._row.classList.remove("js-hidden")
				}
				adjustSize() {
					this._row.style.height = Rt.height() + "px"
				}
				mouseEnterEvent(e) {
					const {
						topPane: t,
						bottomPane: i
					} = this._topBottomPane(!0);
					null !== t && null !== i && (0, s.ensureNotNull)(this._handleEl).classList.add(Ot.hovered)
				}
				mouseLeaveEvent(e) {
					(0, s.ensureNotNull)(this._handleEl).classList.remove(Ot.hovered)
				}
				mouseDownEvent(e) {
					this._mouseDownOrTouchStartEvent(e)
				}
				touchStartEvent(e) {
					this._mouseDownOrTouchStartEvent(e)
				}
				pressedMouseMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				touchMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				mouseUpEvent(e) {
					this._mouseUpOrTouchEndEvent(e)
				}
				touchEndEvent(e) {
					this._mouseUpOrTouchEndEvent(e)
				}
				update() {
					this._cell.style.background = this._color().toString()
				}
				paint() {}
				image() {
					const {
						topPane: e
					} = this._topBottomPane(!1), t = e.leftPriceAxisesContainer().getWidth(), i = e.width(), s = e.rightPriceAxisesContainer().getWidth(), o = this._color(), r = (0, B.createDisconnectedCanvas)(document, new B.Size(t, 1)), n = (0, B.getPrescaledContext2D)(r);
					n.fillStyle = o, n.fillRect(0, 0, t, 1);
					const a = (0, B.createDisconnectedCanvas)(document, new B.Size(i, 1)),
						l = (0, B.getPrescaledContext2D)(a);
					l.fillStyle = o, l.fillRect(0, 0, i, 1);
					const c = (0, B.createDisconnectedCanvas)(document, new B.Size(s, 1)),
						h = (0, B.getPrescaledContext2D)(c);
					return h.fillStyle = o, h.fillRect(0, 0, s, 1), {
						type: "separator",
						leftAxis: {
							content: r.toDataURL(),
							canvas: r,
							contentWidth: t,
							contentHeight: 1
						},
						rightAxis: {
							content: c.toDataURL(),
							canvas: c,
							contentWidth: s,
							contentHeight: 1
						},
						content: a.toDataURL(),
						canvas: a,
						contentWidth: i,
						contentHeight: 1
					}
				}
				static height() {
					const e = window.devicePixelRatio || 1;
					return e >= 1 ? 1 : 1 / e
				}
				_mouseDownOrTouchStartEvent(e) {
					const {
						topPane: t,
						bottomPane: i
					} = this._topBottomPane(!0);
					if (null === t || null === i) return;
					const o = t.state().stretchFactor() + i.state().stretchFactor(),
						r = o / (t.height() + i.height()),
						n = 30 * r;
					o <= 2 * n || (this._resizeInfo = {
						startY: e.pageY,
						prevStretchTopPane: t.state().stretchFactor(),
						maxPaneStretch: o - n,
						totalStretch: o,
						pixelStretchFactor: r,
						minPaneStretch: n
					}, (0, s.ensureNotNull)(this._handleEl).classList.add(Ot.active))
				}
				_pressedMouseOrTouchMoveEvent(e) {
					const {
						topPane: t,
						bottomPane: i
					} = this._topBottomPane(!0), s = this._resizeInfo;
					if (null === s || null === t || null === i) return;
					const o = (e.pageY - s.startY) * s.pixelStretchFactor,
						r = (0, le.clamp)(s.prevStretchTopPane + o, s.minPaneStretch, s.maxPaneStretch);
					t.state().setStretchFactor(r), i.state().setStretchFactor(s.totalStretch - r), this._chart.model().model().fullUpdate()
				}
				_mouseUpOrTouchEndEvent(e) {
					const {
						topPane: t,
						bottomPane: i
					} = this._topBottomPane(!0), o = this._resizeInfo;
					null !== o && null !== t && null !== i && (this._chart.model().addPaneStretchFactorUndoCommand(t.state(), i.state(), o.prevStretchTopPane, t.state().stretchFactor()), this._resizeInfo = null, (0, s.ensureNotNull)(this._handleEl).classList.remove(Ot.active))
				}
				_color() {
					const e = this._chart.properties().childs().paneProperties.childs().separatorColor.value(),
						t = this._chart.model().model().backgroundColor().value();
					if (this._colorCache.lineColor !== e || this._colorCache.backgroundColor !== t) {
						const i = (0, oe.parseRgba)(t),
							s = (0, oe.parseRgba)(e),
							o = 0 === i[3] && 0 === s[3] ? "rgba(0,0,0,0)" : (0, oe.rgbaToString)((0, oe.blendRgba)(i, s));
						this._colorCache = {
							lineColor: e,
							backgroundColor: t,
							color: o
						}
					}
					return this._colorCache.color
				}
				_topBottomPane(e) {
					const t = this._chart.paneWidgets();
					let i = null,
						s = null;
					for (let s = this._topPaneIndex; s >= 0; --s) {
						const o = t[s];
						if (!e || !o.state().collapsed().value()) {
							i = o;
							break
						}
					}
					for (let i = this._bottomPaneIndex; i < t.length; ++i) {
						const o = t[i];
						if (!e || !o.state().collapsed().value()) {
							s = o;
							break
						}
					}
					return {
						topPane: i,
						bottomPane: s
					}
				}
			}
			var Vt = i(121195),
				Wt = i(588746),
				Ft = i(647527);
			i(244680);
			const zt = {
					contextMenuEnabled: !0,
					timezoneMenuEnabled: !0,
					pressedMouseMoveScale: !0
				},
				Ut = new T.TranslatedString("change session", (0, o.t)("change session")),
				Ht = (0, o.t)("Session");
			class Gt {
				constructor(e, t, i, s, o) {
					this._rendererOptions = null, this._onLabelHovered = new(K()), this._mousedown = !1, this._currentCursorClassName = "invalid", this._options = (0, _.merge)((0, _.clone)(zt), t || {}), this.chart = e, this._properties = e.properties().childs().scalesProperties, this._element = document.createElement("tr"), this._backgroundBasedTheme = o;
					const r = () => this.backgroundColor(),
						n = () => {
							throw new Error("Time axis does not support real price scales")
						},
						a = {
							titlesProvider: i,
							stubContextMenuProvider: (e, t) => {
								const i = this.getContextMenuActions(!0);
								let o = s(e, t);
								if (o[o.length - 1] === this.chart.actions().scalesProperties) {
									const e = [new Me.Separator].concat(i);
									Array.prototype.splice.apply(o, [o.length - 2, 0, ...e])
								} else o.push(new Me.Separator), o = o.concat(i);
								return o
							},
							backgroundBasedTheme: o,
							rendererOptionsProvider: e.model().model().rendererOptionsProvider(),
							getBackgroundTopColor: r,
							getBackgroundBottomColor: r,
							showHorizontalBorder: !0
						};
					this._lhsStubContainer = new J(this._properties, "left", n, a, this._options.priceAxisLabelsOptions, this), this._lhsStubContainer.onLabelHovered().subscribe(this, ((e, t) => {
						this._onLabelHovered.fire(e, t)
					})), this._rhsStubContainer = new J(this._properties, "right", n, a, this._options.priceAxisLabelsOptions, this), this._rhsStubContainer.onLabelHovered().subscribe(this, ((e, t) => {
						this._onLabelHovered.fire(e, t)
					})), this._element.appendChild(this._lhsStubContainer.getElement()), this._cell = document.createElement("td"), this._element.appendChild(this._cell), this._cell.classList.add("chart-markup-table", "time-axis"), this._cell.style.height = "25px", this._dv = document.createElement("div"), this._dv.style.width = "100%", this._dv.style.height = "100%", this._dv.style.position = "relative", this._dv.style.overflow = "hidden", this._cell.appendChild(this._dv), this._canvasConfiguredHandler = () => this.chart.model().model().lightUpdate(), this._canvasBinding = (0, B.createBoundCanvas)(this._dv, new B.Size(16, 16)), this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
					const l = this._canvasBinding.canvasElement;
					l.style.position = "absolute", l.style.zIndex = "1", l.style.left = "0", l.style.top = "0", this._topCanvasBinding = (0, B.createBoundCanvas)(this._dv, new B.Size(16, 16)), this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
					const c = this._topCanvasBinding.canvasElement;
					c.style.position = "absolute", c.style.zIndex = "2", c.style.left = "0", c.style.top = "0", this._element.appendChild(this._rhsStubContainer.getElement()), this.restoreDefaultCursor(), this.update(), this._minVisibleSpan = Vt.MINUTE_SPAN, this._mouseEventHandler = new N.MouseEventHandler(this._topCanvasBinding.canvasElement, this, {
						treatVertTouchDragAsPageScroll: !0,
						treatHorzTouchDragAsPageScroll: !1
					}), this.size = new B.Size(0, 0)
				}
				destroy() {
					this._mouseEventHandler.destroy(), this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler), this._topCanvasBinding.dispose(), this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler), this._canvasBinding.dispose(), this._rhsStubContainer.onLabelHovered().unsubscribeAll(this), this._lhsStubContainer.onLabelHovered().unsubscribeAll(this), this._lhsStubContainer.destroy(), this._rhsStubContainer.destroy(), this.chart.properties().childs().paneProperties.childs().background.unsubscribeAll(this)
				}
				setCursor(e) {
					let t = "";
					"grabbing" !== e && "ew-resize" !== e || (t = "time-axis--cursor-" + e), this._currentCursorClassName !== t && (this._currentCursorClassName && this._cell.classList.remove(this._currentCursorClassName), t && this._cell.classList.add(t), this._currentCursorClassName = t, this._cell.style.cursor)
				}
				restoreDefaultCursor() {
					this.setCursor("")
				}
				getElement() {
					return this._element
				}
				optimalHeight() {
					const e = this.rendererOptions();
					return Math.ceil(e.borderSize + e.offsetSize + e.fontSize + e.paddingTop + e.paddingBottom + e.labelBottomOffset)
				}
				setSizes(e, t, i) {
					this.size && this.size.equals(e) || (this.size = e, this._canvasBinding.resizeCanvasElement({
						width: e.w,
						height: e.h
					}), this._topCanvasBinding.resizeCanvasElement({
						width: e.w,
						height: e.h
					}), this._cell.style.width = e.w + "px", this._cell.style.height = e.h + "px"), this._lhsStubContainer.setSizes(e.h, t), this._rhsStubContainer.setSizes(e.h, i)
				}
				rendererOptions() {
					if (!this._rendererOptions || this._rendererOptions.fontSize !== this.fontSize()) {
						const e = this.fontSize();
						this._rendererOptions = {
							borderSize: 1,
							offsetSize: 5,
							fontSize: e,
							font: (0, R.makeFont)(e, z.CHART_FONT_FAMILY, ""),
							widthCache: new ie.TextWidthCache,
							paddingTop: 3 * e / 12,
							paddingBottom: 3 * e / 12,
							paddingHorizontal: 9 * e / 12,
							labelBottomOffset: 4 * e / 12
						}
					}
					return this._rendererOptions
				}
				backgroundColor() {
					return this.chart.model().model().backgroundColor().value()
				}
				lineColor() {
					const e = this._properties.childs().lineColor.value();
					if (0 === (0, oe.parseRgba)(e)[3]) {
						const e = this.chart.model().model().lastPane();
						if (e && (e.collapsed().value() || e.isMainPane() && this._areEventsEnabled())) return this.chart.properties().childs().paneProperties.childs().separatorColor.value()
					}
					return e
				}
				textColor() {
					return this._properties.childs().textColor.value()
				}
				fontSize() {
					return this._properties.childs().fontSize.value()
				}
				baseFont() {
					return (0, R.makeFont)(this.fontSize(), z.CHART_FONT_FAMILY)
				}
				baseBoldFont() {
					return (0, R.makeFont)(this.fontSize(), z.CHART_FONT_FAMILY, "", "bold")
				}
				hasCanvas(e) {
					return this._canvasBinding.canvasElement === e || this._topCanvasBinding.canvasElement === e
				}
				onLabelHovered() {
					return this._onLabelHovered
				}
				getScreenshotData() {
					return {
						content: this._canvasBinding.canvasElement.toDataURL(),
						canvas: this._canvasBinding.canvasElement,
						contentWidth: this.size.w,
						contentHeight: this.size.h,
						lhsStub: this._lhsStubContainer.getScreenshotData(),
						rhsStub: this._rhsStubContainer.getScreenshotData()
					}
				}
				getContextMenuActions(e) {
					var t;
					const i = this.chart;
					i.updateActions();
					const s = i.actions(),
						o = [];
					if (e || o.push(s.timeScaleReset, new Me.Separator), this._options.timezoneMenuEnabled && o.push(s.applyTimeZone), o.push(s.sessionBreaks), !i.model().mainSeries().isDWM()) {
						const e = null === (t = i.model()) || void 0 === t ? void 0 : t.mainSeries().symbolInfo();
						if (e) {
							const t = i.model().mainSeries().properties().childs().sessionId,
								s = (e.subsessions || []).filter((e => !e.private));
							if (s.length > 1) {
								const e = s.map((e => new Wt.TVAction({
										label: (0, Ft.translateSessionDescription)(e.description),
										checkable: !0,
										checked: t.value() === e.id,
										statName: "SetSession",
										onExecute: () => {
											i.model().setProperty(t, e.id, Ut)
										}
									}))),
									r = new Wt.TVAction({
										label: Ht,
										statName: "SetSession",
										subItems: e
									});
								o.push(r)
							}
						}
					}
					return o
				}
				update() {
					if (!this.chart.hasModel()) return;
					const e = this.chart.model().timeScale().marks();
					if (e) {
						this._minVisibleSpan = Vt.YEAR_SPAN;
						for (const t of e) this._minVisibleSpan = Math.min(t.span, this._minVisibleSpan)
					}
				}
				updatePriceAxisStubs() {
					const e = this.chart.model().model(),
						t = this.chart.isMaximizedPane() ? (0, s.ensureNotNull)(this.chart.maximizedPaneWidget()).state() : e.paneForSource(e.mainSeries());
					if (!t) return;
					const i = e.priceScaleSlotsCount();
					this._lhsStubContainer.setScales([], i.left, t.leftPriceScales().length, i.left + i.right),
						this._rhsStubContainer.setScales([], i.right, t.rightPriceScales().length, i.left + i.right)
				}
				paint(e) {
					if (e === f.InvalidationLevel.None || 0 === this.size.w || 0 === this.size.h) return;
					this._canvasBinding.applySuggestedBitmapSize(), this._topCanvasBinding.applySuggestedBitmapSize();
					const t = (0, B.getContext2D)(this._topCanvasBinding.canvasElement);
					if (e > f.InvalidationLevel.Cursor) {
						const i = (0, B.getContext2D)(this._canvasBinding.canvasElement),
							s = (0, B.getBindingPixelRatio)(this._canvasBinding);
						this.drawBackground(i, s), this.chart.hasModel() && (this.drawBorder(i, s), this.drawTickMarks(i, s), this.drawBackLabels(i, s), this.drawCrossHairLabel(t, s)), this._lhsStubContainer.paintStubs(e), this._rhsStubContainer.paintStubs(e)
					}
					this.drawCrossHairLabel(t, (0, B.getBindingPixelRatio)(this._topCanvasBinding))
				}
				drawBackground(e, t) {
					if ((0, B.clearRect)(e, 0, 0, Math.ceil(this.size.w * t) + 1, Math.ceil(this.size.h * t) + 1, this.backgroundColor()), !this.chart.hasModel()) return;
					const i = this.chart.model();
					if (!i.timeScale().isEmpty()) {
						const s = i.model().selection().lineDataSources().reduce(((e, t) => {
							const i = t.timeAxisPoints();
							return 0 === i.length ? e : e.concat(i)
						}), []);
						s.length > 0 && this._hightlightBackground(e, s, t)
					}
					const s = i.model().crossHairSource();
					s.startMeasurePoint() && this._hightlightBackground(e, s.measurePoints(), t)
				}
				drawBorder(e, t) {
					e.save(), e.fillStyle = this.lineColor();
					const i = Math.max(1, Math.floor(this.rendererOptions().borderSize * t)),
						s = Math.ceil(this.size.w * t);
					e.fillRect(0, 0, s + 1, i), e.restore()
				}
				drawTickMarks(e, t) {
					const i = this.chart.model().timeScale().marks();
					if (!i || 0 === i.length) return;
					let s = i.reduce(((e, t) => e.span > t.span ? e : t), i[0]).span;
					s > 30 && s < 40 && (s = 30), e.save(), e.strokeStyle = this.lineColor();
					const o = this.rendererOptions(),
						r = o.borderSize + o.offsetSize + o.paddingTop + o.fontSize / 2;
					e.textAlign = "center", e.textBaseline = "middle", e.fillStyle = this.textColor(), (0, B.drawScaled)(e, t, (() => {
						e.font = this.baseFont();
						for (let t = 0; t < i.length; t++) {
							const o = i[t];
							o.span < s && e.fillText(o.label, o.coord, r)
						}
						e.font = this.baseBoldFont();
						for (let t = 0; t < i.length; t++) {
							const o = i[t];
							o.span >= s && e.fillText(o.label, o.coord, r)
						}
					})), e.restore()
				}
				drawBackLabels(e, t) {
					var i;
					e.save();
					const s = new Set,
						o = this.chart.model().model();
					let r = o.dataSources();
					const n = o.selection().allSources();
					for (const e of n) s.add(e);
					o.hoveredSource() && s.add(o.hoveredSource());
					for (const e of o.sourcesBeingMoved()) s.add(e);
					const a = o.customSourceBeingMoved();
					null !== a && s.add(a);
					const l = null !== (i = o.lineBeingEdited()) && void 0 !== i ? i : o.lineBeingCreated();
					l && s.add(l), s.add(this.chart.model().crossHairSource()), r = r.concat(o.customSources());
					const c = this.rendererOptions();
					for (let i = 0; i < r.length; i++) {
						const o = r[i];
						if (!s.has(o) && o.timeAxisViews) {
							const i = o.timeAxisViews();
							if (i)
								for (let s = 0; s < i.length; s++) i[s].renderer().draw(e, c, t)
						}
					}
					e.restore()
				}
				drawCrossHairLabel(e, t) {
					var i;
					e.save(), e.clearRect(0, 0, Math.ceil(this.size.w * t) + 1, Math.ceil(this.size.h * t) + 1);
					const s = this.chart.model().model(),
						o = [],
						r = null !== (i = s.lineBeingEdited()) && void 0 !== i ? i : s.lineBeingCreated();
					if (r && r.timeAxisViews) {
						const e = r.timeAxisViews();
						e && e.length && o.push(e)
					}
					const n = s.customSourceBeingMoved();
					this._addViewsOrMaxMin(null === n ? [] : [n], o), this._addViewsOrMaxMin(s.sourcesBeingMoved(), o), this._addViewsOrMaxMin(s.selection().allSources(), o);
					const a = s.hoveredSource();
					if (a && (0, k.isDataSource)(a) && !s.selection().isSelected(a) && a.timeAxisViews) {
						const e = a.timeAxisViews();
						e && e.length && o.push(e)
					}
					const l = s.crossHairSource(),
						c = l.timeAxisViews && l.timeAxisViews();
					c && c.length && o.push(c);
					const h = this.rendererOptions();
					for (const i of o)
						for (const s of i) e.save(), s.renderer().draw(e, h, t), e.restore();
					e.restore()
				}
				mouseDownEvent(e) {
					this._mouseDownOrTouchStartEvent(e)
				}
				touchStartEvent(e) {
					this._mouseOrTouchEnterEvent(e), this._mouseDownOrTouchStartEvent(e)
				}
				mouseDownOutsideEvent() {
					this._zoomAvailable() && this._mousedown && (this._mousedown = !1, this.chart.model().endScaleTime(), this.restoreDefaultCursor())
				}
				pressedMouseMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				touchMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				mouseUpEvent(e) {
					this._mouseUpOrTouchEndEvent(e)
				}
				touchEndEvent(e) {
					this._mouseUpOrTouchEndEvent(e), this._mouseOrTouchLeaveEvent(e)
				}
				contextMenuEvent(e) {
					this._contextMenuOrTouchContextMenuEvent(e)
				}
				touchContextMenuEvent(e) {
					this._contextMenuOrTouchContextMenuEvent(e)
				}
				mouseEnterEvent(e) {
					this._mouseOrTouchEnterEvent(e)
				}
				mouseLeaveEvent(e) {
					this._mouseOrTouchLeaveEvent(e)
				}
				mouseDoubleClickEvent(e) {
					this._mouseDoubleClickOrDoubleTapEvent(e)
				}
				doubleTapEvent(e) {
					this._mouseDoubleClickOrDoubleTapEvent(e)
				}
				_hightlightBackground(e, t, i) {
					const s = this.chart.model().timeScale();
					let o = t[0].index,
						r = t[0].index;
					for (let e = 1; e < t.length; e++) o = Math.min(o, t[e].index), r = Math.max(r, t[e].index);
					const n = Math.floor(s.indexToCoordinate(o) * i),
						a = Math.ceil(s.indexToCoordinate(r) * i);
					(0, B.fillRect)(e, n, 0, a - n, Math.ceil(this.size.h * i) + 1, this._properties.childs().axisHighlightColor.value())
				}
				_addViewsOrMaxMin(e, t) {
					if (e.length <= 1) {
						for (const i of e)
							if (i.timeAxisViews) {
								const e = i.timeAxisViews();
								e && e.length && t.push(e)
							}
					} else t.push(this._minMaxViews(e))
				}
				_minMaxViews(e) {
					const t = [];
					let i = 1 / 0,
						s = -1 / 0,
						o = null,
						r = null;
					for (const t of e)
						if (t.timeAxisViews) {
							const e = t.timeAxisViews();
							if (e && e.length)
								for (let t = 0; t < e.length; ++t) {
									const n = e[t],
										a = n.coordinate();
									a >= s && (s = a, r = n), a <= i && (i = a, o = n)
								}
						} return r && t.push(r), o && t.push(o), t
				}
				_zoomAvailable() {
					return !this.chart.model().timeScale().isEmpty() && this.chart.model().model().zoomEnabled() && this._options.pressedMouseMoveScale
				}
				_mouseDownOrTouchStartEvent(e) {
					if (this._mousedown || !this._zoomAvailable()) return;
					this._mousedown = !0;
					const t = this.chart.model();
					t.timeScale().isEmpty() || t.startScaleTime(e.localX)
				}
				_pressedMouseOrTouchMoveEvent(e) {
					this._zoomAvailable() && this.chart.model().scaleTimeTo(e.localX)
				}
				_mouseUpOrTouchEndEvent(e) {
					this._zoomAvailable() && (this._mousedown = !1, this.chart.model().endScaleTime(), this.restoreDefaultCursor())
				}
				_contextMenuOrTouchContextMenuEvent(e) {
					this._options.contextMenuEnabled && Y.ContextMenuManager.showMenu(this.getContextMenuActions(), e, {
						statName: "TimeScaleContextMenu"
					}, {
						menuName: "TimeScaleContextMenu"
					})
				}
				_mouseOrTouchEnterEvent(e) {
					this._zoomAvailable() && this.setCursor("ew-resize")
				}
				_mouseOrTouchLeaveEvent(e) {
					this.restoreDefaultCursor()
				}
				_mouseDoubleClickOrDoubleTapEvent(e) {
					(0, se.trackEvent)("GUI", "Double click time scale"), this.chart.model().resetTimeScale()
				}
				_areEventsEnabled() {
					var e; {
						const t = this.chart.model().mainSeries();
						switch (null === (e = t.symbolInfo()) || void 0 === e ? void 0 : e.type) {
							case "forex":
							case "cfd":
								return !Te.enabled("widget") && this.chart.model().model().properties().childs().chartEventsSourceProperties.childs().visible.value();
							case "stock":
							case "fund":
								if (!Te.enabled("widget") || Te.enabled("esdonwidget")) {
									const {
										esdShowDividends: e,
										esdShowSplits: i,
										esdShowEarnings: s
									} = t.properties().childs();
									return e.value() || i.value() || s.value()
								}
								return !1;
							default:
								return !1
						}
					}
				}
			}

			function jt(e, t) {
				return Object.prototype.hasOwnProperty.call(e, t)
			}

			function qt(e) {
				return e.reduce(((e, t) => {
					for (const i in t)
						if (jt(t, i)) {
							const s = t[i],
								o = e[i];
							o ? o.push(s) : e[i] = [s]
						} return e
				}), {})
			}
			const Kt = new T.TranslatedString("move left", (0, o.t)("move left")),
				Yt = new T.TranslatedString("move right", (0, o.t)("move right")),
				Xt = {
					moving: "wait_finishing",
					wait_finishing: "stop",
					stop: "moving"
				};
			class Zt {
				constructor(e) {
					this._chartModel = null, this._currentDistance = 0, this._deferredFinishTimeout = 0, this._finishingTimeout = 0, this._moveType = "", this._startTime = 0, this._state = "stop", this._movingTimeout = 0, this._chart = e, this._chart.withModel(this, (() => {
						this._chartModel = this._chart.model()
					}))
				}
				destroy() {
					clearTimeout(this._movingTimeout)
				}
				move(e) {
					if (null !== this._chartModel && "stop" === this._state && this._chartModel.beginUndoMacro(1 === e ? Kt : Yt), this._state = Xt.stop, this._moveType = "animated", this._deferredFinishTimeout && (clearTimeout(this._deferredFinishTimeout), this._deferredFinishTimeout = 0), this._finishingTimeout && (clearTimeout(this._finishingTimeout), this._finishingTimeout = 0), this._startTime = Date.now(), 0 === this._movingTimeout) {
						const t = this._startTime,
							i = 10,
							s = () => {
								this.moveStep(t, 0, 50 * e, 1e3), this._movingTimeout = setTimeout(s, i)
							};
						this._movingTimeout = setTimeout(s, i)
					}
				}
				moveStep(e, t, i, s) {
					if (null !== this._chartModel && !this._chartModel.timeScale().isEmpty()) {
						const o = Date.now();
						o < e && (e = o);
						let r = (o - e) / s;
						(r > 1 || !isFinite(r)) && (r = 1);
						const n = 1 - Math.pow(1 - r, 3);
						return this._currentDistance = (i - t) * n + t, this._chartModel.scrollChart(this._currentDistance), r
					}
				}
				moveByBar(e) {
					if (null !== this._chartModel) {
						const t = this._chartModel.timeScale();
						if (t.isEmpty()) return;
						if ("stop" === this._state && this._chartModel.beginUndoMacro(1 === e ? Kt : Yt), null !== t.visibleBarsStrictRange()) {
							const e = t.indexToCoordinate(t.visibleBarsStrictRange().lastBar()) + t.barSpacing() / 2;
							Math.abs(t.width() - e) > t.barSpacing() / 6 && this._chartModel.scrollChart(t.width() - e)
						}
						if (this._state = Xt.stop, this._moveType = "by_bar", this._startTime = Date.now(), !this._movingTimeout) {
							let t = 0,
								i = 150;
							const s = 400,
								o = () => {
									this._moveByBarStep(e), t++, i > 100 && (i -= t / 5 * 20), this._movingTimeout = setTimeout(o, i)
								};
							this._movingTimeout = setTimeout(o, s), this._moveByBarStep(e)
						}
					}
				}
				stopMove() {
					"by_bar" === this._moveType ? this.stopMoveByBar() : this._stopMove()
				}
				stopMoveByBar() {
					"moving" === this._state && (clearTimeout(this._movingTimeout), this._movingTimeout = 0, this._state = Xt.wait_finishing, this._moveType = "", this._movingTimeout = 0,
						this._currentDistance = 0, null !== this._chartModel && this._chartModel.endUndoMacro())
				}
				scrollToRealtime(e) {
					null !== this._chartModel && this._chartModel.timeScale().scrollToRealtime(e)
				}
				_finishMove() {
					clearTimeout(this._movingTimeout), this._movingTimeout = 0, this._deferredFinishTimeout = 0;
					const e = this._currentDistance,
						t = Date.now(),
						i = () => {
							const s = this.moveStep(t, e, 0, 700);
							s && s < 1 ? this._finishingTimeout = setTimeout(i, 10) : null !== this._chartModel && (this._state = Xt.wait_finishing, this._moveType = "", this._movingTimeout = 0, this._currentDistance = 0, this._chartModel.endUndoMacro())
						};
					this._finishingTimeout = setTimeout(i, 10)
				}
				_stopMove() {
					"moving" === this._state && (this._state = Xt.moving, Date.now() - this._startTime < 200 ? this._deferredFinishTimeout = setTimeout(this._finishMove.bind(this), 200 - (Date.now() - this._startTime)) : this._finishMove())
				}
				_moveByBarStep(e) {
					if (null !== this._chartModel) {
						if (this._chartModel.timeScale().isEmpty()) return;
						this._chartModel.scrollChartByBar(e)
					}
				}
			}
			var $t = i(12481),
				Qt = i(833713),
				Jt = i(895370),
				ei = i(198303),
				ti = i(388482);
			const ii = (0, r.getLogger)("Chart.LinkKeyResolver");
			class si {
				constructor(e, t, i) {
					this._pendingRequests = new Map, this._startRequestingDebounced = (0, $t.default)((() => this._startNextRequest()), 500), this._layoutId = e, this._chartId = t, this._ownerSourceId = i
				}
				resolveLinkKey(e, t, i) {
					var s;
					const o = function(e, t) {
							return JSON.stringify([e, t])
						}(e, i),
						r = null !== (s = this._pendingRequests.get(o)) && void 0 !== s ? s : new Map;
					if (r.has(t)) return r.get(t).promise;
					const n = (0, c.createDeferredPromise)();
					return r.set(t, n), this._pendingRequests.set(o, r), this._startRequestingDebounced(), n.promise
				}
				async _startNextRequest() {
					if (0 === this._pendingRequests.size) return;
					const e = (0, ti.getChartStorage)(),
						t = this._pendingRequests.entries().next().value,
						{
							symbol: i,
							brokerName: s
						} = function(e) {
							const t = JSON.parse(e);
							return {
								symbol: t[0],
								brokerName: t[1]
							}
						}(t[0]),
						o = t[1],
						r = {
							requestType: "mainSeriesLineTools",
							seriesSourceId: this._ownerSourceId,
							symbol: i,
							brokerName: s,
							sharingMode: 0
						};
					try {
						const t = await e.loadLineToolsAndGroups(this._layoutId, this._chartId, r);
						null !== t && (t.sources.forEach(((e, t) => {
							if (null === e) return;
							const i = e.state.linkKey;
							if (!i) return;
							const s = o.get(i);
							null == s || s.resolve(e.id), o.delete(i)
						})), t.serverRequestId && console.log(`PROCESSED:${t.serverRequestId}`))
					} catch (e) {
						ii.logError(`Error requesting line tools: ${e}`)
					}
					o.forEach((e => {
						e.resolve(null)
					})), this._pendingRequests.delete(t[0]), await this._startNextRequest()
				}
			}
			var oi = i(69318),
				ri = i(148976),
				ni = i(95935),
				ai = i(55111),
				li = i(963568);
			const ci = [500, 1e4, 6e4],
				hi = new ut.FeatureToggleWatchedValue("disable_retry_load_linetools_from_storage", !1);
			var di = i(929744);
			const ui = (0, r.getLogger)("LineToolsSynchronizer");

			function _i(e, t) {
				return {
					id: e.id,
					name: e.name(),
					symbol: e.symbol(),
					currencyId: e.currencyId(),
					unitId: e.unitId()
				}
			}

			function mi(e) {
				return void 0 === e ? 0 : e
			}

			function pi(e, t, i) {
				const s = new Map,
					o = new Set(null == i ? void 0 : i.keys());
				return e.forEach(((e, r) => {
					const n = !i || i.has(r);
					(e.timestamp > t || !n) && (s.set(r, e), o.delete(r))
				})), {
					stillInvalidated: s,
					validated: Array.from(o)
				}
			}

			function gi(e) {
				return (0, g.isLineTool)(e) || (0, di.isStudyLineToolStub)(e)
			}
			class Si {
				constructor(e, t, i, s, o, r) {
					this._clientId = (0, ni.randomHash)(), this._invalidatedLineToolsAndStudyStubs = new Map, this._allLineToolsAndStudyStubs = new Map, this._originalLineToolSharingMode = new Map, this._invalidatedLineToolGroups = new Map, this._ignoreInvalidatingEventsDepth = 0, this._saveChartService = null, this._debouncedSave = (0, $t.default)((() => this._saveInvalidatedIfRequired(!1)), 500), this._currentlyLoadedSymbol = new Map, this._linkKeyResolver = null, this._brokerName = "", this._hasChanges = new(Ke())(!1), this._lastBanTime = null, this._invalidateViaSync = !1, this._onChangeAutosave = e => {
						e && this._savingImmediatellyEnabled.value() && this._debouncedSave()
					}, this._layoutId = e, this._chartId = t, this._chartModel = i, this._readOnlyMode = s, this._duplicateOperationsForSerializedCharts = o, this._deserializedChartsIds = r, this._assignAllLineTools(this._chartModel.panes()), this._chartModel.panesCollectionChanged().subscribe(this, this._processPanesCollectionChanged.bind(this)), this._chartModel.dataSourceCollectionChanged().subscribe(this, this._processDataSourceCollectionChanged.bind(this)), this._chartModel.lineToolsGroupModel().onChanged().subscribe(this, this._processLineToolsGroupModelChanged.bind(this)), this._chartModel.mainSeries().dataEvents().symbolResolved().subscribe(this, this._onSymbolResolved.bind(this)), this._chartModel.mainSeries().onRestarted().subscribe(this, this._onSeriesRestarted.bind(this)), this._chartModel.sourcePropertiesChanged().subscribe(this, this._processPropertiesChanged.bind(this)), this._chartModel.sourceZOrderChanged().subscribe(this, this._processPropertiesChanged.bind(this)), this._linkKeyResolver = new si(e, t, i.mainSeries().id()), this._savingImmediatellyEnabled = new ut.FeatureToggleWatchedValue("autosave_line_tools_immediately", !1), this._savingImmediatellyEnabled.subscribe((e => {
						e && this._debouncedSave()
					})), this._brokerIdSession = new ut.FeatureToggleWatchedValue("broker_id_session", !1), this._loadWithoutSymbolResolving = new ut.FeatureToggleWatchedValue("chart_storage_with_broker_name", !1), this._removeFromContent = new ut.FeatureToggleWatchedValue("remove_line_tools_from_content", !1), this._removeFromContent.subscribe((e => {
						e && this.invalidateAll()
					})), this._saveSharedLineTools = new ut.FeatureToggleWatchedValue("save_shared_line_tools", !1), this._doNotSaveSharedLineToolsToCharts = new ut.FeatureToggleWatchedValue("do_not_save_shared_line_tools_to_charts", !1), this._sharingModesToUse().forEach((e => {
						0 === e && this._loadAndMergeLineToolsOnStudies(e, !1), this._loadAndMergeLineToolsWithoutSymbol(e, !1)
					}))
				}
				destroy() {
					this._savingImmediatellyEnabled.destroy(), this._loadWithoutSymbolResolving.destroy(), this._removeFromContent.destroy(), this._brokerIdSession.destroy(), this._chartModel.mainSeries().dataEvents().symbolResolved().unsubscribeAll(this), this._chartModel.mainSeries().onRestarted().unsubscribeAll(this), this._chartModel.sourcePropertiesChanged().unsubscribeAll(this), this._chartModel.sourceZOrderChanged().unsubscribeAll(this), this._chartModel.panesCollectionChanged().unsubscribeAll(this), this._chartModel.dataSourceCollectionChanged().unsubscribeAll(this),
						this._chartModel.lineToolsGroupModel().onChanged().unsubscribeAll(this)
				}
				reloadAllLineTools() {
					if (this._currentlyLoadedSymbol.clear(), this._sharingModesToUse().forEach((e => {
							0 === e && this._loadAndMergeLineToolsOnStudies(e, !0), this._loadAndMergeLineToolsWithoutSymbol(e, !0)
						})), this._loadWithoutSymbolResolving.value()) this._onSeriesRestarted();
					else {
						const e = this._chartModel.mainSeries().symbolInfo();
						e && this._onSymbolResolved(e)
					}
				}
				hasChanges() {
					return this._hasChanges
				}
				setSaveChartService(e) {
					this._saveChartService && this._saveChartService.autoSaveEnabled().unsubscribe(this._onChangeAutosave), this._saveChartService = e, this._saveChartService.autoSaveEnabled().subscribe(this._onChangeAutosave)
				}
				prepareDTO(e = !1) {
					const t = new Map;
					return this._sharingModesToUse().forEach((i => {
						t.set(i, this._prepareDTOItem(e, i))
					})), t
				}
				validateAll() {
					this._invalidatedLineToolGroups.clear(), this._invalidatedLineToolsAndStudyStubs.clear(), this._recalculateHasChanges()
				}
				resetInvalidated(e, t, i) {
					const s = pi(this._invalidatedLineToolsAndStudyStubs, e, t.sources);
					this._invalidatedLineToolsAndStudyStubs = s.stillInvalidated, this._invalidatedLineToolGroups = pi(this._invalidatedLineToolGroups, e, null == t ? void 0 : t.groups).stillInvalidated, s.validated.forEach((e => {
						var s;
						if (t.sources.get(e))
							if (0 === i) {
								const t = null !== (s = this._originalLineToolSharingMode.get(e)) && void 0 !== s ? s : i;
								this._originalLineToolSharingMode.set(e, t)
							} else this._originalLineToolSharingMode.set(e, i);
						else this._originalLineToolSharingMode.get(e) === i && this._originalLineToolSharingMode.delete(e)
					})), this._recalculateHasChanges()
				}
				applyLineToolUpdateNotification(e, t) {
					e.clientId !== this._clientId && this._applyLineToolsAndGroupsDTO(e, t)
				}
				startApplyingLineToolUpdateNotification() {
					this._ignoreInvalidatingEventsDepth++
				}
				endApplyingLineToolUpdateNotification() {
					this._ignoreInvalidatingEventsDepth--
				}
				applyAlertIdByExternalSource(e, t) {
					this._withoutInvalidating((() => {
						const i = this._chartModel.dataSourceForId(e);
						i && (0, g.isLineTool)(i) && i.setAlert(t, {
							noChartSave: !0
						})
					}))
				}
				deleteAlertByExternalSource(e) {
					this._withoutInvalidating((() => {
						const t = this._chartModel.dataSourceForId(e);
						t && (0, g.isLineTool)(t) && t.removeAlert()
					}))
				}
				async markSyncedLineToolAsDeleted(e, t) {
					if (this._linkKeyResolver) {
						const i = await this._linkKeyResolver.resolveLinkKey(t, e, this._brokerName);
						if (null !== i) {
							const t = (0, g.lineToolByLinkKey)(this._chartModel, e);
							null === t ? this._invalidateLineToolOrStudyStub(i, performance.now()) : this._withoutInvalidating((() => {
								const e = (0, s.ensureNotNull)(this._chartModel.paneForSource(t)),
									i = this._allLineToolsAndStudyStubs.get(e.id()) || new Map;
								t.detachAlert(), this._chartModel.removeSource(t), i.delete(t.id())
							})), this._debouncedSave()
						}
						return i
					}
					return null
				}
				invalidateAll() {
					const e = performance.now();
					this._allLineToolsAndStudyStubs.forEach((t => {
						t.forEach(((t, i) => {
							this._invalidateLineToolOrStudyStub(i, e)
						}))
					})), this._chartModel.lineToolsGroupModel().groupsForAllSymbols().forEach((t => {
						this._invalidateLineToolGroup(t.id, e)
					}))
				}
				setBroker(e) {
					this._brokerName = e
				}
				executeSyncedAction(e) {
					this._invalidateViaSync = !0;
					try {
						e()
					} finally {
						this._invalidateViaSync = !1
					}
				}
				flushPendingSavings() {
					return this._invalidatedLineToolGroups.size || this._invalidatedLineToolsAndStudyStubs.size ? this._savePromise(!1, !0) : null
				}
				_assignAllLineTools(e) {
					this._allLineToolsAndStudyStubs.clear(), e.forEach((e => {
						const t = e.dataSources().filter(gi).map((e => [e.id(), e.linkKey().value()])),
							i = new Map(t);
						this._allLineToolsAndStudyStubs.set(e.id(), i)
					}))
				}
				_processPropertiesChanged(e, t) {
					gi(t) && this._invalidateLineToolOrStudyStub(t.id(), performance.now())
				}
				_processLineToolsGroupModelChanged(e, t) {
					const i = performance.now();
					this._invalidateLineToolGroup(e, i), t && (t.affectedLineTools || []).forEach((e => this._invalidateLineToolOrStudyStub(e, i)))
				}
				_processPanesCollectionChanged(e) {
					const t = e.map((e => e.id())),
						i = new Set(t),
						o = performance.now();
					Array.from(this._allLineToolsAndStudyStubs.keys()).filter((e => !i.has(e))).forEach((e => {
						Array.from((0, s.ensureDefined)(this._allLineToolsAndStudyStubs.get(e)).keys()).forEach((e => {
							this._invalidateLineToolOrStudyStub(e, o)
						}))
					})), e.filter((e => !this._allLineToolsAndStudyStubs.has(e.id()))).forEach((e => {
						e.dataSources().filter(gi).forEach((e => this._invalidateLineToolOrStudyStub(e.id(), o)))
					})), this._assignAllLineTools(e)
				}
				_processDataSourceCollectionChanged(e) {
					const t = e.dataSources().filter(gi),
						i = t.map((e => [e.id(), e.linkKey().value()])),
						o = new Map(i),
						r = performance.now();
					if (this._allLineToolsAndStudyStubs.has(e.id())) {
						const i = (0, s.ensureDefined)(this._allLineToolsAndStudyStubs.get(e.id()));
						t.filter((e => !i.has(e.id()))).forEach((e => this._invalidateLineToolOrStudyStub(e.id(), r))), Array.from(i.entries()).filter((e => !o.has(e[0]))).forEach((e => {
							null !== e[1] && this._debouncedSave(), this._invalidateLineToolOrStudyStub(e[0], r)
						}))
					} else t.forEach((e => this._invalidateLineToolOrStudyStub(e.id(), r)));
					this._allLineToolsAndStudyStubs.set(e.id(), o)
				}
				_unloadLineTools(e, t, i) {
					const o = e.filter((e => !this._invalidatedLineToolsAndStudyStubs.has(e))).map((e => this._chartModel.dataSourceForId(e))).filter(g.isLineTool).filter(_.notNull).filter((e => e.sharingMode().value() === i)).filter(t).filter((e => {
						const t = this._chartModel.lineToolsGroupModel().groupForLineTool(e);
						return null === t || !this._invalidatedLineToolGroups.has(t.id)
					}));
					this._withoutInvalidating((() => {
						o.forEach((e => {
							var t;
							e.hasAlert.value() && e.detachAlert();
							const i = (0, s.ensureNotNull)(this._chartModel.paneForSource(e));
							this._chartModel.removeSource(e);
							(null !== (t = this._allLineToolsAndStudyStubs.get(i.id())) && void 0 !== t ? t : new Map).delete(e.id())
						})), this._chartModel.lineToolsGroupModel().removeLineTools(o)
					}))
				}
				_unloadLinesOnSeries(e, t) {
					const i = this._chartModel.mainSeries(),
						o = (0, s.ensureNotNull)(this._chartModel.paneForSource(i)),
						r = this._allLineToolsAndStudyStubs.get(o.id());
					if (!(null == r ? void 0 : r.size)) return;
					const n = Array.from(r.keys()).filter((t => !e(t)));
					this._unloadLineTools(n, (e => e.boundToSymbol() && e.ownerSource() === i), t)
				}
				_isAutosaveEnabled() {
					return Boolean(this._saveChartService && this._saveChartService.autoSaveEnabled().value())
				}
				async _saveInvalidatedIfRequired(e, t) {
					if (null !== this._lastBanTime) {
						if (!(performance.now() - this._lastBanTime >= 3e5)) return Promise.resolve();
						this._lastBanTime = null
					}
					if (!this._isAutosaveEnabled() && !t || this._readOnlyMode || !window.is_authenticated) return;
					const i = this.prepareDTO(e);
					return this._sharingModesToUse().reduce(((e, t) => e.then((() => {
						const e = i.get(t);
						if (!e) return;
						if (0 === e.sources.size && 0 === e.groups.size) return;
						const o = performance.now();
						return this._applyToolsAndGroupsDTOToNonDeserializedCharts(e, t), (0, s.ensureNotNull)(this._saveChartService).saveChartLineTools(this._chartId, e, t).then((() => {
							this.resetInvalidated(o, e, t)
						})).catch((e => {
							throw e instanceof ei.SavingLineToolsError && e.shouldBeCooled && (this._lastBanTime = performance.now()), e
						}))
					}))), Promise.resolve())
				}
				async _savePromise(e, t) {
					var i, s;
					return this._savingImmediatellyEnabled.value() && this._isAutosaveEnabled() ? null !== (s = null === (i = this._debouncedSave) || void 0 === i ? void 0 : i.flush()) && void 0 !== s ? s : Promise.resolve() : this._saveInvalidatedIfRequired(e, t)
				}
				_seriesLineToolsUnloader(e, t) {
					const i = this._chartModel.mainSeries();
					this._removeFromContent.value() && "mainSeriesLineTools" === e.requestType && i.symbolSameAsCurrent(e.symbol) && (this._unloadLinesOnSeries(t, e.sharingMode), this._currentlyLoadedSymbol.set(e.sharingMode, e.symbol))
				}
				_onSymbolResolved(e) {
					if (this._loadWithoutSymbolResolving.value()) return;
					const t = this._sharingModesToUse().map((t => {
						const i = {
							requestType: "mainSeriesLineTools",
							seriesSourceId: this._chartModel.mainSeries().id(),
							symbol: e.pro_name,
							brokerName: "",
							sharingMode: t
						};
						return this._makeLoadRequestAndMerge(i, this._seriesLineToolsUnloader.bind(this, i))
					}));
					this._saveSharedLineTools.value() && Promise.all(t).then((() => {
						this._chartModel.dataSources().filter(g.isLineTool).filter((e => 0 === e.sharingMode().value() && e.linkKey().value())).forEach((e => e.share(1)))
					}))
				}
				_onSeriesRestarted() {
					if (!this._loadWithoutSymbolResolving.value()) return;
					const e = e => ({
						requestType: "mainSeriesLineTools",
						seriesSourceId: this._chartModel.mainSeries().id(),
						symbol: this._chartModel.mainSeries().properties().childs().symbol.value(),
						brokerName: this._brokerIdSession.value() ? this._brokerName : "",
						sharingMode: e
					});
					this._savePromise(!0).catch((() => {})).then((async () => {
						if (this._doNotSaveSharedLineToolsToCharts.value()) this._sharingModesToUse().forEach((t => {
							const i = e(t);
							this._makeLoadRequestAndMerge(i, this._seriesLineToolsUnloader.bind(this, i))
						}));
						else {
							const t = e(0);
							await this._makeLoadRequestAndMerge(t, this._seriesLineToolsUnloader.bind(this, t)), this._sharingModesToUse().filter((e => 0 !== e)).forEach((t => {
								const i = e(t);
								this._makeLoadRequestAndMerge(i, this._seriesLineToolsUnloader.bind(this, i))
							}))
						}
					}))
				}
				async _makeLoadRequestAndMerge(e, t) {
					var i;
					const s = this._chartModel.mainSeries(),
						o = null !== (i = this._currentlyLoadedSymbol.get(e.sharingMode)) && void 0 !== i ? i : "";
					if (!!s.symbolSameAsCurrent(o)) return;
					const r = (0, ti.getChartStorage)();
					this._savePromise("mainSeriesLineTools" === e.requestType).catch((() => {})).then((() => async function(e, t, i, s) {
						const o = async () => e.loadLineToolsAndGroups(t, i, s);
						return o().catch((() => hi.value() ? null : (0, li.retriesWithDelays)((async () => (await (0, ai.waitForOnline)(), o())), ci)))
					}(r, this._layoutId, this._chartId, e))).then((i => {
						null !== i && (t((e => i.sources.has(e))), this._applyLineToolsAndGroupsDTO(i, e.sharingMode), i.serverRequestId && console.log(`PROCESSED:${i.serverRequestId}`))
					}))
				}
				_restoreGroups(e, t) {
					const i = new Map;
					return (t.groups || new Map).forEach(((t, o) => {
						const r = this._chartModel.lineToolsGroupModel().groupForId(o);
						if (null === t) null !== r && new ri.ExcludeLineToolsFromGroupUndoCommand(this._chartModel, r, r.lineTools()).redo();
						else if (r && t.serverUpdateTime) {
							const i = (0, s.ensureDefined)(t.serverUpdateTime);
							if (null !== e && e >= i) return;
							r.setName(t.name)
						} else i.set(o, t)
					})), i
				}
				_createNewLineTool(e) {
					const t = this._chartModel.dataSourceForId(e.ownerSource);
					if (null === t) return null;
					const i = (0, s.ensureNotNull)(this._chartModel.paneForSource(t)),
						o = this._chartModel.panes().indexOf(i),
						r = this._chartModel.restoreSource(!1, o, null, e.state, null);
					if (null !== r) {
						const e = this._allLineToolsAndStudyStubs.get(i.id()) || new Map;
						e.set(r.id(), r.linkKey().value()), this._allLineToolsAndStudyStubs.set(i.id(), e)
					}
					return r
				}
				_migrateStateFromMetainfo(e) {
					const t = void 0 !== e.symbol && e.symbol !== e.state.state.symbol;
					t && (e.state.state.symbol = e.symbol);
					const i = void 0 !== e.currencyId && e.currencyId !== e.state.state.currencyId;
					i && (e.state.state.currencyId = e.currencyId);
					const s = void 0 !== e.unitId && e.unitId !== e.state.state.unitId;
					return s && (e.state.state.unitId = e.unitId), t || i || s
				}
				_restoreLineTool(e, t, i) {
					var s;
					if ((null !== (s = t.state.points) && void 0 !== s ? s : []).some((e => !(0, _.isNumber)(e.time_t)))) return null;
					let o = this._chartModel.dataSourceForId(t.id);
					if (null === o && t.state.linkKey && (o = (0, g.lineToolByLinkKey)(this._chartModel, t.state.linkKey)), null !== o && !(0, g.isLineTool)(o)) return null;
					if (o && t.serverUpdateTime) {
						const s = t.serverUpdateTime,
							r = o.serverUpdateTime();
						if (null !== e && e >= s || null !== r && r >= s) return this._saveSharedLineTools.value() && 0 !== i && (o.share(i), this._originalLineToolSharingMode.set(o.id(), i)), null;
						this._chartModel.restoreLineToolState(o, t.state, !1), o.calcIsActualSymbol()
					}
					0 !== i && (t.ownerSource = this._chartModel.mainSeries().id(), t.state.ownerSource = this._chartModel.mainSeries().id());
					this._migrateStateFromMetainfo(t) && this._invalidateLineToolOrStudyStub(t.id, performance.now(), !0);
					const r = o || this._createNewLineTool(t);
					return r && (t.serverUpdateTime && r.setServerUpdateTime(t.serverUpdateTime), t.state.alertId ? r.setAlert(t.state.alertId, {
						noChartSave: !0
					}) : r.detachAlert(), 0 !== i && r.share(i)), r
				}
				_removeLineTool(e) {
					const t = this._chartModel.dataSourceForId(e);
					null !== t && new oi.RemoveSourcesCommand(this._chartModel, [t], null).redo()
				}
				_restoreLineDTO(e, t, i, o, r) {
					if (!this._invalidatedLineToolsAndStudyStubs.has(t))
						if (null === e) {
							const e = this._chartModel.dataSourceForId(t);
							if (!e) return;
							if (!(0, g.isLineTool)(e)) return;
							e.sharingMode().value() === r && (0 !== r && (e.share(0), this._invalidateLineToolOrStudyStub(t, performance.now(), !0)), this._removeLineTool(t), this._originalLineToolSharingMode.delete(t))
						} else {
							const n = this._restoreLineTool(o, e, r);
							if (n) {
								if (e.groupId) {
									const t = this._chartModel.lineToolsGroupModel().groupForLineTool(n),
										o = this._chartModel.lineToolsGroupModel().groupForId(e.groupId);
									if (null !== t && o === t) return;
									if (null !== t && (t.excludeLineTool(n), 0 === t.lineTools().length && this._chartModel.lineToolsGroupModel().removeGroup(t)), o && !o.containsLineTool(n)) o.addLineTools([n]);
									else if (!o && i.has(e.groupId)) {
										const t = (0, s.ensureDefined)(i.get(e.groupId));
										this._chartModel.lineToolsGroupModel().createGroup([n], t.name, t.id)
									}
								} else this._chartModel.lineToolsGroupModel().removeLineTools([n]);
								this._originalLineToolSharingMode.set(t, r)
							}
						}
				}
				_applyLineToolsAndGroupsDTO(e, t) {
					const i = this._chartModel.chartSaveTime(),
						s = this._withoutInvalidating((() => this._restoreGroups(i, e))),
						o = `ChartStorage.Synchronizer.ApplyingDTO.${`${this._layoutId}.${this._chartId}`}`;
					(0, Jt.perfMeasureOperation)(o, (() => this._withoutInvalidating((() => {
						(e.sources || new Map).forEach(((e, o) => {
							try {
								this._restoreLineDTO(e, o, s, i, t)
							} catch (e) {
								ui.logError(`Error restoring line tool ${o}: ${e}`)
							}
						})), (e.groups || new Map).forEach(((e, t) => {
							this._invalidatedLineToolGroups.delete(t)
						})), this._recalculateHasChanges()
					}))))
				}
				_withoutInvalidating(e) {
					try {
						return this._ignoreInvalidatingEventsDepth++, e()
					} finally {
						this._ignoreInvalidatingEventsDepth--
					}
				}
				_invalidateLineToolOrStudyStub(e, t, i) {
					var s;
					if (this._ignoreInvalidatingEventsDepth > 0 && !i) return;
					const o = null === (s = this._invalidatedLineToolsAndStudyStubs.get(e)) || void 0 === s ? void 0 : s.invaildatedViaSyncOnly,
						r = (void 0 === o || o) && this._invalidateViaSync;
					this._invalidatedLineToolsAndStudyStubs.set(e, {
						timestamp: t,
						invaildatedViaSyncOnly: r
					}), this._hasChanges.setValue(!0), this._savingImmediatellyEnabled.value() && this._debouncedSave()
				}
				_invalidateLineToolGroup(e, t) {
					this._ignoreInvalidatingEventsDepth > 0 || (this._invalidatedLineToolGroups.set(e, {
						timestamp: t,
						invaildatedViaSyncOnly: this._invalidateViaSync
					}), this._hasChanges.setValue(!0), this._savingImmediatellyEnabled.value() && this._debouncedSave())
				}
				_prepareDTOItem(e, t) {
					const i = new Map,
						o = new Map;
					return this._invalidatedLineToolsAndStudyStubs.forEach(((r, n) => {
						if (0 !== t && r.invaildatedViaSyncOnly) return;
						const a = this._chartModel.dataSourceForId(n);
						if (!(0, di.isStudyLineToolStub)(a))
							if (null === a) {
								(this._originalLineToolSharingMode.get(n) === t || 0 === t && !this._doNotSaveSharedLineToolsToCharts.value()) && i.set(n, null)
							} else {
								if (a === this._chartModel.lineBeingCreated() || a === this._chartModel.lineBeingEdited() || !a.isSavedInChart()) return;
								const r = a.ownerSource() === this._chartModel.mainSeries(),
									l = !e || r,
									c = a.sharingMode().value() === t || 0 === t && !this._doNotSaveSharedLineToolsToCharts.value();
								if (l) {
									const e = this._chartModel.lineToolsGroupModel().groupForLineTool(a);
									if (c) i.set(n, function(e, t) {
										const i = t.lineToolsGroupModel().groupForLineTool(e),
											o = {
												id: e.id(),
												ownerSource: (0, s.ensureNotNull)(e.ownerSource()).id(),
												state: e.state(!1)
											};
										return e.boundToSymbol() && (o.symbol = e.symbol()), o.currencyId = e.properties().childs().currencyId.value(), o.unitId = e.properties().childs().unitId.value(), null !== i && (o.groupId = i.id), o
									}(a, this._chartModel)), null !== e && o.set(e.id, _i(e, this._chartModel));
									else {
										const s = this._originalLineToolSharingMode.get(n);
										s === t && i.set(n, null), null !== e && s === t && o.set(e.id, null)
									}
								}
							}
					})), this._invalidatedLineToolGroups.forEach(((e, i) => {
						if (!o.has(i)) {
							const e = this._chartModel.lineToolsGroupModel().groupForId(i);
							if (null === e) o.set(i, null);
							else {
								(e.sharingMode().value() === t || 0 === t && !this._doNotSaveSharedLineToolsToCharts.value()) && o.set(i, _i(e, this._chartModel))
							}
						}
					})), {
						sources: i,
						groups: o,
						clientId: this._clientId
					}
				}
				_sharingModesToUse() {
					return this._saveSharedLineTools.value() ? [0, 1, 2] : [0]
				}
				_loadAndMergeLineToolsOnStudies(e, t) {
					const i = {
							requestType: "studiesLineTools",
							seriesSourceId: this._chartModel.mainSeries().id(),
							sharingMode: e
						},
						s = this._chartModel.mainSeries();
					this._makeLoadRequestAndMerge(i, (i => {
						const o = t ? (0, Qt.default)(Array.from(this._allLineToolsAndStudyStubs.values()).map((e => Array.from(e.keys())))).filter((e => !i(e))) : [];
						this._unloadLineTools(o, (e => e.ownerSource() !== s), e)
					}))
				}
				_loadAndMergeLineToolsWithoutSymbol(e, t) {
					const i = {
							requestType: "lineToolsWithoutSymbol",
							seriesSourceId: this._chartModel.mainSeries().id(),
							sharingMode: e
						},
						o = this._chartModel.mainSeries(),
						r = (0, s.ensureNotNull)(this._chartModel.paneForSource(o)),
						n = this._allLineToolsAndStudyStubs.get(r.id());
					this._makeLoadRequestAndMerge(i, (i => {
						const s = t && n ? Array.from(n.keys()).filter((e => !i(e))) : [];
						this._unloadLineTools(s, (e => !e.boundToSymbol() && e.ownerSource() === o), e)
					}))
				}
				_recalculateHasChanges() {
					this._hasChanges.setValue(this._invalidatedLineToolsAndStudyStubs.size > 0 || this._invalidatedLineToolGroups.size > 0)
				}
				_applyToolsAndGroupsDTOToNonDeserializedCharts(e, t) {
					if (!this._doNotSaveSharedLineToolsToCharts.value() && 0 === t && this._duplicateOperationsForSerializedCharts() && this._deserializedChartsIds().length > 0) {
						const t = new Map;
						for (const [i, s] of e.sources) null !== s && "_seriesId" === s.ownerSource && 0 !== mi(this._originalLineToolSharingMode.get(i)) && 0 === mi(s.state.sharingMode) ? t.set(i, null) : (null === s && 0 !== mi(this._originalLineToolSharingMode.get(i)) || null !== s && "_seriesId" === s.ownerSource && 0 !== mi(s.state.sharingMode)) && t.set(i, s);
						if (t.size > 0) {
							const i = {
								groups: new Map,
								sources: t,
								clientId: e.clientId
							};
							for (const e of this._deserializedChartsIds())(0, s.ensureNotNull)(this._saveChartService).saveChartLineTools(e, i, 0).catch((e => {}))
						}
					}
				}
			}
			var vi = i(357547);
			class fi {
				constructor(e, t) {
					this._timerId = null, this._func = e, this._wait = t
				}
				spawm() {
					const e = (...e) => (this._lastArguments = e, null !== this._timerId && vi.workerBasedTimers.clearTimeout(this._timerId), this._timerId = vi.workerBasedTimers.setTimeout((() => this._callImpl()), this._wait), this._lastResult),
						t = e;
					return e.cancel = this._cancel.bind(this), e.flush = this._flush.bind(this), t
				}
				_callImpl() {
					this._lastResult = this._flush()
				}
				_flush() {
					if (this._lastArguments) return this._func(this._lastArguments)
				}
				_cancel() {
					null !== this._timerId && vi.workerBasedTimers.clearTimeout(this._timerId), this._lastArguments = void 0
				}
			}

			function bi(e, t) {
				return new fi(e, t).spawm()
			}
			class yi extends(Ke()) {
				constructor(e, t, i, s) {
					super(), this._base = e, this._base.subscribe(this._onValue.bind(this)), this._debouncedSetter = t(this.setValue.bind(this), i), this._debounceFilter = s, this.setValue(this._base.value())
				}
				_onValue(e) {
					this._debounceFilter(e) ? this._debouncedSetter(e) : (this._debouncedSetter.cancel(), this.setValue(e))
				}
			}
			var Ci = i(125226),
				wi = i(405117),
				Ti = i(552279),
				Pi = i(490901),
				Mi = i(281967),
				xi = i(786559);
			const Ii = (0, o.t)("Why might my US stock data look different?");

			function Ai(e) {
				if ("replaced_to_exchange" === e.type) return {
					text: Ii,
					warningIcon: xi,
					warningType: "notaccurate",
					solutionId: Pi.solutionIds.WHAT_IS_CBOE_BZX_EXCHANGE
				}
			}
			class ki {
				constructor(e) {
					this._activeHint = null, this._deferredPromise = null, this._chart = e;
					e.model().mainSeries().dataEvents().symbolResolved().subscribe(this, this._onSymbolResolved)
				}
				destroy() {
					this._destroyActiveHint();
					this._chart.model().mainSeries().dataEvents().symbolResolved().unsubscribe(this, this._onSymbolResolved)
				}
				_destroyActiveHint() {
					null !== this._activeHint && (this._activeHint.destroy(), this._activeHint = null), this._deferredPromise = null
				}
				async _createHint() {
					if (null === this._deferredPromise) {
						const e = (0, c.createDeferredPromise)();
						this._deferredPromise = e, Promise.all([i.e(99740), i.e(18867), i.e(5244), i.e(75514), i.e(83129)]).then(i.bind(i, 629981)).then((t => {
							e.resolve(new t.ChartWarningHintRenderer(this._chart))
						}))
					}
					return this._deferredPromise.promise
				}
				_onSymbolResolved(e) {
					const t = function(e) {
							const t = (0, Mi.firstReplacedByBatsExchange)(e);
							return null !== t ? {
								type: "replaced_to_exchange",
								exchange: t
							} : null
						}(e),
						i = t && function(e) {
							return `warning.noSubsc_${e.exchange}`
						}(t);
					if (null === t || null === i || Boolean(a.getBool(i))) return void this._destroyActiveHint();
					const s = {
						...Ai(t),
						onClose: () => {
							a.setValue(i, !0, {
								forceFlush: !0
							}), this._destroyActiveHint()
						}
					};
					null !== this._activeHint ? this._activeHint.show(s) : this._createHint().then((e => {
						this._activeHint = e, this._activeHint.show(s)
					}))
				}
			}
			var Li = i(733255),
				Ei = i(983019),
				Di = (i(897116), i(553275));
			const Ni = (0, o.t)("This symbol is only available on {linkStart}TradingView{linkEnd}.");
			class Bi {
				constructor(e) {
					this._lastResolvedSymbol = null, this._chart = e, this._chart.withModel(this, this._connectToModel)
				}
				show() {
					const e = this._getSymbol(),
						t = this._chart.defaultSymbol(),
						[i, s] = e.split(":"),
						o = "https://www.tradingview.com{0}?utm_source=www.tradingview.com&utm_medium=widget&utm_campaign=chart&utm_term={2}:{1}".format((0, Di.getSymbolPagePath)({
							proName: this._getProSymbol()
						}), s, i);
					(0, Li.createNoticeDialog)({
						content: Ni.format({
							linkStart: `<a target="_blank" href="${o}">`,
							linkEnd: "</a>"
						})
					}).then((i => {
						i.on("destroy", (() => {
							let i;
							i = this._lastResolvedSymbol ? this._lastResolvedSymbol : t !== e ? t : "AAPL", this._chart.setSymbol(i)
						})), i.open()
					}))
				}
				_getProSymbol() {
					return this._chart.model().mainSeries().proSymbol()
				}
				_getSymbol() {
					return this._chart.model().mainSeries().actualSymbol()
				}
				_connectToModel() {
					const e = this._chart.model().mainSeries();
					e.dataEvents().symbolResolved().subscribe(this, this._onSymbolResolved), e.dataEvents().symbolGroupNotPermitted().subscribe(this, this._onSymbolGroupNotPermitted), e.dataEvents().symbolNotPermitted().subscribe(this, this.show)
				}
				_onSymbolResolved() {
					this._lastResolvedSymbol = this._getSymbol()
				}
				_onSymbolGroupNotPermitted() {
					this.show()
				}
			}
			var Oi = i(749473),
				Ri = i(364019);
			class Vi {
				constructor() {
					this._draggingSource = null, this._activeTouchPanes = new Set, this._scrollingPane = null, this._pinchingPane = null
				}
				onPaneDestroyed(e) {
					this._activeTouchPanes.delete(e), this._scrollingPane === e && (this._scrollingPane = null), this._pinchingPane === e && (this._pinchingPane = null)
				}
				startTouch(e) {
					this._activeTouchPanes.add(e)
				}
				endTouch(e) {
					this._activeTouchPanes.delete(e)
				}
				hasTouchesOnOtherPanes(e) {
					return this._activeTouchPanes.size > 1 || 1 === this._activeTouchPanes.size && !this._activeTouchPanes.has(e)
				}
				trySetDraggingSource(e, t) {
					return !this.hasTouchesOnOtherPanes(t) && ((0, s.assert)(null === this._draggingSource || this._draggingSource === e), this._draggingSource = e, !0)
				}
				clearDraggingSource() {
					null !== this._draggingSource && (this._draggingSource = null)
				}
				draggingSource() {
					return this._draggingSource
				}
				setScrollingPane(e) {
					(0, s.assert)(null === e || null === this._scrollingPane || this._scrollingPane === e), this._scrollingPane = e
				}
				scrollingPane() {
					return this._scrollingPane
				}
				setPinchingPane(e) {
					(0, s.assert)(null === e || null === this._pinchingPane || this._pinchingPane === e), this._pinchingPane = e
				}
				pinchingPane() {
					return this._pinchingPane
				}
			}
			let Wi = null;

			function Fi(e, t, s, o, r) {
				return Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(78941), i.e(91670), i.e(53221), i.e(63280), i.e(21834), i.e(95468), i.e(80580), i.e(67161), i.e(68074), i.e(52498), i.e(34640), i.e(9935), i.e(82739), i.e(29331), i.e(94430), i.e(44155), i.e(63146), i.e(5799), i.e(24817), i.e(50522), i.e(32151), i.e(52019), i.e(24384), i.e(55706), i.e(35015), i.e(2036), i.e(29499), i.e(61153), i.e(74733), i.e(77542), i.e(50991), i.e(4171), i.e(40731), i.e(86193), i.e(92617), i.e(92716), i.e(93683), i.e(69727), i.e(97430), i.e(45410), i.e(74499), i.e(60990), i.e(82290), i.e(83230), i.e(38489), i.e(43671), i.e(24327), i.e(44072), i.e(59171), i.e(14558), i.e(99738), i.e(20201), i.e(35592), i.e(8946), i.e(75514), i.e(93921), i.e(69397), i.e(29594), i.e(79049), i.e(35189), i.e(88067), i.e(68985), i.e(46e3), i.e(95106), i.e(21114), i.e(81868), i.e(81880), i.e(7835), i.e(41831), i.e(67425), i.e(46265)]).then(i.bind(i, 846932)).then((i => {
					const n = new(0, i.EditObjectDialogRenderer)(e, t, o, r);
					return n.show(s), n
				}))
			}
			let zi = null;
			var Ui = i(525056);
			const Hi = {
					[it.TabNames.symbol]: "symbol",
					[it.TabNames.legend]: "legend",
					[it.TabNames.scales]: "scales",
					[it.TabNames.trading]: "trading",
					[it.TabNames.events]: "events",
					[it.TabNames.timezoneSessions]: "appearance",
					[it.TabNames.text]: "text",
					[it.TabNames.style]: "style",
					[it.TabNames.visibility]: "visibility"
				},
				Gi = {
					[it.TabNames.style]: "style",
					[it.TabNames.visibility]: "visibilities"
				};
			async function ji(e, t, s = {}, o, r) {
				const n = o.activeChartWidget.value(),
					{
						initialTab: a,
						tabName: l
					} = s;
				if (l && !a && (s.initialTab = Gi[l]), (0, g.isStudyLineTool)(e) && function(e) {
						return [Ui.LineToolVbPFixed].some((t => e instanceof t))
					}(e)) return n.propertiesDefinitionsForSource(e).then((i => null !== i ? Fi(e, t, s, r, i) : null));
				if ((0, S.isStudy)(e) && function(e) {
						const {
							shortId: t
						} = e.metaInfo();
						return "Overlay" === t
					}(e) || (0, g.isLineTool)(e)) return n.propertiesDefinitionsForSource(e).then((s => {
					if (null !== s) {
						return function(e) {
							return Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(78941), i.e(91670), i.e(53221), i.e(63280), i.e(21834), i.e(95468), i.e(80580), i.e(67161), i.e(68074), i.e(52498), i.e(34640), i.e(9935), i.e(82739), i.e(29331), i.e(94430), i.e(44155), i.e(63146), i.e(5799), i.e(50522), i.e(32151), i.e(52019), i.e(24384), i.e(55706), i.e(35015), i.e(2036), i.e(29499), i.e(61153), i.e(74733), i.e(77542), i.e(50991), i.e(4171), i.e(40731), i.e(92617), i.e(92716), i.e(93683), i.e(69727), i.e(97430), i.e(45410), i.e(74499), i.e(60990), i.e(82290), i.e(83230), i.e(38489), i.e(43671), i.e(24327), i.e(44072), i.e(59171), i.e(14558), i.e(99738), i.e(20201), i.e(35592), i.e(4002), i.e(75514), i.e(93921), i.e(69397), i.e(29594), i.e(79049), i.e(35189), i.e(88067), i.e(68985), i.e(46e3), i.e(95106), i.e(21114), i.e(81868), i.e(81880), i.e(7835), i.e(41831), i.e(67425), i.e(46780)]).then(i.bind(i, 757381)).then((t => {
								const i = new(0, t.SourcePropertiesEditorRenderer)(e);
								return null !== zi && zi.hide(), i.show(), zi = i, i
							}))
						}({
							propertyPages: s,
							model: t,
							source: e,
							activePageId: l && Hi[l]
						})
					}
					return null
				}));
				if ((0, S.isStudy)(e) && !(0, S.isESDOrRollDatesStudy)(e)) return Fi(e, t, s, r); {
					const t = (0, S.isESDOrRollDatesStudy)(e) ? "events" : l && Hi[l],
						i = o.getChartPropertiesDialogRenderer();
					return i.setActivePage(t), i.show()
				}
			}
			var qi = i(888667),
				Ki = i(560420),
				Yi = i(492747),
				Xi = i(908803);
			class Zi {
				constructor(e, t) {
					this._showed = !1, this._cw = e, this._element = document.createElement("div"), this._element.classList.add("chart-loading-screen"), this._shield = document.createElement("div"), this._shield.classList.add("chart-loading-screen-shield"), this._element.appendChild(this._shield), t.appendChild(this._element), this._cw.withModel(this, this._connectToModel)
				}
				show() {
					this._cw.setInLoadingState(!0), this._showed || (this._showed = !0, this._show())
				}
				hide() {
					this._cw.setInLoadingState(!1), this._showed && this._hide()
				}
				isShown() {
					return this._showed
				}
				_connectToModel() {
					const e = this._cw.model().mainSeries().dataEvents();
					e.symbolError().subscribe(this, (e => {
						e !== Xi.permissionDenied && this.hide()
					})), e.seriesError().subscribe(this, (() => {
						(0, Te.enabled)("hide_loading_screen_on_series_error") && this.hide()
					})), e.completed().subscribe(this, this.hide)
				}
				_show() {
					const e = this._cw.properties().childs().paneProperties.childs();
					let t;
					if (e.backgroundType.value() === Yi.ColorType.Solid) t = e.background.value();
					else {
						t = `linear-gradient(${e.backgroundGradientStartColor.value()},${e.backgroundGradientEndColor.value()})`
					}
					this._shield.style.background = t, this._element.classList.add("fade")
				}
				_hide() {
					this._showed = !1, this._element.classList.remove("fade")
				}
			}
			var $i = i(377884),
				Qi = i(669415),
				Ji = i(214729);
			const es = (0, w.getHexColorByName)("color-cold-gray-700"),
				ts = (0, w.getHexColorByName)("color-cold-gray-400");
			class is {
				constructor(e) {
					this._container = null, this._errorCardRenderer = null, this._mainSeriesErrorMessage = null, this._banErrorMessage = null, this._errorMessageHandler = e => {
						this._chartWidget.hasModel() ? this._updatePaneWidgets(e) : this._renderErrorWithoutModel(e)
					}, this._chartWidget = e, this._subscribeToMainSeriesErrors()
				}
				destroy() {
					var e, t, i;
					null === (e = this._mainSeriesErrorMessage) || void 0 === e || e.destroy(), null === (t = this._banErrorMessage) || void 0 === t || t.destroy(), null === (i = this._errorCardRenderer) || void 0 === i || i.then((e => {
						e.container.remove(), e.destroy()
					}))
				}
				updatePaneWidgets() {
					this._updatePaneWidgets()
				}
				setContainer(e) {
					var t;
					if (this._container !== e) {
						this._container = e, null === (t = this._errorCardRenderer) || void 0 === t || t.then((e => e.container.remove()));
						const i = this._getErrorMessage();
						i && this._errorMessageHandler(i)
					}
				}
				_updatePaneWidgets(e = this._getErrorMessage()) {
					this._chartWidget.paneWidgets().forEach((t => t.setErrorMessage(e)))
				}
				async _renderErrorWithoutModel(e) {
					if (null === this._container || null === e && null === this._errorCardRenderer) return;
					const t = await this._getErrorCardRenderer();
					this._container.contains(t.container) || this._container.appendChild(t.container), t.update(this._createErrorCardRendererState(e))
				}
				async _getErrorCardRenderer() {
					return this._errorCardRenderer || (this._errorCardRenderer = this._createErrorCardRenderer())
				}
				async _createErrorCardRenderer() {
					return new(await rt())
				}
				_createErrorCardRendererState(e) {
					return e ? {
						message: e.message,
						icon: e.icon,
						textColor: ne.watchedTheme.value() === ae.StdTheme.Dark ? ts : es,
						backgroundColor: ne.watchedTheme.value() === ae.StdTheme.Dark ? "#131722" : "#FFF"
					} : {
						message: null
					}
				}
				_subscribeToMainSeriesErrors() {
					const e = this._chartWidget;
					this._banErrorMessage = (0, m.combine)((e => {
						if (!e) return null;
						let t;
						if ("banned by ip" === e.reason) t = (0, o.t)("We noticed some suspicious activity from your IP address, so we've had to suspend it. To resolve this, please sign into your account.");
						else t = (0, o.t)("We noticed some suspicious activity on your account, so we've had to ban it.");
						return {
							message: t,
							icon: "stop-hand"
						}
					}), window.ChartApiInstance.connectionBanInfo()), this._banErrorMessage.subscribe(this._errorMessageHandler, {
						callWithLast: !0
					}), e.withModel(this, (() => {
						const t = e.model().model().mainSeries();
						this._mainSeriesErrorMessage = (0, m.combine)(((t, i, s) => {
							if (t) return t;
							let r;
							switch (i) {
								case 4: {
									const t = e.model().model().mainSeries().seriesErrorMessage();
									null !== t && ("resolution_not_entitled" === t || "custom_resolution" === t || "seconds_not_entitled" === t || t.startsWith("study_not_auth:")) || (r = (0, o.t)("Invalid symbol"));
									break
								}
								case 1:
								case 2:
									break;
								default:
									s && (r = (0, o.t)("No data here"))
							}
							return r ? {
								message: r,
								icon: "ghost"
							} : null
						}), this._banErrorMessage || new(Ke())(null).readonly(), (0, Ji.createWVFromGetterAndSubscription)((() => t.status()), t.onStatusChanged()), (0, Ji.createWVFromGetterAndSubscription)((() => !t.bars().size()), t.dataEvents().dataUpdated()), (0, Ji.createWVFromGetterAndSubscription)((() => ({})), e.model().model().onChartThemeLoaded())), this._mainSeriesErrorMessage.subscribe(this._errorMessageHandler, {
							callWithLast: !0
						})
					}))
				}
				_getErrorMessage() {
					var e, t;
					return (null === (e = this._banErrorMessage) || void 0 === e ? void 0 : e.value()) || (null === (t = this._mainSeriesErrorMessage) || void 0 === t ? void 0 : t.value()) || null
				}
			}
			const ss = (0, Te.enabled)("chart_content_overrides_by_defaults"),
				os = (0, r.getLogger)("ChartWidget", {
					color: "#606"
				}),
				rs = new T.TranslatedString("hide {title}", (0, o.t)("hide {title}"));
			let ns = null;
			if (location.search.toLowerCase().includes("logcanvassaverestoreleaks")) {
				if (!l.isChrome) throw new Error("CanvasRenderingContext2D save/restore leak detection is available for now in Chrome only");
				i.e(15803).then(i.bind(i, 392847)).then((e => {
					e.enableCanvasRenderingContext2DSaveRestoreLeaksDetection(), ns = e.reportCanvasRenderingContext2DSaveRestoreLeaks
				}))
			}
			const as = {
				addToWatchlistEnabled: !0,
				showFinancialsEnabled: !1,
				sourceSelectionEnabled: !0,
				propertyPagesEnabled: !0,
				paneContextMenuEnabled: !0,
				priceScaleContextMenuEnabled: !0,
				currencyConversionEnabled: !1,
				unitConversionEnabled: !1,
				goToDateEnabled: !1,
				marketStatusWidgetEnabled: !0,
				chartWarningWidgetEnabled: !0,
				dataProblemWidgetEnabled: !0,
				paneControlsEnabled: !0,
				isSymbolAvailable: e => Promise.resolve(!0),
				legendWidgetEnabled: !0,
				chartEventsEnabled: !0,
				esdEnabled: !1,
				croppedTickMarks: !0,
				countdownEnabled: !0,
				lastPriceAnimationEnabled: !0,
				useKineticScroll: l.CheckMobile.any(),
				indicatorsDialogShortcutEnabled: !0,
				handleScale: {
					mouseWheel: !0,
					pinch: !0,
					axisPressedMouseMove: {
						time: !0,
						price: !0
					}
				},
				handleScroll: {
					mouseWheel: !0,
					pressedMouseMove: !0,
					horzTouchDrag: !0,
					vertTouchDrag: !0
				}
			};

			function ls(e, t, i, s = 0) {
				const o = t.mainSeries().syncModel(),
					r = e.mainSeries().syncModel();
				let n = i;
				if (null !== o && null !== r) {
					const t = e.createSyncPoint(o.syncSourceTarget(), r.syncSourceTarget());
					0 !== s && (i = o.projectTime(i, s)), n = t.sourceTimeToTargetTime(i)
				}
				return e.timeScale().points().roughIndex(n, r && r.distance.bind(r))
			}
			class cs {
				constructor(e, t, i) {
					this.activePaneWidget = null, this._model = null, this._paneWidgets = [], this._maximizedPaneWidget = null, this._timeAxisWidget = null, this._paneSeparators = [], this._controlBarNavigation = null, this._lineToolsSynchronizer = null, this._modelCreated = new(K()), this._isDestroyed = !1, this._customLegendWidgetsFactoryMap = new Map, this._backgroundTopTheme = new(Ke())("light"), this._backgroundBasedTheme = new(Ke())("light"), this._backgroundBottomTheme = new(Ke())("light"), this._lhsAxesWidth = 0, this._rhsAxesWidth = 0, this._lhsPriceAxisWidthChanged = new(K()), this._rhsPriceAxisWidthChanged = new(K()), this._mainDiv = null, this._parent = null, this._elTooltipDiv = null, this._hotkeysListener = null, this._mouseWheelHelper = null, this._onWheelBound = null, this._justActivated = !1, this._inited = !1, this._containsData = !1, this._initialLoading = !1, this._defTimeframe = void 0, this._removeMaximizeHotkey = null, this._metaInfoRepository = null, this._invalidationMask = null, this._drawPlanned = !1, this._drawRafId = 0, this._inLoadingState = !1, this._timingsMeter = null, this._tagsChanged = new(K()), this._redraw = new(K()), this._isVisible = new(Ke())(!0), this._collapsed = new(Ke())(!1), this._dataWindowWidget = null, this._resizeHandler = null, this._spinner = null, this._keydownEventListener = null, this._properties = null, this._updateThemedColorBound = this._updateThemedColor.bind(this), this._saveChartService = null, this._objectTreeDialogController = null, this._chartPaintedPromise = null, this._noExchangeSubscrptionWarning = null, this._paneWidgetsSharedState = new Vi, this._brokerName = "", this._onZoom = new(K()), this._onScroll = new(K()), this._availableScreen = null, this._hoveredPriceAxes = new Set, this._anyAxisHovered = new(Ke())(!1),
						this._invalidationHandler = e => {
							if (!(e instanceof f.InvalidationMask)) throw new Error("Invalid mask");
							null !== this._invalidationMask ? this._invalidationMask.merge(e) : this._invalidationMask = e, this._drawPlanned || (this._drawPlanned = !0, this._options.visible.when((() => {
								const e = !document.hidden,
									t = this.screen && this.screen.isShown();
								null !== this._timingsMeter && e && !t && this._timingsMeter.startWaitingDraw();
								const i = (0, s.ensureNotNull)((0, s.ensureNotNull)(this._parent).ownerDocument.defaultView);
								this._drawRafId = i.requestAnimationFrame(this._invalidationRAFCallback.bind(this))
							})))
						}, this._subscribeToBanInfo = e => {
							var t, i;
							e ? null === (t = this._spinner) || void 0 === t || t.stop() : null === (i = this._spinner) || void 0 === i || i.spin()
						}, this._id = t, this._layoutId = i, this._options = (0, _.merge)((0, _.clone)(as), e), this._options.customLegendWidgetFactories && (this._customLegendWidgetsFactoryMap = this._options.customLegendWidgetFactories), this._subscribeToDrawingState(), this._chartWidgetCollection = this._options.chartWidgetCollection, this.withModel(this, (() => {
							const e = this.model().model();
							e.backgroundTopColor().subscribe(this._updateThemedColorBound), e.backgroundColor().subscribe(this._updateThemedColorBound)
						})), this._errorRenderer = new is(this), this._scrollHelper = new Zt(this), this._objectTreeDialogController = d.ObjectTreeDialogController.getInstance(), this._showChartEvents = Boolean(!this._options.containsData && this._options.chartEventsEnabled), this._properties = new v.DefaultProperty("chartproperties", void 0, void 0, this._options.useUserChartPreferences), this._properties.addExclusion("scalesProperties.axisHighlightColor"), this._properties.addExclusion("scalesProperties.axisLineToolLabelBackgroundColorActive"), this._properties.addExclusion("scalesProperties.axisLineToolLabelBackgroundColorCommon"), this._properties.addExclusion("scalesProperties.showPriceScaleCrosshairLabel"), this._properties.addExclusion("scalesProperties.showTimeScaleCrosshairLabel"), this._startSpinner(this._options.container.value()), window.ChartApiInstance.connectionBanInfo().subscribe(this._subscribeToBanInfo, {
							callWithLast: !0
						})
				}
				destroy() {
					var e, t;
					null === (e = this._lineToolsSynchronizer) || void 0 === e || e.destroy(), null === (t = this._noExchangeSubscrptionWarning) || void 0 === t || t.destroy(), window.loginStateChange.unsubscribe(this, this._handleLoginStateChanged), null !== this._model && (this._model.model().backgroundTopColor().unsubscribe(this._updateThemedColorBound), this._model.model().backgroundColor().unsubscribe(this._updateThemedColorBound), this._model.destroy()), window.ChartApiInstance.connectionBanInfo().unsubscribe(this._subscribeToBanInfo), this._customLegendWidgetsFactoryMap.clear(), this._scrollHelper.destroy(), this._errorRenderer.destroy(), this._isDestroyed = !0
				}
				lineToolsSynchronizer() {
					return this._lineToolsSynchronizer
				}
				model() {
					return (0, s.ensureNotNull)(this._model)
				}
				id() {
					return this._id
				}
				layoutId() {
					return this._layoutId
				}
				crossHairSyncEnabled() {
					return this._chartWidgetCollection.lock.crosshair.value()
				}
				isVisible() {
					return this._isVisible.value()
				}
				setVisible(e) {
					this._isVisible.setValue(e)
				}
				setCollapsed(e) {
					this._collapsed.setValue(e)
				}
				isJustClonedChart() {
					return !!(this._options || {}).justCloned
				}
				setSymbol(e) {
					this._model ? this._model.setSymbol(this._model.mainSeries(), e) : this.properties().childs().mainSeriesProperties.merge({
						symbol: e
					})
				}
				setResolution(e) {
					this._model ? this._model.setResolution(this._model.mainSeries(), e) : this.properties().childs().mainSeriesProperties.merge({
						interval: e
					})
				}
				async showGeneralChartProperties(e) {
					if (!Te.enabled("show_chart_property_page")) return Promise.resolve(null);
					const t = await this._showChartProperties(this.model().mainSeries(), e, {
						doNotCloseOnBgClick: !0,
						onResetToDefault: async () => {
							this.model().restorePreferences();
							const e = await i.e(83767).then(i.bind(i, 440135)),
								t = e.getCurrentTheme().name;
							e.loadTheme(this.chartWidgetCollection(), {
								themeName: t,
								standardTheme: !0
							})
						}
					});
					if (null === t) return null;
					const s = () => {
						t.hide(), this._chartWidgetCollection.activeChartWidget.unsubscribe(s)
					};
					return this._chartWidgetCollection.activeChartWidget.subscribe(s), t
				}
				async showChartPropertiesForSources(e) {
					if (!(0, Te.enabled)("property_pages")) return Promise.resolve(null);
					const {
						sources: t,
						title: r,
						tabName: n,
						renamable: a
					} = e, l = (0, s.ensureNotNull)(this._model), c = qt(t.map((e => e.properties().childs()))), h = qt(t.map((e => e.properties().childs().intervalsVisibilities))), [{
						createPropertyPage: d
					}, {
						getSelectionStylePropertiesDefinitions: u
					}, {
						getSelectionIntervalsVisibilitiesPropertiesDefinition: _
					}] = await Promise.all([Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 878764)), Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 11571)), Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 982794))]), m = [];
					return m.push(d(u(c, l), "Style", (0, o.t)("Style"))), m.push(d(_(h, l), "Visibility", (0, o.t)("Visibility"))), async function(e) {
						const {
							SourcesPropertiesEditorRenderer: t
						} = await Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(78941), i.e(91670), i.e(53221), i.e(63280), i.e(21834), i.e(95468), i.e(80580), i.e(67161), i.e(68074), i.e(52498), i.e(34640), i.e(9935), i.e(82739), i.e(29331), i.e(94430), i.e(44155), i.e(63146), i.e(5799), i.e(50522), i.e(32151), i.e(52019), i.e(24384), i.e(55706), i.e(35015), i.e(2036), i.e(29499), i.e(61153), i.e(74733), i.e(77542), i.e(50991), i.e(4171), i.e(40731), i.e(92617), i.e(92716), i.e(93683), i.e(69727), i.e(97430), i.e(45410), i.e(74499), i.e(60990), i.e(82290), i.e(83230), i.e(38489), i.e(43671), i.e(24327), i.e(44072), i.e(59171), i.e(14558), i.e(99738), i.e(20201), i.e(35592), i.e(4002), i.e(75514), i.e(93921), i.e(69397), i.e(29594), i.e(79049), i.e(35189), i.e(88067), i.e(68985), i.e(46e3), i.e(95106), i.e(21114), i.e(81868), i.e(81880), i.e(7835), i.e(41831), i.e(67425), i.e(46780)]).then(i.bind(i, 578569)), s = new t(e);
						return null !== Wi && (Wi.hide(), Wi = s), s.show(), s
					}({
						sources: t,
						propertyPages: m,
						undoModel: l,
						title: r,
						activeTabId: n,
						renamable: a
					})
				}
				getPriceAxisWidthChangedByName(e) {
					return "left" === e ? this._lhsPriceAxisWidthChanged : this._rhsPriceAxisWidthChanged
				}
				getPriceAxisMaxWidthByName(e) {
					return "left" === e ? this._lhsAxesWidth : this._rhsAxesWidth
				}
				timeAxisHeight() {
					return null !== this._timeAxisWidget ? this._timeAxisWidget.size.h : 0
				}
				withModel(e, t) {
					null !== this._model ? t.call(e) : this.modelCreated().subscribe(e, t, !0)
				}
				hasModel() {
					return null !== this._model
				}
				copyLineToOtherCharts() {
					const e = (0, s.ensureNotNull)(this._model),
						t = e.selection().lineDataSources().filter((e => e.isSynchronizable()));
					e.copyToOtherCharts(t)
				}
				hideDataSources(e) {
					if (e.length) {
						const t = e.map((e => e.properties().visible)),
							i = e.map((() => !1));
						this.model().setProperties(t, i, rs.format({
							title: new T.TranslatedString(e[0].name(), e[0].title())
						}))
					}
				}
				hideSelectedObject() {
					this.hideDataSources(this.model().selection().dataSources().filter((e => !(0, te.isAlertLabel)(e))))
				}
				unlinkSelectedLine() {
					const e = (0, s.ensureNotNull)(this._model),
						t = e.selection().lineDataSources();
					e.unlinkLines(t)
				}
				onScroll() {
					return this._onScroll
				}
				onZoom() {
					return this._onZoom
				}
				images(e) {
					window.TradingView.printing = !0;
					const t = this.model().selection().allSources();
					this.model().selectionMacro((e => e.clearSelection())), this.model().model().recalculateAllPanes((0, dt.globalChangeEvent)());
					const i = (t, i) => {
							t.paint(i, this.onWidget());
							const s = {
								showCollapsedStudies: Boolean(null == e ? void 0 : e.showCollapsedStudies),
								status: null == e ? void 0 : e.status
							};
							return t.getScreenshotData(s)
						},
						s = [];
					if (null !== this._maximizedPaneWidget) {
						const e = this._paneWidgets.indexOf(this._maximizedPaneWidget);
						s.push(i(this._maximizedPaneWidget, f.InvalidationMask.light().invalidateForPane(e)))
					} else
						for (let e = 0; e < this._paneWidgets.length; ++e) {
							const t = this._paneWidgets[e];
							s.push(i(t, f.InvalidationMask.light().invalidateForPane(e))), e < this._paneWidgets.length - 1 && s.push(this._paneSeparators[e].image())
						}
					let o;
					this._timeAxisWidget && (this._timeAxisWidget.paint(f.InvalidationLevel.Light), o = this._timeAxisWidget.getScreenshotData()), window.TradingView.printing = !1, this.model().selectionMacro((e => {
						t.forEach((t => {
							e.addSourceToSelection(t)
						}))
					})), this.model().model().recalculateAllPanes((0, dt.globalChangeEvent)()), this.model().model().lightUpdate();
					const r = this.mainSeriesQuotesAndMetainfo();
					return {
						panes: s,
						timeAxis: o,
						colors: {
							text: this.properties().childs().scalesProperties.childs().textColor.value(),
							bg: this.properties().childs().paneProperties.childs().background.value(),
							scales: this.properties().childs().scalesProperties.childs().lineColor.value()
						},
						meta: r.meta,
						ohlc: r.ohlc,
						quotes: r.quotes
					}
				}
				setSaveChartService(e) {
					this._saveChartService = e, null !== this._lineToolsSynchronizer && this._lineToolsSynchronizer.setSaveChartService(e)
				}
				getSaveChartService() {
					return this._saveChartService
				}
				mainSeriesQuotesAndMetainfo() {
					let e, t, i;
					const s = this._model && this._model.mainSeries();
					if (s) {
						const o = e => null == e ? "" : s.formatter().format(e, void 0, void 0, !0, !1) + "",
							r = e => null == e ? "" : e + "";
						e = {
							resolution: s.interval(),
							symbol: s.symbol(),
							values: s.valuesProvider().getValues(null)
						};
						const n = s.symbolInfo();
						n && (e.symbol = n.full_name, e.description = n.description, e.exchange = n.exchange);
						const a = s.bars().last();
						null !== a && (t = a.value.slice(1, 5).map(o));
						const l = s.quotes();
						l && (i = {
							change: o(l.change),
							changePercent: r(l.change_percent),
							last: o(l.last_price)
						})
					}
					return {
						meta: e,
						ohlc: t,
						quotes: i
					}
				}
				updateCrossHairPositionIfNeeded() {
					if (this._model) {
						const e = L.tool.value();
						this._model.model().setCurrentTool(e);
						const t = (0, P.lastMouseOrTouchEventInfo)();
						if (t.isTouch) {
							const e = this._maximizedPaneWidget || this._paneWidgets[0];
							if (e.hasState() && (!t.stylus && (this._isLineToolModeExceptBrush() || (0, L.toolIsMeasure)(L.tool.value())) || 0 !== this.selectPointMode().value())) {
								const t = e.state(),
									i = .5 * this._model.model().timeScale().width(),
									s = .5 * t.defaultPriceScale().height();
								this._model.model().setAndSaveCurrentPosition(i, s, t)
							}
						}
						if (this._model && t.isTouch) {
							const e = this._model.model().crossHairSource();
							e.updateAllViews((0, dt.dataSourceChangeEvent)(e.id()))
						}
					}
				}
				trackingModePaneWidget() {
					if (!(0, P.lastMouseOrTouchEventInfo)().isTouch) return null;
					for (const e of this.paneWidgets())
						if (e.trackingModeEnabled()) return e;
					return null
				}
				startTrackingMode() {
					if ((0, P.lastMouseOrTouchEventInfo)().isTouch) {
						this.exitTrackingMode(), this.updateCrossHairPositionIfNeeded();
						const e = this._maximizedPaneWidget || this._paneWidgets[0],
							t = this.model().model().crossHairSource().currentPoint();
						e.startTrackingMode(t, t)
					}
				}
				exitTrackingMode() {
					(0, P.lastMouseOrTouchEventInfo)().isTouch && this.paneWidgets().some((e => e.trackingModeEnabled())) && (this.paneWidgets().forEach((e => e.exitTrackingMode())), this.model().model().clearCurrentPosition())
				}
				onToolChanged() {
					0 !== this.selectPointMode().value() && this.cancelRequestSelectPoint(), this.exitTrackingMode()
				}
				setInLoadingState(e) {
					this._inLoadingState = e
				}
				paint(e) {
					const t = null != e ? e : f.InvalidationMask.full();
					t.validationActions().forEach((e => e())), this._paneWidgets.forEach(((e, i) => {
						null !== this._maximizedPaneWidget && this._maximizedPaneWidget !== e || e.paint(t.invalidateForPane(i), !1)
					})), this._timeAxisWidget && this._timeAxisWidget.paint(t.invalidateForTimeScale()), null == ns || ns(), this._redraw.fire()
				}
				GUIResetScales() {
					(0, se.trackEvent)("GUI", "Reset Scales"), null !== this._model && this._model.resetScales()
				}
				toggleMaximizePane(e) {
					var t;
					if (!(this._paneWidgets.length < 2)) {
						this._maximizedPaneWidget ? (this._maximizedPaneWidget.state().maximized().setValue(!1), this._maximizedPaneWidget = null, this._paneSeparators.forEach((e => e.show()))) : (this._maximizedPaneWidget = e, this._maximizedPaneWidget.state().maximized().setValue(!0), this._paneSeparators.forEach((e => e.hide())));
						for (let e = this._paneWidgets.length; e--;) this._paneWidgets[e].updateControls(), this._paneWidgets[e].updatePriceAxisWidgets();
						this._errorRenderer.updatePaneWidgets(), null === (t = this._timeAxisWidget) || void 0 === t || t.updatePriceAxisStubs(), this._adjustSize(), this.updateCrossHairPositionIfNeeded()
					}
				}
				maximizedPaneWidget() {
					return this._maximizedPaneWidget
				}
				isMaximizedPane() {
					return null !== this._maximizedPaneWidget
				}
				toggleCollapsedPane(e) {
					const t = e.state();
					t.collapsed().setValue(!t.collapsed().value()), this._paneWidgets.forEach((e => e.updateControls())), this._adjustSize(), this.updateCrossHairPositionIfNeeded()
				}
				unsetActivePaneWidget() {
					this.activePaneWidget = null
				}
				setActivePaneWidget(e) {
					this.activePaneWidget = e
				}
				onPaneWidgetDestroyed(e) {
					this.activePaneWidget === e && (this.activePaneWidget = null)
				}
				backgroundTopTheme() {
					return this._backgroundTopTheme.readonly()
				}
				backgroundBasedTheme() {
					return this._backgroundBasedTheme.readonly()
				}
				backgroundBottomTheme() {
					return this._backgroundBottomTheme.readonly()
				}
				lineToolsAndGroupsDTO() {
					return (0, s.ensureNotNull)(this._lineToolsSynchronizer).prepareDTO()
				}
				resetLineToolsInvalidated(e, t, i) {
					(0, s.ensureNotNull)(this._lineToolsSynchronizer).resetInvalidated(e, t, i)
				}
				applyLineToolUpdateNotification(e, t) {
					(0, s.ensureNotNull)(this._lineToolsSynchronizer).applyLineToolUpdateNotification(e, t)
				}
				reloadAllLineTools() {
					(0, s.ensureNotNull)(this._lineToolsSynchronizer).reloadAllLineTools()
				}
				startApplyingLineToolUpdateNotification() {
					var e;
					null === (e = this._lineToolsSynchronizer) || void 0 === e || e.startApplyingLineToolUpdateNotification()
				}
				endApplyingLineToolUpdateNotification() {
					var e;
					null === (e = this._lineToolsSynchronizer) || void 0 === e || e.endApplyingLineToolUpdateNotification()
				}
				applyAlertIdByExternalSource(e, t) {
					var i;
					null === (i = this._lineToolsSynchronizer) || void 0 === i || i.applyAlertIdByExternalSource(e, t)
				}
				deleteAlertByExternalSource(e, t) {
					var i;
					null === (i = this._lineToolsSynchronizer) || void 0 === i || i.deleteAlertByExternalSource(e)
				}
				shouldBeSavedEvenIfHidden() {
					return this.model().model().shouldBeSavedEvenIfHidden()
				}
				showObjectsTreeDialog() {
					var e;
					null === (e = this._objectTreeDialogController) || void 0 === e || e.show()
				}
				addCustomWidgetToLegend(e, t) {
					this._customLegendWidgetsFactoryMap.set(e, t);
					for (const i of this.paneWidgets()) i.addCustomWidgetToLegend(e, t)
				}
				applyIndicatorsToAllChartsAvailable() {
					if (!this.chartWidgetCollection().applyIndicatorsToAllChartsAvailable()) return !1;
					for (const e of this.model().model().panes()) {
						if (e.sourcesByGroup().all().some((e => (0, S.isStudy)(e) && !(0, S.isESDOrRollDatesStudy)(e)))) return !0
					}
					return !1
				}
				restoreState(e, t, o) {
					this._adjustSize();
					const r = (0, s.ensureNotNull)(this._model).restoreState(this._content, t, o);
					this._setActions(), r && r.lines_limit_exceeded && !this.readOnly() && Promise.all([i.e(22850), i.e(55099), i.e(84845), i.e(50407), i.e(71452), i.e(25222), i.e(90609)]).then(i.bind(i, 552036)).then((({
						showLinetoolsLimitExceededDialog: e
					}) => {
						e(this)
					}))
				}
				addCompareAsOverlay(e, t) {
					const i = this.model();
					return (0, s.ensureDefined)(this._options.isSymbolAvailable)(e).then((s => {
						if (!s) return null;
						const o = i.createStudyInserter({
							type: "java",
							studyId: "Overlay@tv-basicstudies"
						});
						return o.setForceOverlay(!0), o.setPreferredPriceScale("as-series"), o.setTargetPriceScaleMode({
							percentage: !0
						}), void 0 !== t && o.setPropertiesState({
							allowExtendTimeScale: t
						}), o.insert((async () => ({
							inputs: {
								symbol: e
							}
						})))
					}))
				}
				scrollHelper() {
					return this._scrollHelper
				}
				setBroker(e) {
					var t;
					this._brokerName = e, null === (t = this._lineToolsSynchronizer) || void 0 === t || t.setBroker(e)
				}
				chartPainted() {
					return this._drawPlanned ? (null === this._chartPaintedPromise && (this._chartPaintedPromise = (0, c.createDeferredPromise)()), this._chartPaintedPromise.promise) : Promise.resolve()
				}
				setDataWindowWidget(e) {
					this._dataWindowWidget = e
				}
				removeDataWindowWidget() {
					this._dataWindowWidget = null
				}
				showSelectedSourcesProperties(e) {
					const t = (0, s.ensureNotNull)(this._model).selection().dataSources();
					if (1 === t.length) this.showSourceProperties(t[0], e);
					else {
						const i = t.filter(g.isLineTool);
						i.length > 0 && this.showChartPropertiesForSources({
							sources: i,
							tabName: e
						})
					}
				}
				update() {
					if (this.hasModel()) {
						for (const e of this._paneWidgets) e.update();
						this._timeAxisWidget && this._timeAxisWidget.update()
					}
				}
				setPriceAxisHovered(e, t) {
					t ? this._hoveredPriceAxes.add(e) : this._hoveredPriceAxes.delete(e), this._anyAxisHovered.setValue(this._hoveredPriceAxes.size > 0)
				}
				anyPriceAxisHovered() {
					return this._anyAxisHovered.readonly()
				}
				async _showChartProperties(e, t, i, s) {
					if (!this._model) return null;
					t && ((0, a.setValue)("properties_dialog.active_tab.chart", t), i.tabName = t);
					const o = await ji(e, this._model, i, this._options.chartWidgetCollection, s);
					return (null == o ? void 0 : o.visible().value()) ? o : null
				}
				_createLineToolsSynchronizerIfNeeded() {
					this._lineToolsSynchronizer = new Si(this._layoutId, this._id, this.model().model(), this.readOnly(), (() => this._chartWidgetCollection.isFirstChartInLayout(this)), (() => this._chartWidgetCollection.deserializedChartIds())), null !== this._saveChartService && this._lineToolsSynchronizer.setSaveChartService(this._saveChartService), this._lineToolsSynchronizer.setBroker(this._brokerName), (0, Ci.isFeatureEnabled)("remove_line_tools_from_content") && (0, s.ensureNotNull)(this._lineToolsSynchronizer).invalidateAll()
				}
				_updateThemedColor() {
					const e = this.model().model(),
						t = e.backgroundColorAtYPercentFromTop(.5);
					let i = e.backgroundTopColor().value(),
						s = e.backgroundColor().value();
					const o = (0, re.isColorDark)(t),
						r = (0, re.isColorDark)(i),
						n = (0, re.isColorDark)(s);
					this.widget().classList.toggle("chart-widget--themed-dark", o), this.widget().classList.toggle("chart-widget--themed-light", !o), this.widget().classList.toggle("chart-widget__top--themed-dark", r), this.widget().classList.toggle("chart-widget__top--themed-light", !r), this.widget().classList.toggle("chart-widget__bottom--themed-dark", n), this.widget().classList.toggle("chart-widget__bottom--themed-light", !n), this._backgroundTopTheme.setValue(r ? "dark" : "light"), this._backgroundBasedTheme.setValue(o ? "dark" : "light"), this._backgroundBottomTheme.setValue(n ? "dark" : "light"), i === s && (0, V.isStdThemedDefaultValue)("chartProperties.paneProperties.background", i, this._backgroundBasedTheme.value()) && (i = null, s = null);
					for (const e of this._paneWidgets) e.updateThemedColors({
						topColor: i,
						bottomColor: s
					})
				}
				_isLineToolModeExceptBrush() {
					const e = L.tool.value();
					return (0, g.isLineToolName)(e) && !(0, g.isLineDrawnWithPressedButton)(e) && 0 === this.selectPointMode().value()
				}
				_cancelCreatingLine() {
					const e = (0, s.ensureNotNull)(this._model).model(),
						t = e.lineBeingCreated();
					if (null !== t) {
						const i = (0, s.ensureNotNull)(e.paneForSource(t));
						(0, s.ensureNotNull)(this.paneByState(i)).cancelCreatingLineTool()
					}
					const i = e.crossHairSource().measurePane().value();
					if (null !== i) {
						(0, s.ensureNotNull)(this.paneByState(i)).cancelMeasuring()
					}
				}
				_adjustSize(e) {
					var t;
					let i = 0;
					const s = null === this._model ? null : this._model.model().priceScaleSlotsCount(),
						o = new Uint32Array(null === s ? 0 : s.left),
						r = new Uint32Array(null === s ? 0 : s.right),
						n = (0, B.getCanvasDevicePixelRatio)(document.body),
						a = (e, t) => e + t,
						l = (e, t) => {
							t.forEach(((t, i) => {
								e[i] = Math.max(e[i], t)
							}))
						},
						c = this._width(),
						d = this._height(),
						u = this._paneSeparators.length,
						_ = this.isMaximizedPane() ? 0 : Rt.height() * u,
						m = null !== this._timeAxisWidget ? this._timeAxisWidget.optimalHeight() : 0;
					let p = d - m >= 61 ? m : 0;
					p % 2 && (p += 1);
					const g = Math.max(1, Math.floor((d - _ - p) / this._paneWidgets.length));
					let S = 0,
						v = null;
					for (const e of this._paneWidgets)
						if (!this._maximizedPaneWidget || this._maximizedPaneWidget === e) {
							e.leftPriceAxisesContainer().updateCurrencyLabels();
							const t = e.leftPriceAxisesContainer().optimalWidths();
							e.rightPriceAxisesContainer().updateCurrencyLabels();
							const s = e.rightPriceAxisesContainer().optimalWidths();
							l(o, t), l(r, s), this._maximizedPaneWidget !== e && e.state().collapsed().value() ? S += Math.min(g, e.collapsedHeight()) : (i += e.stretchFactor(), v = e)
						} let f = o.reduce(a, 0),
						b = r.reduce(a, 0),
						y = Math.max(c - f - b, 0);
					if (y <= 102) {
						f = 0, b = 0, y = c;
						for (let e = 0; e < o.length; e++) o[e] = 0;
						for (let e = 0; e < r.length; e++) r[e] = 0
					}
					for (const e of this._paneSeparators) e.adjustSize();
					const C = _ + S + p,
						w = d < C ? 0 : d - C,
						T = w / i;
					let P = 0,
						M = !1;
					const x = null === (t = this._model) || void 0 === t ? void 0 : t.model();
					for (let e = 0; e < this._paneWidgets.length; ++e) {
						const t = this._paneWidgets[e];
						void 0 !== x && t.setState(x.panes()[e]);
						let i = 0;
						if (this.isMaximizedPane()) i = this._maximizedPaneWidget === t ? w : 0;
						else if (t.state().collapsed().value()) i = Math.min(g, t.collapsedHeight());
						else {
							const e = t === v ? Math.ceil((w - P) * n) / n : Math.round(t.stretchFactor() * T * n) / n;
							i = Math.max(e, 2), P += i
						}
						t.setPriceAxisSizes("left", i, o), t.setPriceAxisSizes("right", i, r), M = M || i !== t.height(), t.setSize(new B.Size(y, i)), x && t.state() && x.setPaneHeight(t.state(), i)
					}
					null !== this._timeAxisWidget && this._timeAxisWidget.setSizes(new B.Size(y, p), o, r), x && x.setWidth(y, e), this._controlBarNavigation && this._controlBarNavigation.updatePosition(), this._lhsAxesWidth !== f && (this._lhsAxesWidth = f, this._lhsPriceAxisWidthChanged.fire(f)), this._rhsAxesWidth !== b && (this._rhsAxesWidth = b, this._rhsPriceAxisWidthChanged.fire(b)), M && h.emit("panes_height_changed")
				}
				_makePaneWidgetsAndSeparators() {
					const e = this.model().model().panes(),
						t = e.length,
						i = this._paneWidgets.length;
					for (let e = t; e < i; e++) {
						(0, s.ensureDefined)(this._paneWidgets.pop()).destroy();
						const e = this._paneSeparators.pop();
						e && e.destroy()
					}
					const o = this._options.containsData;
					for (let s = i; s < t; s++) {
						const t = {
							contextMenuEnabled: this._options.paneContextMenuEnabled,
							currencyConversionEnabled: this._options.currencyConversionEnabled,
							unitConversionEnabled: this._options.unitConversionEnabled,
							handleScale: this._options.handleScale,
							handleScroll: this._options.handleScroll,
							priceScaleContextMenuEnabled: this._options.priceScaleContextMenuEnabled,
							legendWidgetEnabled: this._options.legendWidgetEnabled,
							sourceStatusesWidgetEnabled: !o,
							sourceStatusesWidget: this._options.sourceStatusesWidget,
							marketStatusWidgetEnabled: this._options.marketStatusWidgetEnabled && !o,
							chartWarningWidgetEnabled: this._options.chartWarningWidgetEnabled && !o,
							chartWarningWidget: this._options.chartWarningWidget,
							dataProblemWidgetEnabled: this._options.dataProblemWidgetEnabled && !o,
							legendWidget: this._options.legendWidget,
							propertyPagesEnabled: this._options.propertyPagesEnabled,
							sourceSelectionEnabled: this._options.sourceSelectionEnabled,
							controlsEnabled: this._options.paneControlsEnabled,
							croppedTickMarks: this._options.croppedTickMarks,
							countdownEnabled: this._options.countdownEnabled,
							customLegendWidgetFactories: new Map(this._customLegendWidgetsFactoryMap),
							useKineticScroll: this._options.useKineticScroll
						};
						void 0 !== this._options.paneContextMenu && (t.contextMenu = this._options.paneContextMenu), void 0 !== this._options.priceScaleContextMenu && (t.priceScaleContextMenu = this._options.priceScaleContextMenu);
						const i = new Bt(this, e[s], t, this._paneWidgetsSharedState);
						if (this._paneWidgets.push(i), s > 0) {
							const e = new Rt(this, s - 1, s);
							this._paneSeparators.push(e), this._timeAxisWidget ? this._elMainTable.insertBefore(e.getElement(), this._timeAxisWidget.getElement()) : this._elMainTable.appendChild(e.getElement())
						}
						this._timeAxisWidget ? this._elMainTable.insertBefore(i.getElement(), this._timeAxisWidget.getElement()) : this._elMainTable.appendChild(i.getElement())
					}
					for (let i = 0; i < t; i++) {
						const t = e[i],
							s = this._paneWidgets[i];
						s.hasState() && s.state() === t ? s.updatePriceAxisWidgets() : s.setState(t)
					}
					for (let e = t; e--;) this._paneWidgets[e].updateControls();
					this._errorRenderer.updatePaneWidgets(), this._updateThemedColor()
				}
				_width() {
					return this._options.width.value()
				}
				_height() {
					return this._options.height.value()
				}
				_update(e) {
					var t;
					const i = e ? e.fullInvalidation() : f.InvalidationLevel.Full,
						s = !!e && e.isVisibleTimeRangeLockedOnResize();
					null !== this._timingsMeter && this._timingsMeter.startDraw(i), i === f.InvalidationLevel.Full && (this._model ? this._updateGui(s) : this._adjustSize(s));
					if (e.invalidateForTimeScale() > f.InvalidationLevel.Cursor && (null === (t = this._timeAxisWidget) || void 0 === t || t.update()), this.paint(e), this._dataWindowWidget) {
						const t = e.maxPaneInvalidation();
						t === f.InvalidationLevel.Full ? this._dataWindowWidget.fullUpdate() : t > f.InvalidationLevel.None && this._dataWindowWidget.update()
					}
					for (let t = 0; t < this._paneWidgets.length; t++) this._paneWidgets[t].updateStatusWidget(e.invalidateForPane(t));
					null !== this._timingsMeter && this._timingsMeter.stopDraw(), e && e.panesOrderInvalidated() && h.emit("panes_order_changed")
				}
				_onMousewheel(e) {
					if (!this.model().model().zoomEnabled() || null === this._mouseWheelHelper) return;
					if (!(0, l.onWidget)() && parent && parent !== window && parent.IS_DEMO_PAGE) return;
					if (null === this._model) return;
					if (this.model().timeScale().isEmpty()) return;
					const t = this._mouseWheelHelper.processWheel(e),
						i = t.deltaX,
						o = -t.deltaY;
					if (0 !== i && this._options.handleScroll.mouseWheel || 0 !== o && this._options.handleScale.mouseWheel) {
						if (e.cancelable && e.preventDefault(), 0 !== o && this._options.handleScale.mouseWheel) {
							const t = Math.sign(o) * Math.min(1, Math.abs(o)),
								i = (0, s.ensureNotNull)(this._mainDiv).getBoundingClientRect(),
								r = e.clientX - this._lhsAxesWidth - i.left;
							if (!Number.isFinite(r) || !Number.isFinite(t)) return void os.logWarn("Incorrect mouse wheel processing: scrollPosition: " + r + ", zoomScale: " + t);
							const n = new A.EnvironmentState(e).mod();
							this.model().model().zoomTime(r, t, !!n || void 0), this._onZoom.fire(n)
						}
						0 !== i && this._options.handleScroll.mouseWheel && this.model().scrollChart(-80 * i)
					}
				}
				_updateGui(e) {
					this._model && (this._makeTimeAxisWidget(), this._makePaneWidgetsAndSeparators(), this._elMainTable.style.userSelect = "none", this._adjustSize(e))
				}
				_setElement(e) {
					if (this._mainDiv) {
						this._mainDiv.remove();
						const e = document.createRange();
						e.selectNodeContents((0, s.ensureNotNull)(this._parent)), e.deleteContents()
					}
					this._controlBarNavigation && (this._controlBarNavigation.destroy(), this._controlBarNavigation = null), null !== this._removeMaximizeHotkey && this._removeMaximizeHotkey(), this._removeMaximizeHotkey = this._initMaximizeHotkey(e);
					const t = e.ownerDocument,
						i = t.createElement("div");
					i.classList.add("chart-container-border"), e.insertBefore(i, e.firstChild), this._parent = i;
					const o = t.createElement("div");
					if (o.classList.add("chart-widget"), this._mainDiv = o, this._elTooltipDiv = t.createElement("div"), this._elTooltipDiv.className = "tooltip-wrapper", this._mainDiv.appendChild(this._elTooltipDiv), this._elMainTable = t.createElement("table"), this._elMainTable.className = "chart-markup-table", this._elMainTable.setAttribute("cellpading", "0"), this._elMainTable.setAttribute("cellspacing", "0"), this._mainDiv.appendChild(this._elMainTable), this._hotkeysListener && this._hotkeysListener.destroy(), this._errorRenderer.setContainer(this._parent), this._hotkeysListener = new at.ChartHotkeysListener(this, this._mainDiv), (this._options.controlBarEnabled || (0, Te.enabled)("control_bar")) && this._createControlBar(), this._options.handleScale.mouseWheel || this._options.handleScroll.mouseWheel) {
						this._mouseWheelHelper = new be;
						const e = this._onMousewheel.bind(this);
						this._onWheelBound = e, this._mainDiv.addEventListener("wheel", e, {
							passive: !1
						})
					}
					this.resize(), this._justActivated = !1, this.withModel(this, (() => {
						i.appendChild(o), o.addEventListener("mousedown", this._beginRequestActive.bind(this)), o.addEventListener("mouseup", this._endRequestActive.bind(this)), o.addEventListener("touchstart", this._beginRequestActive.bind(this)), o.addEventListener("touchmove", this._endRequestActive.bind(this)), o.addEventListener("touchend", this._endRequestActive.bind(this)), o.addEventListener("click", this._requestActive.bind(this))
					})), this._inited && (null !== this._timeAxisWidget && (this._timeAxisWidget.destroy(), this._timeAxisWidget = null), this._paneWidgets.forEach((e => {
						e.destroy()
					})), this._paneWidgets.length = 0, this._paneSeparators.forEach((e => {
						e.destroy()
					})), this._paneSeparators.length = 0, this._update(f.InvalidationMask.full()))
				}
				_init() {
					this.hasModel() && this.model().mainSeries().clearData(), this._initColors(), this._makeDefaultGui();
					this._makeDefaultModel(), (() => {
						this._checkObsoleteTimezone(), this._chartSession && this._chartSession.connected() && this.model().model().restart(), this._content && (this._initColors(), this._updateGui(), this.update()), this._resizeHandler = () => {
							this._invalidationHandler(f.InvalidationMask.full())
						}, this._resizeHandler(), (0, s.ensureNotNull)(this._parent).appendChild((0, s.ensureNotNull)(this._mainDiv)), this._spinner && (this._spinner.stop(), this._spinner = null), this._keydownEventListener = e => {
							27 === e.which && e.preventDefault()
						}, window.addEventListener("keydown:chart_" + this._id, this._keydownEventListener), this._initBarsMarksSources(), this._showChartEvents && this._createChartEventsSource(), this._activateSymbolSearchHotkeys(), this.model().timeScale().onScroll().subscribe(this, (() => this._onScroll.fire())), this._inited = !0
					})()
				}
				_makeDefaultModel() {
					let e;
					if (this._content && this._content.timeScale.points) {
						const t = this._content.timeScale.points.items[0];
						e = {
							startDate: t
						}
					}
					if (!(0, s.ensureNotNull)(this._metaInfoRepository).getInternalMetaInfoArray()) throw new Error("Cannot create chart model: studies metainfo is absent");
					const t = () => {
						var t, i;
						const o = {
							readOnly: this.readOnly(),
							isSnapshot: !!this._containsData,
							...(0, n.pickFields)(this._options, ["timeScale", "crossHair", "esdEnabled", "countdownEnabled", "lastPriceAnimationEnabled", "currencyConversionEnabled", "unitConversionEnabled", "watermarkEnabled", "shiftVisibleRangeOnNewBar", "hideIdeas", "onWidget"])
						};
						let r;
						if ((0, Ci.isFeatureEnabled)("hibernate_studies_on_inactive_tabs")) {
							const e = this.chartWidgetCollection().resizerBridge().visible.spawn(),
								t = (0, m.combine)((e => !e), e),
								i = new yi(t, bi, 3e5, (e => e));
							r = (0, m.combine)(((e, t) => e || t), i, this._collapsed)
						} else r = this._collapsed;
						const a = function(e, t, i, s, o, r, n, a, l, c, h) {
							const d = new p.ChartUndoModel(e, t, i, s, o, r, n, a, l, c, h);
							return d.model().fullUpdate(), d
						}(this._chartSession, this._invalidationHandler, this.properties(), e, (0, s.ensureNotNull)(this._metaInfoRepository), this, this._options.undoHistory, this._options.barsMarksContainersFactory, o, r, null !== (i = null === (t = this._saveChartService) || void 0 === t ? void 0 : t.autoSaveEnabled()) && void 0 !== i ? i : new(Ke())(!0));
						return this._createSessions(a.model()), this._createPrePostMarket(a.model()), a
					};
					(0, Te.enabled)("lean_chart_load") ? this._model = this._model || t(): this._model = t(), this._model.model().setChartSaveTime(1e3 * this._chartWidgetCollection.metaInfo.lastModified.value()), this._createVolumeIfNeeded();
					if (this._content) {
						let e = {};
						ss && this._initialLoading && (e = {
							symbol: this._defSymbol,
							interval: this._defInterval,
							style: this._defStyle
						}), this.restoreState(this._content, this._containsData, e), ss && this._defSymbol && this.model().model().recalculatePriceRangeOnce()
					} else this._setActions();
					this._createLineToolsSynchronizerIfNeeded(), (() => {
						const e = (0, s.ensureNotNull)(this._model);
						e.onTagsChanged().subscribe(this, (() => this.onModelTagsChanged())), this._initBackgroundColor(), this._updateGui(), this._modelCreated.fire(e), this._tagsChanged.fire();
						const t = e.mainSeries(),
							i = t.properties().childs();
						this._defTimeframe && t.setDefaultTimeframe(this._defTimeframe), e.lineCancelled().subscribe(this, (() => this.onLineCancelled())), t.dataEvents().symbolNotPermitted().subscribe(null, (e => t.setSymbolParams({
								symbol: e
							}))), window.loginStateChange.subscribe(this, this._handleLoginStateChanged), this._handleLoginStateChanged(), t.dataEvents().symbolResolved().subscribe(this, (e => {
								const i = e.pro_name;
								i && this._options.isSymbolAvailable && this._options.isSymbolAvailable(i).then((e => {
									e || t.setSymbolParams({
										symbol: window.DEFAULT_SYMBOL
									})
								}))
							})),
							void 0 !== this._options.requestFallbackSymbol && t.dataEvents().symbolGroupNotPermitted().subscribe(this, (e => {
								(0, s.ensureDefined)(this._options.requestFallbackSymbol)(i.symbol.value(), {
									type: "group_not_permitted",
									symbolGroup: e
								}).then((e => {
									e && t.setSymbolParams({
										symbol: e
									})
								}))
							})), (0, s.ensureDefined)(t.onInReplayStateChanged).bind(t)().subscribe(this.screen, this.screen.show), i.style.unsubscribe(this, this._onChartStyleChanged), i.style.subscribe(this, this._onChartStyleChanged), t.dataEvents().completed().subscribe(this, (() => this._addPerfMark("SeriesCompleted")), !0), t.dataEvents().barReceived().subscribe(this, (() => this._addPerfMark("SeriesFirstDataReceived")), !0);
						const r = this._options;
						t.dataEvents().chartTypeNotPermitted().subscribe(null, (() => {
							t.setSymbolParams({
								interval: "D"
							}), r.muteSessionErrors || ((0, wi.trackGoProFeature)("kagiRenko"), (0, Ti.reloginOrGoPro)({
								feature: "kagiRenko"
							}))
						})), t.dataEvents().intradaySpreadNotPermitted().subscribe(null, (() => {
							t.setSymbolParams({
								interval: "D"
							}), r.muteSessionErrors || (0, Ti.reloginOrGoPro)({
								feature: "intradaySpread"
							})
						})), t.dataEvents().customIntervalNotPermitted().subscribe(null, (() => {
							t.setSymbolParams({
								interval: (0, Ri.getDefaultResolution)((0, Oi.isRangeStyle)(i.style.value()))
							}), r.muteSessionErrors || (0, Ti.reloginOrGoPro)({
								feature: "customIntervals"
							})
						})), t.dataEvents().secondsIntervalNotPermitted().subscribe(null, (() => {
							t.setSymbolParams({
								interval: (0, Ri.getDefaultResolution)((0, Oi.isRangeStyle)(i.style.value()))
							}), r.muteSessionErrors || (0, Ti.reloginOrGoPro)({
								feature: "secondsIntervals",
								upgradeMessage: (0, o.t)("Upgrade now"),
								forceUpgradeBtn: !0
							})
						})), t.dataEvents().intradayExchangeNotPermitted().subscribe(null, (() => {
							if (t.setSymbolParams({
									interval: "D"
								}), !r.muteSessionErrors) {
								let e = (0, s.ensureNotNull)(t.symbolInfo()).listed_exchange;
								window.ChartApiInstance.supportedExchangesList().forEach((t => {
									t.value === e && (e = t.name)
								})), (0, Ti.reloginOrGoPro)({
									feature: "intradayExchange"
								})
							}
						})), t.requestingIntradayWhenNotSupported.subscribe(null, (() => {
							if (t.setSymbolParams({
									interval: "D"
								}), !r.muteSessionErrors) {
								const e = (0, o.t)("Interval is not applicable"),
									t = document.createElement("div"),
									i = (0, o.t)("{p_start}Only {b_start}D, W, M{b_end} intervals are supported for this symbol/exchange. You will be automatically switched to a D interval. Intraday intervals are not available because of exchange policies.{p_end}").format({
										p_start: "<p>",
										p_end: "</p>",
										b_start: "<b>",
										b_end: "</b>"
									});
								t.innerHTML = i, (0, Li.showNoticeDialog)({
									title: e,
									content: t
								})
							}
						})), t.requestingResolutionWhenNotSupported.subscribe(null, (e => t.setInterval(e))), t.requestingStyleIsNotSupported.subscribe(null, (() => {
							const i = t.interval(),
								s = e.model().defaultResolutions(),
								o = (0, Oi.getLastUsedSingleValueBasedStyle)(),
								r = (0, Ri.getResolutionByChartStyle)(o, i, s);
							t.setChartStyleWithIntervalIfNeeded(o, r)
						})), t.requestingStyleSupportRecovered.subscribe(null, (i => {
							const s = t.interval(),
								o = e.model().defaultResolutions(),
								r = (0, Ri.getResolutionByChartStyle)(i, s, o);
							t.setChartStyleWithIntervalIfNeeded(i, r)
						}))
					})()
				}
				_initBarsMarksSources() {
					this.withModel(this, (() => {
						for (const e of this.model().barsMarksSources()) e.onNeedRepaint.subscribe(this, (() => this.model().model().lightUpdate()))
					}))
				}
				_startSpinner(e) {
					this._spinner || e && (this._spinner = (new u.Spinner).spin(e))
				}
				_handleLoginStateChanged() {
					(0, Te.enabled)("popup_hints") && window.user && window.user.is_pro ? this._noExchangeSubscrptionWarning = new ki(this) : null !== this._noExchangeSubscrptionWarning && (this._noExchangeSubscrptionWarning.destroy(), this._noExchangeSubscrptionWarning = null)
				}
				_checkObsoleteTimezone() {
					const e = this.properties().childs().timezone.value();
					(0, qi.timezoneIsAvailable)(e) || this.properties().childs().timezone.setValue({
						UTC: "Etc/UTC",
						EST: "America/New_York",
						CST: "America/Chicago",
						PST: "America/Los_Angeles"
					} [e] || "exchange")
				}
				_initColors() {
					const e = this.properties().childs(),
						t = e.scalesProperties.childs();
					t.lineColor.listeners().subscribe(this, this._updateAndPaint), t.textColor.listeners().subscribe(this, this._updateAndPaint), e.paneProperties.childs().separatorColor.listeners().subscribe(this, this._setPaneSeparatorLineColor)
				}
				_setPaneSeparatorLineColor() {
					this._paneSeparators.forEach((e => e.update())), this._updateAndPaint()
				}
				_updateAndPaint() {
					this.update(), this.paint()
				}
				_makeDefaultGui() {
					this._makeLoadingScreen(), this.onWidget() && this._makeAvailableOnTVPopup(), this.hasModel() && (this._makeTimeAxisWidget(), this._makePaneWidgetsAndSeparators()), this._adjustSize(), this._updateScalesActions(), (0, B.disableSelection)(this._elMainTable), this.update(), this.paint()
				}
				_makeLoadingScreen() {
					if (Te.enabled("lean_chart_load")) {
						if (this.screen) return;
						this.screen = new Zi(this, (0, s.ensureNotNull)(this._parent))
					} else this.screen = new Zi(this, (0, s.ensureNotNull)(this._mainDiv))
				}
				_makeAvailableOnTVPopup() {
					this._availableScreen || (this._availableScreen = new Bi(this))
				}
				_createChartEventsSource() {
					{
						if (!Te.enabled("chart_events")) return;
						const e = this.model().mainSeries(),
							t = new Ei.ChartEventsSource(e);
						(0, s.ensureNotNull)(this.model().paneForSource(e)).insertDataSource(t, e.priceScale(), 0)
					}
				}
				_activateSymbolSearchHotkeys() {
					this.readOnly() || this._options.hideSymbolSearch || (0, Ki.activateKeyPressHandler)()
				}
				_makeTimeAxisWidget() {
					if (this._timeAxisWidget) return void this._timeAxisWidget.updatePriceAxisStubs();
					const e = this.model();
					this._timeAxisWidget = new Gt(this, this._options.timeScaleWidget, this._titlesProvider.bind(this), this._menuItemsProvider.bind(this), this._backgroundBasedTheme), this._elMainTable.appendChild(this._timeAxisWidget.getElement()), this._timeAxisWidget.updatePriceAxisStubs(), this._timeAxisWidget.onLabelHovered().subscribe(this, ((t, i) => {
						const o = this._maximizedPaneWidget ? this._maximizedPaneWidget.state() : e.paneForSource(e.mainSeries()),
							r = (0, s.ensureNotNull)(this.paneByState((0, s.ensureNotNull)(o))).highlightedPriceAxis(),
							n = r.value();
						(i || n.owner === t.owner) && (r.setValue({
							owner: t.owner,
							axis: i ? t.axis : null
						}), this.model().model().lightUpdate())
					}))
				}
				_titlesProvider(e, t) {
					const i = this.model(),
						o = (0, s.ensureNotNull)(this._maximizedPaneWidget ? this._maximizedPaneWidget.state() : i.paneForSource(i.mainSeries())),
						r = "right" === e ? o.rightPriceScales() : o.leftPriceScales();
					if (r.length < t + 1) return [];
					let n = r[t].orderedSources().filter((e => e === i.mainSeries() || (0, S.isStudy)(e)));
					return n.reverse(), n = (0, $i.moveToHead)(n, i.mainSeries()), n.map((e => e.title(!0, void 0, !1)))
				}
				_menuItemsProvider(e, t) {
					const i = this.model(),
						o = (0, s.ensureNotNull)(this._maximizedPaneWidget ? this._maximizedPaneWidget.state() : i.paneForSource(i.mainSeries())),
						r = "right" === e ? o.visibleRightPriceScales() : o.visibleLeftPriceScales();
					if (r.length < t + 1) return [];
					const n = r[t],
						a = i.model().panes().indexOf(o),
						l = this._paneWidgets[a],
						c = "right" === e ? l.rightPriceAxisesContainer() : l.leftPriceAxisesContainer();
					return (0, s.ensureNotNull)(c.findAxisWidgetForScale(n)).getContextMenuActions()
				}
				_invalidationRAFCallback() {
					this._drawPlanned = !1, this._drawRafId = 0, this._inLoadingState || (this._invalidationMask && (this._update(this._invalidationMask), this._invalidationMask = null), null !== this._chartPaintedPromise && (this._chartPaintedPromise.resolve(), this._chartPaintedPromise = null))
				}
				async _createControlBar() {
					const e = await Promise.all([i.e(90519), i.e(5979), i.e(21834), i.e(44155), i.e(24384), i.e(35015), i.e(2036), i.e(64746), i.e(64300), i.e(75514), i.e(93921), i.e(91622), i.e(59255), i.e(5093)]).then(i.bind(i, 164357));
					this._controlBarNavigation = new e.ControlBarNavigation(this, (0, s.ensureNotNull)(this._mainDiv), this._options.controlBar), this._model && this._adjustSize()
				}
				_subscribeToDrawingState() {
					if (this._options.readOnly) return;
					(0, L.init)();
					const e = (e, t) => {
						const i = this._model;
						if (null === i) return;
						const s = i.model();
						e.model !== s && (this._lineToolsSynchronizer ? this._lineToolsSynchronizer.executeSyncedAction((() => t(s, i))) : t(s, i))
					};
					L.createdLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							const o = (0, s.ensureNotNull)(e.paneForSource(e.mainSeries()));
							let r, n = null;
							if (void 0 === t.pointPositionPercents) {
								if (n = ls(e, t.model, t.point.timeStamp), null === n) return;
								r = t.point.price
							} else {
								const i = t.pointPositionPercents.x * e.timeScale().width(),
									s = e.mainSeries().priceScale(),
									o = t.pointPositionPercents.y * s.height(),
									a = e.mainSeries().firstValue();
								if (null === a) return;
								n = e.timeScale().coordinateToIndex(i), r = s.coordinateToPrice(o, a)
							}
							const a = {
									index: (0, s.ensureNotNull)(n),
									price: r
								},
								l = i.createLineTool({
									pane: o,
									point: a,
									linetool: t.linetool,
									properties: t.properties,
									linkKey: t.linkKey,
									ownerSource: e.mainSeries(),
									disableSynchronization: !0,
									id: t.id
								});
							null !== l && !Boolean(this.model().lineBeingCreated()) && t.finalState && l.restoreExternalPoints(t.finalState, {
								indexesChanged: !0,
								pricesChanged: !0
							})
						}))
					})), L.continuedLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							var s;
							const o = ls(e, t.model, t.point.timeStamp);
							if (null === o) return;
							const r = {
									index: o,
									price: t.point.price
								},
								n = e.lineBeingCreated();
							if (null === n) return;
							i.continueExternalLine(r, null !== (s = t.envState) && void 0 !== s ? s : void 0, !!t.finalState) && t.finalState && n.restoreExternalPoints(t.finalState, {
								indexesChanged: !0,
								pricesChanged: !0
							})
						}))
					})), L.cancelledLineTool.subscribe(null, (t => {
						e(t, ((e, t) => {
							e.cancelCreatingLine()
						}))
					})), L.beenSetLineToolLastPoint.subscribe(null, (t => {
						e(t, ((e, i) => {
							const s = e.lineBeingCreated();
							if (null === s || s.linkKey().value() !== t.linkKey) return;
							const o = ls(e, t.model, t.point.timeStamp);
							if (null === o) return;
							const r = {
								index: o,
								price: t.point.price
							};
							s.setLastPoint(r), s.updateAllViews((0, dt.dataSourceChangeEvent)(s.id())), e.lightUpdate()
						}))
					})), L.startedMovingLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							var s;
							const o = t.linkKeys.map(g.lineToolByLinkKey.bind(null, e)).filter(_.notNull);
							if (o.length) {
								const i = ls(e, t.model, t.point.timeStamp);
								if (null === i) return;
								const r = {
										index: i,
										price: t.point.price
									},
									n = null !== (s = t.activeItem) && void 0 !== s ? s : null,
									a = o[0].pointToScreenPoint(r);
								a && e.startMovingSources(o, {
									logical: r,
									screen: a
								}, n, t.pointPositionPercents, null === t.envState ? void 0 : t.envState, !0)
							}
						}))
					})), L.movedLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							var s;
							const o = e.sourcesBeingMoved().filter(g.isLineTool).filter((e => (e => t.linkKeys.some((t => e.linkKey().value() === t)))(e)));
							if (!o.length) return;
							const r = ls(e, t.model, t.point.timeStamp);
							if (null === r) return;
							const n = {
									index: r,
									price: t.point.price
								},
								a = o[0].pointToScreenPoint(n);
							a && e.moveSources({
								logical: n,
								screen: a
							}, t.pointPositionPercents, null !== (s = t.envState) && void 0 !== s ? s : void 0, !0)
						}))
					})), L.finishedMovingLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							const s = e.sourcesBeingMoved().filter(g.isLineTool);
							if (0 === s.length) return;
							s.forEach((i => {
								const s = (e => {
									for (let i = 0; i < t.linkKeys.length; i++)
										if (t.linkKeys[i] === e.linkKey().value()) return {
											state: t.finalStates[i],
											changes: t.changes[i]
										};
									return null
								})(i);
								e.endMovingSources(null !== s, !0), null !== s && (i.restoreExternalPoints(s.state, s.changes), s.state.pointPositionPercents && i.restorePositionPercents(s.state.pointPositionPercents))
							}))
						}))
					})), L.startedChangingLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							var s;
							const o = (0, g.lineToolByLinkKey)(e, t.linkKey);
							if (null !== o) {
								const i = o.getPoint(t.pointIndex),
									r = i ? i.index : ls(e, t.model, t.point.timeStamp);
								if (null === r) return;
								if (o.isActualSymbol() && o.isActualCurrency() && o.isActualUnit()) {
									const i = {
										index: r,
										price: t.point.price
									};
									e.startChangingLinetool(o, i, t.pointIndex, null !== (s = t.envState) && void 0 !== s ? s : void 0, !0)
								}
							}
						}))
					})), L.changedLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							const o = e.lineBeingEdited();
							if (null === o || o.linkKey().value() !== t.linkKey) return;
							let r = null;
							if (r = t.changes.indexesChanged ? ls(e, t.model, t.point.timeStamp) : (0, s.ensureNotNull)(e.linePointBeingChanged()).index, null !== r && o.isActualSymbol() && o.isActualCurrency() && o.isActualUnit()) {
								const i = {
									index: r,
									price: t.point.price
								};
								e.changeLinePoint(i, void 0, !0)
							}
						}))
					})), L.finishedChangingLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							const s = (0, g.lineToolByLinkKey)(e, t.linkKey);
							null !== s && s.isActualSymbol() && s.isActualCurrency() && s.isActualUnit() && null !== e.lineBeingEdited() && e.endChangingLinetool(!!t.finalState, !0), null !== s && t.finalState && s.restoreExternalPoints(t.finalState, t.changes)
						}))
					})), L.removedLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							const {
								withUndo: s,
								unlink: o,
								linkKey: r
							} = t, n = (0, g.lineToolByLinkKey)(e, r);
							if (null !== n) o && n.detachAlert(), s ? i.removeSource(n, !1) : e.removeSource(n);
							else if (this._lineToolsSynchronizer) {
								const {
									sourceTitle: e,
									symbol: n,
									lineToolState: a
								} = t;
								i.removeUnloadedLineTool({
									lineToolsSynchronizer: this._lineToolsSynchronizer,
									state: a,
									unlink: o,
									sourceTitle: e,
									linkKey: r,
									symbol: n,
									withUndo: s
								})
							}
						}))
					})), L.finishedLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							const s = (0, g.lineToolByLinkKey)(e, t.linkKey);
							null !== s && (0, tt.isLineToolFinishRequiredWhenCreatedByApi)(s.toolname) && s.finish()
						}))
					})), L.changedLineStyle.subscribe(null, (t => {
						e(t, ((e, i) => {
							const s = (0, g.lineToolByLinkKey)(e, t.linkKey);
							null !== s && (s.restoreExternalState(t.state), s.propertiesChanged(!0), t.alertId && s.syncAlert(t.alertId))
						}))
					})), L.restoredLineToolState.subscribe(null, (t => {
						e(t, ((e, i) => {
							const s = (0, g.lineToolByLinkKey)(e, t.linkKey);
							if (null !== s) {
								const i = {
									...t.state
								};
								i.indexes = t.state.points.map((i => ({
									index: ls(e, t.model, i.time_t),
									price: i.price
								}))), e.restoreLineToolState(s, i, !1)
							}
						}))
					})), L.restoredLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							e.restoreSource(t.state.restorePane, t.state.paneIndex, t.state.paneState, t.state.sourceState, null)
						}))
					})), L.copiedLineTool.subscribe(null, (t => {
						e(t, ((e, i) => {
							const o = (0, s.ensureNotNull)(e.paneForSource(e.mainSeries()));
							let r;
							const n = {
									...t.state,
									intervalsVisibilities: (0, Qi.mergeIntervalVisibilitiesDefaults)(t.state.intervalsVisibilities)
								},
								a = (0, g.createLineToolProperties)(t.linetool, n, e),
								l = e.dataSourceForId(t.id);
							if (l) {
								if (!(0, g.isLineTool)(l)) return void os.logError(`Error sync creating line tool. Object with id ${t.id} is already in use and it is not a line tool`);
								if (l.toolname !== t.linetool) return void os.logError(`Error sync creating line tool. Object with id ${t.id} is already in use and its type differs: ${l.toolname} and ${t.linetool}`)
							}
							if (l && (l.linkKey().setValue(t.linkKey), l.share(t.sharingMode)), t.pointPositionPercents) {
								const e = {
									index: 0,
									price: 0
								};
								if (r = null != l ? l : i.createLineTool({
										pane: o,
										point: e,
										linetool: t.linetool,
										properties: a,
										linkKey: t.linkKey,
										disableSynchronization: !0,
										id: t.id
									}), null === r) return;
								r.restorePositionPercents((0, s.ensureDefined)(t.pointPositionPercents))
							} else {
								const n = t.points.map((i => ({
										index: (0, s.ensureNotNull)(ls(e, t.model, i.timeStamp)),
										price: i.price
									}))),
									c = n[0];
								if (r = null != l ? l : i.createLineTool({
										pane: o,
										point: c,
										linetool: t.linetool,
										properties: a,
										linkKey: t.linkKey,
										sharingMode: t.sharingMode,
										disableSynchronization: !0,
										id: t.id
									}), null === r) return;
								if (e.lineBeingCreated())
									for (let e = 1; e < n.length; e++) e === n.length - 1 && (0, tt.isLineToolFinishRequiredWhenCreatedByApi)(t.linetool) && r.finish(), i.continueCreatingLine(n[e], new A.EnvironmentState(void 0, !0), e < n.length - 1, !0)
							}
							r.properties().interval.setValue(t.state.interval), r.restoreExternalState(t.state), r.restoreData && r.restoreData(t), r.propertiesChanged(!0), t.finalState && (r.calcIsActualSymbol(), r.restoreExternalPoints(t.finalState, {
								pricesChanged: !0,
								indexesChanged: !0
							}, !0)), t.alertId && r.syncAlert(t.alertId)
						}))
					}))
				}
			}
		},
		775647: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				allInitialModelsCreated: () => Yt,
				allInitialSymbolsResolved: () => Kt,
				applyIndicatorToAllChartsImpl: () => at,
				applyIndicatorsToAllChartsImpl: () => nt,
				applyLineToolUpdateNotificationImpl: () => pt,
				applyThemeImpl: () => $t,
				chartsSymbolsImpl: () => ft,
				checkProFeatureImpl: () => Xt,
				computeContentBoxImpl: () => xt,
				copyScreenshotToClipboard: () => Tt,
				createBroadcastChannel: () => Gt,
				createChartStorageSubscriptionsIfRequired: () => bt,
				createClipboardHandler: () => St,
				deserializedChartIds: () => _t,
				destroyBroadcastChannel: () => jt,
				downloadScreenshot: () => wt,
				generateNewChartId: () => Nt,
				getAsyncStateForChartImpl: () => dt,
				getClientSnapshot: () => Mt,
				getSnapshot: () => Pt,
				getStateForChartImpl: () => ht,
				getVisuallyAdjacentDefImpl: () => Et,
				hideChartImpl: () => Wt,
				isFirstChartInLayout: () => ut,
				lineToolsAndGroupsDTOsImpl: () => ct,
				removeChartWidgetSubscriptionsImpl: () => Ft,
				resetLineToolsInvalidatedImpl: () => mt,
				setBrokerImpl: () => vt,
				setChartLayoutWithUndoImpl: () => Zt,
				setLayoutImpl: () => zt,
				syncCrosshairImpl: () => Ht,
				syncScrollImpl: () => qt,
				takeScreenshot: () => yt,
				takeServerScreenshot: () => Ct,
				updateLayoutImpl: () => Lt,
				updateLayoutPartialImpl: () => kt
			});
			var s = i(588537),
				o = i(86441),
				r = i(575932),
				n = i(277036),
				a = i(638456),
				l = i(611688),
				c = i(905038),
				h = i(63208),
				d = i(72833);
			class u extends d.UndoCommand {
				constructor(e, t) {
					super(null), this._chartModel = e, this._targetIndex = t
				}
				redo() {
					const e = this._chartModel.createPane(this._targetIndex, void 0, this._paneId);
					this._paneId = e.id()
				}
				undo() {
					const e = (0, s.ensureDefined)(this._paneId),
						t = this._chartModel.panes().find((t => t.id() === e));
					void 0 !== t && this._chartModel.removePane(t)
				}
				createdPaneId() {
					return this._paneId
				}
			}
			class _ extends d.UndoCommand {
				constructor(e, t, i, s) {
					super(s), this._setter = e, this._oldValue = t, this._newValue = i
				}
				redo() {
					this._setter(this._newValue)
				}
				undo() {
					this._setter(this._oldValue)
				}
			}
			class m extends _ {
				constructor(e, t, i, s) {
					super((e => this._vwState.setValue(e)), t, i, s), this._vwState = e
				}
			}
			var p = i(911905),
				g = i(184601),
				S = i(963239);
			const v = (0, p.getLogger)("Clipboard");
			class f {
				constructor(e) {
					this._e = e
				}
				write(e) {
					return (0, S.writeImpl)(this._toRaw(e), this._e)
				}
				_toRaw(e) {
					const t = {
						files: []
					};
					t.text = e.text, void 0 !== e.app ? t.html = this._serializeAppData(e.app, e.text) : e.html && (t.html = e.html);
					for (const i of e.files || []) t.files.push(i);
					return t
				}
				_serializeAppData(e, t) {
					return `<meta charset="utf-8"><span data-tradingview-clip="${(0,g.htmlEscape)(e)}">${t?(0,g.htmlEscape)(t.slice(0,256)):"&#128200;"}</span>`
				}
			}
			class b {
				constructor(e) {
					this._e = e
				}
				async read() {
					this._e && 0 === this._e.eventPhase && (v.logWarn("Cannot use an already dispatched ClipboardEvent for reading"), this._e = null);
					const e = this._e ? this._readUsingEvent(this._e) : await this._readUsingApi();
					return this._fromRaw(e)
				}
				_readUsingEvent(e) {
					const t = (0, s.ensure)(e.clipboardData);
					e.preventDefault();
					const i = {
						files: []
					};
					for (let e = 0; e < t.files.length; e++) i.files.push(t.files[e]);
					for (let e = 0; e < t.items.length; e++) {
						const s = t.items[e];
						"string" === s.kind && ("text/plain" === s.type ? i.text = t.getData(s.type) : "text/html" === s.type ? i.html = t.getData(s.type) : i.files.push(new Blob([t.getData(s.type)], {
							type: s.type
						})))
					}
					return i
				}
				async _readUsingApi() {
					if (!navigator.clipboard || !navigator.clipboard.read) throw new DOMException("ClipboardApi is not supported", "NotSupportedError");
					let e, t;
					const i = [],
						s = await navigator.clipboard.read();
					for (const o of s)
						for (const s of o.types) "text/html" === s ? e = o.getType(s).then(this._readBlobAsText) : "text/plain" === s ? t = o.getType(s).then(this._readBlobAsText) : i.push(o.getType(s));
					return {
						text: await t,
						html: await e,
						files: await Promise.all(i)
					}
				}
				_fromRaw(e) {
					const t = {};
					if (void 0 !== e.text && (t.text = e.text),
						void 0 !== e.html) {
						const i = this._parseAppData(e.html);
						i ? t.app = i : t.html = e.html
					}
					return e.files.length > 0 && (t.files = e.files), t
				}
				_parseAppData(e) {
					if (-1 === e.slice(0, 1024).indexOf("data-tradingview-clip")) return;
					const t = (new DOMParser).parseFromString(e, "text/html").querySelector("[data-tradingview-clip]");
					return t ? t.getAttribute("data-tradingview-clip") || "" : void 0
				}
				_readBlobAsText(e) {
					return new Promise(((t, i) => {
						const s = new FileReader;
						s.onloadend = () => {
							t(s.result)
						}, s.onerror = () => {
							i(s.error)
						}, s.readAsText(e)
					}))
				}
			}
			var y = i(515312);

			function C(e) {
				const t = e.target;
				return null !== t && 1 === t.nodeType && (0, y.isTextEditingField)(t)
			}

			function w(e) {
				const t = e.target;
				if (null === t) return !1;
				const i = (t.ownerDocument || t).getSelection();
				return null !== i && !i.isCollapsed
			}
			class T extends class {
				constructor(e) {
					this._callbacks = Object.assign({}, e), this._boundOnCopy = this._onCopyEv.bind(this), this._boundOnCut = this._onCutEv.bind(this), this._boundOnPaste = this._onPasteEv.bind(this)
				}
				listen() {
					document.addEventListener("copy", this._boundOnCopy), document.addEventListener("cut", this._boundOnCut), document.addEventListener("paste", this._boundOnPaste)
				}
				async peek() {
					if ("granted" !== (await navigator.permissions.query({
							name: "clipboard-read"
						})).state) throw new Error("clipboard-read is not granted");
					return new b(null).read()
				}
				uiRequestCopy(e) {
					this._callbacks.copyRequested && this._callbacks.copyRequested(new f(null), e)
				}
				uiRequestCut(e) {
					this._callbacks.cutRequested && this._callbacks.cutRequested(new f(null), e)
				}
				uiRequestPaste(e) {
					this._callbacks.pasteRequested && this._callbacks.pasteRequested(new b(null), e)
				}
				destroy() {
					document.removeEventListener("copy", this._boundOnCopy), document.removeEventListener("cut", this._boundOnCut), document.removeEventListener("paste", this._boundOnPaste)
				}
				_onCopyEv(e) {
					e.defaultPrevented || this._callbacks.copyRequested && this._callbacks.copyRequested(new f(e))
				}
				_onCutEv(e) {
					e.defaultPrevented || this._callbacks.cutRequested && this._callbacks.cutRequested(new f(e))
				}
				_onPasteEv(e) {
					e.defaultPrevented || this._callbacks.pasteRequested && this._callbacks.pasteRequested(new b(e))
				}
			} {
				_onCopyEv(e) {
					if (!C(e) && !w(e)) return super._onCopyEv(e)
				}
				_onCutEv(e) {
					if (!C(e) && !w(e)) return super._onCutEv(e)
				}
				_onPasteEv(e) {
					if (!C(e)) return super._onPasteEv(e)
				}
			}
			const P = () => i.e(54389).then(i.bind(i, 304830));

			function M(e, t = {}) {
				return P().then((i => i.copyToClipboardImageOfChart(e, t)))
			}

			function x(e, t = {}) {
				return P().then((i => i.getImageOfChartSilently(e, t)))
			}
			var I = i(470316),
				A = i(410864),
				k = i(262325),
				L = i.n(k),
				E = i(588948),
				D = i(388230);
			const N = (0, p.getLogger)("TimingsMeter.Service"),
				B = (0, p.getLogger)("TimingsMeter.Stats", {
					maxCount: 160
				});

			function O() {
				return {
					[D.InvalidationLevel.None]: {
						count: 0,
						lastTime: 0,
						maxTime: 0,
						totalTime: 0
					},
					[D.InvalidationLevel.Cursor]: {
						count: 0,
						lastTime: 0,
						maxTime: 0,
						totalTime: 0
					},
					[D.InvalidationLevel.Light]: {
						count: 0,
						lastTime: 0,
						maxTime: 0,
						totalTime: 0
					},
					[D.InvalidationLevel.Full]: {
						count: 0,
						lastTime: 0,
						maxTime: 0,
						totalTime: 0
					}
				}
			}

			function R(e, t) {
				e.lastTime = t, e.totalTime += t, ++e.count, t > e.maxTime && (e.maxTime = t)
			}

			function V(e) {
				return e.toFixed(2)
			}

			function W(e) {
				const t = e.count;
				if (0 === t) return "no events";
				const i = e.totalTime / t,
					s = V(e.maxTime);
				return `count=${t}, last=${V(e.lastTime)}, max=${s}, avg=${V(i)}`
			}
			class F {
				constructor(e) {
					this._waitDrawStartTime = -1, this._startDrawTime = -1, this._currentDrawLevel = D.InvalidationLevel.Full, this._currentDrawItems = O(), this._currentWaitingItem = {
						count: 0,
						lastTime: 0,
						maxTime: 0,
						totalTime: 0
					}, this._dumpTimingsStatsInterval = 0, this._logPrefix = `[${e}]`
				}
				destroy() {
					this.stopCollect()
				}
				startCollect() {
					0 !== this._dumpTimingsStatsInterval && (N.logWarn(`${this._logPrefix} Multiple start detected`), this.stopCollect()), this._clearCurrentState(), this._dumpTimingsStatsInterval = setInterval(this._dumpTimingsStats.bind(this), 15e3), N.logNormal(`${this._logPrefix} Collecting started`)
				}
				stopCollect() {
					0 !== this._dumpTimingsStatsInterval && (clearInterval(this._dumpTimingsStatsInterval), this._dumpTimingsStatsInterval = 0, N.logNormal(`${this._logPrefix} Collecting stopped. Dumping last state...`), this._dumpTimingsStats())
				}
				startWaitingDraw() {
					this._waitDrawStartTime = window.performance.now()
				}
				startDraw(e) {
					this._startDrawTime = window.performance.now(), this._currentDrawLevel = e
				}
				stopDraw() {
					const e = window.performance.now();
					if (-1 === this._startDrawTime || -1 === this._waitDrawStartTime) return;
					const t = this._startDrawTime - this._waitDrawStartTime;
					R(this._currentWaitingItem, t), this._waitDrawStartTime = -1;
					const i = e - this._startDrawTime;
					R(this._currentDrawItems[this._currentDrawLevel], i), this._startDrawTime = -1
				}
				_dumpTimingsStats() {
					const e = [this._logPrefix, " awaiting:", W(this._currentWaitingItem), "; cursor:", W(this._currentDrawItems[D.InvalidationLevel.Cursor]), "; light:", W(this._currentDrawItems[D.InvalidationLevel.Light]), "; full:", W(this._currentDrawItems[D.InvalidationLevel.Full])].join("");
					B.logNormal(e), this._clearCurrentState()
				}
				_clearCurrentState() {
					this._currentDrawItems = O(), this._currentWaitingItem = {
						count: 0,
						lastTime: 0,
						maxTime: 0,
						totalTime: 0
					}
				}
			}
			var z = i(648684),
				U = i(29084);

			function H(e) {
				return {
					...e,
					panes: (t = e.panes, t.map((e => {
						return {
							...e,
							sources: (t = e.sources, t.filter((e => !(0, U.isLineToolName)(e.type))))
						};
						var t
					})))
				};
				var t
			}

			function G(e, t) {
				var i;
				const s = e.find((e => e.tools.includes(t)));
				return null !== (i = null == s ? void 0 : s.id) && void 0 !== i ? i : null
			}

			function j(e) {
				var t, i;
				const o = e.panes.map((e => e.sources.filter((e => (0, U.isLineToolName)(e.type))))).reduce(((e, t) => t.concat(e)), []),
					r = null !== (i = null === (t = e.lineToolsGroups) || void 0 === t ? void 0 : t.groups) && void 0 !== i ? i : [],
					n = new Map;
				o.forEach((e => {
					const t = e.id;
					n.set(t, function(e, t) {
						var i;
						return {
							id: e.id,
							symbol: e.state.symbol,
							ownerSource: (0, s.ensureDefined)(e.ownerSource),
							state: e,
							groupId: null !== (i = G(t, e.id)) && void 0 !== i ? i : void 0
						}
					}(e, r))
				}));
				const a = new Map;
				return r.forEach((e => {
					const t = function(e, t) {
						var i, s;
						if (0 === e.tools.length) return null;
						const o = e.tools[0];
						return null !== (s = null === (i = t.get(o)) || void 0 === i ? void 0 : i.symbol) && void 0 !== s ? s : null
					}(e, n);
					null !== t && a.set(e.id, {
						id: e.id,
						name: e.name,
						symbol: t
					})
				})), {
					sources: n,
					groups: a
				}
			}
			var q = i(125226),
				K = i(174519),
				Y = i(405117),
				X = i(560507),
				Z = i(833813),
				$ = i(629588),
				Q = i(500521),
				J = i(175203),
				ee = i(314802),
				te = i(37704),
				ie = i(45696),
				se = i(594520),
				oe = i(246433),
				re = i(357547),
				ne = i(97639),
				ae = i.n(ne);

			function le(e) {
				const t = document.querySelector('link[rel~="chart-storage-notifications"]');
				return (null == t ? void 0 : t.href) ? e ? new URL(e, t.href) : new URL(t.href) : null
			}
			const ce = new(i(359663).FeatureToggleWatchedValue)("do_not_reload_line_tools_on_reconnection", !1);

			function he(e, t) {
				return Boolean(e.metaInfo.uid.value()) && !t.containsData && !t.onWidget && (0, q.isFeatureEnabled)("subscribe_line_tool_notifications") && function() {
					if (!(0, ee.isOnMobileAppPage)("new")) return !0;
					const e = /TradingView\/(\d+)\.(\d+)\.(\d+)\.?/.exec(navigator.userAgent);
					if (null === e) return !0;
					const t = Number(e[1]) - 1,
						i = Number(e[2]) - 15,
						s = Number(e[3]) - 0;
					if (t > 0 || 0 === t && i > 0 || 0 === t && 0 === i && s > 0) return !0;
					return !1
				}() && null !== le()
			}
			const de = (0, p.getLogger)("ChartStorageChangesSubscription");
			class ue extends te.PersistentEventSourceTransport {
				constructor(e, t) {
					super((e => this._onMessage(e))), this._destroyed = !1, this._onChangeVisibilityBound = this._onChangeVisibility.bind(this), this._hibernateTimerId = null, this._beforeUnhibernating = new(ae()), this._haveEverBeenHibernated = !1, this._chartWidgetsCollection = e, this._layoutVisibility = e.resizerBridge().visible.spawn(), this._layoutVisibility.subscribe(this._onChangeVisibilityBound, {
						callWithLast: !0
					}), J.telemetry.sendLineToolsStorageReport("line_tools_subscription_initial_connect"), this._connectionStatus.subscribe((e => {
						e === oe.ConnectionStatus.Closed && J.telemetry.sendLineToolsStorageReport("line_tools_subscription_disconnected")
					})), this._subscribeForSharingLayout = t, this.connect()
				}
				destroy() {
					var e;
					null === (e = this._layoutVisibility) || void 0 === e || e.destroy(), this.disconnect(), this._destroyed = !0
				}
				beforeUnhibernating() {
					return this._beforeUnhibernating
				}
				async _prepareParamsForConnection(e) {
					const t = this._chartWidgetsCollection.metaInfo.uid.value();
					if (this._destroyed) return Promise.reject("Subscription is being destroyed");
					const i = await (0, ie.getStorageTarget)(t, "", 0),
						s = le(`/charts-storage/layout/${t}/subscribe`);
					null !== s ? (s.searchParams.delete("jwt"), s.searchParams.append("jwt", i.token), (0, q.isFeatureEnabled)("subscribe_shared_line_tool_notifications") && this._subscribeForSharingLayout && window.user.id && s.searchParams.append("id", "" + window.user.id), this._url = s.toString()) : this._url = ""
				}
				_tryReconnectImpl() {
					super._tryReconnectImpl(), J.telemetry.sendLineToolsStorageReport("line_tools_subscription_reconnecting")
				}
				_onMessage(e) {
					if ("string" != typeof e) throw new Error("Wrong message type, expected string");
					const t = JSON.parse(e);
					Object.entries(t).forEach((e => {
						const t = (0, se.parseLineToolsAndGroupsDTO)(e[1], ""),
							i = e[0];
						let s = 0;
						i === ie.sharedChartId ? s = 1 : i === ie.globallySharedChartId && (s = 2), this._chartWidgetsCollection.applyLineToolUpdateNotification(i, t, s)
					}))
				}
				_onChangeVisibility() {
					const e = (0, s.ensureDefined)(this._layoutVisibility).value();
					e && this.connectionStatus().value() === oe.ConnectionStatus.Closed ? (this.connect(), this._beforeUnhibernating.fire(), this._haveEverBeenHibernated && (de.logNormal("Connect due to becoming visible"),
						J.telemetry.sendLineToolsStorageReport("line_tools_unhibenate_subscription"))) : e || (null !== this._hibernateTimerId && re.workerBasedTimers.clearTimeout(this._hibernateTimerId), this._hibernateTimerId = re.workerBasedTimers.setTimeout((() => this._disconnectIfInvisible()), 6e4))
				}
				_disconnectIfInvisible() {
					!(0, s.ensureDefined)(this._layoutVisibility).value() && (0, q.isFeatureEnabled)("hibernate_line_tool_notifications") && (de.logNormal("Disconnect due to becoming invisible"), this.disconnect(), J.telemetry.sendLineToolsStorageReport("line_tools_hibenate_subscription"), this._haveEverBeenHibernated = !0)
				}
			}
			var _e = i(850775),
				me = i(316017),
				pe = i(251954),
				ge = i(440135),
				Se = i(467608),
				ve = i(724377),
				fe = i(919346),
				be = i(377884),
				ye = i(824112),
				Ce = i(588427),
				we = i(208214),
				Te = i(938069),
				Pe = i(776351);
			const Me = (l.enabled("widget_logo"), !1);

			function xe(e, t = null, i = null) {
				let s = {};
				if ("number" == typeof e) return {
					relativePositions: {
						[e]: {
							l: t,
							t: i
						}
					},
					nextElementLeft: e,
					nextElementTop: e
				};
				const [o, ...r] = e;
				if ("v" === o) {
					let e = null;
					for (const o of r) {
						const r = xe(o, t, i);
						s = {
							...s,
							...r.relativePositions
						}, i = r.nextElementTop, e = r.nextElementLeft
					}
					t = e
				}
				if ("h" === o) {
					let e = null;
					for (const o of r) {
						const r = xe(o, t, i);
						s = {
							...s,
							...r.relativePositions
						}, t = r.nextElementLeft, e = r.nextElementTop
					}
					i = e
				}
				return {
					relativePositions: s,
					nextElementTop: i,
					nextElementLeft: t
				}
			}
			const Ie = function(e) {
				const t = {};
				for (const i of Object.keys(e)) {
					const s = xe(e[i]).relativePositions;
					t[i] = s
				}
				return t
			}(Te);

			function Ae(e, t, i, s) {
				let o = Math.round(10 * s),
					r = Math.round(10 * s);
				const n = i[e];
				if (null !== n.l) {
					const e = Ae(n.l, t, i, s);
					o = e.x + e.width + Math.round(5 * s)
				}
				if (null !== n.t) {
					const e = Ae(n.t, t, i, s);
					r = e.y + e.height + Math.round(5 * s)
				}
				const a = t[e];
				return {
					x: o,
					y: r,
					width: a.w,
					height: a.h
				}
			}

			function ke(e, t, i, s) {
				return (0, ye.drawScaled)(e, s, (() => {
					e.fillText(i, t.x / s, t.y / s)
				})), e.measureText(i).width * s
			}

			function Le(e) {
				return e.map((e => ({
					...e,
					title: ""
				})))
			}

			function Ee(e, t) {
				const i = [{
					text: e.trim()
				}];
				for (const e of t) e.visible && ("" !== i[i.length - 1].text && i.push({
					text: "  "
				}), e.title && i.push({
					text: e.title
				}), i.push({
					text: e.value,
					color: e.color
				}));
				return i
			}
			class De {
				constructor(e, t) {
					this._logoTextColor = null, this._snapshotData = e, t = t || {}, this._options = {
						backgroundColor: ge.themes[e.theme].getThemedColor("color-bg-primary"),
						borderColor: ge.themes[e.theme].getThemedColor("color-border"),
						font: Ce.CHART_FONT_FAMILY,
						fontSize: 12,
						legendMode: "vertical",
						hideResolution: !1,
						showHeaderPublishedBy: !1,
						showHeaderMainSymbol: !1,
						...t
					};
					const i = Ie[e.layout],
						s = e.charts.map((e => function(e) {
							const t = e.panes[0],
								i = t.canvas.width + t.leftAxis.canvas.width + t.rightAxis.canvas.width;
							let s = 0;
							for (const t of e.panes) s += t.canvas.height;
							return void 0 !== e.timeAxis && (s += e.timeAxis.canvas.height), new ye.Size(i, s)
						}(e)));
					if (this._pixelRatio = e.hidpiRatio, this._chartsGeometry = e.charts.map(((e, t) => Ae(t, s, i, this._pixelRatio))), !Me) {
						let i = e.theme;
						void 0 !== t.backgroundColor && (i = "black" === (0, ve.rgbToBlackWhiteString)((0, ve.parseRgb)(t.backgroundColor), 150) ? fe.StdTheme.Dark : fe.StdTheme.Light), this._logoTextColor = ge.themes[i].getThemedColor("color-text-primary")
					}
					this._headerDefaultTextColor = ge.themes[e.theme].getThemedColor("color-text-primary")
				}
				async getImage() {
					const e = this._pixelRatio;
					let t = 0,
						i = 0,
						s = 0;
					const r = this._headerItems();
					if (r.length > 0) {
						s = Math.ceil(1.4 * this._options.fontSize * e) * r.length
					}
					i += s;
					let n = 0,
						a = 0;
					for (const e of this._chartsGeometry) n = Math.max(n, e.x + e.width), a = Math.max(a, e.y + e.height);
					const l = i;
					t += n, i += a, t += Math.round(10 * e);
					const c = Me ? Math.round(10 * e) : Math.round(35 * e),
						h = i;
					i += c;
					const d = (0, ye.createDisconnectedCanvas)(document, new ye.Size(t, i), 1),
						u = (0, ye.getContext2D)(d);
					u.font = (0, we.makeFont)(this._options.fontSize, this._options.font), u.textBaseline = "top", u.fillStyle = this._options.backgroundColor, u.fillRect(0, 0, t, i), r.length > 0 && this._drawHeader(u, r, t, new o.Point(Math.round(10 * e), Math.round(10 * e)));
					for (let e = 0; e < this._snapshotData.charts.length; ++e) {
						const t = this._snapshotData.charts[e],
							i = this._chartsGeometry[e];
						this._drawChart(t, i, u, new o.Point(0, l))
					}
					if (null !== this._logoTextColor) {
						const t = await
						function(e, t, i) {
							var s;
							const o = (new DOMParser).parseFromString(Pe, "image/svg+xml");
							null === (s = null == o ? void 0 : o.firstElementChild) || void 0 === s || s.setAttribute("color", i);
							const r = URL.createObjectURL(new Blob([(new XMLSerializer).serializeToString(o)], {
								type: "image/svg+xml"
							}));
							return new Promise((i => {
								const s = new Image;
								s.width = e, s.height = t, s.onload = () => {
									i({
										image: s,
										width: e,
										height: t
									})
								}, s.src = r
							}))
						}(Math.round(20 * e), Math.round(15 * e), this._logoTextColor);
						u.fillStyle = this._logoTextColor, u.font = (0, we.makeFont)(13, Ce.CHART_FONT_FAMILY);
						const i = h + Math.round(c / 2 - t.height / 2);
						! function(e, t, i, s, o) {
							e.save(), e.drawImage(s.image, t, i, s.width, s.height), e.textBaseline = "bottom";
							const r = (t + s.width) / o + 3,
								n = (i + s.height) / o;
							(0, ye.drawScaled)(e, o, (() => {
								e.fillText("TradingView", r, n)
							})), e.restore()
						}(u, Math.round(10 * e), i, t, e)
					}
					return d
				}
				_drawChart(e, t, i, s) {
					i.save(), i.translate(t.x + s.x, t.y + s.y);
					let r = 0;
					for (const t of e.panes) {
						let s = 0;
						const n = t.leftAxis.canvas.width + Math.round(8 * this._pixelRatio),
							a = r,
							l = r + Math.round(10 * this._pixelRatio);
						t.leftAxis.contentWidth > 0 && (i.drawImage(t.leftAxis.canvas, s, r), s += t.leftAxis.canvas.width), i.drawImage(t.canvas, s, r), s += t.canvas.width, t.rightAxis.contentWidth > 0 && i.drawImage(t.rightAxis.canvas, s, r), "pane" === t.type && (i.fillStyle = e.colors.text, this._drawLegend(t, i, new o.Point(n, l), a)), r += t.canvas.height
					}
					if (void 0 !== e.timeAxis) {
						let t = 0;
						e.timeAxis.lhsStub.contentWidth > 0 && (i.drawImage(e.timeAxis.lhsStub.canvas, t, r), t += e.timeAxis.lhsStub.canvas.width), i.drawImage(e.timeAxis.canvas, t, r), t += e.timeAxis.canvas.width, e.timeAxis.rhsStub.contentWidth > 0 && i.drawImage(e.timeAxis.rhsStub.canvas, t, r)
					}
					i.strokeStyle = this._options.borderColor, i.strokeRect(0, 0, t.width, t.height), i.restore()
				}
				_headerItems() {
					var e, t, i, s;
					const o = [];
					if (this._options.showHeaderPublishedBy && this._snapshotData.publishedBy)
						for (const e of this._snapshotData.publishedBy) o.push([{
							text: e
						}]);
					if (this._options.showHeaderMainSymbol) {
						const r = this._snapshotData.charts[0],
							n = `${null===(e=r.meta)||void 0===e?void 0:e.symbol}, ${null===(t=r.meta)||void 0===t?void 0:t.resolution}`;
						o.push(Ee(n, null !== (s = null === (i = r.meta) || void 0 === i ? void 0 : i.values) && void 0 !== s ? s : []))
					}
					return o
				}
				_drawHeader(e, t, i, s) {
					e.save(), e.fillStyle = this._headerDefaultTextColor;
					const r = Math.ceil(1.4 * this._options.fontSize * this._pixelRatio);
					t.forEach(((t, n) => {
						this._drawLegendLine(e, new o.Point(s.x, s.y + r * n), i, t, !0)
					})), e.restore()
				}
				_drawLegend(e, t, i, s) {
					let r = !0;
					const n = Math.ceil(1.4 * this._options.fontSize * this._pixelRatio);
					let a = i.x,
						l = i.y;
					if (e.mainSeriesText && l + n < s + e.canvas.height) {
						const i = this._drawLegendLine(t, new o.Point(a, l), e.contentWidth * this._pixelRatio, Ee(e.mainSeriesText, e.mainSeriesValues), !0);
						"horizontal" !== this._options.legendMode ? l += n : (a = i + 1.4 * this._options.fontSize * this._pixelRatio, r = !1)
					}
					for (let c = 0; c < e.studies.length; ++c)
						if (l + n < s + e.canvas.height) {
							const s = e.studies[c],
								h = e.studiesValues[c];
							let d = null;
							for (; null === d;) d = this._drawLegendLine(t, new o.Point(a, l), e.contentWidth * this._pixelRatio, Ee(s, Le(h)), r), "horizontal" !== this._options.legendMode ? l += n : null === d ? (r = !0, a = i.x, l += n) : (a = d + 1.4 * this._options.fontSize * this._pixelRatio, r = !1)
						}
				}
				_drawLegendLine(e, t, i, s, r) {
					const n = s.map((e => e.text)).join("");
					let a = t.x;
					const l = function(e, t, i, s) {
						if (e.measureText(t).width * s <= i) return {
							text: t,
							elided: !1
						};
						const o = e.measureText("...").width * s,
							r = [];
						for (let e = 0; e < t.length; ++e) r.push(e);
						const n = (0, be.upperbound)(r, i, ((r, n) => e.measureText(t.slice(0, n + 1)).width * s + o > i));
						return {
							text: (t = t.slice(0, n)).trim(),
							elided: !0
						}
					}(e, n, i - a, this._pixelRatio);
					if (l.elided && !r) return null;
					const c = [];
					let h = 0;
					for (const e of s) {
						if (h + e.text.length > l.text.length) break;
						c.push(e.text), h += e.text.length
					}
					const d = c.join("").trim().length;
					h = 0;
					for (const i of s) {
						if (h + i.text.length > d) break;
						i.color && (e.save(), e.fillStyle = i.color), a += ke(e, new o.Point(a, t.y), i.text, this._pixelRatio), i.color && e.restore(), h += i.text.length
					}
					return l.elided && (a += ke(e, new o.Point(a, t.y), "...", this._pixelRatio)), a
				}
			}
			var Ne = i(95935);
			i(483306), i(308170), i(740204), i(721386), i(218718), i(220422), i(668004);
			i(443275);
			i(919250);
			var Be = i(581996),
				Oe = i(674996),
				Re = i(351728),
				Ve = i(746511),
				We = i(830484),
				Fe = i(125082);
			const ze = new n.TranslatedString("change chart layout to {title}", (0, r.t)("change chart layout to {title}"));
			class Ue extends d.UndoCommand {
				constructor(e, t) {
					super(ze.format({
						title: Se.layouts[t].title
					})), this._chartWidgetCollection = e, this._newLayoutType = t, this._oldLayoutType = e.layout.value()
				}
				redo() {
					this._chartWidgetCollection.setLayout(this._newLayoutType)
				}
				undo() {
					this._chartWidgetCollection.setLayout(this._oldLayoutType)
				}
			}
			var He = i(270617),
				Ge = i(909740);
			const je = new n.TranslatedString("apply toolbars theme", (0, r.t)("apply toolbars theme"));
			class qe extends d.UndoCommand {
				constructor(e, t, i = !0) {
					super(je), this._prevThemeName = e, this._themeName = t, this._syncState = i
				}
				undo() {
					(0, ge.isStdThemeName)(this._prevThemeName) && ((0, Ge.setTheme)(this._prevThemeName), this._syncState && (0, ge.syncTheme)())
				}
				redo() {
					(0, ge.isStdThemeName)(this._themeName.toLowerCase()) && ((0, Ge.setTheme)(this._themeName.toLowerCase()), this._syncState && (0, ge.syncTheme)())
				}
			}
			var Ke = i(10048);
			const Ye = !a.CheckMobile.any(),
				Xe = new n.TranslatedString("apply indicators to entire layout", (0, r.t)("apply indicators to entire layout")),
				Ze = new n.TranslatedString("sync time", (0, r.t)("sync time")),
				$e = new n.TranslatedString("resize layout", (0, r.t)("resize layout")),
				Qe = new n.TranslatedString("reset layout sizes", (0, r.t)("reset layout sizes")),
				Je = new n.TranslatedString("apply chart theme", (0, r.t)("apply chart theme")),
				et = (0, r.t)("Please give us a clipboard writing permission in your browser or press {keystroke}"),
				tt = (0, r.t)("Couldn't copy"),
				it = (0, r.t)("Couldn't cut"),
				st = (0, r.t)("Couldn't paste"),
				ot = (0, r.t)("{userName} published on {customer}, {date}"),
				rt = (0, r.t)("Published on {customer}, {date}");

			function nt(e, t) {
				const i = t.model().model().studyTemplate();
				e.undoHistory.beginUndoMacro(Xe);
				for (let s = 0; s < e.chartWidgetsDefs.length; s++) {
					const o = e.chartWidgetsDefs[s].chartWidget;
					o !== t && (o.hasModel() && o.model().applyStudyTemplate(i, ""))
				}
				e.undoHistory.endUndoMacro()
			}

			function at(e, t, i, o, r) {
				e.undoHistory.beginUndoMacro(r);
				for (let n = 0; n < e.chartWidgetsDefs.length; n++) {
					const a = e.chartWidgetsDefs[n].chartWidget;
					if (a !== t && a && a.hasModel()) {
						const t = a.model();
						let n;
						if (o.isOnMainPane) n = (0, s.ensureNotNull)(t.model().paneForSource(a.model().model().mainSeries()));
						else {
							const i = new u(t.model(), o.paneIndex);
							e.undoHistory.pushUndoCommand(i);
							const r = (0, s.ensureDefined)(i.createdPaneId());
							n = (0, s.ensureDefined)(t.model().panes().find((e => e.id() === r)))
						}
						const l = t.pasteSourceFromClip(n, i, !0);
						if (l && 1 === l.length) {
							const e = l[0];
							if (o.asCompare) {
								const i = (0, s.ensureNotNull)(t.mainSeries().priceScale());
								t.moveToScale(e, (0, s.ensureDefined)(n), i, r), t.setPriceScaleMode({
									percentage: !0
								}, i, null)
							}
						}
						t.model().lightUpdate()
					}
				}
				e.undoHistory.endUndoMacro()
			}

			function lt(e) {
				let t = 1;
				for (; e.has("" + t);) t++;
				return "" + t
			}

			function ct(e) {
				const t = new Map,
					i = e.chartsCountToSave(),
					s = new Set;
				for (let o = 0; o < i; o++)
					if (o < e.chartWidgetsDefs.length) {
						const i = e.chartWidgetsDefs[o].chartWidget,
							r = i.id(),
							n = i.lineToolsAndGroupsDTO();
						t.set(r, n), s.add(r)
					} else {
						const i = e.savedChartWidgetOptions[o - e.chartWidgetsDefs.length].content;
						i.chartId || (i.chartId = lt(s));
						const r = new Map;
						r.set(0, j(i)), t.set(i.chartId, r), s.add(i.chartId)
					} return t
			}

			function ht(e, t, i, s, o, r) {
				if (t < e.chartWidgetsDefs.length) {
					const n = e.chartWidgetsDefs[t].chartWidget;
					return t < e.actualLayoutCount() || n.shouldBeSavedEvenIfHidden() ? n.state(i, s, o, r) : null
				}
				return function(e, t, i, s, o) {
					return o && (0, q.isFeatureEnabled)("migrate_unloaded_charts") ? H(e) : e
				}(e.savedChartWidgetOptions[t - e.chartWidgetsDefs.length].content, 0, 0, 0, r)
			}

			function dt(e, t) {
				return t < e.chartWidgetsDefs.length ? e.chartWidgetsDefs[t].chartWidget.asyncState() : Promise.resolve({})
			}

			function ut(e, t) {
				return e.chartWidgetsDefs[0].chartWidget === t
			}

			function _t(e) {
				return e.savedChartWidgetOptions.map((e => (0, s.ensureDefined)(e.content.chartId)))
			}

			function mt(e, t, i) {
				const s = e.chartsCountToSave();
				i.forEach((i => {
					const s = (o = i.chartId, null !== (n = null === (r = e.chartWidgetsDefs.find((e => e.chartWidget.id() === o))) || void 0 === r ? void 0 : r.chartWidget) && void 0 !== n ? n : null);
					var o, r, n;
					null == s || s.resetLineToolsInvalidated(t, i.savedDto, i.sharingMode)
				}));
				for (let t = e.chartWidgetsDefs.length; t < s; t++) {
					const i = H(e.savedChartWidgetOptions[t - e.chartWidgetsDefs.length].content);
					e.savedChartWidgetOptions[t - e.chartWidgetsDefs.length].content = i
				}
			}

			function pt(e, t, i, s) {
				const o = e.map((e => e.chartWidget));
				o.forEach((e => e.startApplyingLineToolUpdateNotification()));
				try {
					o.filter((e => e.id() === t || 0 !== s)).forEach((e => e.applyLineToolUpdateNotification(i, s)))
				} finally {
					o.forEach((e => e.endApplyingLineToolUpdateNotification()))
				}
			}

			function gt(e) {
				return e instanceof Error ? e.message : null
			}

			function St(e) {
				return new T({
					copyRequested: (t, i) => {
						e.activeChartWidget.value().model().clipboardCopy(t, i).catch((t => {
							var i;
							null === (i = e.toastsFactory) || void 0 === i || i.getChartToasts().then((e => {
								var i;
								(0, s.ensureNotNull)(e).showSimpleToast({
									title: tt,
									text: null !== (i = gt(t)) && void 0 !== i ? i : et.format({
										keystroke: (0, I.humanReadableHash)(I.Modifiers.Mod + 67)
									}),
									role: "alert",
									intent: A.ToastIntent.Warning
								})
							}))
						}))
					},
					cutRequested: (t, i) => {
						e.activeChartWidget.value().model().clipboardCut(t, i).catch((t => {
							var i;
							null === (i = e.toastsFactory) || void 0 === i || i.getChartToasts().then((e => {
								var i;
								(0, s.ensureNotNull)(e).showSimpleToast({
									title: it,
									text: null !== (i = gt(t)) && void 0 !== i ? i : et.format({
										keystroke: (0, I.humanReadableHash)(I.Modifiers.Mod + 88)
									}),
									role: "alert",
									intent: A.ToastIntent.Warning
								})
							}))
						}))
					},
					pasteRequested: (t, i) => {
						(i ? i.model().undoModel() : e.activeChartWidget.value().model()).clipboardPaste(t, i).catch((t => {
							var i;
							null === (i = e.toastsFactory) || void 0 === i || i.getChartToasts().then((e => {
								var i;
								(0, s.ensureNotNull)(e).showSimpleToast({
									title: st,
									text: null !== (i = gt(t)) && void 0 !== i ? i : et.format({
										keystroke: (0, I.humanReadableHash)(I.Modifiers.Mod + 86)
									}),
									role: "alert",
									intent: A.ToastIntent.Warning
								})
							}))
						}))
					}
				})
			}

			function vt(e, t) {
				(0, K.setBroker)(t), e.chartWidgetsDefs.forEach((e => {
					var i;
					return null === (i = e.chartWidget) || void 0 === i ? void 0 : i.setBroker(t)
				}))
			}

			function ft(e) {
				const t = {};
				return e.chartWidgetsDefs.map((e => e.chartWidget)).forEach((e => t[e.id()] = function(e) {
					var t, i;
					const s = {},
						o = e.model().mainSeries(),
						r = o.properties().childs(),
						n = o.symbolInfo();
					s.resolution = r.interval.value(), s.symbol_type = null !== n && n.type || "", s.exchange = null !== n && n.exchange || "", s.listed_exchange = null !== n && n.listed_exchange || "";
					const a = null !== (t = null == n ? void 0 : n.legs) && void 0 !== t ? t : [];
					if (null !== n && o.isSpread()) {
						const e = a[0];
						let t = n.base_name[0];
						t = t.split(":")[1], s.symbol = e, s.short_name = t, s.expression = n.full_name
					} else s.symbol = null !== n && n.ticker || r.symbol.value(), s.short_name = r.shortName.value();
					const l = null !== (i = null == n ? void 0 : n.base_name) && void 0 !== i ? i : [];
					return s.legs = a.map(((e, t) => ({
						symbol: e,
						pro_symbol: l[t]
					}))), s
				}(e))), t
			}

			function bt(e, t) {
				if (he(e, t.widgetOptions)) {
					const i = new ue(e, !e.readOnly());
					i.beforeUnhibernating().subscribe(e, (() => {
						ce.value() || function(e) {
							e.chartWidgetsDefs.map((e => e.chartWidget)).forEach((e => e.reloadAllLineTools()))
						}(t)
					})), t.setChartStorageNotificationSubscription(i)
				}
			}

			function yt(e, t) {
				const i = {
					snapshotUrl: e
				};
				return i.asyncSave = !window.TVD, x(t, i).then((e => ((0, pe.emit)("onScreenshotReady", e), e)))
			}

			function Ct(e, t) {
				const i = {
					snapshotUrl: e
				};
				i.asyncSave = !window.TVD;
				const s = (0, ee.isOnMobileAppPage)("any");
				return (s ? x : M)(t, i).then((e => ((0, pe.emit)("onScreenshotReady", e), s || (0, pe.emit)("onServerScreenshotCopiedToClipboard"), e)))
			}

			function wt(e) {
				return function(e) {
					return P().then((t => t.downloadClientScreenshot(e)))
				}(e)
			}

			function Tt(e) {
				return function(e) {
					return P().then((t => t.copyToClipboardClientScreenshot(e)))
				}(e).then((() => {
					(0, pe.emit)("onClientScreenshotCopiedToClipboard")
				}))
			}

			function Pt(e, t, i, s) {
				const o = Math.max(1, window.devicePixelRatio || 1),
					r = e.getAll();
				let n; {
					const s = t || "TradingView.com";
					let o = e.activeChartWidget.value().properties().childs().timezone.value();
					if ("exchange" === o) {
						const t = e.activeChartWidget.value().model().mainSeries().symbolInfo();
						o = t ? t.timezone : o
					}
					const r = {
							timezone: o,
							dateFormat: "MMM dd, yyyy"
						},
						a = new me.DateTimeWithTzFormatter(r).format(Date.now() / 1e3),
						l = e.metaInfo.username.value(),
						c = !l || e.readOnly() || i ? rt : ot,
						h = [c.split(/{date}/)[0].format({
							userName: l,
							customer: s
						}).trim(), a],
						d = [c.format({
							userName: l,
							customer: s,
							date: a
						}).trim()];
					n = _e.mediaState.isPhoneSizeDevice() ? h : d
				}
				const a = e.maximizedChartWidget();
				if (s && s.onlyActiveChart || a) return {
					layout: "s",
					hidpiRatio: o,
					theme: (0, ge.getCurrentTheme)().name,
					charts: [e.activeChartWidget.value().images(s)],
					publishedBy: n
				};
				const l = [],
					c = Se.layouts[e.layout.value()].count,
					h = {
						showCollapsedStudies: (s = s || {}).showCollapsedStudies,
						status: s.status
					};
				for (let e = 0; e < r.length && e < c; e++) l.push(r[e].images(h));
				return {
					layout: e.layout.value(),
					hidpiRatio: o,
					theme: (0, ge.getCurrentTheme)().name,
					charts: l,
					publishedBy: n
				}
			}

			function Mt(e, t, i, s) {
				const o = s || {},
					r = {
						hideResolution: Boolean(o.hideResolution)
					};
				return o.showHeaderPublishedBy = !0, async function(e, t) {
					return new De(e, t).getImage()
				}(Pt(e, t, i, {
					showCollapsedStudies: !1,
					status: r
				}), o)
			}

			function xt(e) {
				var t, i, s, o, r, n;
				const a = (null !== (t = e.options.edge) && void 0 !== t ? t : 0) + (null !== (i = e.options.border) && void 0 !== i ? i : 0),
					l = null !== (o = null === (s = e.bottomToolbar.value()) || void 0 === s ? void 0 : s.offsetHeight) && void 0 !== o ? o : 0,
					c = null !== (n = null === (r = e.replayContainer) || void 0 === r ? void 0 : r.offsetHeight) && void 0 !== n ? n : 0;
				return {
					width: e.widthWV.value() - 2 * a,
					height: e.heightWV.value() - l - c - a,
					top: 0,
					left: a
				}
			}

			function It(e) {
				return `chart-widget-collection-border-${e}`
			}
			class At {
				constructor(e, t, i) {
					this._onShiftPressed = e => {
						const t = this._state.currentLayoutResizeAction.value();
						t && this._applyMouseMove(t.delta, e)
					}, this._state = e, this._splitterElement = t, this._splitter = i, (0, Fe.shiftPressed)().subscribe(this._onShiftPressed)
				}
				destroy() {
					(0, Fe.shiftPressed)().unsubscribe(this._onShiftPressed)
				}
				mouseDownEvent(e) {
					this._mouseDownOrTouchStartEvent(e)
				}
				touchStartEvent(e) {
					this._mouseDownOrTouchStartEvent(e)
				}
				pressedMouseMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				touchMoveEvent(e) {
					this._pressedMouseOrTouchMoveEvent(e)
				}
				mouseUpEvent(e) {
					this._mouseUpOrTouchEndEvent(e)
				}
				touchEndEvent(e) {
					this._mouseUpOrTouchEndEvent(e)
				}
				mouseEnterEvent(e) {
					this._highlightSplitters(e.shiftKey)
				}
				mouseLeaveEvent(e) {
					const t = It(this._splitter.className);
					Array.from(this._state.parent.getElementsByClassName(t)).forEach((e => e.classList.remove(Ke.hovered)))
				}
				mouseDoubleClickEvent(e) {
					const t = (0, Re.layoutInitialSizingState)(this._state.layoutTemplate.value().expression);
					this._state.undoHistory.beginUndoMacro(Qe), this._state.undoHistory.pushUndoCommand(new m(this._state.sizingState.spawn(), this._state.sizingState.value(), t, Qe));
					const i = this._state.layoutTemplate.value().layoutType;
					this._state.undoHistory.pushUndoCommand(new _((e => e ? this._state.allLayoutSizesState.set(i, e) : this._state.allLayoutSizesState.delete(i)), this._state.allLayoutSizesState.get(this._state.layoutTemplate.value().layoutType), t, Qe)), this._state.undoHistory.endUndoMacro()
				}
				_highlightSplitters(e) {
					const t = It(this._splitter.className);
					Array.from(this._state.parent.getElementsByClassName(t)).forEach((e => e.classList.remove(Ke.hovered)));
					(e ? Array.from(this._state.parent.getElementsByClassName(t)) : [this._splitterElement]).forEach((e => e.classList.add(Ke.hovered)))
				}
				_mouseDownOrTouchStartEvent(e) {
					const t = new o.Point(e.localX + this._splitterElement.offsetLeft, e.localY + this._splitterElement.offsetTop),
						i = (0, Ve.deepCopy)(this._state.sizingState.value());
					this._state.currentLayoutResizeAction.setValue({
						point: t,
						splitter: this._splitter,
						initialState: i,
						alignedState: this._state.layoutTemplate.value().syncSublayoutsBySplitter(this._splitter, (0, Ve.deepCopy)(i)),
						shiftState: e.shiftKey,
						delta: 0
					}), this._splitterElement.classList.add(Ke["i-active"]), this._highlightSplitters(e.shiftKey)
				}
				_pressedMouseOrTouchMoveEvent(e) {
					const t = this._state.currentLayoutResizeAction.value();
					if (!t) return;
					t.shiftState !== e.shiftKey && (this._highlightSplitters(e.shiftKey), t.shiftState = e.shiftKey);
					const i = new o.Point(e.localX + this._splitterElement.offsetLeft, e.localY + this._splitterElement.offsetTop);
					t.delta = "v" === t.splitter.orientation ? i.y - t.point.y : i.x - t.point.x, this._applyMouseMove(t.delta, e.shiftKey)
				}
				_mouseUpOrTouchEndEvent(e) {
					const t = this._state.currentLayoutResizeAction.value();
					if (t && (this._splitterElement.classList.remove(Ke["i-active"]), this._state.currentLayoutResizeAction.setValue(null), t.currentState)) {
						this._state.undoHistory.beginUndoMacro($e), this._state.undoHistory.pushUndoCommand(new m(this._state.sizingState.spawn(), t.initialState, t.currentState, $e));
						const e = this._state.layoutTemplate.value().layoutType;
						this._state.undoHistory.pushUndoCommand(new _((t => t ? this._state.allLayoutSizesState.set(e, t) : this._state.allLayoutSizesState.delete(e)), this._state.allLayoutSizesState.get(this._state.layoutTemplate.value().layoutType), this._state.sizingState.value(), Qe)), this._state.undoHistory.endUndoMacro(), this._state.layoutSizesChanged.setValue(!0)
					}
				}
				_applyMouseMove(e, t) {
					var i;
					const o = (0, s.ensureNotNull)(this._state.currentLayoutResizeAction.value()),
						r = t ? o.alignedState : o.initialState,
						n = null !== (i = this._state.options.padding) && void 0 !== i ? i : 2,
						a = xt(this._state);
					o.currentState = this._state.layoutTemplate.value().resizeApplier(a, n, e, o.splitter, (0, Ve.deepCopy)(r), t), this._state.sizingState.setValue(o.currentState)
				}
			}

			function kt(e, t, i, s, o) {
				var r, n;
				const a = null !== (r = e.options.padding) && void 0 !== r ? r : 2,
					l = null !== (n = e.options.border) && void 0 !== n ? n : 0;
				o = null != o ? o : e.layoutTemplate.value();
				const c = xt(e),
					h = o.sizer(c, i, s, a + l, Ye ? e.sizingState.value() : void 0);
				h.width = Math.max(Math.round(h.width), 0), h.height = Math.max(Math.round(h.height), 0), h.top = Math.round(h.top), h.left = Math.round(h.left), t.metrics = h;
				const d = t.container.value();
				if (d) {
					d.style.width = h.width + "px", d.style.height = h.height + "px", d.style.top = h.top + "px", d.style.left = h.left + "px";
					const e = 1 === s;
					d.classList.toggle("single-visible", e);
					const t = Math.round(c.width),
						i = 0 === h.top && 0 === h.left,
						o = 0 === h.top && h.left + h.width === t,
						r = 0 === h.top && h.width === t;
					d.classList.toggle("top-left-chart", !e && !r && i), d.classList.toggle("top-right-chart", !e && !r && o), d.classList.toggle("top-full-width-chart", e || r)
				}
				t.width.setValue(h.width), t.height.setValue(h.height)
			}

			function Lt(e) {
				var t, i, s;
				let o;
				const r = e.layoutTemplate.value(),
					n = e.maximizedChartDef.value();
				if (o = n ? [n] : e.chartWidgetsDefs.slice(0, r.count).filter((e => !e.hiddenInLayout.value())), o.forEach(((t, i) => kt(e, t, i, o.length))), Ye && !e.maximizedChartDef.value()) {
					const o = xt(e),
						n = null !== (t = e.options.padding) && void 0 !== t ? t : 2,
						a = null !== (i = e.options.border) && void 0 !== i ? i : 0,
						l = r.splitters(o, n + a, e.sizingState.value()),
						c = null !== (s = e.splitters.value()) && void 0 !== s ? s : [];
					c.forEach(((e, t) => {
						t >= l.length && (e.splitterElement.remove(), e.mouseHandler.destroy(), e.mouseListener.destroy())
					}));
					const h = l.map(((t, i) => {
						const s = i < c.length ? c[i].splitterElement : document.createElement("div");
						let o, r;
						i < c.length ? (o = c[i].mouseListener, r = c[i].mouseHandler) : (o = new At(e, s, t), r = new We.MouseEventHandler(s, o));
						const n = t.metrics,
							a = s.classList.contains(Ke.hovered),
							l = s.classList.contains(Ke["i-active"]);
						return s.className = "", s.classList.add(Ke.chartsSplitter), s.classList.add(It(t.className)), a && s.classList.add(Ke.hovered), l && s.classList.add(Ke["i-active"]), s.style.left = n.left + "px", s.style.top = n.top + "px", s.style.width = n.width + "px", s.style.height = n.height + "px", "v" === t.orientation ? s.style.cursor = "ns-resize" : s.style.cursor = "ew-resize", e.parent.appendChild(s), {
							splitter: t,
							splitterElement: s,
							mouseHandler: r,
							mouseListener: o
						}
					}));
					e.splitters.setValue(h)
				}
			}

			function Et(e, t, i) {
				const s = e.chartWidgetsDefs.slice(0, e.layoutTemplate.value().count).map(((t, i, s) => ({
					def: t,
					metrics: e.layoutTemplate.value().sizer({
						top: 0,
						left: 0,
						width: 256,
						height: 256
					}, i, s.length, 0)
				}))).sort(((e, t) => e.metrics.top - t.metrics.top || e.metrics.left - t.metrics.left)).map((e => e.def));
				if (s.length < 2) return null;
				let o = s.indexOf(t);
				return -1 === o ? null : (o = (o + (i ? s.length - 1 : 1)) % s.length, s[o])
			}

			function Dt(e, t) {
				return e.chartWidgetsDefs.some((e => {
					var i;
					return (null === (i = e.chartWidget) || void 0 === i ? void 0 : i.id()) === t
				}))
			}

			function Nt(e) {
				let t = 1;
				for (; e("" + t);) t++;
				return "" + t
			}

			function Bt(e) {
				const t = e.activeChartWidget.value();
				if (t) {
					const i = t.state();
					return i.chartId = Nt((t => Dt(e, t))), i.shouldBeSavedEvenIfHidden = !1, {
						content: i
					}
				}
			}

			function Ot(e, t, i) {
				const s = [];
				if (null == i ? void 0 : i.publishedChartsEnabled) {
					const i = new z.PublishedChartsTimeline(e, (e => function(e, t) {
						e = {
							...e,
							chartWidgetCollection: t
						}, (0, Q.pushChartPage)(e)
					}(e, t)));
					s.push(i)
				}
				return s
			}

			function Rt(e, t, i) {
				const o = e.toastsFactory;
				let r = {
					chartWidgetCollection: t,
					isActive: 0 === e.chartWidgetsDefs.length,
					barsMarksContainersFactory: i => Ot(i, t, e.options),
					undoHistory: e.undoHistory,
					readOnly: e.readOnly,
					initialLoading: e.initialLoading,
					getToasts: o ? () => o.getChartToasts() : void 0,
					...null != i ? i : {}
				};
				void 0 !== e.customLegendWidgetsFactoriesMap && (r.customLegendWidgetFactories = new Map(e.customLegendWidgetsFactoriesMap));
				const n = document.createElement("div");
				n.classList.add("chart-container"), n.style.position = "absolute", n.style.overflow = "hidden", e.parent.appendChild(n), a.isEdge && (n.style.touchAction = "none", n.style.msTouchAction = "none"), r.className && n.classList.add(r.className);
				const l = {
					alive: new(L())(!0),
					container: new(L())(n),
					width: new(L()),
					height: new(L()),
					collapsed: new(L())(!1),
					hiddenInLayout: new(L())(!1),
					visible: new(L()),
					rdState: new Be.ResizerDetacherState,
					requestFullscreen: () => {
						e.globalDetachable.value() && (e.setMaximized(l), e.activeChartWidget.setValue((0, s.ensureNotNull)(l.chartWidget)))
					},
					exitFullscreen: () => {
						e.activeChartWidget.value() === l.chartWidget && e.setMaximized(null)
					},
					detachable: e.globalDetachable,
					fullscreenable: e.globalDetachable,
					fullscreen: new(L()),
					chartWidget: null
				};
				l.rdState.pushOwner(l), e.chartWidgetsDefs.push(l);
				const c = () => {
					l.visible.setValue(!l.hiddenInLayout.value() && e.options.resizerBridge.visible.value())
				};
				l.hiddenInLayout.subscribe((() => {
						(0, s.ensureNotNull)(l.chartWidget).setVisible(!l.hiddenInLayout.value()), c()
					})), l.collapsed.subscribe((() => (0, s.ensureNotNull)(l.chartWidget).setCollapsed(l.collapsed.value()))), e.options.resizerBridge.visible.subscribe(c), c(),
					function(e, t) {
						let i = 0,
							s = 0;
						const o = t.layoutTemplate.value();
						for (let r = 0; r < o.count; r++) t.chartWidgetsDefs[r] === e && (s = i), i++;
						kt(t, e, s, i, o)
					}(l, e), r = {
						...r,
						...l.rdState.bridge()
					};
				const h = r.content ? (0, s.ensureDefined)(r.content.chartId) : Nt((t => Dt(e, t))),
					d = new Oe.ChartWidget(r, h, t.metaInfo.uid.value());
				return l.chartWidget = d, e.saveChartService && l.chartWidget.setSaveChartService(e.saveChartService), e.readOnly || (l.timingsMeter = new F(String(e.chartWidgetsDefs.length - 1)), l.chartWidget.setTimingsMeter(l.timingsMeter)), r.containsData ? d.finishInitWithoutConnect() : d.connect(), d.withModel(null, (() => {
					const t = d.model().model();
					e.customSources.forEach(((e, i) => {
						t.addCustomSource(i, e.factory, e.layer)
					}))
				})), e.updateWatchedValue(), e.updateActivityView(), e.chartWidgetCreatedDelegate.fire(d), l
			}

			function Vt(e, t, i, s) {
				const o = {
						...e.widgetOptions,
						...e.savedChartWidgetOptions.shift() || Bt(e),
						...0 === i || e.symbolLock.value() ? void 0 : {
							defSymbol: null
						}
					},
					r = Rt(e, t, o),
					n = r.chartWidget;
				return n.modelCreated().subscribe(null, (() => {
					s ? s() : e.checkAllPendingModelsAlreadyCreated(), e.dateRangeLock.value() && n === e.activeChartWidget.value() && e.subscribeToCompletedEventForDateRangeSync(n, !0)
				}), !0), r
			}

			function Wt(e) {
				e.hiddenInLayout.setValue(!0);
				const t = e.container.value();
				t.parentNode && t.parentNode.removeChild(t), e.fullscreen.setValue(!1)
			}

			function Ft(e, t) {
				e.chartWidgetsDefs.forEach((i => {
					const o = (0, s.ensureNotNull)(i.chartWidget);
					o.onZoom().unsubscribeAll(t),
						o.onScroll().unsubscribeAll(t), o.withModel(null, (() => {
							const t = o.lineToolsSynchronizer();
							null !== t && (t.hasChanges().unsubscribe(e.recalcHasChanges), e.recalcHasChanges())
						}))
				}))
			}
			async function zt(e, t, i) {
				var o, r; {
					const e = ["2-3", "5h", "6h", "7h", "8h"];
					(0, E.getInitData)().is_mobile_new && e.includes(t) && !(0, l.enabled)("mobile_app_supports_new_layout_types") && (t = "s")
				}
				const n = e.chartWidgetsDefs.map((e => {
					var t, i, s;
					return null !== (s = null === (i = null === (t = e.chartWidget) || void 0 === t ? void 0 : t.lineToolsSynchronizer()) || void 0 === i ? void 0 : i.flushPendingSavings()) && void 0 !== s ? s : null
				})).filter(He.notNull);
				n.length && await Promise.all(n), (t = e.checkProFeature(t)) in Se.layouts || (t = "s"), Ft(e, i);
				const a = e.layoutType,
					c = Se.layouts[t].count;
				(0, pe.emit)("layout_about_to_be_changed", t), (null !== (o = e.splitters.value()) && void 0 !== o ? o : []).forEach(((e, t) => {
					e.splitterElement.remove(), e.mouseHandler.destroy()
				})), e.splitters.setValue([]);
				const d = Se.layouts[t];
				e.layoutTemplate.setValue(d);
				const u = null !== (r = e.allLayoutSizesState.get(d.layoutType)) && void 0 !== r ? r : (0, Re.layoutInitialSizingState)(d.expression);
				e.allLayoutSizesState.set(d.layoutType, u), e.sizingState.setValue(u);
				const _ = e.maximizedChartDef.value();
				if (e.isPhoneSize.value() && e.viewMode.value() === h.CollectionViewMode.ForceFullscreen)
					if (_) {
						const t = e.chartWidgetsDefs.indexOf(_);
						(t < 0 || t >= c) && e.maximizedChartDef.setValue(e.chartWidgetsDefs[0])
					} else e.maximizedChartDef.setValue(e.chartWidgetsDefs[0]);
				else a !== t && e.maximizedChartDef.value() && e.maximizedChartDef.setValue(null);
				_ && e.activeChartWidget.setValue((0, s.ensureNotNull)(_.chartWidget));
				for (let t = 0; t < c || t < e.chartWidgetsDefs.length; t++) {
					let o, r = e.chartWidgetsDefs[t];
					const n = t >= c;
					if (o = e.maximizedChartDef.value() ? e.maximizedChartDef.value() === r : t < c, o) {
						if (r) {
							if (e.parent.appendChild(r.container.value()), r.hiddenInLayout.setValue(!1), e.loadingContent) {
								const t = e.savedChartWidgetOptions.shift();
								t && (e.setLoadingContent(!0), (0, s.ensureNotNull)(r.chartWidget).loadContent(t.content, e.initialLoading), e.setLoadingContent(!1))
							}
						} else Vt(e, i, t, void 0), r = e.chartWidgetsDefs[t];
						r.container.value().classList.toggle("multiple", c > 1), r.fullscreen.setValue(e.maximizedChartDef.value() === r), r.collapsed.setValue(n)
					} else r ? (Wt(r), r.collapsed.setValue(n)) : e.isPhoneSize.value() && e.viewMode.value() === h.CollectionViewMode.ForceFullscreen && (Vt(e, i, t, void 0), Wt(e.chartWidgetsDefs[t]), e.chartWidgetsDefs[t].collapsed.setValue(n))
				}
				e.sizingState.setValue(u), Lt(e), e.layoutWV.setValue(t), e.setLayoutType(t), e.updateWatchedValue(),
					function(e) {
						const t = e.layoutTemplate.value().count;
						e.inlineChartsCount.setValue(t), e.globalDetachable.setValue(t > 1)
					}(e), e.checkAllPendingModelsAlreadyCreated(),
					function(e, t) {
						e.chartWidgetsDefs.forEach((i => {
							const o = (0, s.ensureNotNull)(i.chartWidget);
							o.onZoom().subscribe(t, (t => e.onZoom.fire(t))), o.onScroll().subscribe(t, (() => e.onScroll.fire())), o.withModel(null, (() => {
								const t = o.lineToolsSynchronizer();
								null !== t && (t.hasChanges().subscribe(e.recalcHasChanges), e.recalcHasChanges())
							}))
						}))
					}(e, i), e.initialLoading || e.updateViewMode(),
					e.inlineChartsCount.value() < 1 && c > 0 && e.chartWidgetsDefs[c - 1].rdState.bridge().attach()
			}

			function Ut(e, t, i, s, o) {
				if (!s && !e.crosshairLockRaw) return !1;
				const r = e.actualLayoutCount();
				return e.chartWidgetsDefs.slice(0, r).filter((e => e.rdState.bridge().visible.value())).map((e => e.chartWidget)).filter((e => e.id() !== i && e.hasModel())).forEach((e => e.model().model().setExternalPosition(t, o))), !0
			}

			function Ht(e, t, i, s, o) {
				if (Ut(e, t, i, s, o)) {
					const i = e.crossHairSyncBroadcast;
					if (i) {
						const e = {
							type: "crosshair",
							payload: {
								point: t,
								envState: o,
								sourceUniqueId: i.uniqueId
							}
						};
						i.channel.postMessage(e)
					}
				}
			}

			function Gt(e) {
				const t = new BroadcastChannel("ChartWidgetsCollection");
				return t.onmessage = t => {
					const i = t.data,
						s = e();
					if (s.crossHairSyncBroadcast && "crosshair" === i.type) s.crossHairSyncBroadcast.uniqueId !== i.payload.sourceUniqueId && Ut(s, i.payload.point, null, !1, i.payload.envState)
				}, {
					channel: t,
					uniqueId: (0, Ne.randomHashN)(6)
				}
			}

			function jt(e) {
				var t;
				null === (t = e.crossHairSyncBroadcast) || void 0 === t || t.channel.close()
			}

			function qt(e, t, i) {
				if (!e.trackTimeLock.value() || e.dateRangeLock.value()) return;
				const s = e.layoutTemplate.value().count;
				e.undoHistory.beginUndoMacro(Ze), e.chartWidgetsDefs.slice(0, s).filter((e => e.chartWidget.hasModel() && e.chartWidget.model().model() !== i)).forEach((e => {
					const i = e.chartWidget.model().model(),
						s = i.mainSeries().syncModel();
					s && i.syncTimeWithModel(s.syncSourceTarget(), t)
				})), e.undoHistory.endUndoMacro()
			}

			function Kt(e) {
				return Promise.all(e.map((e => {
					const t = e.model().mainSeries();
					return t.symbolResolvingActive().value() ? (0, c.delegateToPromise)(t.dataEvents().symbolResolved()).promise : t.symbolInfo()
				})))
			}

			function Yt(e) {
				return e.chartWidgetsDefs.every((e => e.chartWidget.hasModel())) ? Promise.resolve(e.chartWidgetsDefs.map((e => e.chartWidget))) : Promise.all(e.chartWidgetsDefs.map((e => e.chartWidget.hasModel() || (0, c.delegateToPromise)(e.chartWidget.modelCreated()).promise))).then((() => Yt(e)))
			}

			function Xt(e, t) {
				var i, o, r;
				if ((0, l.enabled)("charting_library_base")) return t;
				if ("s" === t || e.widgetOptions.containsData || e.readOnly || (0, X.enabled)(Z.ProductFeatures.MULTIPLE_CHARTS) && (0, s.ensure)(null === (i = (0, X.getConfig)(Z.ProductFeatures.MULTIPLE_CHARTS)) || void 0 === i ? void 0 : i.limit) >= Se.layouts[t].count) return t;
				let n = "s"; {
					let t = 1;
					const i = null !== (r = null === (o = (0, X.getConfig)(Z.ProductFeatures.MULTIPLE_CHARTS)) || void 0 === o ? void 0 : o.limit) && void 0 !== r ? r : 0;
					for (const e of Object.keys(Se.layouts)) {
						const s = Se.layouts[e].count;
						s <= i && s > t && (n = e, t = s)
					}
					Yt(e).then(Kt).then((() => {
						(0, Y.trackGoProFeature)("multipleCharts"), (0, $.createGoProDialog)({
							feature: "multipleCharts"
						})
					}))
				}
				return n
			}
			async function Zt(e, t, i) {
				if (i = Xt(e, i), e.layoutWV.value() === i) return !1;
				const s = e.chartWidgetsDefs.map((e => {
					var t, i, s;
					return null !== (s = null === (i = null === (t = e.chartWidget) || void 0 === t ? void 0 : t.lineToolsSynchronizer()) || void 0 === i ? void 0 : i.flushPendingSavings()) && void 0 !== s ? s : null
				})).filter(He.notNull);
				return s.length && await Promise.all(s), e.undoHistory.pushUndoCommand(new Ue(t, i)), !0
			}
			async function $t(e, t, i) {
				const {
					theme: s,
					onlyActiveChart: o,
					restoreNonThemeDefaults: r,
					themeName: n,
					standardTheme: a,
					syncState: l = !0,
					noUndo: c
				} = i, h = (0, ge.getCurrentTheme)().name;
				let d;
				o ? d = [e.activeChartWidget.value()] : (await Promise.all(e.savedChartWidgetOptions.map(((i, s) => new Promise((i => {
					Wt(Vt(e, t, s, i))
				}))))), d = e.chartWidgetsDefs.map((e => e.chartWidget))), c ? (a && new qe(h, n, l).redo(), d.forEach((e => {
					e.model().model().restoreTheme(s, r, c)
				}))) : (e.undoHistory.beginUndoMacro(Je), a && e.undoHistory.pushUndoCommand(new qe(h, n, l)), d.forEach((e => {
					e.model().model().restoreTheme(s, r)
				})), e.undoHistory.endUndoMacro())
			}
		},
		674996: (e, t, i) => {
			"use strict";
			var s = i(97639);
			i(90974);
			var o = i(575932).t,
				r = i(277036).TranslatedString,
				n = i(588537),
				a = n.assert,
				l = n.ensureDefined,
				c = i(404703).Series,
				h = i(611688),
				d = i(127085).ActionBinder,
				u = i(62802).setValue,
				_ = i(697455).TabNames,
				m = i(578101).showGoToDateDialog,
				p = i(470316),
				g = i(398835),
				S = i(382384).showConfirmInputsDialog,
				v = i(682244).createAddNoteAction,
				f = i(813652).Version,
				b = i(427840).showDeleteStudyTreeConfirm,
				y = i(733255).showNoticeDialog,
				C = i(769393).InsertionErrorCode,
				w = i(779923).showConfirm,
				T = i(987433).confirmDatasourceRemoving;
			const P = i(876322).showFinancialsDialog;
			var M = i(180389).showThemeSwitcher,
				x = i(180389).showThemeAction,
				I = i(800733).updateThemeActions,
				A = i(448874).Study,
				k = i(147627).StudyStub,
				L = i(140662).isStudy,
				E = i(724145).LineDataSource,
				D = i(540968),
				N = D.isLineTool,
				B = D.isStudyLineTool,
				O = i(418458).STUDYPLOTDISPLAYTARGET,
				R = i(829770).Action,
				V = i(363585).ACTION_ID,
				W = i(308170),
				F = i(273044).Interval,
				z = i(749473),
				U = z.getDefaultStyle,
				H = z.hasVolume,
				G = i(891075).showSymbolInfoDialog,
				j = i(388230).InvalidationMask,
				q = i(583912).linking,
				K = i(544998).showChangeIntervalDialogAsync,
				Y = i(588746).TVAction,
				X = i(715518).showDetailsDialog,
				Z = i(72368).isMobile,
				$ = i(776734).getTracker,
				Q = i(159621).WatchlistWithSubmenuAction,
				J = i(560420).showDialog,
				ee = i(888667),
				te = ee.availableTimezones,
				ie = ee.timezoneIsAvailable,
				se = i(951713).toggleHideMode,
				oe = i(328289).ChartSession,
				re = i(970028).StudyMetaInfo,
				ne = i(345848).trackEvent,
				ae = i(420808).lastMouseOrTouchEventInfo,
				le = i(385518);
			const {
				viewportChangeEvent: ce
			} = i(194459);
			var he = i(911905).getLogger("ChartWidget", {
					color: "#606"
				}),
				de = i(97985).appendEllipsis,
				ue = i(190472).StudyMetaInfoRepository,
				_e = i(467608).isMultipleLayout,
				me = i(895370).addPerfMark,
				pe = i(214729).combineProperty,
				ge = i(557865).ChartWidgetBase,
				Se = i(638456).CheckMobile.any(),
				ve = i(285055).TIMEFRAMETYPE,
				fe = i(579917).createDeferredPromise,
				be = i(733133).addPlusButtonProperty;
			var ye = new r("change timezone", o("change timezone")),
				Ce = new r("scale price chart only", o("scale price chart only")),
				we = new r("stay in drawing mode", o("stay in drawing mode")),
				Te = new r("hide all drawing tools", o("hide all drawing tools")),
				Pe = new r("hide marks on bars", o("hide marks on bars")),
				Me = new r("change symbol last value visibility", o("change symbol last value visibility")),
				xe = new r("change symbol previous close value visibility", o("change symbol previous close value visibility")),
				Ie = new r("change previous close price line visibility", o("change previous close price line visibility")),
				Ae = new r("change symbol labels visibility", o("change symbol labels visibility")),
				ke = new r("change indicators and financials name labels visibility", o("change indicators and financials name labels visibility")),
				Le = new r("change indicators and financials value labels visibility", o("change indicators and financials value labels visibility")),
				Ee = new r("change bid and ask labels visibility", o("change bid and ask labels visibility")),
				De = new r("change bid and ask lines visibility", o("change bid and ask lines visibility")),
				Ne = new r("change pre/post market price label visibility", o("change pre/post market price label visibility")),
				Be = new r("change pre/post market price line visibility", o("change pre/post market price line visibility")),
				Oe = new r("change high and low price lines visibility", o("change high and low price lines visibility")),
				Re = new r("change high and low price labels visibility", o("change high and low price labels visibility")),
				Ve = (new r("change average close price line visibility", o("change average close price line visibility")), new r("change average close price label visibility", o("change average close price label visibility")), new r("change countdown to bar close visibility", o("change countdown to bar close visibility"))),
				We = new r("change plus button visibility", o("change plus button visibility")),
				Fe = new r("change price line visibility", o("change price line visibility")),
				ze = new r("unlock {title}", o("unlock {title}")),
				Ue = new r("lock {title}", o("lock {title}")),
				He = new r("change session breaks visibility", o("change session breaks visibility")),
				Ge = o("On the left"),
				je = o("On the right"),
				qe = o("Move scale to left"),
				Ke = o("Move scale to right");
			e.exports.ChartWidget = class extends ge {
				constructor(e, t, i) {
					super(e, t, i), this._options.timeScaleWidget && (this._options.timeScaleWidget.pressedMouseMoveScale = this._options.handleScale.axisPressedMouseMove.time);
					var o = this,
						r = this._options.content,
						n = this._options.readOnly;
					this._removeMaximizeHotkey = null, o._hotkeys = g.createGroup({
						desc: "Chart actions",
						isDisabled: function() {
							return !o._isActive
						}
					});
					var a = this._options.containsData,
						l = this._options.onWidget,
						c = this._options.onCmeWidget;
					c && he.logWarn("[ChartWidget] 'onCmeWidget' option is depricated");
					var h = this._options.widgetCustomer,
						d = this._options.timezone,
						u = this._options.hideSymbolSearch,
						_ = this._options.defSymbol,
						m = F.isValid(this._options.defInterval) ? this._options.defInterval : void 0,
						p = parseInt(this._options.defStyle),
						S = z.isValidStyle(p) ? p : void 0,
						v = this._options.defSessionId,
						f = void 0 !== this._options.defTimeframe ? {
							value: this._options.defTimeframe.toUpperCase(),
							type: ve.PeriodBack
						} : void 0;
					this._content = r, this._initialLoading = this._options.initialLoading, this._readOnly = n, this._containsData = a, this._defSymbol = _, this._defInterval = m, this._defTimeframe = f, this._defStyle = S, this._onWidget = !!l, this._compareSymbols = this._options.compareSymbols, this._onWidget && (c ? this._widgetCustomer = "cme" : h && (this._widgetCustomer = h)), this._hideSymbolSearch = u, this._frameTime = 30, this._model = null, this._metaInfo = {}, this._drawRafId = 0, this._compareDialog = this._chartWidgetCollection.getCompareDialogRenderer();
					var b = this._contentSeriesProperties();
					b && (_ = b.symbol, m = b.interval), void 0 === this._options.useUserChartPreferences && (this._options.useUserChartPreferences = !0);
					var y = "chartproperties.mainSeriesProperties",
						C = this._options.useUserChartPreferences ? le.defaults(y) : le.factoryDefaults(y);
					this._properties.mainSeriesProperties.merge(C), this._properties.mainSeriesProperties.hasChild("esdBreaksStyle") && this._properties.mainSeriesProperties.removeProperty("esdBreaksStyle"), m = m || C.interval || "D", z.isValidStyle(S) || (S = z.isValidStyle(C.style) ? C.style : U(F.isRange(m))), this._properties.mainSeriesProperties.merge({
						visible: !0,
						symbol: _ || DEFAULT_SYMBOL,
						shortName: "",
						timeframe: "",
						onWidget: this._onWidget,
						interval: m,
						currencyId: null,
						unitId: null,
						style: S,
						sessionId: v,
						lineStyle: {
							styleType: le.factoryDefaults("chartproperties.mainSeriesProperties.lineStyle.styleType")
						}
					}), this._containsData && this._properties.mainSeriesProperties.merge({
						showCountdown: !1
					}), d && ie(d) && this._properties.timezone.setValue(d), this._tagsChanged = new s, this._disconnected = new s, this._reconnectBailout = new s, this._connected = new s, this.chartWidgetInitialized = new s, this._chartSession = new oe(ChartApiInstance), this._metaInfoRepository = new ue(this._chartSession), this._timingsMeter = null, this._isActive = this._options.isActive, this._options.container.subscribe((function(e) {
						o._setElement(e)
					}), {
						callWithLast: !0
					});
					var w = function() {
						o.resize()
					};
					this._options.width.subscribe(w), this._options.height.subscribe(w), this._options.visible.subscribe(this._updateTimingsMeterState.bind(this)), this._aboutToBeDestroyed = new s, this._actions = null, this._definitionsViewModel = null, this._backgroundTopColorSpawn = null, this._backgroundBottomColorSpawn = null, this._hintDefferedPromise = null, this._activeHint = null
				}
				isInitialized() {
					return Boolean(this._inited)
				}
				compareSymbols() {
					return this._compareSymbols
				}
				async _getChartPropertyDefinitionsViewModel() {
					if (null === this._definitionsViewModel) {
						const {
							ChartPropertyDefinitionsViewModel: e
						} = await Promise.all([i.e(39509), i.e(64320), i.e(83596)]).then(i.bind(i, 478482));
						if (this._isDestroyed) throw new Error("Chart widget already destroyed");
						await new Promise((e => this.withModel(null, e))),
							null === this._definitionsViewModel && (this._definitionsViewModel = new e(this.model(), this.properties(), this._options))
					}
					return this._definitionsViewModel
				}
				_initMaximizeHotkey(e) {
					var t = this;

					function i(e) {
						e.defaultPrevented || p.modifiersFromEvent(e) === p.Modifiers.Alt && e.stopPropagation()
					}

					function s(e) {
						e.defaultPrevented || p.modifiersFromEvent(e) === p.Modifiers.Alt && (e.preventDefault(), e.stopPropagation(), t.toggleFullscreen())
					}
					return e.addEventListener("mousedown", i, !0), e.addEventListener("click", s, !0),
						function() {
							e.removeEventListener("mousedown", i, !0), e.removeEventListener("click", s, !0)
						}
				}
				toggleFullscreen() {
					var e = this.getResizerDetacher();
					e.fullscreenable.value() && (e.fullscreen.value() ? e.exitFullscreen() : e.requestFullscreen())
				}
				_beginRequestActive() {
					var e = this._chartWidgetCollection.activeChartWidget.value() !== this;
					if (this._chartWidgetCollection.activeChartWidget.setValue(this), e) {
						const e = ae();
						e.isTouch && !e.stylus && this._isLineToolModeExceptBrush() && this.updateCrossHairPositionIfNeeded(), this._justActivated = !0
					}
				}
				_endRequestActive() {
					var e = this;
					this._justActivated && setTimeout((function() {
						e._justActivated = !1
					}), 0)
				}
				_requestActive() {
					this._beginRequestActive(), this._endRequestActive()
				}
				justActivated() {
					return this._justActivated
				}
				setTimezone(e) {
					e && ie(e) ? this._properties.timezone.setValue(e) : console.warn("Incorrect timezone: " + JSON.stringify(e))
				}
				getTimezone() {
					return this._properties.timezone.value()
				}
				refreshMarks() {
					this.model().barsMarksSources().forEach((function(e) {
						e.refreshData()
					}))
				}
				clearMarks() {
					this.model().barsMarksSources().forEach((function(e) {
						e.clearMarks()
					}))
				}
				metaInfoRepository() {
					return this._metaInfoRepository
				}
				_initBackgroundColor() {
					null === this._backgroundTopColorSpawn && (this._backgroundTopColorSpawn = this._model.model().backgroundTopColor().spawn(), this._backgroundTopColorSpawn.subscribe(this._onBackgroundColorChanged.bind(this))), null === this._backgroundBottomColorSpawn && (this._backgroundBottomColorSpawn = this._model.model().backgroundColor().spawn(), this._backgroundBottomColorSpawn.subscribe(this._onBackgroundColorChanged.bind(this)))
				}
				paneWidgets() {
					return this._paneWidgets
				}
				paneByCanvas(e) {
					for (var t = 0; t < this._paneWidgets.length; t++)
						if (this._paneWidgets[t].hasCanvas(e)) return this._paneWidgets[t];
					return null
				}
				paneByState(e) {
					for (var t = 0; t < this._paneWidgets.length; t++)
						if (this._paneWidgets[t].state() === e) return this._paneWidgets[t];
					return null
				}
				timeAxisByCanvas(e) {
					return this._timeAxisWidget.hasCanvas(e) ? this._timeAxisWidget : null
				}
				properties() {
					return this._properties
				}
				emulateCriticalError() {
					this._chartSession.removeSeries("-1")
				}
				readOnly() {
					return this._readOnly
				}
				onDisconnected() {
					return this._disconnected
				}
				onReconnectBailout() {
					return this._reconnectBailout
				}
				onConnected() {
					return this._connected
				}
				onRedraw() {
					return this._redraw
				}
				modelCreated() {
					return this._modelCreated
				}
				getResolution() {
					return this._model ? this._model.mainSeries().properties().interval.value() : this._properties.mainSeriesProperties.interval.value()
				}
				addOverlayStudy(e, t, i) {
					var s = this.model();
					return this._options.isSymbolAvailable(e).then((function(o) {
						if (!o) return null;
						var r = s.createStudyInserter({
								type: "java",
								studyId: "Overlay@tv-basicstudies"
							}),
							n = {
								allowExtendTimeScale: i
							};
						if (h.enabled("use_overrides_for_overlay")) {
							var a = le.factoryDefaults("study_Overlay@tv-basicstudies.style");
							n.style = a
						}
						return r.setPropertiesState(n), r.setForceOverlay(t), r.insert((function() {
							return Promise.resolve({
								inputs: {
									symbol: e
								}
							})
						}))
					}))
				}
				addCompareStudy(e) {
					var t = this.model();
					return this._options.isSymbolAvailable(e).then((function(i) {
						return i ? t.createStudyInserter({
							type: "java",
							studyId: "Compare@tv-basicstudies"
						}).insert((function() {
							return Promise.resolve({
								inputs: {
									symbol: e
								}
							})
						})) : null
					}))
				}
				updateActions() {
					for (var e = this.actions(), t = this._model.dataSources(), i = !1, s = !1, r = 0, n = t.length; r < n; r++) {
						var a = t[r];
						TradingView.isInherited(a.constructor, E) && a.isUserDeletable() && (i = !0), TradingView.isInherited(a.constructor, A) && a.removeByRemoveAllStudies() && (s = !0), TradingView.isInherited(a.constructor, k) && (s = !0)
					}
					this._readOnly || (e.paneRemoveAllStudies && e.paneRemoveAllStudies.update({
						disabled: !s
					}), e.paneRemoveAllDrawingTools && e.paneRemoveAllDrawingTools.update({
						disabled: !i
					}), e.paneRemoveAllStudiesDrawingTools && e.paneRemoveAllStudiesDrawingTools.update({
						disabled: !s && !i
					})), !(M() || x() || window.is_authenticated) || I(this);
					var l = this,
						c = [],
						h = function(e) {
							return e.id === l.model().model().properties().timezone.value()
						};
					te.forEach((function(e) {
						if (!e.separator) {
							var t = new R({
								actionId: V.ChartChangeTimeZone,
								label: e.title,
								checkable: !0,
								checked: h(e),
								statName: "SetTimeZone",
								onExecute: function() {
									l.model().setProperty(l.model().model().properties().timezone, e.id, ye)
								}
							});
							c.push(t)
						}
					}), this), e.applyTimeZone.update({
						subItems: c
					}), e.addToWatchlist && (e.addToWatchlist.request(), e.addToWatchlist.updateLabel(this.getSymbol(!0))), e.addToTextNotes && e.addToTextNotes.update({
						label: o("Add text note for {symbol}").format({
							symbol: this.getSymbol(!0)
						})
					}), e.moveChartAction && e.moveChartAction.update({
						disabled: !this._chartWidgetCollection.activeChartCanBeMoved()
					})
				}
				actions() {
					return null === this._actions && this._setActions(), this._actions
				}
				_setActions() {
					this._actions && this._actions.addToWatchlist && (this._actions.addToWatchlist.destroy(), delete this._actions.addToWatchlist);
					var e = this;
					this._hotkeys.add({
						desc: "Maximize",
						hotkey: g.Modifiers.Alt + 13,
						handler: function() {
							e.toggleFullscreen()
						},
						isDisabled: function() {
							return !e._options.fullscreenable.value()
						}
					}), this._hotkeys.add({
						desc: "Cancel selection",
						hotkey: 27,
						handler: function() {
							0 === e.selectPointMode().value() ? e._model.selectionMacro((function(t) {
								e._cancelCreatingLine(), t.clearSelection()
							})) : e.cancelRequestSelectPoint()
						},
						isDisabled: function() {
							var t = 0 === e._model.selection().allSources().length,
								i = null === e._model.crossHairSource().measurePane().value(),
								s = 0 === e.selectPointMode().value(),
								o = t && i && s;
							return !e._model || o
						}
					}), e.withModel(null, (function() {
						var t = function() {
							e._hotkeys.promote()
						};
						e._model.onSelectedSourceChanged().subscribe(null, t), e._model.crossHairSource().measurePane().subscribe((e => {
							null !== e && t()
						}))
					}));
					var t = new R({
							actionId: V.ChartScalesReset,
							label: o("Reset chart"),
							icon: i(139267),
							statName: "ResetChart",
							onExecute: this.GUIResetScales.bind(this),
							hotkeyGroup: this._hotkeys,
							hotkeyHash: g.Modifiers.Alt + 82
						}),
						s = new R({
							actionId: V.ChartSeriesPriceScaleToggleInvertPriceScale,
							label: o("Invert scale"),
							statName: "Invert Scale",
							checkable: !0,
							onExecute: function() {
								e._model.invertPriceScale(e._model.mainSeries().priceScale())
							},
							hotkeyGroup: this._hotkeys,
							hotkeyHash: g.Modifiers.Alt + 73
						}),
						r = new R({
							actionId: V.ChartSeriesPriceScaleToggleAutoScale,
							label: o("Auto (fits data to screen)"),
							checkable: !0,
							onExecute: function() {
								var t = e._model.mainSeries().priceScale();
								e._model.togglePriceScaleAutoScaleMode(t), r.update({
									checked: t.isAutoScale()
								})
							}
						}),
						n = new R({
							actionId: V.ChartScalesToggleLockPriceToBarRatio,
							label: o("Lock price to bar ratio"),
							checkable: !0,
							statName: "ToggleLockScale",
							onExecute: function() {
								e._model.togglePriceScaleLockScaleMode(e._model.mainSeries().priceScale())
							}
						}),
						a = new R({
							actionId: V.ChartSeriesPriceScaleToggleRegular,
							label: o("Regular"),
							checkable: !0,
							statName: "ToggleRegularScale",
							onExecute: function() {
								var t = e._model.mainSeries().priceScale();
								e._model.setPriceScaleRegularScaleMode(t), a.update({
									checked: t.isRegular()
								})
							}
						}),
						l = new R({
							actionId: V.ChartSeriesPriceScaleTogglePercentage,
							label: o("Percent"),
							checkable: !0,
							statName: "TogglePercantage",
							onExecute: function() {
								e._model.togglePriceScalePercentageScaleMode(e._model.mainSeries().priceScale())
							},
							hotkeyGroup: this._hotkeys,
							hotkeyHash: g.Modifiers.Alt + 80
						}),
						c = new R({
							actionId: V.ChartSeriesPriceScaleToggleIndexedTo100,
							label: o("Indexed to 100"),
							checkable: !0,
							statName: "ToggleIndexedTo100",
							onExecute: function() {
								e._model.togglePriceScaleIndexedTo100ScaleMode(e._model.mainSeries().priceScale())
							}
						}),
						S = new R({
							actionId: V.ChartSeriesPriceScaleToggleLogarithmic,
							label: o("Logarithmic"),
							statName: "ToggleLogScale",
							checkable: !0,
							onExecute: function() {
								e._model.togglePriceScaleLogScaleMode(e._model.mainSeries().priceScale())
							},
							hotkeyGroup: this._hotkeys,
							hotkeyHash: g.Modifiers.Alt + 76
						}),
						f = new R({
							actionId: V.ChartUndo,
							label: o("Undo"),
							onExecute: function() {
								ne("GUI", "Undo"), e._model.undoHistory().undo()
							},
							disabled: !0,
							hotkeyGroup: this._hotkeys,
							hotkeyHash: g.Modifiers.Mod + 90
						}),
						b = new R({
							actionId: V.ChartRedo,
							label: o("Redo"),
							onExecute: function() {
								ne("GUI", "Redo"), e._model.undoHistory().redo()
							},
							disabled: !0,
							hotkeyGroup: this._hotkeys,
							hotkeyHash: g.Modifiers.Mod + 89
						});
					e.withModel(null, (function() {
						e._model.undoHistory().undoStack().onChange().subscribe(e, e.updateUndoRedo), e._model.undoHistory().redoStack().onChange().subscribe(e, e.updateUndoRedo)
					}));
					var y = !(M() || x() || window.is_authenticated) ? null : new Y({
							name: "apply-color-theme",
							label: o("Color Theme"),
							icon: i(527409),
							subItems: [new Y({
								label: o("Loading")
							})],
							statName: "ColorTheme"
						}),
						C = new R({
							actionId: V.ChartChangeTimeZone,
							label: o("Time zone"),
							statName: "TimeZone"
						}),
						w = new R({
							actionId: V.ChartDialogsShowChangeSymbol,
							label: de(o("Change Symbol")),
							statName: "ChangeSymbol",
							onExecute: function() {
								J({
									defaultValue: ""
								})
							}
						});
					u("symboledit.dialog_last_entry", "");
					var T = {
						actionId: V.ChartDialogsShowChangeInterval,
						label: de(o("Change interval")),
						statName: "ChangeInterval",
						onExecute: function() {
							K({
								initVal: q.interval.value(),
								selectOnInit: !0
							})
						}
					};
					!h.enabled("show_interval_dialog_on_key_press") || this.readOnly() || this._hideSymbolSearch || (T.shortcutHint = ",", T.hotkeyGroup = this._hotkeys, T.hotkeyHash = 188);
					var I, A, k = new R(T);
					if (!TradingView.onWidget()) {
						if (this._options.addToWatchlistEnabled) {
							const e = {
								hotkeyGroup: this._hotkeys
							};
							I = new Q(this, e)
						}
						A = v(this, {
							hotkeyGroup: this._hotkeys
						}, Z())
					}
					var L = new R({
							actionId: V.ChartTimeScaleReset,
							label: o("Reset time scale"),
							icon: i(139267),
							statName: "ResetScale",
							onExecute: function() {
								e.model().resetTimeScale()
							},
							hotkeyGroup: this._hotkeys,
							hotkeyHash: g.Modifiers.Mod + g.Modifiers.Alt + 81
						}),
						E = new R({
							actionId: V.ChartRemoveAllIndicators,
							label: o("Remove indicators"),
							statName: "RemoveAllIndicators",
							onExecute: this.removeAllStudies.bind(this)
						}),
						D = new R({
							actionId: V.ChartRemoveAllLineTools,
							label: o("Remove drawings"),
							statName: "RemoveAllDrawingTools",
							onExecute: this.removeAllDrawingTools.bind(this)
						}),
						N = new R({
							actionId: V.ChartRemoveAllIndicatorsAndLineTools,
							label: o("All indicators and drawing tools"),
							statName: "RemoveAllIndicatorsAndDrawingTools",
							onExecute: this.removeAllStudiesDrawingTools.bind(this)
						}),
						B = this.chartWidgetCollection(),
						O = new R({
							actionId: V.ChartApplyIndicatorsToAllCharts,
							label: o("Apply these indicators to entire layout"),
							statName: "ApplyIndicatorsToAllCharts",
							onExecute: function() {
								B.applyIndicatorsToAllCharts(e)
							}
						}),
						F = {
							actionId: V.ChartDialogsShowInsertIndicators,
							label: de(o("Insert indicator")),
							statName: "InsertIndicator",
							onExecute: function() {
								e.showIndicators()
							}
						};
					this._options.indicatorsDialogShortcutEnabled && (F.hotkeyGroup = this._hotkeys, F.hotkeyHash = 191, this._hotkeys.add({
						handler: function() {
							this.showIndicators()
						}.bind(this),
						desc: "Show insert indicator dialog",
						hotkey: 111
					}));
					var z, U = new R(F),
						H = new R({
							actionId: V.ChartDialogsShowCompareOrAddSymbol,
							label: de(o("Compare or Add Symbol")),
							statName: "CompareOrAddSymbol",
							onExecute: this.toggleCompareOrAdd.bind(this)
						}),
						ee = new R({
							actionId: V.ChartObjectTreeShow,
							label: de(o("Object Tree")),
							statName: "ObjectsTree",
							onExecute: this.showObjectsTreePanelOrDialog.bind(this)
						}),
						te = new R({
							actionId: V.ChartDialogsShowGeneralSettings,
							label: de(o("Settings")),
							icon: i(951983),
							statName: "ChartProperties",
							onExecute: function() {
								e.showGeneralChartProperties()
							}
						}),
						ie = new R({
							actionId: V.ChartDialogsShowGeneralSettingsSymbolTab,
							label: de(o("Settings")),
							icon: i(951983),
							statName: "MainSeriesProperties",
							onExecute: function() {
								e.showGeneralChartProperties(_.symbol)
							}
						}),
						oe = new R({
							actionId: V.ChartSelectedObjectToggleLocked,
							label: o("Lock/unlock"),
							statName: "ToggleLockSelectedObject",
							onExecute: this.toggleLockSelectedObject.bind(this)
						}),
						re = new R({
							actionId: V.ChartSelectedObjectHide,
							label: o("Hide"),
							icon: i(484959),
							statName: "HideSelectedObject",
							onExecute: this.hideSelectedObject.bind(this)
						});
					h.enabled("property_pages") && (z = new R({
						actionId: V.ChartSelectedObjectShowSettingsDialog,
						label: de(o("Settings")),
						icon: i(951983),
						statName: "EditSelectedObject",
						onExecute: function() {
							e.showSelectedSourcesProperties()
						}
					})), this.withModel(null, (function() {
						var t = e.model().mainSeries(),
							i = t.properties();
						i.priceAxisProperties.subscribe(e, e._updateScalesActions),
							t.priceScaleAboutToBeChanged().subscribe(e, (function() {
								i.priceAxisProperties.unsubscribeAll(e)
							})), t.priceScaleChanged().subscribe(e, (function() {
								i.priceAxisProperties.subscribe(e, e._updateScalesActions), e._updateScalesActions()
							}))
					}));
					var ae = new R({
						actionId: V.ChartPriceScaleToggleAutoScaleSeriesOnly,
						label: o("Scale price chart only"),
						checkable: !0,
						statName: "ScalePriceChartOnly"
					});
					ae.binder = new d(ae, this._properties.scalesProperties.scaleSeriesOnly, this.model(), Ce);
					var le = this.model().model();
					this._properties.scalesProperties.scaleSeriesOnly.listeners().subscribe(null, (function() {
						le.recalculateAllPanes(ce()), le.invalidate(j.full())
					}));
					var he = new R({
							actionId: V.ChartDrawingToolbarToggleVisibility,
							label: o("Drawings toolbar"),
							checkable: !0,
							statName: "ToggleDrawingToolbar"
						}),
						ue = this._options.isDrawingToolbarVisible;
					ue && (ue.subscribe((function(e) {
						he.update({
							checked: e
						})
					}), {
						callWithLast: !0
					}), he.update({
						onExecute: function() {
							ue.setValue(!ue.value())
						}
					}));
					var _e, me = new R({
						actionId: "",
						label: o("Stay in drawing mode"),
						checkable: !0,
						statName: "ToggleStayInDrawingMode"
					});
					me.binder = new d(me, W.properties().stayInDrawingMode, this.model(), we), (_e = new Y({
						label: o("Hide all drawing tools"),
						checkable: !0,
						statName: "ToggleHideAllDrawingTools",
						hotkeyHash: g.Modifiers.Mod + g.Modifiers.Alt + 72,
						hotkeyGroup: this._hotkeys
					})).binder = new d(_e, W.hideAllDrawings(), this.model(), Te, (function() {
						se()
					}));
					var ge = new R({
						actionId: V.ChartMarksToggleVisibility,
						label: o("Hide marks on bars"),
						checkable: !0,
						statName: "ToggleHideMarksOnBars"
					});
					ge.binder = new d(ge, W.hideMarksOnBars(), this.model(), Pe, (function() {
						W.hideMarksOnBars().setValue(this.value())
					}));
					const Se = this.properties().scalesProperties;
					var ve = new R({
						actionId: V.ChartPriceScaleLabelsToggleSeriesLastValueVisibility,
						label: o("Symbol last price label"),
						checkable: !0,
						checked: !1,
						statName: "ToggleSymbolLastValue"
					});
					ve.binder = new d(ve, Se.showSeriesLastValue, this.model(), Me);
					var fe = new R({
						actionId: V.ChartPriceScaleLabelsToggleSymbolPrevCloseValueVisibility,
						label: o("Symbol previous day close price label"),
						checkable: !0,
						checked: !1,
						statName: "ToggleSymbolPrevCloseValue"
					});
					fe.binder = new d(fe, Se.showSeriesPrevCloseValue, this.model(), xe);
					var ye = new R({
						actionId: V.ChartLinesToggleSeriesPrevCloseLineVisibility,
						label: o("Previous day close price line"),
						checkable: !0,
						checked: !1,
						statName: "ToggleSymbolPrevCloseLine"
					});
					ye.binder = new d(ye, this.model().mainSeries().properties().showPrevClosePriceLine, this.model(), Ie), this.model().mainSeries().onRestarted().subscribe(this, (function() {
						this.updateActionForIntradayOnly(fe), this.updateActionForIntradayOnly(ye)
					}));
					var ze = new R({
						actionId: V.ChartPriceScaleLabelsToggleSymbolNameLabelsVisibility,
						label: o("Symbol name label"),
						checkable: !0,
						checked: !1,
						statName: "ToggleSymbolLabels"
					});
					ze.binding = new d(ze, Se.showSymbolLabels, this.model(), Ae);
					const Ue = pe(((e, t) => e || t), Se.showStudyLastValue, Se.showFundamentalLastValue);
					var He = new R({
						actionId: V.ChartPriceScaleLabelsToggleIndicatorsValueLabelsVisibility,
						label: o("Indicators and financials value labels"),
						checkable: !0,
						checked: !1,
						statName: "ToggleStudiesAndFundamentalsPriceLabels"
					});
					He.binder = new d(He, Ue, this.model(), null, (() => {
						const e = !Ue.value();
						this.model().beginUndoMacro(Le), this.model().setProperty(Se.showStudyLastValue, e, null), this.model().setProperty(Se.showFundamentalLastValue, e, null), this.model().endUndoMacro()
					}));
					const Ye = pe(((e, t) => e || t), Se.showStudyPlotLabels, Se.showFundamentalNameLabel);
					var Xe = new R({
						actionId: V.ChartPriceScaleLabelsToggleIndicatorsNameLabelsVisibility,
						label: o("Indicators and financials name labels"),
						checkable: !0,
						checked: !1,
						statName: "ToggleStudiesAndFundamentalsNameLabels"
					});
					Xe.binding = new d(Xe, Ye, this.model(), null, (() => {
						const e = !Ye.value();
						this.model().beginUndoMacro(ke), this.model().setProperty(Se.showStudyPlotLabels, e, null), this.model().setProperty(Se.showFundamentalNameLabel, e, null), this.model().endUndoMacro()
					}));
					var Ze = new R({
						actionId: V.ChartPriceScaleLabelsToggleBidAskLabelsVisibility,
						label: o("Bid and ask labels"),
						checkable: !0,
						checked: !1,
						statName: "ToggleBidAskLabels"
					});
					Ze.binding = new d(Ze, Se.showBidAskLabels, this.model(), Ee);
					var $e = new R({
						actionId: V.ChartLinesToggleBidAskLinesVisibility,
						label: o("Bid and ask lines"),
						checkable: !0,
						checked: !1,
						statName: "ToggleBidAskLines"
					});
					$e.binding = new d($e, this.model().mainSeries().properties().bidAsk.visible, this.model(), De);
					var Qe = new Y({
						label: o("Pre/post market price label"),
						checkable: !0,
						checked: !1,
						statName: "TogglePrePostMarketPriceLabel"
					});
					Qe.binding = new d(Qe, Se.showPrePostMarketPriceLabel, this.model(), Ne);
					var Je = new Y({
						label: o("Pre/post market price line"),
						checkable: !0,
						checked: !1,
						statName: "TogglePrePostMarketPriceLine"
					});
					Je.binding = new d(Je, this.model().mainSeries().properties().prePostMarket.visible, this.model(), Be), this.model().mainSeries().isPrePostMarketPricesAvailableProperty().subscribe(this, (function(e) {
						Qe.update({
							disabled: !e.value()
						}), Je.update({
							disabled: !e.value()
						})
					}));
					var et = this.model().mainSeries().properties().highLowAvgPrice,
						tt = new R({
							actionId: V.ChartPriceScaleLabelsToggleHighLowPriceLabelsVisibility,
							label: o("High and low price labels"),
							checkable: !0,
							checked: !1,
							statName: "ToggleHighLowPriceLabels"
						});
					tt.binding = new d(tt, et.highLowPriceLabelsVisible, this.model(), Re);
					var it, st, ot = new R({
						actionId: V.ChartLinesToggleHighLowLinesVisibility,
						label: o("High and low price lines"),
						checkable: !0,
						checked: !1,
						statName: "ToggleHighLowPriceLine"
					});
					ot.binding = new d(ot, et.highLowPriceLinesVisible, this.model(), Oe);
					var rt = new R({
						actionId: V.ChartPriceScaleToggleCountdownToBarCloseVisibility,
						label: o("Countdown to bar close"),
						checkable: !0,
						checked: !1,
						statName: "ToggleCountdown"
					});
					rt.binder = new d(rt, this.model().mainSeries().properties().showCountdown, this.model(), Ve);
					var nt = new R({
						actionId: V.ChartPriceScaleToggleAddOrderPlusButtonVisibility,
						label: o("Plus button"),
						checkable: !0,
						checked: be.value(),
						statName: "ToggleAddOrderPlusButton"
					});
					nt.binder = new d(nt, be, this.model(), We);
					var at = null;
					this._options.goToDateEnabled && (at = new R({
						actionId: V.ChartDialogsShowGoToDate,
						label: de(o("Go to date")),
						statName: "GoToDate",
						onExecute: function() {
							var t = e._chartWidgetCollection.activeChartWidget.value();
							m(t)
						},
						hotkeyGroup: this._hotkeys,
						hotkeyHash: g.Modifiers.Alt + 71
					}));
					var lt, ct = new R({
							actionId: V.ChartDialogsShowSymbolInfo,
							label: de(Z() ? o("Symbol details") : o("Symbol info")),
							icon: i(437924),
							checkable: !1,
							statName: "SymbolInfo",
							onExecute: function() {
								if (Z()) X(), ne("ContextMenuClick", "Mobile", "SymbolInfo");
								else {
									var t = e.model().mainSeries().symbol(),
										i = e.model().mainSeries().symbolInfo(),
										s = e.model().model().availableUnits(),
										o = {
											symbolInfo: i,
											showUnit: e.model().model().unitConversionEnabled(),
											unitDescription: e => s.description(e),
											dateFormatter: e.model().model().dateTimeFormatter()
										};
									G(t, o)
								}
							}
						}),
						ht = new R({
							actionId: V.ChartPriceScaleMergeAllScalesToLeft,
							label: Ge,
							statName: "MergeAllScalesToLeft",
							onExecute: function() {
								e.model().mergeAllScales("left")
							}
						}),
						dt = new R({
							actionId: V.ChartPriceScaleMergeAllScalesToRight,
							label: je,
							statName: "MergeAllScalesToRight",
							onExecute: function() {
								e.model().mergeAllScales("right")
							}
						}),
						ut = new R({
							actionId: V.ChartPriceScaleMoveToLeft,
							label: qe,
							statName: "MoveScaleToLeft",
							onExecute: function() {
								e.model().mergeAllScales("left")
							}
						}),
						_t = new R({
							actionId: V.ChartPriceScaleMoveToRight,
							label: Ke,
							statName: "MoveScaleToRight",
							onExecute: function() {
								e.model().mergeAllScales("right")
							}
						});
					lt = new R({
						actionId: V.ChartMoveChartInLayout,
						label: o("Move chart"),
						subItems: [new R({
							actionId: V.ChartMoveChartInLayoutForward,
							label: o("Forward"),
							statName: "MoveChartRight",
							onExecute: function() {
								e._chartWidgetCollection.moveActiveChartWithUndo(!1)
							}
						}), new R({
							actionId: V.ChartMoveChartInLayoutBack,
							label: o("Back"),
							statName: "MoveChartLeft",
							onExecute: function() {
								e._chartWidgetCollection.moveActiveChartWithUndo(!0)
							}
						})]
					});
					var mt = h.enabled("show_object_tree");
					let pt;
					if (this._options.showFinancialsEnabled && (pt = new Y({
							label: de(o("Financials")),
							icon: i(428026),
							statName: "Financials",
							onExecute: () => {
								P(), window.matchMedia("screen and (max-width: 428px)").matches && ne("ContextMenuClick", "", "Financials"), $().then((e => {
									null !== e && e.trackFinancialsDialog(q.proSymbol.value(), "contextMenu")
								}))
							}
						})), this._actions = {
							chartProperties: te,
							mainSeriesPropertiesAction: ie,
							timeScaleReset: L,
							chartReset: t,
							invertSeriesScale: s,
							logSeriesScale: S,
							autoSeriesScale: r,
							lockSeriesScale: n,
							regularSeriesScale: a,
							percentSeriesScale: l,
							indexedTo100SeriesScale: c,
							compareOrAdd: H,
							paneObjectTree: mt ? ee : void 0,
							insertIndicator: U,
							symbolSearch: w,
							showSymbolInfoDialog: ct,
							changeInterval: k,
							seriesHide: re,
							studyHide: re,
							lineToggleLock: oe,
							lineHide: re,
							scaleSeriesOnly: ae,
							drawingToolbarAction: he,
							stayInDrawingModeAction: me,
							hideAllMarks: ge,
							applyTimeZone: C,
							showCountdown: rt,
							addPlusButton: nt,
							showSeriesLastValue: ve,
							showSeriesPrevCloseValue: fe,
							showSeriesPrevCloseLine: ye,
							showBidAskLabels: Ze,
							showBidAskLines: $e,
							showPrePostMarketPriceLabel: Qe,
							showPrePostMarketPriceLine: Je,
							showHighLowPriceLabels: tt,
							showHighLowPriceLines: ot,
							showAverageClosePriceLabel: it,
							showAverageClosePriceLine: st,
							showSymbolLabelsAction: ze,
							showStudyLastValue: He,
							showStudyPlotNamesAction: Xe,
							undo: f,
							redo: b,
							mergeLeftScalesAction: ht,
							mergeRightScalesAction: dt,
							moveScaleToLeft: ut,
							moveScaleToRight: _t,
							moveChartAction: lt
						}, y && (this._actions.applyColorTheme = y), I && (this._actions.addToWatchlist = I),
						pt && (this._actions.showFinancials = pt), _e && (this._actions.hideAllDrawingsAction = _e), h.enabled("show_source_code") && (this._actions.viewSourceCode = new Y({
							label: de(o("Source code")),
							statName: "OpenSelectedObjectSource",
							onExecute: this.openSelectedObjectSource.bind(this)
						})), !TradingView.onWidget() && h.enabled("text_notes") && (this._actions.addToTextNotes = A), null !== at && (this._actions.gotoDate = at), this.createSessionBreaksActions(), !this.readOnly()) {
						var gt = new R({
							actionId: V.ChartSelectedObjectRemove,
							label: o("Remove"),
							icon: i(535149),
							statName: "RemoveSelectedObject",
							onExecute: function() {
								var e = this._chartWidgetCollection.activeChartWidget.value();
								e || (e = this), e.removeSelectedSources()
							}.bind(this),
							hotkeyGroup: this._hotkeys,
							hotkeyHash: p.isMacKeyboard ? 8 : 46
						});
						this._hotkeys.add({
							handler: function() {
								this.removeSelectedSources()
							}.bind(this),
							desc: "Remove selected source",
							hotkey: p.isMacKeyboard ? 46 : 8
						}), this._actions.paneRemoveAllStudies = E, this._actions.paneRemoveAllDrawingTools = D, this._actions.paneRemoveAllStudiesDrawingTools = N, this._actions.applyStudiesToAllCharts = O, this._actions.studyRemove = gt, this._actions.lineRemove = gt, h.enabled("property_pages") && (this._actions.format = z)
					}
					this._actions.showPriceLine = new R({
						actionId: V.ChartLinesToggleSeriesPriceLineVisibility,
						label: o("Price line"),
						checkable: !0,
						statName: "TogglePriceLine"
					}), this._actions.showPriceLine.binding = new d(this._actions.showPriceLine, this.model().mainSeries().properties().showPriceLine, this.model(), Fe), this.readOnly() || (this._hotkeys.add({
						desc: "Draw Horizontal Line here",
						hotkey: g.Modifiers.Alt + 72,
						handler: function() {
							e.activePaneWidget && e.activePaneWidget.drawRightThere("LineToolHorzLine")
						}
					}), this._hotkeys.add({
						desc: "Draw Horizontal Ray here",
						hotkey: g.Modifiers.Alt + 74,
						handler: function() {
							e.activePaneWidget && e.activePaneWidget.drawRightThere("LineToolHorzRay")
						}
					}), this._hotkeys.add({
						desc: "Draw Vertical Line here",
						hotkey: g.Modifiers.Alt + 86,
						handler: function() {
							e.activePaneWidget && e.activePaneWidget.drawRightThere("LineToolVertLine")
						}
					}), this._hotkeys.add({
						desc: "Draw Cross Line here",
						hotkey: g.Modifiers.Alt + 67,
						handler: function() {
							e.activePaneWidget && e.activePaneWidget.drawRightThere("LineToolCrossLine")
						}
					}), this._hotkeys.add({
						desc: "Draw Trend Line",
						hotkey: g.Modifiers.Alt + 84,
						handler: function() {
							e.activePaneWidget && W.tool.setValue("LineToolTrendLine")
						}
					}), this._hotkeys.add({
						desc: "Draw Fib Retracement",
						hotkey: g.Modifiers.Alt + 70,
						handler: function() {
							e.activePaneWidget && W.tool.setValue("LineToolFibRetracement")
						}
					})), this._updateScalesActions()
				}
				options() {
					return this._options
				}
				executeActionById(e) {
					if ("takeScreenshot" === e) return console.warn('Action "takeScreenshot" is deprecated. Use method "takeScreenshot" instead'), void this._chartWidgetCollection.takeScreenshot();
					"hideAllDrawingsAction" === e && console.warn('Action "hideAllDrawingsAction" is deprecated. Use method "hideAllDrawingTools" instead'), e in this._actions ? this._actions[e] instanceof R && this._actions[e].execute() : console.warn("Unknown action id: " + e)
				}
				getCheckableActionState(e) {
					if (e in this._actions) {
						var t = this._actions[e];
						if (t instanceof R && t.isCheckable()) return t.isChecked();
						console.warn("Action " + e + " has no state")
					} else console.warn("Unknown action id: " + e);
					return null
				}
				_updateScalesActions() {
					if (null !== this._actions) {
						var e = this.model().mainSeries(),
							t = e.priceScale(),
							i = e.properties(),
							s = t.isLockScale(),
							o = i.style.value() === c.STYLE_PNF;
						this._actions.percentSeriesScale.update({
							disabled: s || o,
							checked: t.isPercentage()
						}), this._actions.logSeriesScale.update({
							disabled: s || o,
							checked: t.isLog()
						}), this._actions.regularSeriesScale.update({
							disabled: s || o,
							checked: t.isRegular()
						}), this._actions.indexedTo100SeriesScale.update({
							disabled: s || o,
							checked: t.isIndexedTo100()
						}), this._actions.invertSeriesScale.update({
							checked: t.isInverted()
						}), this._actions.lockSeriesScale.update({
							checked: t.isLockScale()
						}), this._actions.autoSeriesScale.update({
							checked: t.isAutoScale(),
							disabled: t.properties().autoScaleDisabled.value()
						})
					}
				}
				removeAllStudies() {
					this._model.removeAllStudies()
				}
				removeAllDrawingTools() {
					this._model.removeAllDrawingTools()
				}
				removeAllStudiesDrawingTools() {
					this._model.removeAllStudiesAndDrawingTools()
				}
				defaultSymbol() {
					return this._defSymbol
				}
				connect() {
					this._handler = function(e) {
						this._onData(e)
					}.bind(this), this._boundOnChartSessionIsConnectedChanged = this._onChartSessionIsConnectedChanged.bind(this), this._chartSession.isConnected().subscribe(this._boundOnChartSessionIsConnectedChanged), this._chartSession.criticalError().subscribe(this, this._onChartSessionCriticalError), this._chartSession.connect(this._handler)
				}
				finishInitWithoutConnect() {
					this._chartSession.disable(), this._init(), this.chartWidgetInitialized.fire()
				}
				reconnect() {
					this._chartSession.disconnect(), this._chartSession.connect()
				}
				widget() {
					return this._mainDiv
				}
				_onBackgroundColorChanged() {
					for (var e = 0; e < this._paneWidgets.length; e++) this._paneWidgets[e].setCursorForTool();
					this.update(), this.model().model().fullUpdate()
				}
				setTimingsMeter(e) {
					this._timingsMeter = e, this._updateTimingsMeterState()
				}
				ownerDocument() {
					return this._parent.ownerDocument
				}
				_updateTimingsMeterState() {
					var e = this._options.visible.value();
					null !== this._timingsMeter && (e ? this._timingsMeter.startCollect() : this._timingsMeter.stopCollect())
				}
				_createVolumeIfNeeded() {
					var e = h.enabled("create_volume_indicator_by_default") && this._options.addVolume,
						t = !this._content,
						i = h.enabled("charting_library_base"),
						s = h.enabled("create_volume_indicator_by_default_once"),
						o = this._content && !this._content.loading;
					e && (t || i && o && !s) && this._model.mainSeries().dataEvents().symbolResolved().subscribe(this, (function() {
						var e = this;
						setTimeout((function() {
							var t = e._model.model().mainSeries().symbolInfo();
							if (t) {
								var i = H(t);
								if (!e.containsVolume() && i) {
									var s = le.factoryDefaults("chartproperties.volumePaneSize"),
										o = e._model.model().createStudyInserter({
											type: "java",
											studyId: "Volume@tv-basicstudies"
										});
									o.setForceOverlay(h.enabled("volume_force_overlay")), o.setPaneSize(s), h.enabled("hide_volume_ma") && o.setPropertiesState({
										styles: {
											vol_ma: {
												display: O.None
											}
										}
									}), o.insert()
								} else if (!i && e.containsVolume()) {
									var r = e.model().dataSources().filter((function(e) {
										return e instanceof A && "Volume" === e.metaInfo().shortId
									}))[0];
									e._model.model().removeSource(r)
								}
							}
						}), 0)
					}), s)
				}
				_createSessions(e) {
					var t = this.showGeneralChartProperties.bind(this, _.timezoneSessions);
					e.createSessions(t)
				}
				_createPrePostMarket(e) {
					var t = this.showGeneralChartProperties.bind(this, _.symbol);
					e.createPrePostMarket(t)
				}
				_onChartStyleChanged() {
					ne("Chart", "Chart Style " + this._model.mainSeries().getStyleShortName().toUpperCase())
				}
				setVisibleTimeRange(e, t, i, s) {
					throw new Error("Not implemented")
				}
				loadRange(e) {
					this._model && (this.screen.show(), this._model.loadRange(e))
				}
				getSymbol(e) {
					var t;
					return (t = this._model ? this._model.mainSeries().properties() : this._properties.mainSeriesProperties) ? e && t.shortName && t.shortName.value() ? t.shortName.value() : t.symbol.value() : ""
				}
				insertStudy(e, t, i, s) {
					var o = this;
					return new Promise((function(r) {
						t ? window.runOrSignIn((function() {
							r(o._insertStudy(e, t, i, s))
						}), {
							source: "study on study"
						}) : r(o._insertStudy(e, t, i, s))
					})).catch((function() {}))
				}
				_insertStudy(e, t, i, s) {
					var r = this._model.createStudyInserter(e, t, i);
					r.setForceOverlay("java" === e.type && "Volume@tv-basicstudies" === e.studyId && h.enabled("volume_force_overlay"));
					var n = this,
						a = r.insert((function(e, t, i) {
							return new Promise((function(o, r) {
								0 !== n.selectPointMode().value() && n.cancelRequestSelectPoint(), s ? o(s(e, t, i)) : n.isSymbolicStudy(i) ? (ne("GUI", "Confirmation dialogs", "Symbol confirmation dialog"), S(n, i, o, r, "symbol")) : n.hasConfirmInputs(t) ? (ne("GUI", "Confirmation dialogs", "Inputs confirmation dialog"), S(n, i, o, r)) : o({
									inputs: {}
								})
							}))
						}));
					return a.then((function() {
						W.hideAllIndicators().value() && se()
					})).catch((function(e) {
						e === C.StudyCannotBeChild && y({
							type: "modal",
							title: o("Oops!"),
							content: o("This indicator cannot be applied to another indicator.")
						}), e === C.CannotGetMetainfo && y({
							type: "modal",
							title: o("Oops!"),
							content: o("Something went wrong. Please try again later.")
						})
					})), a
				}
				hasConfirmInputs(e) {
					if (void 0 === e) return !1;
					for (var t = 0; t < e.length; ++t) {
						var i = e[t];
						if (void 0 !== i.confirm && i.confirm) return !0
					}
					return !1
				}
				isSymbolicStudy(e) {
					switch (e.id) {
						case "Overlay@tv-basicstudies":
						case "CorrelationCoefficient@tv-basicstudies":
						case "Correlation Coeff@tv-basicstudies":
						case "Spread@tv-basicstudies":
						case "Ratio@tv-basicstudies":
							return !0;
						default:
							return !1
					}
				}
				_onChartSessionIsConnectedChanged(e) {
					e ? this._onConnection() : this._onDisconnect()
				}
				_onChartSessionCriticalError(e, t) {
					this._disconnected.fire(!0)
				}
				_onData(e) {
					if ("reconnect_bailout" === e.method) this._reconnectBailout.fire();
					else this._model.model().onData(e)
				}
				_onConnection() {
					this._online = !0, this.requestMetadata(), this._model && (this._model.restart(), this.model().model().fullUpdate(), this._connected.fire())
				}
				_onDisconnect() {
					this._model && this._model.disconnect(), this._online = !1, this._model && this._model.model().fullUpdate(), this._disconnected.fire()
				}
				_applyStudiesOverrides() {
					re.overrideDefaults(this._metaInfoRepository.getInternalMetaInfoArray())
				}
				requestMetadata() {
					this._addPerfMark("RequestMetadataStart"), he.logInfo("RequestMetadataStart"), this._metaInfoRepository.requestMetaInfo().then(function() {
						this._addPerfMark("RequestMetadataEnd"), he.logInfo("RequestMetadataEnd, already initialized: " + Boolean(this._inited)),
							this._inited ? this.model().model().setStudiesMetaData(this._metaInfoRepository.getInternalMetaInfoArray(), this._metaInfoRepository.getMigrations()) : (this._init(), this.chartWidgetInitialized.fire(), h.enabled("charting_library_base") || he.logDebug("initialized"))
					}.bind(this))
				}
				studiesMetaData() {
					return this._model.studiesMetaData()
				}
				getTimeScale() {
					return this._timeAxisWidget
				}
				chartWidgetCollection() {
					return this._chartWidgetCollection
				}
				setSeriesStyle(e, t) {
					this._model.setProperty(e.properties().style, t)
				}
				showObjectsTreePanelOrDialog() {
					var e = !1,
						t = window.widgetbar;
					t && t.isVisible() && (e = "object_tree" === t.setPage("object_tree").name);
					e || this.showObjectsTreeDialog()
				}
				showChartPropertiesForSource(e, t, i, s) {
					return h.enabled("property_pages") ? e === this._model.model().mainSeries() ? this.showGeneralChartProperties(t) : ((i = i || {}).onResetToDefault = this._model.restorePropertiesForSource.bind(this._model, e), this._showChartProperties(e, t, i, s)) : Promise.resolve(null)
				}
				generalPropertiesDefinitions() {
					return this._getChartPropertyDefinitionsViewModel().then((function(e) {
						return e.propertyPages()
					}))
				}
				propertiesDefinitionsForSource(e) {
					return N(e) || L(e) || B(e) ? e.getPropertyDefinitionsViewModel().then((function(e) {
						return null === e ? null : e.propertyPages()
					})).catch((function(e) {
						return he.logWarn(e), null
					})) : Promise.resolve(null)
				}
				toggleCompareOrAdd() {
					this._compareDialog.visible().value() ? this._compareDialog.hide() : this._compareDialog.show()
				}
				showIndicators(e, t) {
					if (window.studyMarket) return window.studyMarket.visible().value() ? void window.studyMarket.hide() : (window.studyMarket.show(e, t), window.studyMarket)
				}
				showFundamentals(e) {
					this.showIndicators(e, "financials")
				}
				removeSelectedSources() {
					this.removeDataSources(this._model.selection().dataSources())
				}
				removeDataSources(e) {
					var t = e.filter(function(e) {
						return e !== this._model.mainSeries() && e !== this._model.lineBeingCreated() && e.isUserDeletable()
					}.bind(this));
					if (0 !== t.length) {
						var i = null;
						L(t[0]) && (a(1 === t.length, "Cannot remove several studies (no multi select for studies)"), i = t[0]), t.find((function(e) {
							return e.hasAlert.value()
						})) ? T().then(function(e) {
							e && this._model.removeSelectedSources()
						}.bind(this)) : i && i.hasChildren() ? b(this._model.removeSelectedSources.bind(this._model)) : this._model.removeSelectedSources()
					}
				}
				toggleLockSelectedObject() {
					var e = this._model;
					e.selection().lineDataSources().forEach((function(t) {
						var i = t.properties().frozen.value();
						e.setProperty(t.properties().frozen, !i, (i ? ze : Ue).format({
							title: new r(t.name(), t.title())
						}))
					}))
				}
				showSourceProperties(e, t = null) {
					e === this._model.mainSeries() && (t = _.symbol), this.showChartPropertiesForSource(e, t)
				}
				openSelectedObjectSource(e) {
					var t = this._model.selection().dataSources()[0];
					if (t && t.metaInfo) {
						var s = t.metaInfo();
						if (s && s.scriptIdPart && s.pine)
							if (TradingView.bottomWidgetBar) i(366156).getPineSourceCode(s.scriptIdPart, s.pine.version).done((function(e) {
								var t = f.parse(e.version),
									i = e.lastVersionMaj ? f.parse(e.lastVersionMaj) : new f(0, 0),
									o = {
										scriptSource: e.source,
										scriptIdPart: s.scriptIdPart,
										scriptName: e.scriptName,
										scriptTitle: e.scriptTitle,
										version: e.version,
										isOld: !i.isZero() && i.major() !== t.major()
									};
								TradingView.bottomWidgetBar.activateScriptEditorTab(o)
							}))
					}
				}
				tags() {
					return this._model ? this._model.calculateDefaultTags() : []
				}
				state(e, t, i, s) {
					if (this._model) {
						const o = this._model.state(e, t, i, s);
						return o.chartId = this.id(), o
					}
					return this._content ? this._content : {}
				}
				metaInfo() {
					var e = this._metaInfo;
					return this._model && (e.systemTags = this._model.calculateDefaultTags()), e
				}
				onTagsChanged() {
					return this._tagsChanged
				}
				onModelTagsChanged() {
					this._tagsChanged.fire()
				}
				onAboutToBeDestroyed() {
					return this._aboutToBeDestroyed
				}
				destroy() {
					this._aboutToBeDestroyed.fire(), null !== this._removeMaximizeHotkey && (this._removeMaximizeHotkey(), this._removeMaximizeHotkey = null), 0 !== this._drawRafId && this._parent.ownerDocument.defaultView.cancelAnimationFrame(this._drawRafId), null !== this._backgroundTopColorSpawn && this._backgroundTopColorSpawn.destroy(), null !== this._backgroundBottomColorSpawn && this._backgroundBottomColorSpawn.destroy(), null !== this._timingsMeter && (this._timingsMeter.stopCollect(), this._timingsMeter = null);
					for (var e = 0; e < this._paneWidgets.length; e++) this._paneWidgets[e].destroy();
					this._paneWidgets.length = 0;
					for (e = 0; e < this._paneSeparators.length; e++) this._paneSeparators[e].destroy();
					for (var t in this._paneSeparators.length = 0, this._hotkeysListener && this._hotkeysListener.destroy(), this._barsButton && this._barsButton.destroy(), this._controlBarNavigation && (this._controlBarNavigation.destroy(), this._controlBarNavigation = void 0), this._mainDiv && this._mainDiv.remove(), this._actions) {
						var i = this._actions[t];
						i instanceof R && (i.destroy(), i.binder && i.binder.destroy())
					}
					null !== this._timeAxisWidget && (this._timeAxisWidget.destroy(), this._timeAxisWidget = null), null !== this._definitionsViewModel && this._definitionsViewModel.destroy(), this._hotkeys && (this._hotkeys.destroy(), this._hotkeys = null), this._mainDiv.removeEventListener("wheel", this._onWheelBound), window.removeEventListener("keydown:chart_" + this._id, this._keydownEventListener), super.destroy(), this._chartSession.criticalError().unsubscribe(this, this._onChartSessionCriticalError), this._chartSession.isConnected().unsubscribe(this._boundOnChartSessionIsConnectedChanged), this._chartSession.destroy()
				}
				title() {
					return o("Chart Properties")
				}
				symbolProperty() {
					return this._model.mainSeries().properties().shortName ? this._model.mainSeries().properties().shortName : this._model.mainSeries().properties().symbol
				}
				loadContent(e, t) {
					this.screen.show();
					var i = this;
					this.isMaximizedPane() && this.toggleMaximizePane(null);
					for (var s, o = i._model.model().dataSources(), r = 0; r < o.length; r++) {
						var n = o[r];
						n !== i._model.mainSeries() && i._model.model().removeSource(n, !0)
					}
					this._model.disconnect(), i.activePaneWidget = null, i._model.mainSeries().purgeSymbolInfo(), e.loading = !0, this._content = e, this._initialLoading = Boolean(t);
					for (r = 0; r < e.panes.length; ++r)
						for (var a = 0; a < e.panes[r].sources.length; ++a)
							if (e.panes[r].sources[a].state.symbol) {
								s = e.panes[r].sources[a].state;
								break
							} if (!s) throw Error("An error occured while determining main series ion the chart");
					i._properties.mainSeriesProperties.mergeAndFire({
						visible: !0,
						symbol: s.symbol,
						timeframe: "",
						onWidget: i._onWidget,
						interval: s.interval || "D",
						style: s.style
					}), i._init(), i._model.undoHistory().clearStack()
				}
				_contentSeriesProperties() {
					if (this._content)
						for (var e = this._content.panes.length; e-- > 0;)
							for (var t = this._content.panes[e].sources, i = t.length; i-- > 0;)
								if ("MainSeries" === t[i].type) return t[i].state
				}
				updateUndoRedo() {
					this._model && (this.actions().undo.update({
						disabled: this._model.undoHistory().undoStack().isEmpty()
					}), this.actions().redo.update({
						disabled: this._model.undoHistory().redoStack().isEmpty()
					}))
				}
				createSessionBreaksActions() {
					var e = new R({
						actionId: V.ChartSessionBreaksToggleVisibility,
						label: o("Session breaks"),
						checkable: !0,
						statName: "ToggleSessionBreaks"
					});
					e.binder = new d(e, this._model.chartModel().sessions().properties().graphics.vertlines.sessBreaks.visible, this.model(), He), this._actions.sessionBreaks = e
				}
				updateActionForIntradayOnly(e) {
					e && e instanceof R && e.update({
						disabled: this.model().mainSeries().isDWM()
					})
				}
				containsVolume() {
					return this.model().dataSources().some((function(e) {
						return e instanceof A && "Volume" === e.metaInfo().shortId
					}))
				}
				containsStudyByPredicate(e) {
					return !!this._model && this._model.dataSources().some((function(t) {
						if (!(t instanceof A)) return !1;
						var i = t.metaInfo();
						return e(i)
					}))
				}
				containsStudy(e) {
					return this.containsStudyByPredicate((function(t) {
						return t.id === e || t.fullId === e
					}))
				}
				isSmall() {
					return this._width() < 550 || this._height() < 300
				}
				onWidget() {
					return this._onWidget
				}
				onCmeWidget() {
					return "cme" === this.widgetCustomer()
				}
				widgetCustomer() {
					return this._widgetCustomer
				}
				resize() {
					var e = this._height() + "px",
						t = this._width() + "px";
					this._mainDiv.style.height = e, this._mainDiv.style.width = t, this._elMainTable.style.height = e, this._elMainTable.style.width = t, this._resizeHandler && this._mainDiv && this._resizeHandler()
				}
				chartSession() {
					return this._chartSession
				}
				onLineCancelled() {
					W.resetToCursor()
				}
				applyOverrides(e) {
					var t = {};
					for (var i in e) i.startsWith("mainSeriesProperties.priceAxisProperties") || (t[i] = e[i]);
					if (applyPropertiesOverrides(this.properties(), null, !1, t, null), this._model) {
						applyPropertiesOverrides(this._model.model().properties(), null, !1, t), applyPropertiesOverrides(this._model.mainSeries().properties(), null, !1, t, "mainSeriesProperties"), this._model.model().sessions().applyOverrides(t);
						const e = this._model.chartModel().watermarkSource();
						null !== e && e.applyOverrides(t)
					}
				}
				applyStudiesOverrides(e) {
					re.mergeDefaultsOverrides(e), this._applyStudiesOverrides()
				}
				setActive(e) {
					this._isActive = e, ae().isTouch && (e && 0 !== this.selectPointMode().value() ? this.startTrackingMode() : this.exitTrackingMode()), this._paneWidgets.forEach((function(e) {
						e.update()
					})), e || this.model().selectionMacro((function(e) {
						e.clearSelection()
					}))
				}
				isActive() {
					return this._isActive
				}
				trackTime() {
					return this._chartWidgetCollection.lock.trackTime
				}
				isMultipleLayout() {
					return _e(this._chartWidgetCollection.layout.value())
				}
				selectPointMode() {
					return this._model.model().selectPointMode()
				}
				cancelRequestSelectPoint() {
					this._model.model().cancelRequestSelectPoint()
				}
				requestSelectPoint(e, t) {
					var i = this;
					return new Promise((function(s, o) {
						if (a()) {
							W.resetToCursor(!0), i._model.lineBeingCreated() && i._model.cancelCreatingLine();
							var r = !1,
								n = {};
							i._model.model().onPointSelected().subscribe(n, (function(e, t) {
								r = !0, i._isVisible.unsubscribe(a), i._hideHint(), s({
									point: e,
									pane: t
								})
							}), !0), i._model.model().requestSelectPoint(e), i.startTrackingMode(), void 0 !== t && i._showHint(t), i._isVisible.subscribe(a), i.selectPointMode().subscribe((function() {
								setTimeout((function() {
									r || (0 === i.selectPointMode().value() && i._hideHint(), i._model.model().onPointSelected().unsubscribeAll(n), i._isVisible.unsubscribe(a), o("cancelled"))
								}))
							}), {
								once: !0
							})
						}

						function a() {
							return !!i.isVisible() || (o("Chartwidget must be visible"), i.cancelRequestSelectPoint(), !1)
						}
					}))
				}
				showReplayOrderConfirmationDialog() {
					return this.model().isInReplay() ? new Promise((function(e, t) {
						w({
							text: o("You are in the chart replay mode. An order will be placed in real-time. Do you still want to place the order?"),
							onConfirm: function(t) {
								e(), t.dialogClose()
							},
							onClose: t
						})
					})) : Promise.resolve()
				}
				_addPerfMark(e) {
					me("ChartWidget." + this._id + "." + e)
				}
				requestFullscreen() {
					this._options.requestFullscreen()
				}
				getResizerDetacher() {
					return this._options
				}
				_createHint() {
					if (null === this._hintDefferedPromise) {
						var e = fe();
						this._hintDefferedPromise = e;
						var t = this;
						Promise.all([i.e(8834), i.e(91579), i.e(75514), i.e(26166)]).then(i.bind(i, 410837)).then((function(i) {
							e.resolve(new i.ChartEventHintRenderer(t._chartWidgetCollection.getContainer()))
						}))
					}
					return this._hintDefferedPromise ? l(this._hintDefferedPromise).promise : null
				}
				_showHint(e) {
					if (h.enabled("popup_hints"))
						if (null !== this._activeHint) this._activeHint.show(e);
						else {
							var t = this,
								i = this._createHint();
							null !== i && i.then((function(i) {
								if (null !== i) {
									if (t._activeHint = i, void 0 === e) return;
									t._activeHint.show(e)
								}
							}))
						}
				}
				_hideHint() {
					null !== this._activeHint && this._activeHint.hide()
				}
			}
		},
		264170: (e, t, i) => {
			"use strict";
			var s = i(97639),
				o = i(588537).assert,
				r = i(575932).t,
				n = i(579917).createDeferredPromise,
				a = (r = i(575932).t, i(277036).TranslatedString),
				l = i(467608).layouts,
				c = i(638456).supportTouch,
				h = i(440081).createUndoHistory,
				d = i(308170),
				u = i(398835),
				_ = i(470316),
				m = i(251954),
				p = i(611688),
				g = i(262325),
				S = i(911905).getLogger("Chart.ChartWidgetCollection"),
				v = i(860502).preventDefaultForContextMenu,
				f = i(195048),
				b = i(509966).rangesAreEqual,
				y = i(161590).GeneralChartPropertiesRenderer,
				C = i(364019).setLastUsedResolution,
				w = i(834698).CompareDialogRenderer,
				T = i(314802).isOnMobileAppPage,
				P = i(393987),
				M = i(749473);
			const {
				isSupportedLayout: x,
				tryGuessingTheMostSuitableLayout: I
			} = i(467608);
			var A = i(63208).CollectionViewMode,
				k = i(850775).mediaState,
				L = i(657624).SwapChartsUndoCommand,
				E = i(313528).ToastsFactory,
				D = i(174519).reconnectChartApi,
				N = i(690352).marketStatusText,
				B = i(195048).STYLE_RANGE,
				O = i(273044).Interval,
				R = i(779923).showConfirm,
				V = i(125226).isFeatureEnabled,
				W = i(775647),
				F = W.applyIndicatorsToAllChartsImpl,
				z = W.applyIndicatorToAllChartsImpl,
				U = W.lineToolsAndGroupsDTOsImpl,
				H = W.getStateForChartImpl,
				G = W.resetLineToolsInvalidatedImpl,
				j = W.applyLineToolUpdateNotificationImpl,
				q = W.createClipboardHandler,
				K = W.chartsSymbolsImpl,
				Y = W.updateLayoutImpl,
				X = W.computeContentBoxImpl,
				Z = W.getVisuallyAdjacentDefImpl,
				$ = W.setLayoutImpl,
				Q = W.removeChartWidgetSubscriptionsImpl,
				J = W.createChartWidgetImpl,
				ee = W.generateNewChartId,
				te = W.syncCrosshairImpl,
				ie = W.createBroadcastChannel,
				se = W.destroyBroadcastChannel,
				oe = W.syncScrollImpl,
				re = W.allInitialModelsCreated,
				ne = W.allInitialSymbolsResolved,
				ae = W.applyThemeImpl,
				le = W.isFirstChartInLayout,
				ce = W.deserializedChartIds,
				he = W.setBrokerImpl,
				de = {
					saveChartEnabled: !0,
					takeScreenshotEnabled: !0,
					publishedChartsEnabled: !0
				},
				ue = new a("symbol lock", r("symbol lock")),
				_e = new a("interval lock", r("interval lock")),
				me = new a("date range lock", r("date range lock")),
				pe = new a("track time", r("track time")),
				ge = new a("change symbol", r("change symbol")),
				Se = new a("change resolution", r("change resolution")),
				ve = new a("change series style", r("change series style")),
				fe = r("Bar Replay isn't available for this chart type. Do you want to exit Bar Replay?"),
				be = V("sync_daterange_with_right_margin");
			e.exports = function(e) {
				var t = this,
					r = Object.assign({}, de, e),
					a = new g,
					V = r.readOnly || !1,
					ye = [],
					Ce = 0,
					we = new g,
					Te = new g,
					Pe = new g,
					Me = "s",
					xe = new g(null),
					Ie = new Map,
					Ae = new g([]),
					ke = new g;
				ke.setValue(A.ForceFullscreen);
				var Le = [],
					Ee = !1,
					De = !1,
					Ne = new g(!1),
					Be = new g(null),
					Oe = new g(!1),
					Re = new g(!1),
					Ve = new g(!1),
					We = new g(!1),
					Fe = new g(!1);
				Fe.subscribe(Xt), xe.subscribe(Zt);
				var ze = new g(TVSettings.getBool("chart.syncCrosshair", !0)),
					Ue = u.createGroup({
						desc: "Layout"
					}),
					He = null,
					Ge = null,
					je = null,
					qe = null;
				if (window.TVD) {
					var Ke = window.TVD.crosshairSyncEnabled;
					Ke ? (Ke.value() && (je = ie(ft)), qe = Ke.subscribe((e => {
						e ? je = ie(ft) : (se(ft()), je = null)
					}))) : je = ie(ft)
				}
				var Ye = ze.value();
				ze.subscribe((function(e) {
					Ye = e = !!e, TVSettings.setValue("chart.syncCrosshair", e);
					for (var t = 0; t < ye.length; ++t) {
						var i = ye[t].chartWidget;
						i.hasModel() && i.model().model().lightUpdate()
					}
				}));
				var Xe = new g(Me),
					Ze = r.resizerBridge.width,
					$e = r.resizerBridge.height,
					Qe = new g(null),
					Je = r.widgetOptions || {},
					et = r.metaInfo || {},
					tt = {
						id: new g(et.id || null),
						name: new g(et.name),
						description: new g(et.description),
						username: new g(et.username),
						uid: new g(et.uid),
						lastModified: new g(et.lastModified)
					},
					it = h();
				it.onChange().subscribe(null, (function(e) {
					m.emit("undo_redo_state_changed", e)
				}));
				var st = r.resizerBridge.container.value();
				st.addEventListener("contextmenu", v);
				var ot, rt = n(),
					nt = new s,
					at = new s,
					lt = new s,
					ct = new g(!1),
					ht = new g(null),
					dt = null,
					ut = null;
				r.seriesControlBarEnabled && (ot = "0px", ht.setValue(document.createElement("div")), ht.value().style.left = ot, ht.value().style.right = ot, ht.value().style.bottom = ot,
					ht.value().classList.add("chart-toolbar", "chart-controls-bar"), ht.value().setAttribute("data-is-chart-toolbar-component", "true"), st.appendChild(ht.value()), Promise.all([i.e(90519), i.e(8348), i.e(37135), i.e(5979), i.e(21834), i.e(95468), i.e(80580), i.e(82739), i.e(29331), i.e(44155), i.e(12580), i.e(73327), i.e(45410), i.e(84236), i.e(68631), i.e(69184), i.e(25257), i.e(75514), i.e(98449), i.e(20795), i.e(14135), i.e(47260)]).then(i.bind(i, 272976)).then((({
						BottomToolbarRenderer: e
					}) => {
						var i = r.resizerBridge,
							o = [i.container.spawn(), i.width.spawn(), i.height.spawn()],
							n = i.container.value(),
							a = function() {
								var e = n.getBoundingClientRect(),
									t = X(ft());
								return t.top = e.top + t.top, t.left = e.left + t.left, t
							},
							l = new s,
							c = function() {
								l.fire()
							};
						o.forEach((function(e) {
							e.subscribe(c)
						}));
						var h = function() {
							o.forEach((function(e) {
								e.destroy()
							})), l.destroy()
						};
						dt = new e(ht.value(), l, a, t, ChartApiInstance, Je, r.seriesControlBar), ut = function() {
							null !== dt && (dt.destroy(), dt = null, ht.value().remove(), ht.setValue(null)), h()
						}
					})));
				var _t, mt = new y(t),
					pt = new w(t),
					gt = null;

				function St() {
					ct.setValue(ye.some((e => {
						const t = e.chartWidget.lineToolsSynchronizer();
						return null !== t && t.hasChanges().value()
					})))
				}

				function vt(e) {
					return W.checkProFeatureImpl(ft(), e)
				}

				function ft() {
					return {
						undoHistory: it,
						chartWidgetsDefs: ye,
						chartsCountToSave: bt,
						actualLayoutCount: yt,
						savedChartWidgetOptions: Le,
						activeChartWidget: a,
						options: r,
						parent: st,
						toastsFactory: gt,
						crosshairLockRaw: Ye,
						crossHairSyncBroadcast: je,
						setChartStorageNotificationSubscription: e => {
							Ge = e
						},
						maximizedChartDef: Qe,
						setMaximized: At,
						layoutTemplate: Pe,
						widthWV: Ze,
						heightWV: $e,
						checkProFeature: vt,
						lineToolsSynchronizerHasChanges: ct,
						recalcHasChanges: St,
						onZoom: at,
						onScroll: lt,
						layoutType: Me,
						layoutWV: Xe,
						setLayoutType: e => {
							Me = e
						},
						isPhoneSize: Ne,
						viewMode: ke,
						updateViewMode: Lt,
						loadingContent: Ee,
						setLoadingContent: e => {
							Ee = e
						},
						initialLoading: De,
						inlineChartsCount: Te,
						updateWatchedValue: Et,
						checkAllPendingModelsAlreadyCreated: kt,
						readOnly: V,
						symbolLock: Re,
						customLegendWidgetsFactoriesMap: _i,
						globalDetachable: we,
						saveChartService: He,
						customSources: di,
						updateActivityView: Dt,
						chartWidgetCreatedDelegate: nt,
						sizingState: Be,
						currentLayoutResizeAction: xe,
						allLayoutSizesState: Ie,
						splitters: Ae,
						trackTimeLock: We,
						widgetOptions: Je,
						dateRangeLock: Fe,
						bottomToolbar: ht,
						replayContainer: ui,
						layoutSizesChanged: Oe,
						subscribeToCompletedEventForDateRangeSync: qt
					}
				}

				function bt() {
					return ye.length + Le.length
				}

				function yt() {
					return l[Me].count
				}

				function Ct(e, t, i, s, o) {
					return H(ft(), e, t, i, s, o)
				}

				function wt() {
					Y(ft())
				}
				gt = new E(r.resizerBridge, (function() {
					return ht.value() ? ht.offsetHeight : 0
				})), Be.subscribe((() => wt())), Ze.subscribe(wt), $e.subscribe(wt), this.updateLayout = wt, Ne.setValue(!1);
				var Tt = ["phone", "phone-vertical"];

				function Pt(e, t) {
					r.mobileForceChartMaximizeEnabled && (!Tt.includes(k.device) || t && Tt.includes(t) ? Tt.includes(k.device) || t && !Tt.includes(t) || Ne.setValue(!1) : Ne.setValue(!0))
				}

				function Mt() {
					window.is_authenticated && (Ne.value() ? ke.value() === A.ForceFullscreen && (_t = Qe.value(), a.value().requestFullscreen()) : _t || (At(null), Lt()))
				}

				function xt(e) {
					return e.rdState.owner.value() !== e
				}

				function It(e) {
					return $(ft(), e, t)
				}

				function At(e) {
					Qe.value() !== e && (Qe.setValue(e), It(Me))
				}

				function kt() {
					ye.every((e => e.chartWidget.hasModel())) && (Et(), m.emit("layout_changed"))
				}

				function Lt() {
					"s" === Me || Qe.value() ? ke.setValue(A.ForceFullscreen) : ke.setValue(A.Multichart)
				}

				function Et() {
					var e = Math.min(Pe.value().count, ye.length) - 1;
					if (e < 0) a.deleteValue();
					else {
						var t = Ce;
						t < 0 && (t = 0), t > e && (t = e), a.setValue(ye[t].chartWidget)
					}
				}

				function Dt() {
					for (var e = ye.length; e--;) {
						var t = e === Ce;
						ye[e].container.value().classList.toggle("active", t), ye[e].container.value().classList.toggle("inactive", !t)
					}
				}

				function Nt(e, t) {
					return Z(ft(), e, t)
				}

				function Bt(e) {
					var t = Nt(ye[Ce], e);
					t && (a.setValue(t.chartWidget), Qe.value() && It(Me))
				}

				function Ot(e, t) {
					var i = ye.findIndex((function(t) {
							return t.chartWidget === e
						})),
						s = ye.findIndex((function(e) {
							return e.chartWidget === t
						}));
					if (-1 === i || -1 === s) throw new Error("chart is not in the layout");
					var o = ye[i],
						r = ye[s];
					ye[i] = r, ye[s] = o, Ce === i ? Ce = s : Ce === s && (Ce = i), wt()
				}
				var Rt = new s,
					Vt = new g,
					Wt = new g([]);

				function Ft(e, t) {
					var i = e.model(),
						s = i.mainSeries().properties().style;
					i.setChartStyleProperty(s, t, ve)
				}
				var zt = null;

				function Ut(e) {
					var t = e.mainSeries().properties();
					t.style.subscribe(null, Ht), Ht(t.style), e.model().onSelectedSourceChanged().subscribe(null, Gt), Fe.value() && (Kt(e), Qt()), Gt(e.selection().allSources())
				}

				function Ht(e) {
					Vt.setValue(e.value())
				}

				function Gt() {
					var e = zt.model();
					Wt.setValue(e.selection().allSources())
				}
				a.subscribe((function(e) {
					if (e) {
						for (var t, i = ye.length; i--;)
							if (ye[i].chartWidget === e) {
								t = i;
								break
							} if (!isFinite(t)) throw new Error("Cannot make detached ChartWidget active");
						if (Ce !== t) {
							Qe.value() && (xt(ye[t]) || Qe.setValue(ye[t])), Ce = t, Dt();
							for (i = ye.length; i--;) ye[i].chartWidget !== e && ye[i].chartWidget.setActive(!1);
							gi(), e.setActive(!0)
						}! function(e) {
							if (zt !== e) {
								if (zt && (zt.modelCreated().unsubscribe(null, Ut), zt.hasModel())) {
									var t = zt.model();
									Fe.value() && Yt(t), t.mainSeries().properties().style.unsubscribe(null, Ht), t.model().onSelectedSourceChanged().unsubscribe(null, Gt), zt = null
								}
								e && (zt = e, e.hasModel() ? Ut(e.model()) : e.modelCreated().subscribe(null, Ut))
							}
						}(e)
					}
				}), {
					callWithLast: !0
				});
				var jt = new Map;

				function qt(e, t) {
					var i = e.id();
					if (!jt.has(i)) {
						var s = function() {
							const i = e.id();
							jt.has(i) && (jt.delete(i), Qt(t ? e : void 0))
						};
						e.model().mainSeries().dataEvents().completed().subscribe(null, s, !0), jt.set(i, {
							cw: e,
							callback: s
						})
					}
				}

				function Kt(e) {
					e.timeScale().visibleBarsStrictRangeChanged().subscribe(null, $t)
				}

				function Yt(e) {
					e.timeScale().visibleBarsStrictRangeChanged().unsubscribe(null, $t), jt.forEach((function(e) {
						var t = e.cw,
							i = e.callback;
						t.model().mainSeries().dataEvents().completed().unsubscribe(null, i)
					})), jt.clear()
				}

				function Xt(e) {
					var t = a.value();
					if (t && t.hasModel()) {
						var i = t.model();
						e ? (Kt(i), Qt()) : Yt(i)
					}
				}

				function Zt(e) {
					Fe.value() && null === e && Qt()
				}

				function $t(e, t) {
					Qt()
				}

				function Qt(e) {
					if (Fe.value() && null === xe.value()) {
						var t = a.value(),
							i = t.model().mainSeries();
						if (M.isTimeBasedStyle(i.style())) {
							var s = t.model().timeScale(),
								o = s.visibleBarsStrictRange();
							if (null !== o) {
								var r = o.firstBar(),
									n = be ? o.lastBar() : Math.min(o.lastBar(), s.points().lastIndex()),
									l = s.indexToTimePoint(r);
								null === l && i.endOfData() && (l = s.indexToTimePoint(s.points().firstIndex()));
								var c = s.indexToTimePoint(n);
								if (be && null == c && (c = s.indexToTimePoint(s.points().lastIndex())), null !== l && null !== c) {
									if (jt.delete(t.id()), !be) {
										var h = i.barCloseTime();
										null !== h && h < c && (c = h)
									}
									var d = 1e3 * l,
										u = 1e3 * c;
									if (i.isDWM()) {
										var _ = new Date(d),
											m = new Date(u);
										P.set_hms(_, 0, 0, 0, 0), P.set_hms(m, 0, 0, 0, 0), d = _.getTime(), u = m.getTime()
									}
									for (var p = 0; p < ye.length; p++) {
										var g = ye[p].chartWidget;
										g.hasModel() && g !== t && (void 0 === e || g === e) && M.isTimeBasedStyle(g.model().mainSeries().style()) && setTimeout(Jt.bind(null, g, d, u))
									}
								} else qt(t, !1)
							}
						}
					}
				}

				function Jt(e, t, i) {
					e.model().model().gotoTimeRange(t, i)
				}

				function ei(e) {
					for (var t = !1, i = 0; i < ye.length; i++) {
						var s = ye[i].chartWidget;
						if (s.hasModel()) s.model().mainSeries().properties().symbol.value() !== e && (t || (it.beginUndoMacro(ge), t = !0), s.setSymbol(e))
					}
					t && it.endUndoMacro()
				}
				var ti = !1;

				function ii(e) {
					if (C(e), ti = !0, Ve.value()) {
						for (var t = !1, i = 0; i < ye.length; i++) {
							var s = ye[i].chartWidget;
							s.model().mainSeries().properties().interval.value() !== e && (t || (it.beginUndoMacro(Se), t = !0), s.setResolution(e))
						}
						t && it.endUndoMacro()
					} else a.value().setResolution(e);
					ti = !1
				}

				function si() {
					var e = [];
					if (Ve.value())
						for (var t = 0; t < ye.length; t++) e.push(ye[t].chartWidget);
					else e.push(a.value());
					return e
				}
				var oi = !1,
					ri = new s;

				function ni() {
					r.resizerBridge.requestFullscreen()
				}

				function ai() {
					r.resizerBridge.exitFullscreen()
				}

				function li() {
					return r.resizerBridge.fullscreenable
				}

				function ci() {
					return r.resizerBridge.fullscreen
				}

				function hi(e) {
					if (0 !== ye.length) {
						for (var t = ye.length; t--;) ye[t].chartWidget.setActive(!1);
						ye[Ce].chartWidget.setActive(e)
					}
				}
				V || (Ue.add({
					desc: "Switch active chart",
					hotkey: 9,
					handler: function() {
						Bt(!1)
					}
				}), Ue.add({
					desc: "Switch active chart",
					hotkey: _.Modifiers.Shift + 9,
					handler: function() {
						Bt(!0)
					}
				})), Ue.add({
					desc: "Fullscreen mode",
					hotkey: _.Modifiers.Shift + 70,
					isDisabled: p.enabled("widget") || !li().value(),
					handler: function() {
						ci().value() ? ai() : ni()
					}
				}), r.takeScreenshotEnabled && (Ue.add({
					desc: "Screenshot server",
					hotkey: _.Modifiers.Alt + 83,
					handler: W.takeServerScreenshot.bind(this, r.snapshotUrl, t)
				}), T("any") || (Ue.add({
					desc: "Download client screenshot",
					hotkey: _.Modifiers.Mod + _.Modifiers.Alt + 83,
					handler: W.downloadScreenshot.bind(this, t)
				}), Ue.add({
					desc: "Copy client screenshot",
					hotkey: _.Modifiers.Mod + _.Modifiers.Shift + 83,
					handler: W.copyScreenshotToClipboard.bind(this, t)
				}))), r.saveChartEnabled && Ue.add({
					desc: "Save Chart Layout",
					hotkey: _.Modifiers.Mod + 83,
					handler: function() {
						Rt.fire()
					}
				});
				var di = new Map,
					ui = null,
					_i = new Map;
				const mi = q(ft());

				function pi(e, t) {
					if (Ee = !0, De = Boolean(t), Le.splice(0), e) {
						if (e.charts || (e = {
								layout: "s",
								charts: [e]
							}), e.layoutsSizes)
							for (const t of Object.keys(e.layoutsSizes)) Ie.set(t, e.layoutsSizes[t]);
						var i = new Set;
						e.charts.forEach((function(e) {
							e.chartId && i.add(e.chartId)
						})), e.charts.forEach((function(e) {
							if (!e.chartId) {
								var t = ee((function(e) {
									return i.has(e)
								}));
								i.add(t), e.chartId = t
							}
						}));
						let t = e.layout;
						if (!x(t)) {
							const e = I(t);
							S.logError(`Loading unsupported layout ${t}. Force migration to ${e}`), t = e
						}
						Me = vt(t || "s");
						for (var s = 0; s < e.charts.length; s++) {
							var o = e.charts[s];
							Le.push({
								content: o
							})
						}
						e.symbolLock && Re.setValue(!0), e.intervalLock && Ve.setValue(!0), e.trackTimeLock && We.setValue(!0), e.dateRangeLock && Fe.setValue(!0)
					}
					It(Me), "s" === Me || r.mobileForceChartMaximizeEnabled || ke.setValue(A.Multichart), d.init(), d.tool.subscribe(Si), d.tool.subscribe(gi), Ee = !1, De = !1
				}

				function gi() {
					var e = a.value();
					ye.forEach((function(t) {
						t.chartWidget !== e && t.chartWidget.updateCrossHairPositionIfNeeded()
					})), e && e.updateCrossHairPositionIfNeeded()
				}

				function Si() {
					ye.forEach((function(e) {
						e.chartWidget.onToolChanged()
					}))
				}
				r.globalEvents && mi.listen(), Object.assign(this, {
					createChartWidget: function(e) {
						return J(ft(), this, e).chartWidget
					},
					getAll: function() {
						return ye.map((function(e) {
							return e.chartWidget
						}))
					},
					maximizedChartWidget: () => null === Qe.value() ? null : Qe.value().chartWidget,
					destroy: function() {
						if (ri.fire(), hi(!1), null !== ut && (ut(), ut = null), Q(ft()), Fe.unsubscribe(Xt), xe.unsubscribe(Zt), ye.forEach((function(e) {
								void 0 !== e.timingsMeter && e.timingsMeter.destroy(), e.chartWidget.destroy()
							})), r.resizerBridge.remove(), Ae.value().forEach((e => {
								e.mouseHandler.destroy(), e.mouseListener.destroy()
							})), window.removeEventListener("resize", wt), k.off("changeDevice", Pt), r.mobileForceChartMaximizeEnabled && !r.handleMaximizedChartOnResizeDisabled && k.off("changeDevice", Mt), d.tool.unsubscribe(gi), d.tool.unsubscribe(Si), rt.resolve(), st.remove(), di.clear(), _i.clear(), Ue.destroy(), Ge && Ge.destroy(), mi && mi.destroy(), window.TVD) {
							const e = window.TVD.crosshairSyncEnabled;
							e && e.unsubscribe(qe), se(ft())
						}
					},
					onAboutToBeDestroyed: ri,
					layout: Xe.readonly(),
					setLayout: It,
					activeChartWidget: a,
					viewMode: ke,
					activeChartStyle: Vt.readonly(),
					setChartStyleToWidget: function(e, t) {
						if (t || (t = a.value()), t) {
							for (var i = !1, s = si(), o = 0; o < s.length; o++) {
								var r = s[o].model().model();
								if (r.isInReplay() && !r.isSeriesStyleSupported(e)) {
									i = !0;
									break
								}
							}
							i ? R({
								text: fe,
								onConfirm: function(i) {
									Ft(t, e), i.dialogClose()
								}
							}) : Ft(t, e)
						}
					},
					selectedSources: Wt.readonly(),
					metaInfo: tt,
					state: function(e, i, s, o) {
						for (var r = [], n = bt(), a = 0; a < n; a++) {
							var l = Ct(a, e, i, s, o);
							l && r.push(l)
						}
						var c = {
							name: t.metaInfo.name.value(),
							layout: Me,
							charts: r
						};
						return Re.value() && (c.symbolLock = 1), Ve.value() && (c.intervalLock = 1), We.value() && (c.trackTimeLock = 1), Fe.value() && (c.dateRangeLock = 1), c.layoutsSizes = {}, Ie.forEach(((e, t) => {
							c.layoutsSizes[t] = e
						})), c
					},
					lineToolsAndGroupsDTOs: function() {
						return U(ft())
					},
					resetLineToolsInvalidated: function(e, t) {
						return G(ft(), e, t)
					},
					applyLineToolUpdateNotification: j.bind(null, ye),
					readOnly: function() {
						return V
					},
					onZoom: function() {
						return at
					},
					onScroll: function() {
						return lt
					},
					resizerBridge: function() {
						return r.resizerBridge
					},
					lock: {
						symbol: Re,
						setSymbolLockWithUndo: function(e) {
							if (e !== Re.value()) {
								if (it.beginUndoMacro(ue), e)
									for (var t = a.value(), i = t.getSymbol(), s = 0; s < ye.length; s++) {
										var o = ye[s].chartWidget;
										o !== t && (o.getSymbol() !== i && (o.setSymbol(i), Fe.value() && qt(o, !0)))
									}
								it.setWatchedValue(Re, e, ue), it.endUndoMacro()
							}
						},
						interval: Ve,
						setIntervalLockWithUndo: function(e) {
							if (e !== Ve.value()) {
								if (it.beginUndoMacro(_e), e)
									for (var t = a.value(), i = t.getResolution(), s = 0; s < ye.length; s++) {
										var o = ye[s].chartWidget;
										o !== t && (o.getResolution() !== i && (o.setResolution(i), Fe.value() && qt(o, !0)))
									}
								it.setWatchedValue(Ve, e, _e), it.endUndoMacro()
							}
						},
						dateRange: Fe,
						setDateRangeLockWithUndo: function(e) {
							e !== Fe.value() && it.setWatchedValue(Fe, e, me)
						},
						crosshair: ze,
						trackTime: We,
						setTrackTimeWithUndo: function(e) {
							We.value() !== e && it.setWatchedValue(We, e, pe)
						}
					},
					setSymbol: function(e) {
						Re.value() ? ei(e) : a.value().setSymbol(e)
					},
					setResolution: function(e) {
						if (!oi && !ti) {
							var t = !1;
							if (O.isRange(e))
								for (var i = si(), s = 0; s < i.length; s++) {
									var o = i[s].model().model();
									if (o.isInReplay() && o.mainSeries().style() !== B) {
										t = !0;
										break
									}
								}
							t ? R({
								text: fe,
								onConfirm: function(t) {
									ii(e), t.dialogClose()
								}
							}) : ii(e)
						}
					},
					setTimeFrame: function(e) {
						if (!oi) {
							if (oi = !0, Ve.value())
								for (var t = 0; t < ye.length; t++) {
									var i, s = ye[t].chartWidget;
									null !== (i = s.model().model().appliedTimeFrame().value()) && b(i, e) || s.loadRange(e)
								} else null !== (i = a.value().model().model().appliedTimeFrame().value()) && b(i, e) || a.value().loadRange(e);
							oi = !1
						}
					},
					updateLayout: wt,
					setChartLayoutWithUndo: function(e) {
						return W.setChartLayoutWithUndoImpl(ft(), this, e)
					},
					images: W.getSnapshot.bind(this, this, r.widgetOptions.customerReadableName, Je.onWidget),
					clientSnapshot: W.getClientSnapshot.bind(this, this, r.widgetOptions.customerReadableName, Je.onWidget),
					tags: function() {
						for (var e = [], t = 0; t < ye.length && t < Pe.value().count; t++) e = e.concat(ye[t].chartWidget.tags());
						return e = (e = Array.from(new Set(e))).map((function(e) {
							return e.toLowerCase().replace(/\W+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "")
						}))
					},
					syncCrosshair: (e, t, i, s) => te(ft(), e, t, i, s),
					syncScroll: function(e, t) {
						return oe(ft(), e, t)
					},
					setSymbolAll: ei,
					clearChartMetaInfo: function() {
						tt.id.setValue(null), tt.uid.setValue(void 0), tt.name.setValue(void 0)
					},
					takeScreenshot: W.takeScreenshot.bind(this, r.snapshotUrl, this),
					takeServerScreenshot: W.takeServerScreenshot.bind(this, r.snapshotUrl, this),
					loadContent: pi,
					purgeUnusedWidgets: function() {
						for (var e = l[Me].count; e < ye.length; e++) ye[e].chartWidget.destroy();
						ye.splice(l[Me].count)
					},
					applyOverrides: function(e) {
						for (var t = 0; t < ye.length; t++) ye[t].chartWidget.applyOverrides(e)
					},
					applyStudiesOverrides: function(e) {
						for (var t = 0; t < ye.length; t++) ye[t].chartWidget.applyStudiesOverrides(e)
					},
					switchChart: Bt,
					startFullscreen: ni,
					exitFullscreen: ai,
					fullscreen: ci,
					fullscreenable: li,
					destroyPromise: function() {
						return rt.promise()
					},
					chartWidgetCreated: function() {
						return nt
					},
					saveKeysPressed: function() {
						return Rt
					},
					getContainer: function() {
						return st
					},
					onWidget: Je.onWidget,
					applyTheme: ae.bind(null, ft(), t),
					applyIndicatorsToAllCharts: function(e) {
						F(ft(), e)
					},
					applyIndicatorsToAllChartsAvailable: function() {
						return !V && yt() > 1
					},
					applyIndicatorToAllCharts: function(e, t, i, s) {
						z(ft(), e, t, i, s)
					},
					setActive: hi,
					inlineChartsCount: Te.readonly(),
					revertToInline: function() {
						if (!Ne.value() || ke.value() !== A.ForceFullscreen) {
							At(null);
							for (var e = 0; e < ye.length; e++) ye[e].rdState.bridge().attach()
						}
					},
					chartMarketStatuses: function() {
						return ye.map((function(e) {
							var t = e.chartWidget.hasModel() ? e.chartWidget.model().mainSeries().marketStatusModel() : null;
							return null !== t ? N(t.status()) : "-"
						}))
					},
					chartSeriesStatuses: function() {
						return ye.map((function(e) {
							var t = e.chartWidget.hasModel() ? e.chartWidget.model().mainSeries().status() : null;
							return (null === t ? "" : f.SERIES_STATUS_TEXT[t]) + " (" + t + ")"
						}))
					},
					undoHistory: it,
					lineToolsSynchronizerHasChanges: ct,
					applyPreferencesToAllCharts: function(e) {
						var t = e.model().preferences();
						ye.forEach((function(i) {
							i.chartWidget._model !== e && i.chartWidget._model.applyPreferences(t)
						}))
					},
					getToasts: function() {
						return gt.getChartToasts()
					},
					addCustomSource: function(e, t, i) {
						o(!di.has(e), "Cannot create the same custom source multiple times"), di.set(e, {
							factory: t,
							layer: i
						});
						for (var s = 0; s < ye.length; ++s) {
							var r = ye[s].chartWidget;
							r.hasModel() && r.model().model().addCustomSource(e, t, i)
						}
					},
					removeCustomSource: function(e) {
						o(di.has(e), "Cannot remove not created custom source"), di.delete(e);
						for (var t = 0; t < ye.length; ++t) {
							var i = ye[t].chartWidget;
							i.hasModel() && i.model().model().removeCustomSource(e)
						}
					},
					addCustomWidgetToLegend: function(e, t) {
						o(!_i.has(e), "Cannot create the same custom widget in legend multiple times"), _i.set(e, t);
						for (var i = 0; i < ye.length; ++i) ye[i].chartWidget.addCustomWidgetToLegend(e, t)
					},
					addReplayWidget: function(e) {
						o(null === ui, "Cannot create replay container multiple times"), (ui = document.createElement("div")).style.position = "absolute", ui.style["min-height"] = "51px", ui.style.overflow = "hidden", ui.style.left = "0px", ui.style.right = "0px";
						var t = null === ht.value() ? 0 : ht.value().offsetHeight;
						ui.style.bottom = `${t}px`, ui.setAttribute("data-is-chart-toolbar-component", "true"), st.prepend(ui), e(ui), wt()
					},
					destroyReplayWidget: function() {
						o(null !== ui, "Cannot remove replay container, container is not created"), ui.remove(), ui = null, wt()
					},
					setViewMode: function(e) {
						ke.setValue(e)
					},
					moveActiveChartWithUndo: function(e) {
						var t = ye[Ce],
							i = Nt(t, e);
						i && it.pushUndoCommand(new L(Ot, t.chartWidget, i.chartWidget))
					},
					activeChartCanBeMoved: function() {
						return !(V || Te.value() < 2 || xt(ye[Ce]))
					},
					generalPropertiesDefinitions: function() {
						return a.value().generalPropertiesDefinitions()
					},
					reconnectChartApi: function(e) {
						D(e)
					},
					setBroker: function(e) {
						he(ft(), e)
					},
					setSaveChartService: function(e) {
						He = e;
						for (var t = 0; t < ye.length; ++t) {
							ye[t].chartWidget.setSaveChartService(e)
						}
					},
					getCompareDialogRenderer: function() {
						return pt
					},
					getChartPropertiesDialogRenderer: function() {
						return mt
					},
					clipboard: mi,
					chartsSymbols: function() {
						return K(ft())
					},
					isFirstChartInLayout: le.bind(null, ft()),
					deserializedChartIds: ce.bind(null, ft()),
					layoutSizesChanged: () => Oe
				}), W.createChartStorageSubscriptionsIfRequired(this, ft()), pi(r.content, !0), Xe.subscribe((function() {
					Dt()
				})), Xe.hook = function(e) {
					return e === this.value() ? e : vt(e)
				}, V && (Xe.writeLock = !0), window.addEventListener("resize", wt), r.mobileForceChartMaximizeEnabled && (k.on("changeDevice", Pt), r.handleMaximizedChartOnResizeDisabled || k.on("changeDevice", Mt), Pt(), Mt());
				var vi = 0;

				function fi() {
					0 === --vi && m.emitOnce("onChartReady")
				}
				if (ye.forEach((function(e) {
						if (e) {
							vi++;
							var t = e.chartWidget;
							t.withModel(null, (function() {
								r.metaInfo && t.model().model().setChartSaveTime(1e3 * r.metaInfo.lastModified);
								var e = t.model().mainSeries();
								if (e.bars().size() > 0 || e.isStatusBad()) fi();
								else {
									var i = e.dataEvents(),
										s = function() {
											fi(), i.barReceived().unsubscribe(null, s), i.completed().unsubscribe(null, s), i.error().unsubscribe(null, s)
										};
									i.barReceived().subscribe(null, s), i.completed().subscribe(null, s), i.error().subscribe(null, s)
								}
							}))
						}
					})), c()) {
					var bi = d.tool.setValue;
					d.tool.setValue = function() {
						t.selectedSources.value() && t.activeChartWidget.value().model().lineBeingCreated() && t.activeChartWidget.value().model().cancelCreatingLine(), bi.apply(d.tool, arguments)
					}
				}
				re(ft()).then(ne).then((function() {
					window.saver && window.is_authenticated && r.widgetOptions.justCloned && window.saver.saveChartSilently()
				})).catch(S.logError.bind(S))
			}
		},
		682244: (e, t, i) => {
			"use strict";
			i.d(t, {
				createAddNoteAction: () => l
			});
			var s = i(575932),
				o = i(588746),
				r = i(470316),
				n = i(301062),
				a = i(324020);

			function l(e, t, i) {
				return new o.TVAction({
					icon: a,
					label: (0, s.t)("Add to text notes"),
					statName: "AddToTextNotes",
					onExecute: () => {
						window.runOrSignIn((() => {
							var t;
							null === (t = window.widgetbar) || void 0 === t || t.setPage("base"), (0, n.createSymbolNote)(e.getSymbol(), i)
						}), {
							source: "Add text note in chart context menu"
						})
					},
					hotkeyHash: r.Modifiers.Alt + 78,
					...t
				})
			}
		},
		697455: (e, t, i) => {
			"use strict";
			var s;
			i.d(t, {
					TabNames: () => s
				}),
				function(e) {
					e.background = "Background", e.coordinates = "Coordinates", e.drawings = "Drawings", e.events = "Events", e.eventsAndAlerts = "Events & Alerts", e.inputs = "Inputs", e.properties = "Properties", e.scales = "Scales", e.legend = "Legend", e.sourceCode = "Source Code", e.style = "Style", e.symbol = "Symbol", e.timezoneSessions = "Timezone/Sessions", e.trading = "Trading", e.visibility = "Visibility", e.text = "Text"
				}(s || (s = {}))
		},
		617376: (e, t, i) => {
			"use strict";
			i.d(t, {
				getPriceAxisNameInfo: () => n
			});
			const s = ["Z", "Y", "X", "W", "V", "U", "T", "S"],
				o = ["A", "B", "C", "D", "E", "F", "G", "H"];
			class r {
				constructor(e) {
					this.label = e
				}
				equals(e) {
					return null !== e && this.label === e.label
				}
			}

			function n(e, t) {
				const i = "left" === e ? s : o;
				return new r(t < i.length ? i[t] : "")
			}
		},
		312820: (e, t, i) => {
			"use strict";
			i.d(t, {
				KineticAnimation: () => n
			});
			var s = i(588537);

			function o(e, t) {
				return e.position - t.position
			}

			function r(e, t, i) {
				const s = (e.position - t.position) / (e.time - t.time);
				return Math.sign(s) * Math.min(Math.abs(s), i)
			}
			class n {
				constructor(e, t, i, s) {
					this._position1 = null, this._position2 = null, this._position3 = null, this._position4 = null, this._animationStartPosition = null, this._durationMsecs = 0, this._speedPxPerMsec = 0, this._terminated = !1, this._minSpeed = e, this._maxSpeed = t, this._dumpingCoeff = i, this._minMove = s
				}
				addPosition(e, t) {
					if (null !== this._position1) {
						if (this._position1.time === t) return void(this._position1.position = e);
						if (Math.abs(this._position1.position - e) < this._minMove) return
					}
					this._position4 = this._position3, this._position3 = this._position2, this._position2 = this._position1, this._position1 = {
						time: t,
						position: e
					}
				}
				start(e, t) {
					if (null === this._position1 || null === this._position2) return;
					if (t - this._position1.time > 50) return;
					let i = 0;
					const s = r(this._position1, this._position2, this._maxSpeed),
						n = o(this._position1, this._position2),
						a = [s],
						l = [n];
					if (i += n, null !== this._position3) {
						const e = r(this._position2, this._position3, this._maxSpeed);
						if (Math.sign(e) === Math.sign(s)) {
							const t = o(this._position2, this._position3);
							if (a.push(e), l.push(t), i += t, null !== this._position4) {
								const e = r(this._position3, this._position4, this._maxSpeed);
								if (Math.sign(e) === Math.sign(s)) {
									const t = o(this._position3, this._position4);
									a.push(e), l.push(t), i += t
								}
							}
						}
					}
					let c = 0;
					for (let e = 0; e < a.length; ++e) c += l[e] / i * a[e];
					Math.abs(c) < this._minSpeed || (this._animationStartPosition = {
						position: e,
						time: t
					}, this._speedPxPerMsec = c, this._durationMsecs = function(e, t) {
						const i = Math.log(t);
						return Math.log(1 * i / -e) / i
					}(Math.abs(c), this._dumpingCoeff))
				}
				getPosition(e) {
					const t = (0, s.ensureNotNull)(this._animationStartPosition),
						i = e - t.time;
					return t.position + this._speedPxPerMsec * (Math.pow(this._dumpingCoeff, i) - 1) / Math.log(this._dumpingCoeff)
				}
				finished(e) {
					return null === this._animationStartPosition || this._progressDuration(e) === this._durationMsecs
				}
				terminated() {
					return this._terminated
				}
				terminate() {
					this._terminated = !0
				}
				_progressDuration(e) {
					const t = e - (0, s.ensureNotNull)(this._animationStartPosition).time;
					return Math.min(t, this._durationMsecs)
				}
			}
		},
		830484: (e, t, i) => {
			"use strict";
			i.d(t, {
				MouseEventHandler: () => h
			});
			var s = i(638456),
				o = i(588537),
				r = i(270617),
				n = i(196726),
				a = i(420808);
			const l = s.isSafari ? "click" : "auxclick",
				c = {
					treatVertTouchDragAsPageScroll: !1,
					treatHorzTouchDragAsPageScroll: !1
				};
			class h {
				constructor(e, t, i) {
					this._clickCount = 0, this._clickTimeoutId = null, this._clickPosition = {
						x: Number.NEGATIVE_INFINITY,
						y: Number.POSITIVE_INFINITY
					}, this._tapCount = 0, this._tapTimeoutId = null, this._tapPosition = {
						x: Number.NEGATIVE_INFINITY,
						y: Number.POSITIVE_INFINITY
					}, this._longTapTimeoutId = null, this._longTapActive = !1, this._mouseMoveStartPosition = null, this._touchMoveStartPosition = null, this._touchMoveExceededManhattanDistance = !1, this._cancelClick = !1, this._cancelTap = !1, this._unsubscribeOutsideMouseEvents = null, this._unsubscribeOutsideTouchEvents = null, this._unsubscribeMobileSafariEvents = null, this._unsubscribeMousemove = null, this._unsubscribeRootMouseEvents = null, this._unsubscribeRootTouchEvents = null, this._startPinchMiddlePoint = null, this._startPinchDistance = 0, this._pinchPrevented = !1, this._preventTouchDragProcess = !1, this._mousePressed = !1, this._lastTouchEventTimeStamp = 0, this._activeTouchId = null, this._acceptMouseLeave = !s.CheckMobile.iOS(), this._onFirefoxOutsideMouseUp = e => {
						this._mouseUpHandler(e)
					}, this._onMobileSafariDoubleClick = e => {
						if (this._firesTouchEvents(e)) {
							const t = this._makeCompatEvent(e);
							if (++this._tapCount, this._tapTimeoutId && this._tapCount > 1) {
								const {
									manhattanDistance: i
								} = this._touchMouseMoveWithDownInfo(u(e), this._tapPosition);
								i < 30 && !this._cancelTap && this._processTouchEvent(t, this._handler.doubleTapEvent), this._resetTapTimeout()
							}
						} else {
							const t = this._makeCompatEvent(e);
							if (++this._clickCount, this._clickTimeoutId && this._clickCount > 1) {
								const {
									manhattanDistance: i
								} = this._touchMouseMoveWithDownInfo(u(e), this._clickPosition);
								i < 5 && !this._cancelClick && this._processMouseEvent(t, this._handler.mouseDoubleClickEvent), this._resetClickTimeout()
							}
						}
					}, this._target = e, this._handler = t, this._options = (0, r.merge)((0, r.clone)(c), i || {}), this._init()
				}
				destroy() {
					null !== this._unsubscribeOutsideMouseEvents && (this._unsubscribeOutsideMouseEvents(), this._unsubscribeOutsideMouseEvents = null), null !== this._unsubscribeOutsideTouchEvents && (this._unsubscribeOutsideTouchEvents(), this._unsubscribeOutsideTouchEvents = null),
						null !== this._unsubscribeMousemove && (this._unsubscribeMousemove(), this._unsubscribeMousemove = null), null !== this._unsubscribeRootMouseEvents && (this._unsubscribeRootMouseEvents(), this._unsubscribeRootMouseEvents = null), null !== this._unsubscribeRootTouchEvents && (this._unsubscribeRootTouchEvents(), this._unsubscribeRootTouchEvents = null), null !== this._unsubscribeMobileSafariEvents && (this._unsubscribeMobileSafariEvents(), this._unsubscribeMobileSafariEvents = null), this._clearLongTapTimeout(), this._resetClickTimeout()
				}
				_mouseEnterHandler(e) {
					this._unsubscribeMousemove && this._unsubscribeMousemove();
					const t = this._mouseMoveHandler.bind(this);
					if (this._unsubscribeMousemove = () => {
							this._target.removeEventListener("mousemove", t)
						}, this._target.addEventListener("mousemove", t), this._firesTouchEvents(e)) return;
					const i = this._makeCompatEvent(e);
					this._processMouseEvent(i, this._handler.mouseEnterEvent), this._acceptMouseLeave = !0
				}
				_resetClickTimeout() {
					null !== this._clickTimeoutId && clearTimeout(this._clickTimeoutId), this._clickCount = 0, this._clickTimeoutId = null, this._clickPosition = {
						x: Number.NEGATIVE_INFINITY,
						y: Number.POSITIVE_INFINITY
					}
				}
				_resetTapTimeout() {
					null !== this._tapTimeoutId && clearTimeout(this._tapTimeoutId), this._tapCount = 0, this._tapTimeoutId = null, this._tapPosition = {
						x: Number.NEGATIVE_INFINITY,
						y: Number.POSITIVE_INFINITY
					}
				}
				_mouseMoveHandler(e) {
					if (this._mousePressed || null !== this._touchMoveStartPosition) return;
					if (this._firesTouchEvents(e)) return;
					const t = this._makeCompatEvent(e);
					this._processMouseEvent(t, this._handler.mouseMoveEvent), this._acceptMouseLeave = !0
				}
				_touchMoveHandler(e) {
					const t = p(e.changedTouches, (0, o.ensureNotNull)(this._activeTouchId));
					if (null === t) return;
					if (this._lastTouchEventTimeStamp = m(e), null !== this._startPinchMiddlePoint) return;
					if (this._preventTouchDragProcess) return;
					this._pinchPrevented = !0;
					const i = this._touchMouseMoveWithDownInfo(u(t), (0, o.ensureNotNull)(this._touchMoveStartPosition)),
						{
							xOffset: s,
							yOffset: r,
							manhattanDistance: a
						} = i;
					if (this._touchMoveExceededManhattanDistance || !(a < 5)) {
						if (!this._touchMoveExceededManhattanDistance) {
							const e = .5 * s,
								t = r >= e && !this._options.treatVertTouchDragAsPageScroll,
								i = e > r && !this._options.treatHorzTouchDragAsPageScroll;
							t || i || (this._preventTouchDragProcess = !0), this._touchMoveExceededManhattanDistance = !0, this._cancelTap = !0, this._clearLongTapTimeout(), this._resetTapTimeout()
						}
						if (!this._preventTouchDragProcess) {
							const i = this._makeCompatEvent(e, t);
							this._processTouchEvent(i, this._handler.touchMoveEvent), (0, n.preventDefault)(e)
						}
					}
				}
				_mouseMoveWithDownHandler(e) {
					if (0 !== e.button) return;
					const t = this._touchMouseMoveWithDownInfo(u(e), (0, o.ensureNotNull)(this._mouseMoveStartPosition)),
						{
							manhattanDistance: i
						} = t;
					if (i >= 5 && (this._cancelClick = !0, this._resetClickTimeout()), this._cancelClick) {
						const t = this._makeCompatEvent(e);
						this._processMouseEvent(t, this._handler.pressedMouseMoveEvent)
					}
				}
				_touchMouseMoveWithDownInfo(e, t) {
					const i = Math.abs(t.x - e.x),
						s = Math.abs(t.y - e.y);
					return {
						xOffset: i,
						yOffset: s,
						manhattanDistance: i + s
					}
				}
				_touchEndHandler(e) {
					let t = p(e.changedTouches, (0, o.ensureNotNull)(this._activeTouchId));
					if (null === t && 0 === e.touches.length && (t = e.changedTouches[0]), null === t) return;
					this._activeTouchId = null, this._lastTouchEventTimeStamp = m(e), this._clearLongTapTimeout(), this._touchMoveStartPosition = null, this._unsubscribeRootTouchEvents && (this._unsubscribeRootTouchEvents(), this._unsubscribeRootTouchEvents = null);
					const i = this._makeCompatEvent(e, t);
					if (this._processTouchEvent(i, this._handler.touchEndEvent), ++this._tapCount, this._tapTimeoutId && this._tapCount > 1) {
						const {
							manhattanDistance: e
						} = this._touchMouseMoveWithDownInfo(u(t), this._tapPosition);
						e < 30 && !this._cancelTap && this._processTouchEvent(i, this._handler.doubleTapEvent), this._resetTapTimeout()
					} else this._cancelTap || (this._processTouchEvent(i, this._handler.tapEvent), this._handler.tapEvent && (0, n.preventDefault)(e));
					0 === this._tapCount && (0, n.preventDefault)(e), 0 === e.touches.length && this._longTapActive && (this._longTapActive = !1, (0, n.preventDefault)(e))
				}
				_mouseUpHandler(e) {
					if (0 !== e.button) return;
					const t = this._makeCompatEvent(e);
					if (this._mouseMoveStartPosition = null, this._mousePressed = !1, this._unsubscribeRootMouseEvents && (this._unsubscribeRootMouseEvents(), this._unsubscribeRootMouseEvents = null), s.isFF) {
						this._target.ownerDocument.documentElement.removeEventListener("mouseleave", this._onFirefoxOutsideMouseUp)
					}
					if (!this._firesTouchEvents(e))
						if (this._processMouseEvent(t, this._handler.mouseUpEvent), ++this._clickCount, this._clickTimeoutId && this._clickCount > 1) {
							const {
								manhattanDistance: i
							} = this._touchMouseMoveWithDownInfo(u(e), this._clickPosition);
							i < 5 && !this._cancelClick && this._processMouseEvent(t, this._handler.mouseDoubleClickEvent), this._resetClickTimeout()
						} else this._cancelClick || this._processMouseEvent(t, this._handler.mouseClickEvent)
				}
				_clearLongTapTimeout() {
					null !== this._longTapTimeoutId && (clearTimeout(this._longTapTimeoutId), this._longTapTimeoutId = null)
				}
				_touchStartHandler(e) {
					if (null !== this._activeTouchId) return;
					const t = e.changedTouches[0];
					this._activeTouchId = t.identifier, this._lastTouchEventTimeStamp = m(e);
					const i = this._target.ownerDocument.documentElement;
					this._cancelTap = !1, this._touchMoveExceededManhattanDistance = !1, this._preventTouchDragProcess = !1, this._touchMoveStartPosition = u(t), this._unsubscribeRootTouchEvents && (this._unsubscribeRootTouchEvents(), this._unsubscribeRootTouchEvents = null); {
						const t = this._touchMoveHandler.bind(this),
							s = this._touchEndHandler.bind(this);
						this._unsubscribeRootTouchEvents = () => {
							i.removeEventListener("touchmove", t), i.removeEventListener("touchend", s)
						}, i.addEventListener("touchmove", t, {
							passive: !1
						}), i.addEventListener("touchend", s, {
							passive: !1
						}), this._clearLongTapTimeout(), this._longTapTimeoutId = setTimeout(this._longTapHandler.bind(this, e), 240)
					}
					const s = this._makeCompatEvent(e, t);
					this._processTouchEvent(s, this._handler.touchStartEvent), this._tapTimeoutId || (this._tapCount = 0, this._tapTimeoutId = setTimeout(this._resetTapTimeout.bind(this), 500), this._tapPosition = u(t))
				}
				_wheelClickHandler(e) {
					if (1 !== e.button) return;
					if (this._firesTouchEvents(e)) return;
					const t = this._makeCompatEvent(e);
					this._processMouseEvent(t, this._handler.wheelClickEvent)
				}
				_mouseDownHandler(e) {
					if (0 !== e.button) return;
					const t = this._target.ownerDocument.documentElement;
					s.isFF && t.addEventListener("mouseleave", this._onFirefoxOutsideMouseUp), this._cancelClick = !1, this._mouseMoveStartPosition = u(e), this._unsubscribeRootMouseEvents && (this._unsubscribeRootMouseEvents(), this._unsubscribeRootMouseEvents = null); {
						const e = this._mouseMoveWithDownHandler.bind(this),
							i = this._mouseUpHandler.bind(this);
						this._unsubscribeRootMouseEvents = () => {
							t.removeEventListener("mousemove", e), t.removeEventListener("mouseup", i)
						}, t.addEventListener("mousemove", e), t.addEventListener("mouseup", i)
					}
					if (this._mousePressed = !0, this._firesTouchEvents(e)) return;
					const i = this._makeCompatEvent(e);
					this._processMouseEvent(i, this._handler.mouseDownEvent), this._clickTimeoutId || (this._clickCount = 0, this._clickTimeoutId = setTimeout(this._resetClickTimeout.bind(this), 500), this._clickPosition = u(e))
				}
				_init() {
					this._target.addEventListener("mouseenter", this._mouseEnterHandler.bind(this)), this._target.addEventListener("touchcancel", this._clearLongTapTimeout.bind(this)); {
						const e = this._target.ownerDocument,
							t = e => {
								this._handler.mouseDownOutsideEvent && (e.target && this._target.contains(e.target) || this._handler.mouseDownOutsideEvent())
							};
						this._unsubscribeOutsideTouchEvents = () => {
							e.removeEventListener("touchstart", t)
						}, this._unsubscribeOutsideMouseEvents = () => {
							e.removeEventListener("mousedown", t)
						}, e.addEventListener("mousedown", t), e.addEventListener("touchstart", t, {
							passive: !0
						})
					}
					s.CheckMobile.iOS() && (this._unsubscribeMobileSafariEvents = () => {
						this._target.removeEventListener("dblclick", this._onMobileSafariDoubleClick)
					}, this._target.addEventListener("dblclick", this._onMobileSafariDoubleClick)), this._target.addEventListener("mouseleave", this._mouseLeaveHandler.bind(this)), this._target.addEventListener("contextmenu", this._contextMenuHandler.bind(this)), this._target.addEventListener("touchstart", this._touchStartHandler.bind(this), {
						passive: !0
					}), (0, n.preventScrollByWheelClick)(this._target), this._target.addEventListener("mousedown", this._mouseDownHandler.bind(this)), this._target.addEventListener(l, this._wheelClickHandler.bind(this)), this._initPinch(), this._target.addEventListener("touchmove", (() => {}), {
						passive: !1
					})
				}
				_initPinch() {
					void 0 === this._handler.pinchStartEvent && void 0 === this._handler.pinchEvent && void 0 === this._handler.pinchEndEvent || (this._target.addEventListener("touchstart", (e => this._checkPinchState(e.touches)), {
						passive: !0
					}), this._target.addEventListener("touchmove", (e => {
						if (2 === e.touches.length && null !== this._startPinchMiddlePoint && void 0 !== this._handler.pinchEvent) {
							const t = e.touches[0],
								i = e.touches[1],
								s = _(t, i) / this._startPinchDistance,
								o = d(this._target);
							this._handler.pinchEvent(this._startPinchMiddlePoint, {
								x: t.clientX - o.left,
								y: t.clientY - o.top
							}, {
								x: i.clientX - o.left,
								y: i.clientY - o.top
							}, s), (0, n.preventDefault)(e)
						}
					}), {
						passive: !1
					}), this._target.addEventListener("touchend", (e => {
						this._checkPinchState(e.touches)
					})))
				}
				_checkPinchState(e) {
					1 === e.length && (this._pinchPrevented = !1), 2 !== e.length || this._pinchPrevented || this._longTapActive ? this._stopPinch() : this._startPinch(e)
				}
				_startPinch(e) {
					if (void 0 !== this._handler.pinchStartEvent) {
						const t = d(this._target),
							i = e[0],
							s = e[1],
							o = {
								x: i.clientX - t.left,
								y: i.clientY - t.top
							},
							r = {
								x: s.clientX - t.left,
								y: s.clientY - t.top
							};
						this._startPinchMiddlePoint = {
							x: (o.x + r.x) / 2,
							y: (o.y + r.y) / 2
						}, this._startPinchDistance = _(i, s), this._handler.pinchStartEvent(this._startPinchMiddlePoint, o, r)
					}
					this._clearLongTapTimeout()
				}
				_stopPinch() {
					null !== this._startPinchMiddlePoint && (this._startPinchMiddlePoint = null, void 0 !== this._handler.pinchEndEvent && this._handler.pinchEndEvent())
				}
				_mouseLeaveHandler(e) {
					if (this._unsubscribeMousemove && this._unsubscribeMousemove(), this._firesTouchEvents(e)) return;
					if (!this._acceptMouseLeave) return;
					const t = this._makeCompatEvent(e);
					this._processMouseEvent(t, this._handler.mouseLeaveEvent), this._acceptMouseLeave = !s.CheckMobile.iOS()
				}
				_longTapHandler(e) {
					const t = p(e.touches, (0, o.ensureNotNull)(this._activeTouchId));
					if (null === t) return;
					const i = this._makeCompatEvent(e, t);
					this._processTouchEvent(i, this._handler.longTapEvent), this._processTouchEvent(i, this._handler.touchContextMenuEvent), this._cancelTap = !0, this._longTapActive = !0
				}
				_contextMenuHandler(e) {
					if ((0, n.preventDefault)(e), null !== this._touchMoveStartPosition) return;
					if (this._firesTouchEvents(e)) return;
					const t = this._makeCompatEvent(e);
					this._processMouseEvent(t, this._handler.contextMenuEvent), this._cancelClick = !0
				}
				_firesTouchEvents(e) {
					return e.sourceCapabilities && void 0 !== e.sourceCapabilities.firesTouchEvents ? e.sourceCapabilities.firesTouchEvents : m(e) < this._lastTouchEventTimeStamp + 500
				}
				_processTouchEvent(e, t) {
					(0, a.setLastMouseOrTouchEventInfo)(e), t && t.call(this._handler, e)
				}
				_processMouseEvent(e, t) {
					"mouseleave" !== e.srcType && (0, a.setLastMouseOrTouchEventInfo)(e), t && t.call(this._handler, e)
				}
				_makeCompatEvent(e, t) {
					const i = t || e,
						s = this._target.getBoundingClientRect() || {
							left: 0,
							top: 0
						};
					return {
						clientX: i.clientX,
						clientY: i.clientY,
						pageX: i.pageX,
						pageY: i.pageY,
						screenX: i.screenX,
						screenY: i.screenY,
						localX: i.clientX - s.left,
						localY: i.clientY - s.top,
						ctrlKey: e.ctrlKey,
						altKey: e.altKey,
						shiftKey: e.shiftKey,
						metaKey: e.metaKey,
						isTouch: !e.type.startsWith("mouse") && "contextmenu" !== e.type && "click" !== e.type,
						stylus: "stylus" === (null == t ? void 0 : t.touchType),
						srcType: e.type,
						target: i.target,
						view: e.view,
						preventDefault: () => {
							"touchstart" !== e.type && (0, n.preventDefault)(e)
						}
					}
				}
			}

			function d(e) {
				return e.getBoundingClientRect() || {
					left: 0,
					top: 0
				}
			}

			function u(e) {
				return {
					x: e.pageX,
					y: e.pageY
				}
			}

			function _(e, t) {
				const i = e.clientX - t.clientX,
					s = e.clientY - t.clientY;
				return Math.sqrt(i * i + s * s)
			}

			function m(e) {
				return e.timeStamp || performance.now()
			}

			function p(e, t) {
				for (let i = 0; i < e.length; ++i)
					if (e[i].identifier === t) return e[i];
				return null
			}
		},
		127085: (e, t, i) => {
			"use strict";
			i.d(t, {
				ActionBinder: () => s
			});
			class s {
				constructor(e, t, i, s, o = null) {
					this._property = t, this._undoModel = i, this._undoText = s, this._action = e, this.setValue(t.value()), t.subscribe(this, this._propertyChanged), null !== o ? e.update({
						onExecute: o.bind(this)
					}) : e.update({
						onExecute: this._onActionCallback.bind(this)
					})
				}
				destroy() {
					this._property.unsubscribe(this, this._propertyChanged)
				}
				value() {
					return this._action.isChecked()
				}
				setValue(e) {
					this._action.update({
						checked: Boolean(e)
					})
				}
				_onActionCallback() {
					this._undoModel.setProperty(this._property, this.value(), this._undoText)
				}
				_propertyChanged(e) {
					this.setValue(e.value())
				}
			}
		},
		374097: (e, t, i) => {
			"use strict";
			i.d(t, {
				showMarketOpenStatusProperty: () => a,
				restoreShowMarketOpenStatusProperty: () => l
			});
			var s = i(860949),
				o = i(62802);
			const r = "Chart.ShowMarketOpenStatus";

			function n() {
				return o.getBool(r, true)
			}
			const a = (0, s.createPrimitiveProperty)(n());

			function l() {
				a.setValue(true), o.remove(r)
			}
			o.onSync.subscribe(null, (() => a.setValue(n()))), a.subscribe(null, (() => o.setValue(r, a.value())))
		},
		690352: (e, t, i) => {
			"use strict";
			i.d(t, {
				marketStatusText: () => o
			});
			var s = i(135933);

			function o(e) {
				const t = e.value();
				if (null !== t) {
					const e = s.titleMap.get(t);
					if (void 0 !== e) return e
				}
				return ""
			}
		},
		135933: (e, t, i) => {
			"use strict";
			i.d(t, {
				iconMap: () => L,
				classNameMap: () => E,
				tooltipMap: () => D,
				titleMap: () => N,
				titleColorMap: () => B,
				marketStatusDescription: () => O,
				countdownFnMap: () => F,
				actionMap: () => z
			});
			var s = i(679520),
				o = i(575932),
				r = i(321035),
				n = i(720983),
				a = i(816030),
				l = i(434074),
				c = i(627086),
				h = i(20123),
				d = i(323373),
				u = i(572074),
				_ = i(690981);
			const m = (0, o.t)("Market open"),
				p = (0, o.t)("Pre-market"),
				g = (0, o.t)("Post-market"),
				S = (0, o.t)("Market closed"),
				v = (0, o.t)("Holiday"),
				f = (0, o.t)("All's well  Market is open."),
				b = (0, o.t)("Morning. Market is open for pre-market trading."),
				y = (0, o.t)("Evening. Market is open for post-market trading."),
				C = (0, o.t)("Time for a walk  this market is closed."),
				w = (0, o.t)("Market is currently on holiday. Lucky them."),
				T = (0, o.t)("less than 1 minute"),
				P = (0, o.t)("{days} and {hours}"),
				M = (0, o.t)("{hours} and {minutes}"),
				x = (0, o.t)("Market opens in {remainingTime}."),
				I = (0, o.t)("Market closes in {remainingTime}."),
				A = (0, o.t)("It'll go to post-market trading in {remainingTime}."),
				k = (0, o.t)("It'll open for pre-market trading in {remainingTime}."),
				L = new Map([
					["market", new Map([
						["small", n],
						["medium", a],
						["large", a]
					])],
					["pre_market", new Map([
						["small", d],
						["medium", u],
						["large", u]
					])],
					["post_market", new Map([
						["small", c],
						["medium", h],
						["large", h]
					])],
					["out_of_session", new Map([
						["small", r],
						["medium", r],
						["large", r]
					])],
					["holiday", new Map([
						["small", l],
						["medium", l],
						["large", l]
					])]
				]),
				E = new Map([
					["market", _.marketStatusOpen],
					["pre_market", _.marketStatusPre],
					["post_market", _.marketStatusPost],
					["out_of_session", _.marketStatusClose],
					["holiday", _.marketStatusHoliday]
				]),
				D = new Map([
					["market", m],
					["pre_market", p],
					["post_market", g],
					["out_of_session", S],
					["holiday", v]
				]),
				N = new Map([
					["market", m],
					["pre_market", p],
					["post_market", g],
					["out_of_session", S],
					["holiday", v]
				]),
				B = new Map([
					["market", s.colorsPalette["color-market-open"]],
					["pre_market", s.colorsPalette["color-pre-market"]],
					["post_market", s.colorsPalette["color-post-market"]],
					["out_of_session", s.colorsPalette["color-market-closed"]],
					["holiday", s.colorsPalette["color-market-holiday"]]
				]),
				O = {
					market: f,
					pre_market: b,
					post_market: y,
					out_of_session: C,
					holiday: w
				};

			function R(e) {
				return (0, o.t)("{number} minute", {
					plural: "{number} minutes",
					count: e
				}).format({
					number: e.toString()
				})
			}

			function V(e) {
				return (0, o.t)("{number} hour", {
					plural: "{number} hours",
					count: e
				}).format({
					number: e.toString()
				})
			}

			function W(e) {
				const t = Math.floor(e / 86400),
					i = Math.floor((e - 86400 * t) / 3600),
					s = Math.floor((e - 86400 * t - 3600 * i) / 60);
				return 0 === t && 0 === i && 0 === s ? T : t > 0 ? P.format({
					days: (r = t, (0, o.t)("{number} day", {
						plural: "{number} days",
						count: r
					}).format({
						number: r.toString()
					})),
					hours: V(i)
				}) : i > 0 ? M.format({
					hours: V(i),
					minutes: R(s)
				}) : R(s);
				var r
			}
			const F = {
					market: e => ("post_market" === e.status ? A : I).format({
						remainingTime: W(e.remainingSeconds)
					}),
					pre_market: e => x.format({
						remainingTime: W(e.remainingSeconds)
					}),
					post_market: e => I.format({
						remainingTime: W(e.remainingSeconds)
					}),
					out_of_session: e => ("pre_market" === e.status ? k : x).format({
						remainingTime: W(e.remainingSeconds)
					}),
					holiday: e => ("pre_market" === e.status ? k : x).format({
						remainingTime: W(e.remainingSeconds)
					})
				},
				z = new Map([
					["market", null],
					["pre_market", null],
					["post_market", null],
					["out_of_session", null],
					["holiday", null]
				])
		},
		313528: (e, t, i) => {
			"use strict";
			i.d(t, {
				ToastsFactory: () => s
			});
			class s {
				constructor(e, t) {
					this._chartToastsPromise = null, this._resizerBridge = e, this._bottomToolbarOffsetHeightProvider = t
				}
				async getChartToasts() {
					return null !== this._chartToastsPromise || (this._chartToastsPromise = async function() {
						return Promise.all([Promise.all([i.e(17967), i.e(42270), i.e(90383), i.e(75514), i.e(53088)]).then(i.bind(i, 78181)), Promise.all([i.e(42270), i.e(91077), i.e(75514), i.e(13830), i.e(94291)]).then(i.bind(i, 13830))]).then((e => [e[0].ChartToasts, e[1].globalToasts]))
					}().then((e => {
						const t = e[0],
							i = e[1];
						return new t(this._resizerBridge, this._resizerBridge.container.value(), i, this._bottomToolbarOffsetHeightProvider())
					}))), this._chartToastsPromise
				}
			}
		},
		240025: (e, t, i) => {
			"use strict";
			i.d(t, {
				createTradeContext: () => o
			});
			var s = i(588537);
			async function o(e, t) {
				let i = NaN,
					o = NaN,
					r = "";
				const n = e.proSymbol(),
					a = (e.symbolInfo() || {
						name: null
					}).name || n,
					l = e.priceScale();
				if (t) {
					const s = e.firstValue();
					i = null !== s ? l.coordinateToPrice(t, s) : null, r = null !== i ? e.formatter().format(i) : ""
				}
				const c = e.bars().last();
				null !== c && (o = (0, s.ensure)(c.value[TradingView.CLOSE_PLOT]));
				return {
					symbol: n,
					displaySymbol: a,
					value: i,
					formattedValue: r,
					last: o,
					symbolInfoTradable: !!(e.symbolInfo() || {
						is_tradable: !1
					}).is_tradable
				}
			}
		},
		44777: (e, t, i) => {
			"use strict";
			i.d(t, {
				isMobileTradingAvailable: () => d,
				isBrokerHidden: () => u
			});
			var s = i(638456),
				o = i(125226),
				r = i(314802),
				n = i(611688);
			const a = (0, o.isFeatureEnabled)("mobile_trading_ios") && s.CheckMobile.iOS() && (0, r.isOnMobileAppPage)("old"),
				l = (0, o.isFeatureEnabled)("mobile_trading_android") && s.CheckMobile.Android() && (0, r.isOnMobileAppPage)("new"),
				c = (0, o.isFeatureEnabled)("mobile_trading_web") && s.CheckMobile.any() && !s.CheckMobile.isIPad() && (window.matchMedia("screen and (orientation: portrait) and (max-width: 567px)").matches || window.matchMedia("screen and (orientation: landscape) and (max-height: 567px)").matches) && !(0, r.isOnMobileAppPage)("any"),
				h = n.enabled("mobile_trading") && (a || l || c);

			function d() {
				return h
			}

			function u(e) {
				return a ? (0, o.isFeatureEnabled)(`hide_${e}_on_ios`) : l ? (0, o.isFeatureEnabled)(`hide_${e}_on_android`) : !!c && (0, o.isFeatureEnabled)(`hide_${e}_on_mobile_web`)
			}
		},
		800733: (e, t, i) => {
			"use strict";
			i.d(t, {
				updateThemeActions: () => _
			});
			var s = i(575932),
				o = i(694755),
				r = i(345848),
				n = i(588746),
				a = i(829770),
				l = i(97985),
				c = i(104436),
				h = i(180389);
			const d = ["system", "dark", "light"],
				u = {
					dark: (0, s.t)("Dark"),
					light: (0, s.t)("Light"),
					system: (0, s.t)("As in system")
				};
			async function _(e) {
				const [t, _] = await Promise.all([i.e(83767).then(i.bind(i, 440135)), i.e(83767).then(i.bind(i, 867432))]), m = async i => {
					let m = [];
					if ((0, h.showThemeSwitcher)()) {
						const i = t.getStdThemeNames(),
							s = t.getCurrentTheme().name;
						m = i.map((i => {
							const a = new n.TVAction({
								name: "theme-switch-to-" + i,
								label: (0, o.clean)(t.translateStdThemeName(i)),
								checkable: !0,
								checked: s === i,
								onExecute: () => {
									a.update({
										checked: !0
									}), t.loadTheme(e.chartWidgetCollection(), {
										themeName: i,
										standardTheme: !0
									}).then((() => {
										e.readOnly() || window.saver.saveChartSilently(), (0, r.trackEvent)("GUI", "Themes", "Switch to " + i + " theme")
									}))
								}
							});
							return a
						})), m.sort(((e, t) => e.getLabel() > t.getLabel() ? -1 : 1))
					} else if ((0, h.showThemeAction)() && window.TVD && window.TVD.getThemeSetting) {
						const e = await window.TVD.getThemeSetting();
						e && (m = d.map((t => {
							const i = new n.TVAction({
								name: "theme-switch-to-" + t,
								label: u[t],
								checkable: !0,
								checked: e === t,
								onExecute: () => {
									i.update({
										checked: !0
									}), window.TVD && window.TVD.setThemeSetting && window.TVD.setThemeSetting(t)
								}
							});
							return i
						})))
					}
					const p = [...m];
					if (window.is_authenticated) {
						p.length && p.push(new a.Separator);
						const t = new n.TVAction({
							name: "theme-save-as",
							label: (0, l.appendEllipsis)((0, s.t)("Save as")),
							onExecute: () => _.showThemeSaveDialogAsync(e.model().model().theme())
						});
						p.push(t)
					}
					i && i.length && window.is_authenticated && (p.length && p.push(new a.Separator), i.forEach((i => {
						const s = new n.TVAction({
							label: (0, o.clean)(t.translateStdThemeName(i)),
							checkable: !1,
							onExecute: () => {
								t.loadTheme(e.chartWidgetCollection(), {
									themeName: i,
									standardTheme: !1
								}).then((() => {
									window.saver.saveChartSilently(), (0, r.trackEvent)("GUI", "Switch to custom theme")
								}))
							},
							toolbox: {
								type: c.ToolboxType.Delete,
								action: () => _.showRemoveThemeDialogAsync(i)
							},
							showToolboxOnHover: !0
						});
						p.push(s)
					}))), e.actions().applyColorTheme.update({
						subItems: p
					})
				};
				window.is_authenticated ? t.getThemeNames().then(m) : m()
			}
		},
		159621: (e, t, i) => {
			"use strict";
			i.d(t, {
				WatchlistWithSubmenuAction: () => v
			});
			var s = i(575932),
				o = i(97985),
				r = i(470316),
				n = i(833813),
				a = i(552279),
				l = i(829770),
				c = i(588746),
				h = i(588537),
				d = i(845437);

			function u(e, t) {
				return {
					...t,
					actionId: "Chart.AddSymbolToWatchList",
					icon: d,
					statName: "AddToWatchlist",
					hotkeyHash: r.Modifiers.Alt + 87,
					onExecute: () => {
						window.runOrSignIn((() => {
							var t;
							if (window.widgetbar) {
								const i = null === (t = (0, h.ensureNotNull)(window.widgetbar.setPage("base")).widget("watchlist")) || void 0 === t ? void 0 : t.widgetObject;
								if (!i) return;
								i.addSymbols([e.getSymbol()])
							}
						}), {
							source: "add symbol to watchlist"
						})
					}
				}
			}
			var _ = i(888778),
				m = i(826939),
				p = i(72368),
				g = i(440498),
				S = i(611688);
			class v extends c.TVAction {
				constructor(e, t) {
					super({
						...u(e, t),
						subItems: [new c.TVLoader]
					}), this._controller = new AbortController, this._hadSymbolOnInit = !1, this._isMobile = (0, p.isMobile)(), this._onRequest = null, this._chart = e, this._load()
				}
				updateLabel(e) {
					this.update({
						label: (0, s.t)("Add {symbol} to watchlist").format({
							symbol: e
						})
					})
				}
				request() {
					var e;
					this._hadSymbolOnInit = !1, this._isMobile = (0,
						p.isMobile)(), this.update({
						subItems: [new c.TVLoader]
					}), null === (e = this._onRequest) || void 0 === e || e.call(this)
				}
				destroy() {
					super.destroy(), this._controller.abort(), this._chart = null, this._onRequest = null, this._options = {
						actionId: "TVActionId"
					}
				}
				async _load() {
					const [e, t, h, u, p, v, f] = await Promise.all([i.e(75514).then(i.t.bind(i, 559496, 19)), (0, _.initSymbolListService)(), Promise.all([i.e(93921), i.e(29594), i.e(91622), i.e(35883), i.e(44692), i.e(1026)]).then(i.bind(i, 38506)), Promise.all([i.e(93921), i.e(29594), i.e(91622), i.e(35883), i.e(44692), i.e(1026)]).then(i.bind(i, 244692)), Promise.all([i.e(90519), i.e(8348), i.e(48181), i.e(37135), i.e(35354), i.e(5979), i.e(3086), i.e(72066), i.e(78941), i.e(91670), i.e(15107), i.e(53221), i.e(21834), i.e(95468), i.e(82739), i.e(37619), i.e(29331), i.e(44155), i.e(12580), i.e(63146), i.e(24817), i.e(28111), i.e(24384), i.e(35015), i.e(2036), i.e(29499), i.e(1689), i.e(74733), i.e(4171), i.e(86193), i.e(59446), i.e(73327), i.e(81532), i.e(32256), i.e(34663), i.e(54072), i.e(1419), i.e(65407), i.e(9327), i.e(72623), i.e(10866), i.e(75514), i.e(93921), i.e(69397), i.e(29594), i.e(79049), i.e(95904), i.e(70549), i.e(45815), i.e(46e3), i.e(35883), i.e(28248), i.e(99958), i.e(91196)]).then(i.bind(i, 15814)), Promise.all([i.e(90519), i.e(8348), i.e(48181), i.e(37135), i.e(35354), i.e(5979), i.e(3086), i.e(72066), i.e(78941), i.e(91670), i.e(15107), i.e(53221), i.e(21834), i.e(95468), i.e(82739), i.e(37619), i.e(29331), i.e(44155), i.e(12580), i.e(63146), i.e(24817), i.e(28111), i.e(24384), i.e(35015), i.e(2036), i.e(29499), i.e(1689), i.e(74733), i.e(4171), i.e(86193), i.e(59446), i.e(73327), i.e(81532), i.e(32256), i.e(34663), i.e(54072), i.e(1419), i.e(65407), i.e(9327), i.e(72623), i.e(10866), i.e(75514), i.e(93921), i.e(69397), i.e(29594), i.e(79049), i.e(95904), i.e(70549), i.e(45815), i.e(46e3), i.e(35883), i.e(28248), i.e(99958), i.e(91196)]).then(i.bind(i, 436779)), Promise.all([i.e(90519), i.e(8348), i.e(48181), i.e(37135), i.e(35354), i.e(5979), i.e(3086), i.e(72066), i.e(78941), i.e(91670), i.e(15107), i.e(53221), i.e(21834), i.e(95468), i.e(82739), i.e(37619), i.e(29331), i.e(44155), i.e(12580), i.e(63146), i.e(24817), i.e(28111), i.e(24384), i.e(35015), i.e(2036), i.e(29499), i.e(1689), i.e(74733), i.e(4171), i.e(86193), i.e(59446), i.e(73327), i.e(81532), i.e(32256), i.e(34663), i.e(54072), i.e(1419), i.e(65407), i.e(9327), i.e(72623), i.e(10866), i.e(75514), i.e(93921), i.e(69397), i.e(29594), i.e(79049), i.e(95904), i.e(70549), i.e(45815), i.e(46e3), i.e(35883), i.e(28248), i.e(99958), i.e(91196)]).then(i.bind(i, 631530))]);
					if (this._controller.signal.aborted) return;
					const {
						store: b
					} = t;
					this._onRequest = () => b.dispatch(h.getCustomWatchlistsThunk(null));
					const y = b.subscribe((() => {
						if (!this._chart) return;
						const t = b.getState();
						if (null === p.getCustomListsState(t).timestamp) return;
						const i = this._chart.getSymbol(),
							h = p.getCustomLists(t),
							{
								activeSymbolList: _
							} = t,
							y = h.find((e => e.id === _));
						this._hadSymbolOnInit || (this._hadSymbolOnInit = !!y && y.symbols.includes(i));
						const C = S.enabled("multiple_watchlists") ? h.filter((e => e.id !== _)).sort(v.sortComparator) : [];
						let w = y ? [y, ...C] : C;
						w = w.filter((e => !(0, g.isDeletedSymbolsList)(e.id)));
						const T = w.map((t => {
								const s = t.symbols.includes(i);
								return new c.TVAction({
									jsxLabel: e.createElement(f.ContextMenuWatchlistItem, {
										title: t.name,
										isChecked: s,
										isSmallSize: this._isMobile
									}),
									shortcutHint: t.id === _ ? (0, r.humanReadableHash)(r.Modifiers.Alt + 87) : void 0,
									invisibleHotkey: t.id === _ ? s : void 0,
									doNotCloseOnClick: !0,
									onExecute: () => {
										const e = s ? u.removeSymbolsThunk(m.WATCHLIST_WIDGET_ID, i, t.id, !0) : u.addSymbolsToCustomListThunk(m.WATCHLIST_WIDGET_ID, t.id, [i]);
										t.id !== _ || window.is_authenticated || this._hadSymbolOnInit ? b.dispatch(e) : window.runOrSignIn((() => {
											b.dispatch(e)
										}), {
											source: "Chart context menu"
										})
									}
								})
							})),
							P = new c.TVAction({
								label: (0, o.appendEllipsis)((0, s.t)("Create new list")),
								icon: this._isMobile ? d : void 0,
								onExecute: () => {
									(0, a.runOrGoPro)((() => {
										b.dispatch(u.userCreateWatchlistThunk(null, {
											symbols: [i]
										}))
									}), n.ProductFeatures.MULTIPLE_WATCHLISTS, {
										feature: "multipleWatchLists",
										featureLocation: "moveSymbolsToNew"
									})
								}
							});
						this.update({
							subItems: [...T, new l.Separator, P]
						})
					}));
					this._controller.signal.addEventListener("abort", (() => y()), {
						once: !0
					})
				}
			}
		},
		733133: (e, t, i) => {
			"use strict";
			i.d(t, {
				addPlusButtonProperty: () => a,
				restoreAddPlusButtonSettingsValue: () => l
			});
			var s = i(62802),
				o = i(860949);
			const r = "add_plus_button";

			function n() {
				return s.getBool(r, !0)
			}
			const a = (0, o.createPrimitiveProperty)(n());

			function l() {
				a.setValue(!0), s.remove(r)
			}
			s.onSync.subscribe(null, (() => a.setValue(n()))), a.subscribe(null, (() => s.setValue(r, a.value())))
		},
		256160: (e, t, i) => {
			"use strict";
			i.d(t, {
				defaultSettings: () => d,
				getSettingsProperty: () => m
			});
			var s = i(62802),
				o = i(270617),
				r = i(345185),
				n = i(385518),
				a = i(232567),
				l = i.n(a);
			const c = "alertLabels";
			let h;
			const d = {
				visible: !0,
				color: "rgba( 245, 124, 0, 1)",
				highlightColor: "rgba( 245, 124, 0, 1)",
				hoverColor: "rgba( 245, 124, 0, 1)",
				line: {
					visible: !0,
					style: r.LINESTYLE_DASHED,
					width: 1
				}
			};

			function u() {
				let e = (0, s.getJSON)(c, null);
				if (null === e) {
					const t = (0, n.defaults)("chartproperties");
					t && t.alertsProperties && t.alertsProperties.labels && (e = t.alertsProperties.labels)
				}
				return null === e && (e = (0, o.clone)(d)), e
			}

			function _() {
				h && (0, s.setJSON)(c, h.state())
			}

			function m() {
				return h || (h = new(l())(u()), h.listeners().subscribe(null, _), s.onSync.subscribe(null, (() => {
					h.merge(u())
				})), h)
			}
		},
		171670: (e, t, i) => {
			"use strict";
			i.d(t, {
				ALERT_LABEL_WIDTH: () => O,
				AlertLabel: () => V,
				isAlertLabel: () => R
			});
			var s = i(588537),
				o = i(62949),
				r = i(534953),
				n = i(232567),
				a = i.n(n),
				l = i(273044),
				c = i(749473),
				h = i(345848),
				d = i(256160),
				u = i(86441),
				_ = i(717611),
				m = i(218718),
				p = i(859447),
				g = i(72461),
				S = i(164149),
				v = i(601132),
				f = i(380047);
			class b extends f.ScaledPaneRenderer {
				constructor(e) {
					super(), this._data = e
				}
				hitTest(e, t) {
					const i = (0, v.interactionTolerance)().line;
					return this._data.item.points.reduce(((t, s, o) => Math.abs(s.y - e.y) <= i ? new m.HitTestResult(m.HitTestResult.MOVEPOINT, {
						activeItem: o,
						hideCrosshairLinesOnHover: !0
					}) : t), null)
				}
				_drawImpl(e, t) {
					e.lineWidth = this._data.lineWidth, e.strokeStyle = this._data.color, (0, g.setLineStyle)(e, this._data.lineStyle), this._data.item.points.forEach((t => (0, S.drawHorizontalLine)(e, t.y, 0, t.x)))
				}
			}
			var y = i(588427);
			class C extends f.ScaledPaneRenderer {
				constructor(e) {
					super(), this._data = e
				}
				hitTest() {
					return null
				}
				_drawImpl(e, t) {
					let i;
					const s = [`Alert: ${this._data.item.alert.get("name")||this._data.item.alert.get("description")}`];
					e.font = "12px " + y.CHART_FONT_FAMILY;
					const o = s.reduce(((t, i) => Math.max(e.measureText(i).width, t)), 0),
						r = 40 + o,
						n = 12 * s.length + 16 + 8 * (s.length - 1);
					if (2 === this._data.item.points.length) {
						const e = this._data.item.points[0],
							t = this._data.item.points[1];
						let s, o;
						this._data.cursor.x < e.x - this._data.labelWidth ? (s = this._data.cursor.x, o = Math.abs(t.y - this._data.cursor.y) < Math.abs(e.y - this._data.cursor.y) ? t.y : e.y) : (s = e.x, o = this._data.cursor.y, o = Math.min(t.y, o), o = Math.max(e.y, o)), i = new u.Point(s, o)
					} else i = new u.Point(this._data.cursor.x, this._data.item.points[0].y);
					const a = 5 + r,
						l = t.cssWidth >= a + 52,
						c = {
							x: this._data.tryCenterTooltip && l ? t.cssWidth / 2 - a / 2 : t.cssWidth - 6 - 20 - a,
							y: i.y - n / 2
						};
					e.lineWidth = 1, e.strokeStyle = this._data.borderColor, e.fillStyle = this._data.bgColor, e.translate(c.x, c.y), e.beginPath(), e.moveTo(0, 0), e.lineTo(r, 0), e.lineTo(r, n / 2 - 5), e.lineTo(r + 5, n / 2), e.lineTo(r, n / 2 + 5), e.lineTo(r, n), e.lineTo(0, n), e.lineTo(0, 0), e.stroke(), e.fill(), e.textBaseline = "bottom", e.fillStyle = this._data.fontColor, e.textAlign = "center";
					const h = 20 + o / 2;
					let d = 0;
					for (let t = 0; t < s.length; t++) d += 20, e.fillText(s[t], h, d);
					e.translate(-c.x, -c.y)
				}
			}
			var w = i(679520);
			const T = {
					fontColor: (0, w.getHexColorByName)("color-cold-gray-200"),
					bgColor: (0, w.getHexColorByName)("color-cold-gray-850")
				},
				P = {
					fontColor: (0, w.getHexColorByName)("color-cold-gray-900"),
					bgColor: (0, w.getHexColorByName)("color-white")
				};
			class M {
				constructor(e, t) {
					this._invalidated = !0, this._labelWidth = 10, this._compositeRenderer = new _.CompositeRenderer, this._alertLabel = e, this._model = t
				}
				update() {
					this._invalidated = !0
				}
				invalidate() {
					this._model.lightUpdate()
				}
				renderer() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._compositeRenderer
				}
				_updateImpl() {
					var e;
					this._compositeRenderer.clear();
					const t = this._alertLabel,
						i = t.alert(),
						o = (0, s.ensureDefined)(i.get("extra")),
						r = [],
						n = (0, s.ensureNotNull)(this._model.paneForSource(t)),
						a = (0, s.ensureNotNull)(n.mainDataSource()).firstValue();
					if (null === a || !t.canDrawLabelForAlert()) return;
					const l = e => (0, s.ensureNotNull)(t.priceScale()).priceToCoordinate(e, a),
						c = n.width() - this._labelWidth / 2 - 1;
					if (o.conditionData().isChannel) {
						const e = o.price(),
							t = l(e.upper),
							i = l(e.lower);
						r.push(new u.Point(c, t)), r.push(new u.Point(c, i))
					} else {
						const e = l(o.price());
						r.push(new u.Point(c, e))
					}
					const h = {
							alert: i,
							points: r
						},
						d = this._model,
						_ = {
							item: h,
							height: 10,
							width: this._labelWidth,
							connectingLineWidth: 1,
							color: t.color(),
							lineWidth: this._lineWidth(),
							lineStyle: this._lineStyle(),
							cursor: d.crossHairSource().currentPoint(),
							borderColor: "",
							labelWidth: 0,
							tryCenterTooltip: t.drawHorzLine()
						};
					t.drawHorzLine() && this._compositeRenderer.append(new b(_));
					const g = d.selection().isSelected(t);
					if (g) {
						const o = n.height(),
							a = r.map((e => this._model.backgroundColorAtYPercentFromTop(e.y / o))),
							l = {
								points: r,
								hittestResult: m.HitTestResult.MOVEPOINT,
								bgColors: a,
								visible: !0,
								barSpacing: this._model.timeScale().barSpacing()
							};
						this._compositeRenderer.append(new p.SelectionRenderer(l)), t.isMoving() || (_.cursor = (0,
							s.ensureDefined)(i.get("extra")).conditionData().isChannel && 1 === (null === (e = this._model.lastSelectedHittestData()) || void 0 === e ? void 0 : e.activeItem) ? h.points[1] : h.points[0])
					}
					if (!t.isMoving() && (g || t.isHovered())) {
						const {
							bgColor: e,
							fontColor: t
						} = this._model.isDark() ? T : P;
						this._compositeRenderer.append(new C({
							..._,
							bgColor: e,
							fontColor: t
						}))
					}
				}
				_lineWidth() {
					return d.defaultSettings.line.width
				}
				_lineStyle() {
					return d.defaultSettings.line.style
				}
			}
			var x = i(721386),
				I = i(934026);
			class A {
				constructor(e) {
					this._data = e
				}
				hitTest(e, t, i) {
					const s = [],
						o = this._data.items[0],
						r = this._data.items[1],
						n = this._claculateTriangleHeight(o, r),
						a = this._data.connectingLineWidth,
						l = this._data.lineWidth / 2;
					"right" === i ? (s.push((0, u.box)((0, u.point)(1, o - l), (0, u.point)(1 + this._data.width, o + n))), s.push((0, u.box)((0, u.point)(1, r + l), (0, u.point)(1 + this._data.width, r - n))), r > o && s.push((0, u.box)((0, u.point)(1 + this._data.width - a, r), (0, u.point)(1 + this._data.width + a, o)))) : (s.push((0, u.box)((0, u.point)(t - 1, o - l), (0, u.point)(t - 1 - this._data.width, o + n))), s.push((0, u.box)((0, u.point)(t - 1, r + l), (0, u.point)(t - 1 - this._data.width, r - n))), r > o && s.push((0, u.box)((0, u.point)(t - 1 - this._data.width - a, r), (0, u.point)(t - 1 - this._data.width + a, o))));
					const c = (0, v.interactionTolerance)().line;
					return s.map((e => (0, u.box)(e.min.subtract((0, u.point)(c, c)), e.max.add((0, u.point)(c, c))))).some((t => (0, I.pointInBox)(e, t))) ? new m.HitTestResult(m.HitTestResult.REGULAR) : null
				}
				draw(e, t, i, s, o, r, n) {
					const a = this._data.items[0],
						l = this._data.items[1],
						c = this._claculateTriangleHeight(a, l),
						h = this._data.connectingLineWidth,
						d = this._data.lineWidth / 2;
					e.save(), e.fillStyle = this._data.color, e.strokeStyle = this._data.color, e.lineWidth = h, (0, g.setLineStyle)(e, this._data.lineStyle);
					const u = Math.round(1 * n),
						_ = Math.round(s * n),
						m = Math.round(d * n),
						p = Math.round(this._data.width * n),
						S = Math.round(c * n),
						v = Math.round(l * n),
						f = Math.round(a * n);
					if ("left" === r) {
						if (e.beginPath(), e.moveTo(u, f - m), e.lineTo(u + p, f - m), e.lineTo(u + p, f + S), e.closePath(), e.fill(), e.beginPath(), e.moveTo(u, v + m), e.lineTo(u + p, v + m), e.lineTo(u + p, v - S), e.closePath(), e.fill(), v < f) return;
						e.beginPath(), e.moveTo(u + p, v), e.lineTo(u + p, f), e.stroke()
					} else {
						if (e.beginPath(), e.moveTo(_ - u, f - m), e.lineTo(_ - u - p, f - m), e.lineTo(_ - u - p, f + S), e.closePath(), e.fill(), e.beginPath(), e.moveTo(_ - u, v + m), e.lineTo(_ - u - p, v + m), e.lineTo(_ - u - p, v - S), e.closePath(), e.fill(), v < f) return;
						e.beginPath(), e.moveTo(_ - u - p, v), e.lineTo(_ - u - p, f), e.stroke()
					}
					e.restore()
				}
				height() {
					return 0
				}
				setData(e, t) {}
				_claculateTriangleHeight(e, t) {
					let i = this._data.height;
					return e <= t && (i = Math.min(i, Math.abs(e - t) / 2)), i
				}
			}
			class k {
				constructor(e) {
					this._data = e
				}
				draw(e, t, i, s, o, r, n) {
					e.save(), e.fillStyle = this._data.color;
					const a = this._data.items[0],
						l = Math.round(1 * n),
						c = Math.round(a * n),
						h = Math.round(5 * n),
						d = Math.round(5 * n),
						u = Math.round(2 * n),
						_ = Math.round(s * n);
					"left" === r ? (e.beginPath(), e.moveTo(l, c), e.lineTo(l + h, c - d), e.lineTo(l + h + u, c - d), e.lineTo(l + h + u, c + d), e.lineTo(l + h, c + d), e.closePath(), e.fill()) : (e.beginPath(), e.moveTo(_ - l, c), e.lineTo(_ - l - h, c - d), e.lineTo(_ - l - h - u, c - d), e.lineTo(_ - l - h - u, c + d), e.lineTo(_ - l - h, c + d), e.closePath(), e.fill()), e.restore()
				}
				hitTest(e, t, i) {
					const s = this._data.items[0];
					let o = null;
					o = "right" === i ? (0, u.box)((0, u.point)(1, s - 5), (0, u.point)(8, s + 5)) : (0, u.box)((0, u.point)(t - 1 - 1, s - 5), (0, u.point)(t - 1 - 5 - 2 - 1, s + 5));
					const r = (0, v.interactionTolerance)().line;
					return o = (0, u.box)(o.min.subtract((0, u.point)(r, r)), o.max.add((0, u.point)(r, r))), (0, I.pointInBox)(e, o) ? new m.HitTestResult(m.HitTestResult.REGULAR, {
						hideCrosshairLinesOnHover: !0
					}) : null
				}
				height() {
					return 0
				}
				setData(e, t) {}
			}
			class L {
				constructor(e) {
					this._bases = e
				}
				draw(e, t, i, s, o, r, n) {
					this._bases.forEach((a => a.draw(e, t, i, s, o, r, n)))
				}
				height() {
					return 0
				}
				setData(e, t) {}
			}
			class E {
				constructor(e, t) {
					this._data = null, this._invalidated = !0, this._alertLabel = e, this._model = t, this._invalidated = !0
				}
				coordinate() {
					return null === this._data ? 0 : this._data.items.length > 0 ? this._data.items[0] : 0
				}
				floatCoordinate() {
					return 0
				}
				getFixedCoordinate() {
					return 0
				}
				height() {
					return 0
				}
				isVisible() {
					return !!this._data && this._data.visible
				}
				isAxisLabelVisible() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !0), !!this._data && this._data.visible
				}
				paneRenderer() {
					return new L([])
				}
				setFixedCoordinate() {}
				text() {
					return ""
				}
				update() {
					this._invalidated = !0
				}
				generateTextColor(e) {
					return (0, x.colorFromBackground)(e)
				}
				renderer() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !0), null === this._data || 0 === this._data.items.length ? new L([]) : 1 === this._data.items.length ? new k(this._data) : 2 === this._data.items.length ? new A(this._data) : new L([])
				}
				secondLineText() {}
				thirdLineText() {}
				ignoreAlignment() {
					return !1
				}
				_updateImpl() {
					this._data = null;
					if (null === this._model.paneForSource(this._alertLabel)) return;
					const e = (0, s.ensureNotNull)((0, s.ensureNotNull)(this._model.paneForSource(this._alertLabel)).mainDataSource()).firstValue();
					if (null === e) return;
					const t = t => (0, s.ensureNotNull)(this._alertLabel.priceScale()).priceToCoordinate(t, e),
						i = this._alertLabel.alert(),
						o = (0, s.ensureDefined)(i.get("extra"));
					if (this._alertLabel.canDrawLabelForAlert())
						if (this._data = {
								visible: !0,
								width: 7,
								height: 7,
								color: this._alertLabel.color(),
								items: [],
								connectingLineWidth: 1,
								lineWidth: (0, d.getSettingsProperty)().childs().line.childs().width.value(),
								lineStyle: (0, d.getSettingsProperty)().childs().line.childs().style.value()
							}, o.conditionData().isChannel) {
							const e = o.price(),
								i = t(e.upper),
								s = t(e.lower);
							this._data.items.push(i), this._data.items.push(s)
						} else {
							const e = t(o.price());
							this._data.items.push(e)
						}
				}
			}
			var D = i(342141);
			class N extends E {
				constructor(e, t) {
					super(e, t), this._renderers = [], this._renderers = [], this._compositeRenderer = new L(this._renderers)
				}
				renderer() {
					if (this._invalidated && (this._updateImpl(), this._invalidated = !1), null === this._data || !this._data.visible) return new L([]);
					const e = {
						visible: this._data.visible,
						linewidth: this._data.lineWidth,
						linestyle: this._data.lineStyle,
						text: "",
						separatorVisible: !1,
						borderVisible: !1,
						ignoreOffset: !0
					};
					for (let t = this._renderers.length; t < this._data.items.length; t++) {
						const i = {
							textColor: this._data.color,
							coordinate: this._data.items[t],
							background: "",
							additionalPaddingBottom: 0,
							additionalPaddingTop: 0
						};
						this._renderers.push(new D.PriceLineAxisRenderer(e, i))
					}
					return this._renderers.length > this._data.items.length && this._renderers.splice(this._data.items.length), this._data.items.forEach(((t, i) => {
						const o = {
							textColor: (0, s.ensureNotNull)(this._data).color,
							coordinate: t,
							background: "",
							additionalPaddingBottom: 0,
							additionalPaddingTop: 0
						};
						this._renderers[i].setData(e, o)
					})), this._compositeRenderer
				}
				ignoreAlignment() {
					return !0
				}
				_updateImpl() {
					this._alertLabel.drawHorzLine() || !this._data ? super._updateImpl() : this._data.visible = !1
				}
			}
			const B = r.sortSourcesPreOrdered.AlertLabel,
				O = 5;

			function R(e) {
				return e instanceof V
			}
			class V extends o.DataSource {
				constructor(e, t, i, o) {
					super(), this._highlighted = !1, this._highlightCallback = this._highlight.bind(this), this._resetUserEditEnabledCallback = this._resetUserEditEnabled.bind(this), this._propertyMock = new(a()), this._startMovingPoint = null, this._currentMovingPoint = null, this._propertyMock.addProperty("visible", !0), this._model = e, this._alert = t, this._alertOwnerSource = i, this._paneView = new M(this, e), this._priceAxisView = new E(this, e), this._priceLinePriceAxisView = new N(this, e), this._invokeAlertEditor = o, this._resetUserEditEnabled(), this.hasAlert.setValue(!0), this._chartModelLightUpdate = e.lightUpdate.bind(e), this._onAlertSelectedChangeCallback = this._onAlertSelectedChangeCallback.bind(this), this._alertSeriesId = (0, s.ensureDefined)((0, s.ensureDefined)(t.get("extra")).alertSeries()).id, t.on("change:id", this._resetUserEditEnabledCallback), t.on("change:extra", this._resetUserEditEnabledCallback), t.on("change:extra", this._chartModelLightUpdate), t.on("change:isBeingEdited", this._resetUserEditEnabledCallback), t.on("change:selected", this._onAlertSelectedChangeCallback), this.alert().on("fired", this._highlightCallback), t.get("selected") && this.canDrawLabelForAlert() && this._selectAlertLabel()
				}
				zorder() {
					return B
				}
				alertOwnerSource() {
					return this._alertOwnerSource
				}
				alertSeriesId() {
					return this._alertSeriesId
				}
				isSpeciallyZOrderedSource() {
					return !0
				}
				stop() {
					this._alert.off("change:id", this._resetUserEditEnabledCallback), this._alert.off("change:extra", this._resetUserEditEnabledCallback), this._alert.off("change:extra", this._chartModelLightUpdate), this._alert.off("change:isBeingEdited", this._resetUserEditEnabledCallback), this._alert.off("change:selected", this._onAlertSelectedChangeCallback), this._alert.off("fired", this._highlightCallback)
				}
				alert() {
					return this._alert
				}
				isMoving() {
					return null !== this._startMovingPoint
				}
				isHovered() {
					return this === this._model.hoveredSource()
				}
				alertId() {
					return this.alert().id
				}
				getAlert() {
					return Promise.resolve(this._alert)
				}
				getAlertSync() {
					return this._alert
				}
				movable() {
					return !0
				}
				color() {
					let e;
					return e = this._highlighted ? (0, d.getSettingsProperty)().childs().highlightColor.value() : this._alert.isNew() ? "rgba( 119, 119, 119, 1)" : d.defaultSettings.color, e
				}
				convertYCoordinateToPriceForMoving(e, t) {
					const i = this.priceScale();
					if (!t || !i || i.isEmpty()) return null;
					const s = t.firstValue();
					return null === s ? null : i.coordinateToPrice(e, s)
				}
				isSynchronizable() {
					return !1
				}
				state() {
					const e = this.alert().get("extra"),
						t = [];
					if (e)
						if (e.conditionData().isChannel) {
							const i = e.price();
							t.push({
								price: i.upper
							}), t.push({
								price: i.lower
							})
						} else t.push({
							price: e.price()
						});
					return {
						id: this._id,
						type: "AlertLabel",
						zorder: this.zorder(),
						points: t
					}
				}
				restorePoints(e) {
					const t = (0, s.ensureDefined)(this.alert().get("extra"));
					t.conditionData().isChannel ? t.price({
						upper: e[0].price,
						lower: e[1].price
					}) : t.price(e[0].price)
				}
				createServerPoints() {}
				properties() {
					return this._propertyMock
				}
				paneViews() {
					return window.TradingView.printing ? null : this.labelVisible() ? [this._paneView] : null
				}
				dataWindowView() {
					return null
				}
				priceAxisViews(e, t) {
					return window.TradingView.printing ? [] : this.labelVisible() ? e.findTargetPriceAxisViews(this, t, [this._priceAxisView], [this._priceLinePriceAxisView]) : []
				}
				updateAllViews() {
					this._paneView.update(), this._priceAxisView.update(), this._priceLinePriceAxisView.update()
				}
				pointsCount() {
					return 0
				}
				title() {
					return this.alert().title()
				}
				startMoving(e, t, i, s) {
					var o;
					this._userEditEnabled = !1, this._startMovingPoint = null !== (o = e.logical) && void 0 !== o ? o : null, this.alert().saveState()
				}
				move(e, t, i, o) {
					if (!e.logical || null === t) return;
					let r = e.logical.price;
					const n = (0, s.ensureDefined)(this.alert().get("extra"));
					n.conditionData().isChannel && (0 === t ? r = {
						upper: r
					} : 1 === t && (r = {
						lower: r
					})), n.price(r), this._currentMovingPoint = e.logical
				}
				endMoving() {
					const e = this._startMovingPoint,
						t = this._currentMovingPoint;
					if (this._userEditEnabled = !0, this._startMovingPoint = null, this._currentMovingPoint = null, !e || !t || e === t) return;
					(0, h.trackEvent)("chart_alert", "edit", "move"), this._invokeAlertEditor({
						dataSourceHub: this._model,
						alert: this.alert(),
						type: "edit_alert",
						onEditCancel: () => {
							setTimeout((() => {
								this.alert().restoreState(), this._chartModelLightUpdate()
							}), 0)
						},
						actionSource: "alert_label_move"
					})
				}
				showInObjectTree() {
					return !1
				}
				isRemovedByStudyTemplates() {
					return !1
				}
				isUserDeletable() {
					return !1
				}
				doesMovingAffectsUndo() {
					return !1
				}
				drawHorzLine() {
					return this.labelLineVisible()
				}
				canDrawLabelForAlert() {
					const e = this.alert(),
						t = e.get("extra"),
						i = t && t.getMainSeries(),
						s = i && i.getStyle && i.getStyle(),
						o = this._model.mainSeries(),
						r = o && o.properties().childs(),
						n = r && r.style && r.style.value(),
						a = l.Interval.isEqual(e.get("resolution"), o.interval()) || e.get("crossInterval"),
						h = !e.isRangeBasedStyle() && !(0, c.isRangeBasedStyle)(o.style()) || s === n;
					return e.isPrice() && a && h
				}
				labelVisible() {
					const e = this._alertOwnerSource.symbolSource();
					return (!e || !e.isConvertedToOtherCurrency() && !e.isConvertedToOtherUnit()) && (!this._model.isInReplay() && d.defaultSettings.visible)
				}
				labelLineVisible() {
					return (0, d.getSettingsProperty)().childs().line.childs().visible.value()
				}
				_highlight() {
					const e = () => {
							this._highlighted = !1, this._paneView.update(), this._paneView.invalidate()
						},
						t = () => {
							this._highlighted = !0, this._paneView.update(), this._paneView.invalidate(), setTimeout(e, 500)
						};
					t(), setTimeout(t, 1e3)
				}
				_resetUserEditEnabled() {
					const e = this._alert;
					this._userEditEnabled = !(e.get("isBeingEdited") || e.isNew() || !e.isPrice() || !e.get("extra"))
				}
				_onAlertSelectedChangeCallback(e, t) {
					this.canDrawLabelForAlert() && (t ? this._selectAlertLabel() : this._unselectAlertLabel())
				}
				_selectAlertLabel() {
					this._model.selectionMacro((e => {
						e.selection().isSelected(this) || (e.clearSelection(), e.addSourceToSelection(this))
					}))
				}
				_unselectAlertLabel() {
					this._model.selectionMacro((e => {
						e.selection().isSelected(this) && e.removeSourceFromSelection(this)
					}))
				}
			}
		},
		788661: (e, t, i) => {
			"use strict";
			i.d(t, {
				AppliedTimeFrame: () => o
			});
			var s = i(257380);
			class o {
				constructor(e) {
					this._appliedTimeFrame = new s.WatchedObject(null), this._appliedTimeFrameInfo = null, this._appliedTimeFrameChangedBound = this._appliedTimeFrameChanged.bind(this), this._model = e, e.mainSeries().dataEvents().seriesTimeFrame().subscribe(this, this._onSeriesTimeFrame), this._appliedTimeFrame.subscribe(this._appliedTimeFrameChangedBound)
				}
				destroy() {
					this._appliedTimeFrame.unsubscribe(this._appliedTimeFrameChangedBound), this._model.timeScale().logicalRangeChanged().unsubscribeAll(this), this._model.mainSeries().dataEvents().seriesTimeFrame().unsubscribeAll(this)
				}
				appliedTimeFrame() {
					return this._appliedTimeFrame
				}
				_appliedTimeFrameChanged() {
					this._model.timeScale().logicalRangeChanged().unsubscribe(this, this._invalidateAppliedTimeFrame)
				}
				_onSeriesTimeFrame(e, t, i, s) {
					if (s) {
						const e = this._model.timeScale();
						this._appliedTimeFrameInfo = {
							logicalRange: e.logicalRange(),
							baseIndex: e.baseIndex()
						}, e.logicalRangeChanged().subscribe(this, this._invalidateAppliedTimeFrame)
					}
				}
				_invalidateAppliedTimeFrame() {
					if (null === this._appliedTimeFrameInfo) return;
					const e = this._model.timeScale(),
						t = e.logicalRange(),
						i = e.baseIndex(),
						s = this._appliedTimeFrameInfo.logicalRange,
						o = this._appliedTimeFrameInfo.baseIndex;
					(null === t || null === s || Math.abs(i - t.left() - (o - s.left())) >= .01 || Math.abs(i - t.right() - (o - s.right())) >= .01) && this._appliedTimeFrame.setValue(null)
				}
			}
		},
		507942: (e, t, i) => {
			"use strict";
			i.d(t, {
				defaultsPreferencesByWhiteList: () => x,
				preferencesByWhiteList: () => M
			});
			var s = i(270617),
				o = i(781995);
			var r = i(911905),
				n = i(926281),
				a = i(385518),
				l = i(734815),
				c = i(198796),
				h = i(492747),
				d = i(679520);
			const u = {
				visible: !1,
				lineStyle: i(345185).LINESTYLE_DOTTED,
				lineWidth: 1,
				bidLineColor: d.colorsPalette["color-tv-blue-500"],
				askLineColor: d.colorsPalette["color-ripe-red-400"]
			};
			var _ = i(3452);
			const m = (0, r.getLogger)("Chart.ApplyPreferencesToAllCharts"),
				p = {
					color: "",
					style: 0
				},
				g = {
					autoScale: !1,
					autoScaleDisabled: !1,
					lockScale: !1,
					percentage: !1,
					percentageDisabled: !1,
					log: !1,
					logDisabled: !1,
					alignLabels: !1,
					isInverted: !1,
					indexedTo100: !1
				},
				S = {
					backgroundType: h.ColorType.Solid,
					background: "",
					backgroundGradientStartColor: "",
					backgroundGradientEndColor: "",
					topMargin: 0,
					bottomMargin: 0,
					rightOffset: 0,
					horzGridProperties: (0, c.deepExtend)({}, p),
					vertGridProperties: (0, c.deepExtend)({}, p),
					crossHairProperties: (0, c.deepExtend)({}, {
						color: "",
						style: 0,
						transparency: 0,
						width: 0
					}),
					legendProperties: (0, c.deepExtend)({}, {
						showStudyArguments: !1,
						showStudyTitles: !1,
						showStudyValues: !1,
						showSeriesTitle: !1,
						showSeriesOHLC: !1,
						showLegend: !1,
						showBarChange: !0,
						showVolume: !1,
						showBackground: !0,
						backgroundTransparency: 0
					}),
					axisProperties: (0, c.deepExtend)({}, g),
					separatorColor: ""
				},
				v = {
					lineColor: "",
					textColor: "",
					fontSize: 0,
					scaleSeriesOnly: !1,
					showSeriesLastValue: !1,
					seriesLastValueMode: n.PriceAxisLastValueMode.LastValueAccordingToScale,
					showSeriesPrevCloseValue: !1,
					showStudyLastValue: !1,
					showSymbolLabels: !1,
					showStudyPlotLabels: !1,
					showBidAskLabels: !1,
					showPrePostMarketPriceLabel: !0,
					showFundamentalLastValue: !1,
					showFundamentalNameLabel: !1,
					showPriceScaleCrosshairLabel: !0,
					showTimeScaleCrosshairLabel: !0
				},
				f = {
					...v
				},
				b = {
					visible: !1,
					futureOnly: !1,
					breaks: (0, c.deepExtend)({}, {
						color: "",
						visible: !1,
						style: 0,
						width: 0
					})
				},
				y = {
					style: 0,
					minTick: "",
					showPriceLine: !1,
					priceLineWidth: 0,
					priceLineColor: "",
					baseLineColor: "",
					showPrevClosePriceLine: !1,
					showCountdown: !0,
					prevClosePriceLineWidth: 0,
					sessionId: "regular",
					prevClosePriceLineColor: "",
					esdShowDividends: !1,
					esdShowSplits: !1,
					esdShowEarnings: !1,
					esdShowBreaks: !1,
					showContinuousContractSwitches: !1,
					showContinuousContractSwitchesBreaks: !1,
					dividendsAdjustment: !1,
					backAdjustment: !1,
					settlementAsClose: !0,
					statusViewStyle: (0, c.deepExtend)({}, {
						fontSize: 16,
						showExchange: !0,
						showInterval: !0,
						symbolTextSource: "description"
					}),
					priceAxisProperties: (0, c.deepExtend)({}, g),
					bidAsk: (0, c.deepExtend)({}, u),
					prePostMarket: (0, c.deepExtend)({}, _.defaultPrePostMarketPreferences),
					highLowAvgPrice: (0, c.deepExtend)({}, {
						highLowPriceLinesVisible: !1,
						highLowPriceLabelsVisible: !1,
						averageClosePriceLabelVisible: !1,
						averageClosePriceLineVisible: !1
					}),
					candleStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						drawWick: !1,
						drawBorder: !1,
						drawBody: !0,
						borderColor: "",
						borderUpColor: "",
						borderDownColor: "",
						wickColor: "",
						wickUpColor: "",
						wickDownColor: "",
						barColorsOnPrevClose: !1
					}),
					hollowCandleStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						drawWick: !1,
						drawBorder: !1,
						drawBody: !0,
						borderColor: "",
						borderUpColor: "",
						borderDownColor: "",
						wickColor: "",
						wickUpColor: "",
						wickDownColor: ""
					}),
					barStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						barColorsOnPrevClose: !1,
						dontDrawOpen: !1,
						thinBars: !0
					}),
					lineStyle: (0, c.deepExtend)({}, {
						color: "",
						linestyle: 0,
						linewidth: 0,
						styleType: 0
					}),
					areaStyle: (0, c.deepExtend)({}, {
						color1: "",
						color2: "",
						linecolor: "",
						linestyle: 0,
						linewidth: 0,
						transparency: 0
					}),
					baselineStyle: (0, c.deepExtend)({}, {
						topFillColor1: "",
						topFillColor2: "",
						bottomFillColor1: "",
						bottomFillColor2: "",
						topLineColor: "",
						bottomLineColor: "",
						baselineColor: "",
						topLineWidth: 0,
						bottomLineWidth: 0,
						transparency: 0,
						baseLevelPercentage: 0
					}),
					hiloStyle: (0, c.deepExtend)({}, {
						color: "",
						showBorders: !1,
						borderColor: "",
						showLabels: !1,
						labelColor: "",
						drawBody: !0
					}),
					haStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						drawWick: !1,
						drawBorder: !1,
						drawBody: !0,
						borderColor: "",
						borderUpColor: "",
						borderDownColor: "",
						wickColor: "",
						wickUpColor: "",
						wickDownColor: "",
						showRealLastPrice: !1,
						barColorsOnPrevClose: !1,
						inputs: {}
					}),
					renkoStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						borderUpColor: "",
						borderDownColor: "",
						upColorProjection: "",
						downColorProjection: "",
						borderUpColorProjection: "",
						borderDownColorProjection: "",
						wickUpColor: "",
						wickDownColor: "",
						inputs: {
							boxSize: 0,
							style: "",
							atrLength: 0,
							wicks: !1,
							sources: "",
							source: ""
						}
					}),
					pbStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						borderUpColor: "",
						borderDownColor: "",
						upColorProjection: "",
						downColorProjection: "",
						borderUpColorProjection: "",
						borderDownColorProjection: "",
						inputs: {
							source: "",
							lb: 0
						}
					}),
					kagiStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						upColorProjection: "",
						downColorProjection: "",
						inputs: {
							style: "",
							atrLength: 0,
							reversalAmount: 0
						}
					}),
					pnfStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						upColorProjection: "",
						downColorProjection: "",
						inputs: {
							reversalAmount: 0,
							boxSize: 0,
							style: "",
							atrLength: 0
						}
					}),
					rangeStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						upColorProjection: "",
						downColorProjection: "",
						thinBars: !1,
						inputs: {
							range: 0,
							phantomBars: !1
						}
					}),
					columnStyle: (0, c.deepExtend)({}, {
						upColor: "",
						downColor: "",
						barColorsOnPrevClose: !1
					})
				},
				C = {
					priceScaleSelectionStrategyName: "auto",
					timeScale: (0, c.deepExtend)({}, {
						defaultRightOffset: 0
					}),
					mainSeries: (0, c.deepExtend)({}, y),
					sessions: (0, c.deepExtend)({}, l.sessionsPreferencesDefault),
					paneProperties: (0, c.deepExtend)({}, S),
					chartEventsSourceProperties: (0, c.deepExtend)({}, b),
					tradingProperties: (0, c.deepExtend)({}, o.tradingPreferencesDefault)
				},
				w = {
					timezone: "",
					scalesProperties: (0, c.deepExtend)({}, f),
					...C
				},
				T = {
					scalesProperties: (0, c.deepExtend)({}, v),
					...C
				};

			function P(e, t, i, o, r = !0) {
				if (void 0 === t[e]) return m.logDebug(`We haven't had this property ${o}.${e} yet, please, remove it from whiteList`), null;
				if ((0, s.isObject)(i[e])) {
					const s = Object.keys(i[e]);
					let n = "";
					return s.map((s => ({
						[s]: P(s, t[e], i[e], `${o}.${e}`, r)
					}))).reduce(((e, t) => (n = Object.keys(t)[0], e[n] = t[n], e)), {})
				}
				return r ? t[e].value() : t[e]
			}

			function M(e, t, i = w) {
				const s = {
						timezone: "",
						priceScaleSelectionStrategyName: "auto",
						timeScale: {
							defaultRightOffset: e.timeScale().defaultRightOffset().value()
						},
						mainSeries: {},
						sessions: {},
						paneProperties: {},
						scalesProperties: {},
						chartEventsSourceProperties: {},
						tradingProperties: {}
					},
					o = ["timeScale", "mainSeries", "sessions"],
					r = i.mainSeries,
					n = Object.keys(i),
					a = Object.keys(r),
					l = t.properties(),
					c = e.properties(),
					h = i.sessions,
					d = Object.keys(h),
					u = e.sessions().properties();
				return a.forEach((e => {
					s.mainSeries[e] = P(e, l, r, "mainSeries")
				})), d.forEach((e => {
					s.sessions[e] = P(e, u, h, "sessions")
				})), n.forEach((e => {
					o.includes(e) || (s[e] = P(e, c, i, "preferences"))
				})), s
			}

			function x(e, t, i = T) {
				const s = {
						timeScale: {
							defaultRightOffset: e.timeScale().rightOffsetDefaultValue()
						},
						mainSeries: {},
						sessions: (0, c.deepExtend)({}, l.sessionsPreferencesDefault),
						paneProperties: {},
						scalesProperties: {},
						chartEventsSourceProperties: {},
						tradingProperties: {},
						priceScaleSelectionStrategyName: "auto"
					},
					o = ["timeScale", "mainSeries", "sessions"],
					r = i.mainSeries,
					n = Object.keys(i),
					h = Object.keys(r),
					d = (0, a.factoryDefaults)("chartproperties.mainSeriesProperties"),
					u = (0, a.factoryDefaults)("chartproperties");
				return h.forEach((e => {
					s.mainSeries[e] = P(e, d, r, "mainSeries", !1)
				})), n.forEach((e => {
					o.includes(e) || (s[e] = P(e, u, i, "preferences", !1))
				})), s
			}
		},
		983019: (e, t, i) => {
			"use strict";
			i.d(t, {
				ChartEventsSource: () => V,
				supportedCurrenciesForChartEvents: () => B
			});
			var s = i(588537),
				o = i(62949),
				r = i(534953),
				n = i(232567),
				a = i.n(n),
				l = i(235893),
				c = i(86441),
				h = i(679520),
				d = i(849204),
				u = i(752604),
				_ = i(824112),
				m = i(345185),
				p = i(218718),
				g = i(717611),
				S = i(673444),
				v = i(940448),
				f = i(715303),
				b = i(535818),
				y = i(934026),
				C = i(164149);
			class w {
				constructor() {
					this._data = null, this._hitTest = null
				}
				setData(e) {
					this._data = e
				}
				setHitTest(e) {
					this._hitTest = e
				}
				draw(e, t) {
					const i = this._data;
					if (null === i) return;
					const s = i.centerPoint.x,
						o = i.centerPoint.y,
						r = i.diameter,
						n = r / 2;
					e.fillStyle = i.backColor, (0, _.drawScaled)(e, t.pixelRatio, (() => {
						(0, C.createCircle)(e, s, o, n - 1), e.fill(),
							e.drawImage(i.template, s - n, o - n, r, r)
					}))
				}
				hitTest(e, t) {
					const i = this._data;
					return null !== i && (0, y.pointInCircle)(e, new c.Point(i.centerPoint.x, i.centerPoint.y), i.diameter / 2) ? this._hitTest : null
				}
			}
			var T = i(393987);
			const P = h.colorsPalette["color-banana-yellow-500"],
				M = h.colorsPalette["color-tan-orange-500"],
				x = h.colorsPalette["color-ripe-red-500"],
				I = (0, d.getLogoUrlResolver)();

			function A(e) {
				const t = v.dateFormatProperty.value();
				return new f.DateTimeFormatter({
					dateFormat: t,
					timeFormat: (0, b.getHourMinuteFormat)(),
					dateTimeSeparator: "   "
				}).format(e)
			}
			class k {
				constructor(e, t, i) {
					this._renderer = new g.CompositeRenderer, this._invalidated = !1, this._templatesCache = null, this._clickedSource = null, this._series = e, this._source = t, this._showTooltipHandler = i
				}
				update() {
					this._invalidated = !0
				}
				renderer(e, t) {
					return this._invalidated && (this._updateImpl(e, t), this._invalidated = !1), this._renderer
				}
				onClickOutside() {
					this.clearLastClicked()
				}
				clearLastClicked() {
					this._clickedSource = null
				}
				_updateImpl(e, t) {
					this._createTemplates();
					const i = (0, s.ensureNotNull)(this._templatesCache);
					this._renderer.clear();
					const o = this._source.getAllGroups();
					if (null === o) return;
					const r = this._series.model().lastHittestData(),
						n = this._source.properties().childs().breaks,
						a = n.childs().visible.value();
					if (a)
						for (let t = 0; t < o.length; t++) {
							const i = new S.VerticalLineRenderer;
							i.setData({
								color: n.childs().color.value(),
								linestyle: n.childs().style.value(),
								linewidth: n.childs().width.value(),
								x: o[t].x,
								top: 0,
								bottom: e - 2 - 22 * o[t].groups.length
							}), this._renderer.append(i)
						}
					const l = new _.Size(t, e),
						h = this._chartEventBackgroundColor();
					let d, u;
					for (let t = o.length - 1; t >= 0; t--) {
						const n = o[t];
						for (let _ = n.groups.length - 1; _ >= 0; _--) {
							const g = n.groups[_],
								v = g.items[0].currency,
								f = g.maxImportance,
								b = new w;
							let y = !1;
							if (this._series.model().hoveredSource() === this._source && null !== r) {
								const e = r.activeItem;
								y = e.groupIndex === o[t].index && e.itemIndex === _
							}
							const C = this._clickedSource && this._clickedSource.groupIndex === n.index && this._clickedSource.itemIndex === _;
							let T;
							T = y || C ? i.hovered.get(v) : f < -.5 ? i.low.get(v) : f < .5 ? i.mid.get(v) : i.hi.get(v);
							const P = new c.Point(n.x, e - 2 - 22 * (_ + 1) + 11),
								M = {
									template: (0, s.ensureDefined)(T),
									centerPoint: P,
									diameter: 22,
									backColor: h
								},
								x = {
									activeItem: {
										groupIndex: n.index,
										itemIndex: _
									},
									clickHandler: this._chartEventMouseClickHandler.bind(this, n, _, P, l),
									tapHandler: this._chartEventMouseClickHandler.bind(this, n, _, P, l)
								};
							b.setData(M), b.setHitTest(new p.HitTestResult(p.HitTestResult.CUSTOM, x)), C ? (d = b, a || (u = new S.VerticalLineRenderer, u.setData({
								color: "#535353",
								linestyle: m.LINESTYLE_DASHED,
								linewidth: 1,
								x: n.x,
								top: 0,
								bottom: e - 2 - 22 * n.groups.length
							}))) : this._renderer.append(b)
						}
					}
					u && this._renderer.append(u), d && this._renderer.append(d)
				}
				_chartEventBackgroundColor() {
					return this._series.model().isDark() ? h.colorsPalette["color-cold-gray-900"] : h.colorsPalette["color-white"]
				}
				_chartEventMouseClickHandler(e, t, i, s, o) {
					if (null !== this._clickedSource && this._clickedSource.groupIndex === e.index && this._clickedSource.itemIndex === t) return void(this._clickedSource = null);
					this._clickedSource = {
						groupIndex: e.index,
						itemIndex: t
					};
					const r = {
						target: o.target,
						targetSize: s,
						point: new c.Point(i.x, i.y - 11 - 10),
						marginTop: 15
					};
					this._showTooltipHandler(r, (() => {
						const i = e.groups[t].items.slice(),
							s = this._source.timezone();
						return i.sort(((e, t) => {
							var i, s;
							const o = null !== (i = e.importance) && void 0 !== i ? i : 0;
							return (null !== (s = t.importance) && void 0 !== s ? s : 0) - o
						})).map((e => this._createTooltipContentForItem(e, s)))
					}))
				}
				_createTooltipContentForItem(e, t) {
					let i;
					const s = e.importance;
					return i = !Number.isFinite(s) || s < 0 ? P : s < 1 ? M : x, {
						title: e.title,
						subTitle: A((0, T.utc_to_cal)(t, e.timestamp)),
						content: [{
							content: [{
								name: "Actual",
								value: null !== e.actual ? e.actual.toString() : ""
							}, {
								name: "Forecast",
								value: null !== e.forecast ? e.forecast.toString() : ""
							}, {
								name: "Previous",
								value: null !== e.previous ? e.previous.toString() : ""
							}]
						}],
						style: {
							color: i
						}
					}
				}
				_createTemplates() {
					if (!this._templatesCache) {
						this._templatesCache = {
							hi: new Map,
							hovered: new Map,
							low: new Map,
							mid: new Map
						};
						for (let e = 0; e < B.length; e++) {
							const t = B[e];
							this._createTemplateCircle(this._templatesCache.low, t, P), this._createTemplateCircle(this._templatesCache.mid, t, M), this._createTemplateCircle(this._templatesCache.hi, t, x), this._createTemplateCircle(this._templatesCache.hovered, t, h.colorsPalette["color-brand-hover"])
						}
					}
				}
				_createTemplateCircle(e, t, i) {
					const s = (0, _.createDisconnectedCanvas)(document, new _.Size(44, 44)),
						o = (0, _.getPrescaledContext2D)(s);
					e.set(t, s);
					const r = () => {
							const i = new Image;
							i.onload = () => {
								e.set(t, i)
							}, i.src = s.toDataURL()
						},
						n = Math.floor(22),
						a = 32,
						l = () => {
							o.beginPath(), o.arc(n, n, 20.5, 0, 2 * Math.PI), o.closePath(), o.lineWidth = 3, o.strokeStyle = i, o.stroke()
						},
						c = t.slice(0, 2);
					if ((0, u.isCountryCode)(c)) {
						const e = new Image;
						e.onload = () => {
							(e => {
								e.width = a, e.height = a, o.drawImage(e, n - 16, n - 16, a, a), o.globalCompositeOperation = "destination-in", o.beginPath(), o.arc(n, n, 16, 0, 2 * Math.PI), o.closePath(), o.fillStyle = "white", o.fill(), o.globalCompositeOperation = "source-over"
							})(e), l(), r(), this._source.invalidate()
						}, e.crossOrigin = "anonymous", e.src = I.getCountryFlagUrl(c, d.LogoSize.Medium) + "?resetCache=true"
					} else l(), r()
				}
			}
			var L = i(273044),
				E = i(797753),
				D = i(699882),
				N = i(749473);
			const B = ["EUR", "USD", "JPY", "GBP", "CHF", "AUD", "CAD", "NZD", "CNY"],
				O = r.sortSourcesPreOrdered.ChartEventsSource;

			function R(e, t, i) {
				return i ? e.getTime() : (0, T.cal_to_utc)(t, e)
			}
			class V extends o.DataSource {
				constructor(e, t) {
					if (super(), this.toolname = "ChartEventsSource", this._distribution = null, this._coordinates = null, this._timezone = (0, T.get_timezone)("invalid"), this._chartEvents = null, this._cachedTimescaleState = null, this._minImportance = null, this._symbolName = null, this._sessionSpecCache = null, this._series = e, t && t.fixedData) {
						this._distribution = t.fixedData;
						const i = e.model().properties().childs().chartEventsSourceProperties.state();
						i.visible = !0, this._properties = new(a())(i)
					} else this._chartEvents = new l.ChartEvents({
						minImportance: 1
					}, !0), this._properties = e.model().properties().childs().chartEventsSourceProperties;
					this.setOwnerSource(e), this._paneView = new k(this._series, this, this._showTooltip.bind(this)), this._series.dataEvents().completed().subscribe(this, this._recalcDistribution), this._series.dataEvents().symbolResolved().subscribe(this, this._updateTimezone),
						this._chartEvents && this._chartEvents.changed.subscribe(this, (() => {
							this._recalcDistribution(), this._series.model().updateSource(this)
						})), this._properties.subscribe(this, this._recalcDistribution), this._series.model().properties().childs().timezone.subscribe(this, this._updateTimezone), this._updateTimezone(), this._recalcDistribution()
				}
				getAllGroups() {
					return this._coordinates || this._recalcCoordinates(), this._coordinates
				}
				timezone() {
					return this._timezone
				}
				destroy() {
					this._series.dataEvents().completed().unsubscribeAll(this), this._series.dataEvents().symbolResolved().unsubscribeAll(this), this._series.model().properties().childs().timezone.unsubscribeAll(this), this._properties.unsubscribeAll(this)
				}
				zorder() {
					return O
				}
				isSpeciallyZOrderedSource() {
					return !0
				}
				title() {
					return "Chart Events"
				}
				showInObjectTree() {
					return !1
				}
				onClickOutside() {
					this._paneView.onClickOutside()
				}
				properties() {
					return this._properties
				}
				updateAllViews() {
					const e = this._series.model().timeScale();
					if (!e) return;
					this._paneView.update();
					const t = {
						width: e.width(),
						barSpacing: e.barSpacing(),
						logicalRange: e.logicalRange()
					};
					this._cachedTimescaleState && this._cachedTimescaleState.width === t.width && this._cachedTimescaleState.barSpacing === t.barSpacing && D.LogicalRange.compare(this._cachedTimescaleState.logicalRange, t.logicalRange) || (this._cachedTimescaleState = t, this._coordinates = null)
				}
				paneViews() {
					if (!this._properties.childs().visible.value()) return null;
					const e = this._series.symbolInfo();
					return e && (0, N.isCryptoSymbol)(e) ? null : [this._paneView]
				}
				invalidate() {
					this._series.model().updateSource(this)
				}
				isUserDeletable() {
					return !1
				}
				isSavedInChart(e) {
					return !!e
				}
				state(e) {
					if (this._distribution || this._recalcDistribution(), !this._distribution) return null;
					const t = {
						type: "ChartEventsSource",
						id: this.id(),
						state: null,
						zorder: this.zorder()
					};
					if (e) {
						const e = {},
							i = Object.keys(this._distribution).map(Number).filter(isFinite).sort(((e, t) => t - e));
						let s = 1 / 0;
						const o = this._series.model().timeScale().visibleBarsStrictRange();
						null !== o && (s = o.firstBar());
						let r = 0;
						for (let t = 0; t < i.length && !(r > 300); t++) {
							const o = i[t];
							if (o < s) break;
							e[o] = [];
							const n = this._distribution[o];
							for (let t = 0; t < n.length && !(r > 400); t++) {
								e[o][t] = [];
								const i = this._distribution[o][t];
								for (let s = 0; s < i.items.length && !(r > 400); s++) e[o][t][s] = i.items[s], r++
							}
						}
						t.state = {
							distribution: e
						}
					}
					return t
				}
				static createFromState(e, t, i) {
					var s, o, r, n, a;
					if (!t) return null;
					const l = i.mainSeries();
					if (!l) return null;
					const c = e && e.state && e.state.distribution;
					if (!c) return null;
					const h = {};
					for (const e of Object.keys(c)) {
						const t = e,
							i = c[t];
						h[t] = [];
						for (const e of Object.keys(i)) {
							const l = i[e],
								c = l.reduce(((e, t) => e.importance > t.importance ? e : t)).importance;
							h[t].push({
								items: l,
								maxImportance: c
							});
							for (const e of l) e.actual = null !== (s = e.actual) && void 0 !== s ? s : null, e.forecast = null !== (o = e.forecast) && void 0 !== o ? o : null, e.previous = null !== (r = e.previous) && void 0 !== r ? r : null, e.title = null !== (n = e.title) && void 0 !== n ? n : "", e.importance = null !== (a = e.importance) && void 0 !== a ? a : 0
						}
					}
					return new V(l, {
						fixedData: h
					})
				}
				_recalcDistribution() {
					const e = this._series.symbolInfo();
					if (null === e) return;
					if (!this._chartEvents) return;
					if (this._coordinates = null,
						this._distribution = null, !this._properties.childs().visible.value()) return;
					if (!e || !e.name || e.name.length < 6) return;
					if (!(0, N.symbolHasEconomicEvents)(e)) return;
					const t = this._series.model().timeScale().tickMarks(),
						i = t.maxIndex;
					if (void 0 === i) return;
					const o = this._series.data().bars(),
						r = o.firstIndex(),
						n = o.lastIndex();
					if (null === r || null === n) return;
					let a = null;
					const l = e.name;
					let c, h = 0;
					for (let t = 0; t < 2; t++) {
						let t;
						(0, N.isCryptoSymbol)(e) && "DOGE" === l.substring(h, h + 4).toUpperCase() ? (t = "DOGE", h += 4) : (t = l.substring(h, h + 3).toUpperCase(), h += 3), -1 !== B.indexOf(t) && (a || (a = {}), a[t] = !0)
					}
					if (!a) return;
					const d = L.Interval.parse(this._series.interval());
					if (!d.isValid()) return;
					let u = NaN;
					switch (d.kind()) {
						case L.ResolutionKind.Weeks:
							u = 168 * d.multiplier();
							break;
						case L.ResolutionKind.Days:
							u = 24 * d.multiplier();
							break;
						case L.ResolutionKind.Minutes:
							u = d.multiplier() / 60;
							break;
						case L.ResolutionKind.Seconds:
							u = d.multiplier() / 3600;
							break;
						default:
							return
					}
					if (u < 4) c = -1;
					else if (u < 48) c = 0;
					else {
						if (!(u < 672)) return;
						c = 1
					}
					this._minImportance === c && this._symbolName === l || (this._chartEvents.reset({
						minImportance: c,
						currencyFilter: Object.keys(a)
					}), this._minImportance = c, this._symbolName = l);
					const _ = this._chartEvents.items(),
						m = {};
					this._distribution = m;
					let p = r;
					if (this._properties.childs().futureOnly.value() && (p = Math.max(p, n)), !isFinite(p)) return;
					const g = i,
						S = _.length;
					let v = 0;
					const f = d.isDWM(),
						b = this._timezone,
						y = t.indexToTime(g);
					if (y) {
						const e = R(y, b, f);
						for (; v < _.length && !(_[v].timestamp <= e); v++);
					}
					const C = R((0, s.ensureNotNull)(t.indexToTime(p)), b, f),
						w = this._getSessionSpec(e);
					for (let e = g; e >= p; e--) {
						const i = t.indexToTime(e);
						if (!i) continue;
						const s = R(i, b, f);
						for (; v < S; v++) {
							const t = _[v];
							if (a && !a[t.currency]) continue;
							let i, o = t.timestamp;
							if (f) {
								const e = (0, T.utc_to_cal)(b, o);
								w.correctTradingDay(e), (0, T.set_hms)(e, 0, 0, 0, 0), o = e.getTime()
							}
							if (t.timestamp < s) break;
							for (m[e] || (m[e] = []), i = m[e].length; i--;) {
								const s = m[e][i];
								if (s.items[0].currency === t.currency) {
									s.items.push(t), t.importance > s.maxImportance && (s.maxImportance = t.importance);
									break
								}
							}
							i < 0 && m[e].push({
								items: [t],
								maxImportance: t.importance
							})
						}
						this._chartEvents.minObtainedTimestamp > C && this._chartEvents.requestMore({
							from: C
						})
					}
				}
				_recalcCoordinates() {
					this._distribution || this._recalcDistribution(), this._coordinates = null;
					const e = this._distribution;
					if (!e) return;
					const t = this._series.model().timeScale(),
						i = t.visibleBarsStrictRange();
					if (null === i) return;
					const s = i.lastBar(),
						o = [];
					for (let r = i.firstBar(); r <= s; r++) e[r] && o.push({
						x: t.indexToCoordinate(r),
						groups: e[r],
						index: r
					});
					this._coordinates = o.length > 0 ? o : null
				}
				async _showTooltip(e, t) {
					const s = this._series.model().timeScale(),
						o = [s.onScroll(), s.barSpacingChanged(), this._series.onSymbolIntervalChanged()],
						r = this.onClickOutside.bind(this),
						n = this._paneView.clearLastClicked.bind(this._paneView),
						a = await Promise.all([i.e(8348), i.e(21834), i.e(11675), i.e(75514), i.e(49039)]).then(i.bind(i, 871003));
					a.showLollipopTooltip({
						items: t(),
						position: e,
						customCloseSubscriptions: o,
						onClickOutside: r,
						onCustomClose: n,
						showScrollFades: !0,
						cardType: a.LollipopCardType.Minimal
					})
				}
				_getSessionSpec(e) {
					return null !== this._sessionSpecCache && this._sessionSpecCache.session === e.session && this._sessionSpecCache.timezone === e.timezone && this._sessionSpecCache.holidays === e.session_holidays && this._sessionSpecCache.corrections === e.corrections || (this._sessionSpecCache = {
						sessionSpec: new E.SessionSpec(e.timezone, e.session, e.session_holidays, e.corrections),
						session: e.session,
						timezone: e.timezone,
						holidays: e.session_holidays,
						corrections: e.corrections
					}), this._sessionSpecCache.sessionSpec
				}
				_updateTimezone() {
					let e = this._series.model().timezone();
					if (!e || "exchange" === e) {
						const t = this._series.symbolInfo();
						e = null !== t ? t.timezone : "invalid"
					}
					this._timezone = (0, T.get_timezone)(e)
				}
			}
			window.TradingView.ChartEventsSource = V
		},
		411260: (e, t, i) => {
			"use strict";
			i.d(t, {
				ChartModelBase: () => Ss
			});
			var s = i(12481),
				o = i(588537),
				r = i(86441),
				n = i(724377),
				a = i(679520),
				l = i(575932),
				c = i(909740),
				h = i(440135),
				d = i(345848),
				u = i(579917),
				_ = i(251954),
				m = i(49437),
				p = i(781995),
				g = i(831845),
				S = i(377884),
				v = i(171670),
				f = i(540968);

			function b(e) {
				return (0, f.isLineTool)(e) && e.boundToSymbol() || (0, v.isAlertLabel)(e)
			}
			class y {
				constructor() {
					this._items = [], this._set = new Set, this._dataSourcesCache = null, this._customSourcesCache = null, this._lineSourcesCache = null
				}
				isEmpty() {
					return 0 === this._items.length
				}
				add(e) {
					if (this._items.length > 0 && !b(this._items[0]) && this.clear(), b(e)) {
						const t = (0, S.lowerbound)(this._items, e, ((e, t) => e.zorder() < t.zorder()));
						this._items.splice(t, 0, e)
					} else this.clear(), this._items = [e];
					this._set.add(e), this._invalidateCache()
				}
				canBeAddedToSelection(e) {
					return 0 === this._items.length || b(this._items[0]) && b(e)
				}
				isSelected(e) {
					return this._set.has(e)
				}
				allSources() {
					return this._items.slice(0)
				}
				dataSources() {
					return null === this._dataSourcesCache && (this._dataSourcesCache = this._items.filter(g.isDataSource)), this._dataSourcesCache
				}
				lineDataSources() {
					return null === this._lineSourcesCache && (this._lineSourcesCache = this._items.filter(f.isLineTool)), this._lineSourcesCache
				}
				customSources() {
					return null === this._customSourcesCache && (this._customSourcesCache = this._items.filter((e => !(0, g.isDataSource)(e)))), this._customSourcesCache
				}
				checkLineToolSelection() {
					this._items.forEach((e => (0, f.isLineTool)(e) && e.calcIsActualSymbol())), this._items = this._items.filter((e => !(0, f.isLineTool)(e) || e.isActualSymbol())), this._invalidateCache()
				}
				remove(e) {
					this._items = this._items.filter((t => t !== e)), this._set.delete(e), this._invalidateCache()
				}
				clear() {
					this._items = [], this._set.clear(), this._invalidateCache()
				}
				_invalidateCache() {
					this._customSourcesCache = null, this._dataSourcesCache = null, this._lineSourcesCache = null
				}
			}
			var C = i(610498),
				w = i.n(C),
				T = i(147627),
				P = i(273044),
				M = i(346090),
				x = i(232567),
				I = i.n(x),
				A = i(208214),
				k = i(588427);
			class L {
				constructor(e) {
					this._rendererOptions = {
						borderSize: 1,
						offsetSize: 5,
						fontSize: NaN,
						font: "",
						color: "",
						paneBackgroundColor: "",
						paddingBottom: 0,
						paddingInner: 0,
						paddingOuter: 0,
						paddingTop: 0,
						lineSpacing: 0
					}, this._chartModel = e
				}
				options() {
					const e = this._rendererOptions,
						t = this._chartModel.properties().childs(),
						i = t.scalesProperties.childs().fontSize.value();
					return e.fontSize !== i && (e.fontSize = i, e.font = (0, A.makeFont)(i, k.CHART_FONT_FAMILY, ""),
						e.paddingTop = 2.5 / 12 * i, e.paddingBottom = e.paddingTop, e.paddingInner = i / 12 * e.offsetSize, e.paddingOuter = i / 12 * e.offsetSize, e.lineSpacing = 2 / 12 * i), e.color = t.scalesProperties.childs().textColor.value(), e.paneBackgroundColor = t.paneProperties.childs().background.value(), this._rendererOptions
				}
			}
			var E = i(12270),
				D = i(721925),
				N = i(689765),
				B = i(385518),
				O = i(506656),
				R = i(611688),
				V = i(749473),
				W = i(734815),
				F = i(194459);
			const z = new N.PriceFormatter,
				U = "sessions";
			class H extends O.CustomSourceBase {
				constructor(e, t, i) {
					super(e, t), this._studySource = null, this._paneViews = [], this._metaInfo = null, this._destroyed = !1, this._isStarted = !1, this._loadedGraphics = null, this._doubleClickHandler = i;
					const s = t.mainSeries();
					this._properties = new M.DefaultProperty("sessions"), (0, B.applyDefaultsOverrides)(this._properties.childs().graphics, void 0, !1, U), this._removeDuplicateProperties(), this._properties.subscribe(this, this._onPropertiesChanged), t.studyMetaInfoRepository().findById({
						type: "java",
						studyId: "Sessions@tv-basicstudies"
					}).then((i => {
						this._destroyed || null === this._loadedGraphics && (this._setMetaInfo(i), null !== this._metaInfo && (this._studySource = new E.StudyDataSource(t.chartApi(), s.seriesSource(), "sessions_", this._metaInfo), this._createPaneViews(), this._studySource.dataCleared().subscribe(this, this.updateAllViews.bind(this, (0, F.dataSourceChangeEvent)(e))), this._studySource.dataUpdated().subscribe(this, this.updateAllViews.bind(this, (0, F.dataSourceChangeEvent)(e))), this._studySource.setInputs({}), this._processHibernate()))
					})), t.timeScale().onReset().subscribe(this, this._clearData), t.timeScale().logicalRangeChanged().subscribe(this, this.updateAllViews.bind(this, (0, F.viewportChangeEvent)())), t.mainSeries().sessionIdProxyProperty().subscribe(this, this._updateVisibleOfPreAndPostMarketBackground), t.mainSeries().properties().childs().interval.subscribe(this, this._processHibernate), this._updateVisibleOfPreAndPostMarketBackground(t.mainSeries().properties().childs().sessionId)
				}
				applyOverrides(e) {
					(0, B.applyPropertiesOverrides)(this._properties.childs().graphics, void 0, !1, e, U), this._model.updateSource(this)
				}
				start() {
					this._isStarted = !0, this._processHibernate()
				}
				restart() {
					this._clearData(), R.enabled("stop_study_on_restart") && this.stop(), this.start()
				}
				isStarted() {
					return this._isStarted
				}
				stop() {
					this._isStarted = !1, null !== this._studySource && this._studySource.stop()
				}
				isHoveredEnabled() {
					return !1
				}
				paneViews(e) {
					return this._paneViews
				}
				updateAllViews(e) {
					this._paneViews.forEach((t => t.update(e)))
				}
				updateViewsForPane(e, t) {
					this.updateAllViews(t)
				}
				destroy() {
					this._destroyed = !0, null !== this._studySource && (this._studySource.dataCleared().unsubscribeAll(this), this._studySource.dataUpdated().unsubscribeAll(this), this._studySource.destroy(), this._studySource = null), this._model.timeScale().logicalRangeChanged().unsubscribeAll(this), this._model.timeScale().onReset().unsubscribeAll(this), this._model.mainSeries().sessionIdProxyProperty().unsubscribeAll(this), this._model.mainSeries().properties().childs().interval.unsubscribeAll(this), this._properties.unsubscribeAll(this)
				}
				series() {
					return this._model.mainSeries()
				}
				priceScale() {
					return this.series().priceScale()
				}
				graphics() {
					return this._loadedGraphics || (0, o.ensureNotNull)(this._studySource).graphics()
				}
				properties() {
					return this._properties
				}
				graphicsInfo() {
					return (0, o.ensureNotNull)(this._metaInfo).graphics
				}
				firstValue(e) {
					return this._model.mainSeries().firstValue()
				}
				formatter() {
					return z
				}
				state(e) {
					const t = {
						properties: this._properties.state()
					};
					return e && null !== this._metaInfo && (t.data = {
						graphics: (0, D.saveStudyGraphics)(this.graphics()),
						metaInfo: this._metaInfo
					}), t
				}
				restoreState(e, t) {
					const i = e.properties;
					this._migrateOutOfSessionProperty(i), this._properties.mergeAndFire(i), this._removeDuplicateProperties(), this._updateVisibleOfPreAndPostMarketBackground(this._model.mainSeries().properties().childs().sessionId), void 0 !== e.data && t && (this._loadStudyGraphics(e.data.graphics), this._setMetaInfo(e.data.metaInfo), this._createPaneViews())
				}
				restoreOldState(e, t) {
					const i = {
						properties: {
							graphics: e.state.graphics
						}
					};
					void 0 !== e.data && void 0 !== e.metaInfo && t && (i.data = {
						metaInfo: e.metaInfo,
						graphics: e.data.graphics
					}), this.restoreState(i, t)
				}
				applyPreferences(e) {
					this._properties.mergePreferences(e)
				}
				metaInfo() {
					return (0, o.ensureNotNull)(this._metaInfo)
				}
				_loadStudyGraphics(e) {
					const t = e.backgrounds;
					if (void 0 !== t) {
						const e = t.findIndex((e => "inSession" === e.styleId)); - 1 !== e && t.splice(e, 1)
					}
					this._loadedGraphics = (0, D.loadStudyGraphics)(e)
				}
				_setMetaInfo(e) {
					const t = e.graphics.backgrounds;
					void 0 !== t && void 0 !== t.inSession && delete t.inSession, this._metaInfo = e
				}
				_updateVisibleOfPreAndPostMarketBackground(e) {
					const t = !(0, V.isRegularSessionId)(e.value());
					this._outOfSessionVisibilityProperty().setValue(t), this._preMarketVisibilityProperty().setValue(t), this._postMarketVisibilityProperty().setValue(t)
				}
				_clearData() {
					null !== this._studySource && this._studySource.clearData()
				}
				_createPaneViews() {
					const e = {
						doubleClickHandler: this._doubleClickHandler
					};
					(0, D.createGraphicsPaneViews)(this, this._model, e).then((e => {
						this._paneViews = e, this._model.lightUpdate()
					}))
				}
				_onPropertiesChanged() {
					this._processHibernate(), this.updateAllViews((0, F.dataSourceChangeEvent)(this.id()))
				}
				_processHibernate() {
					if (null !== this._studySource) {
						const e = this._canBeHibernated(),
							t = this._isHibernated(),
							i = this._studySource.isStarted();
						!t && e && i ? this._studySource.stop() : !t || e || i || this._studySource.start()
					}
				}
				_canBeHibernated() {
					const e = this._model.mainSeries(),
						t = this._preMarketVisibilityProperty().value() && this._postMarketVisibilityProperty().value() && this._outOfSessionVisibilityProperty().value();
					return e.isDWM() || !t && !this._vertLinesVisibleProperty().value()
				}
				_isHibernated() {
					return this._isStarted && (null === this._studySource || !this._studySource.isStarted())
				}
				_outOfSessionVisibilityProperty() {
					return this._properties.childs().graphics.childs().backgrounds.childs().outOfSession.childs().visible
				}
				_preMarketVisibilityProperty() {
					return this._properties.childs().graphics.childs().backgrounds.childs().preMarket.childs().visible
				}
				_postMarketVisibilityProperty() {
					return this._properties.childs().graphics.childs().backgrounds.childs().postMarket.childs().visible
				}
				_vertLinesVisibleProperty() {
					return this._properties.childs().graphics.childs().vertlines.childs().sessBreaks.childs().visible
				}
				_removeDuplicateProperties() {
					this._properties.hasChild("properties") && (this._properties.removeProperty("properties"), (0, M.saveDefaultProperties)(!0), this._properties.childChanged(null), (0, M.saveDefaultProperties)(!1))
				}
				_migrateOutOfSessionProperty(e) {
					const t = e.graphics.backgrounds;
					if (void 0 !== t) {
						const i = t.outOfSession;
						i.color === (0, o.ensureDefined)(W.sessionsPreferencesDefault.graphics.backgrounds).outOfSession.color || "postMarket" in t || (e.graphics.backgrounds = {
							...t,
							postMarket: {
								color: i.color,
								transparency: i.transparency,
								visible: i.visible
							},
							preMarket: {
								color: i.color,
								transparency: i.transparency,
								visible: i.visible
							}
						})
					}
				}
			}
			var G = i(140662),
				j = i(97639),
				q = i.n(j),
				K = i(262325),
				Y = i.n(K),
				X = i(388230),
				Z = i(38627),
				$ = i(911905),
				Q = i(95935),
				J = i(104129),
				ee = i(49318),
				te = i(929744),
				ie = i(983019),
				se = i(902899),
				oe = i(748863),
				re = i(534953);
			const ne = new Map([
					["price", e => (0, se.isPriceDataSource)(e)],
					["trading", e => (0, f.isTrading)(e)],
					["drawing", e => (0, f.isLineTool)(e) && !(0, f.isTrading)(e) && !e.isPhantom()],
					["drawingsForAllSymbols", e => (0, f.isLineTool)(e) && !(0, f.isTrading)(e) && !e.isPhantom()],
					["phantom", e => (0, f.isLineTool)(e) && e.isPhantom()],
					["restRowSources", e => !(0, f.isLineTool)(e) && !(0, f.isTrading)(e)],
					["legendViewSources", e => (0, se.isPriceDataSource)(e) || (0, f.isStudyLineTool)(e)],
					["leftPriceScale", (e, t) => "left" === le(e, t)],
					["rightPriceScale", (e, t) => "right" === le(e, t)],
					["overlayPriceScale", (e, t) => "overlay" === le(e, t)]
				]),
				ae = new Map([
					["price", "visibleSorted"],
					["trading", "visibleSorted"],
					["drawing", "visibleSorted"],
					["drawingsForAllSymbols", "allSorted"],
					["phantom", "visibleSorted"],
					["restRowSources", "visibleSorted"],
					["legendViewSources", "visibleSorted"],
					["leftPriceScale", "visibleSorted"],
					["rightPriceScale", "visibleSorted"],
					["overlayPriceScale", "visibleSorted"]
				]);

			function le(e, t) {
				const i = e.priceScale();
				return null === i ? "overlay" : t.priceScalePosition(i)
			}
			class ce {
				constructor(e) {
					this._groupedSources = new Map, this._sources = null, this._pane = e
				}
				clear() {
					this._groupedSources.clear(), this._sources = null
				}
				destroy() {
					this.clear()
				}
				all() {
					return this._groupedSources.has("visibleSorted") || this._sortSources(), (0, o.ensureDefined)(this._groupedSources.get("visibleSorted"))
				}
				allIncludingHidden() {
					return this._groupedSources.has("allSorted") || this._sortSources(), (0, o.ensureDefined)(this._groupedSources.get("allSorted"))
				}
				allExceptSpecialSources() {
					if (!this._groupedSources.has("exceptSpecial")) {
						const e = this.allIncludingHidden().filter((e => !e.isSpeciallyZOrderedSource()));
						this._groupedSources.set("exceptSpecial", e)
					}
					return (0, o.ensureDefined)(this._groupedSources.get("exceptSpecial"))
				}
				tradingSources() {
					return this._getSourcesByGroupType("trading")
				}
				priceSources() {
					return this._getSourcesByGroupType("price")
				}
				lineSources() {
					return this._getSourcesByGroupType("drawing")
				}
				lineSourcesForAllSymbols() {
					return this._getSourcesByGroupType("drawingsForAllSymbols")
				}
				phantomSources() {
					return this._getSourcesByGroupType("phantom")
				}
				allExceptLineAndTradingSources() {
					return this._getSourcesByGroupType("restRowSources")
				}
				hitTestSources() {
					if (!this._groupedSources.has("hitTest")) {
						const e = this.allExceptLineAndTradingSources().concat(this.lineSources());
						this._groupedSources.set("hitTest", e)
					}
					return (0, o.ensureDefined)(this._groupedSources.get("hitTest"))
				}
				generalSources() {
					if (!this._groupedSources.has("general")) {
						const e = this.allExceptLineAndTradingSources().concat(this.lineSources());
						this._groupedSources.set("general", (0, re.sortSources)(e))
					}
					return (0, o.ensureDefined)(this._groupedSources.get("general"))
				}
				leftPriceScalesSources() {
					return this._getSourcesByGroupType("leftPriceScale")
				}
				rightPriceScalesSources() {
					return this._getSourcesByGroupType("rightPriceScale")
				}
				overlayPriceScaleSources() {
					return this._getSourcesByGroupType("overlayPriceScale")
				}
				legendViewSources() {
					return this._getSourcesByGroupType("legendViewSources")
				}
				_getSourcesByGroupType(e) {
					const t = (0, o.ensureDefined)(ae.get(e));
					return this._groupedSources.has(t) ? this._groupedSources.has(e) || this._groupSources(e) : (this._sortSources(), this._groupSources(e)), (0, o.ensureDefined)(this._groupedSources.get(e))
				}
				_sortSources() {
					null === this._sources && (this._sources = this._pane.dataSources());
					const e = (0, re.sortSources)(this._sources),
						t = e.filter((e => !(0, f.isLineTool)(e) || e.isActualSymbol() && e.isActualCurrency() && e.isActualUnit()));
					this._groupedSources.set("allSorted", e), this._groupedSources.set("visibleSorted", t)
				}
				_groupSources(e) {
					const t = (0, o.ensureDefined)(ae.get(e)),
						i = ne.get(e);
					if (void 0 !== i) {
						const s = (0, o.ensureDefined)(this._groupedSources.get(t)).filter((e => i(e, this._pane)));
						this._groupedSources.set(e, s)
					}
				}
			}
			var he = i(812380),
				de = i(510196),
				ue = i(559270),
				_e = i(992179),
				me = i(676024),
				pe = i(986607),
				ge = i(195048),
				Se = i(970028),
				ve = i(270617),
				fe = i(906096);
			const be = [],
				ye = [];
			class Ce {
				constructor(e) {
					this._studies = {}, this._deferreds = {}, this._container = e, be.push(e), ye.push(this)
				}
				add(e, t) {
					this._deferreds[e] && (this._deferreds[e].resolve(t), delete this._deferreds[e]), this._studies[e] = t
				}
				get(e) {
					return this._studies[e] ? Promise.resolve(this._studies[e]) : (this._deferreds[e] || (this._deferreds[e] = (0, u.createDeferredPromise)()), this._deferreds[e].promise)
				}
				reset() {
					const e = be.indexOf(this._container);
					~e && (be.splice(e, 1), ye.splice(e, 1))
				}
				static instance(e) {
					const t = be.indexOf(e);
					return ~t ? ye[t] : new Ce(e)
				}
			}
			var we = i(448874),
				Te = i(561708);
			var Pe = i(669415),
				Me = i(183819),
				xe = i(386779),
				Ie = i(409304),
				Ae = i(318440),
				ke = i(101421);
			const Le = (0, $.getLogger)("Chart.Pane");

			function Ee(e, t, i) {
				e.setMargins({
					top: t,
					bottom: i
				})
			}
			class De {
				constructor(e, t, i, s) {
					this.m_dataSources = [], this._sourceWatchedValuesSubscriptions = new Map, this.m_mainDataSource = null, this._cachedOrderedSources = new ce(this), this._sourcesById = new Map, this._priceSourcesById = new Map, this._sourcePropertiesChanged = new(q()), this._sourcesZOrderChanged = new(q()), this._tagsChanged = new(q()), this._stretchFactor = 1e3, this._isInInsertManyDataSourcesState = !1, this._lastLineDataSourceZOrder = null, this._rightPriceScales = [], this._leftPriceScales = [], this._lockedPriceScale = null, this._currentPriceScaleRatio = null, this._onPriceScalesChanged = new(q()), this._isRecalculatingScales = !1, this._priceDataSources = [], this._symbolSources = [],
						this._symbolSourceResolved = new(q()), this._symbolSourceResolvingActive = new(Y())(!1), this._bulkActions = {
							activeCounter: 0
						}, this._height = 0, this._width = 0, this._dataSourcesCollectionChanged = new(q()), this._symbolSourceCollectionChanged = new(q()), this._maximized = new(Y())(!1), this._collapsed = new(Y())(!1), this._destroyed = new(q()), this._executionsPositionController = null, this._recalcSymbolSourceResolvingActive = () => {
							for (const e of this._symbolSources)
								if (e.symbolResolvingActive().value()) return void this._symbolSourceResolvingActive.setValue(!0);
							this._symbolSourceResolvingActive.setValue(!1)
						}, this._onSymbolSourceCollectionChanged = () => {
							0 === this._bulkActions.activeCounter ? this._symbolSourceCollectionChanged.fire() : this._bulkActions.symbolSourceCollectionChanged = !0
						}, this._priceScaleSelectionStrategy = (0, oe.createPriceScaleSelectionStrategy)(i.properties().childs().priceScaleSelectionStrategyName.value()), this._id = null != s ? s : (0, Q.randomHashN)(6), this._timeScale = e, this.m_mainDataSource = null, this._properties = t, this._model = i, i.properties().childs().priceScaleSelectionStrategyName.subscribe(null, (e => {
							this._priceScaleSelectionStrategy = (0, oe.createPriceScaleSelectionStrategy)(e.value()), this._priceScaleSelectionStrategy.apply(this)
						})), this._timeScale.barSpacingChanged().subscribe(this, (() => {
							this.m_mainDataSource === this._model.mainSeries() && this._recalculatePriceScaleByScaleRatio(this.m_mainDataSource.priceScale())
						})), t.childs().topMargin.subscribe(this, this._updateMargins), t.childs().bottomMargin.subscribe(this, this._updateMargins), this._updateMargins()
				}
				destroy() {
					this._properties.childs().topMargin.unsubscribeAll(this), this._properties.childs().bottomMargin.unsubscribeAll(this), this._model.properties().childs().priceScaleSelectionStrategyName.unsubscribeAll(this), this._timeScale.barSpacingChanged().unsubscribeAll(this), this._leftPriceScales.concat(this._rightPriceScales).forEach((e => {
						e.modeChanged().unsubscribeAll(this), e.priceRangeChanged().unsubscribeAll(this), e.internalHeightChanged().unsubscribeAll(this)
					}));
					for (const e of this.m_dataSources) this.removeSourceFromPriceScale(e), e.destroy && e.destroy();
					this._destroyed.fire()
				}
				id() {
					return this._id
				}
				bulkActionMacro(e) {
					const t = this._bulkActions;
					t.activeCounter += 1, e(), t.activeCounter -= 1, 0 === t.activeCounter && (this._dataSourcesCollectionChanged.fire(), t.symbolSourceCollectionChanged && this._symbolSourceCollectionChanged.fire(), t.symbolSourceCollectionChanged = !1)
				}
				defaultPriceScale() {
					var e, t;
					const i = null !== (t = null === (e = this.m_mainDataSource) || void 0 === e ? void 0 : e.priceScale()) && void 0 !== t ? t : null;
					if (null !== i) return i;
					const s = this.properties().childs().axisProperties.state();
					return s.autoScale = !0, new he.PriceScale(this._model.properties().childs().scalesProperties, s)
				}
				leftPriceScales() {
					return this._leftPriceScales
				}
				rightPriceScales() {
					return this._rightPriceScales
				}
				visibleLeftPriceScales() {
					var e;
					const t = this._model.priceScaleSlotsCount();
					if (this._leftPriceScales.length > t.left) {
						const i = (0, S.moveToHead)(this._leftPriceScales, null === (e = this.mainDataSource()) || void 0 === e ? void 0 : e.priceScale());
						return i.splice(t.left), i
					}
					return this._leftPriceScales
				}
				visibleRightPriceScales() {
					var e;
					const t = this._model.priceScaleSlotsCount();
					if (this._rightPriceScales.length > t.right) {
						const i = (0, S.moveToHead)(this._rightPriceScales, null === (e = this.mainDataSource()) || void 0 === e ? void 0 : e.priceScale());
						return i.splice(t.right), i
					}
					return this._rightPriceScales
				}
				clearSeries(e) {
					const t = this._model.mainSeries();
					for (let i = this.m_dataSources.length - 1; i >= 0; i--) this.m_dataSources[i] === t && this._removeSourceFromCollections(i, e)
				}
				sourcesByGroup() {
					return this._cachedOrderedSources
				}
				dataSourceForId(e) {
					return this._sourcesById.get(e) || null
				}
				changeSourceId(e, t) {
					(0, o.assert)(this.hasDataSource(e));
					const i = e.id();
					e.setId(t), this._sourcesById.delete(i), this._sourcesById.set(t, e), (0, se.isPriceDataSource)(e) && (this._priceSourcesById.delete(i), this._priceSourcesById.set(t, e))
				}
				movePriceScale(e, t, i) {
					const s = this.priceScalePosition(e);
					if (s !== t) this.removePriceScale(e), this._placePriceScale(e, t, i), e.invalidateMargins(), this._invalidateSourcesCache();
					else if (void 0 !== i && "overlay" !== s) {
						const t = "left" === s ? this._leftPriceScales : this._rightPriceScales,
							o = t.indexOf(e);
						t.splice(o, 1), t.splice(i, 0, e)
					}
				}
				mainDataSource() {
					return this.m_mainDataSource
				}
				isEmpty() {
					return null === this.m_mainDataSource
				}
				recalculatePriceScale(e, t) {
					if (!e) return;
					const i = e.sourcesForAutoscale();
					if ((e.isAutoScale() || e.priceRangeShouldBeRecalculatedOnce()) && i && i.length > 0 && !this.timeScale().isEmpty()) {
						const t = this.timeScale().visibleBarsStrictRange();
						e.recalculatePriceRange(t)
					}
					e.updateAllViews(t)
				}
				onSourceTagsChanged() {
					this._tagsChanged.fire()
				}
				insertDataSource(e, t, i) {
					e.setZorder(i), t || (t = this.findSuitableScale(e)), this._addSourceToCollections(e);
					let s = !1;
					e === this.model().mainSeries() ? (this.m_mainDataSource = this.model().mainSeries(), s = !0) : null === this.m_mainDataSource && (0, se.isPriceDataSource)(e) && (this.m_mainDataSource = e, s = !0), t.addDataSource(e, this._isInInsertManyDataSourcesState), e.setPriceScale(t), t.invalidateMargins(), e.onTagsChanged && e.onTagsChanged().subscribe(this, this.onSourceTagsChanged), s && this._processMainSourceChange(), this._tagsChanged.fire(), (0, se.isPriceDataSource)(e) && this.recalculatePriceScale(t, (0, F.dataSourceChangeEvent)(e.id())), this._invalidateSourcesCache(), this._isInInsertManyDataSourcesState || (0, o.ensureNotNull)(this.model().alertsWatcher()).syncSourceAlertLabels(e)
				}
				addDataSource(e, t, i) {
					let s = e.zorder();
					i || ((0, f.isLineTool)(e) && !e.isSpeciallyZOrderedSource() ? (s = null !== this._lastLineDataSourceZOrder ? this._lastLineDataSourceZOrder + 1 : this.newLineToolZOrder(), this._isInInsertManyDataSourcesState && (this._lastLineDataSourceZOrder = s)) : (0, G.isStudy)(e) && !e.isSpeciallyZOrderedSource() && (s = this.newStudyZOrder())), this.insertDataSource(e, t, s)
				}
				removeDataSource(e, t, i) {
					const s = this.m_dataSources.indexOf(e);
					if (-1 === s) return void Le.logDebug("removeDataSource: invalid data source");
					(0, o.ensureNotNull)(this.model().alertsWatcher()).detachSourceAlertLabels(e), this._removeSourceFromCollections(s, !!i), e !== this.m_mainDataSource || t || (this.m_mainDataSource = null);
					const r = e.priceScale();
					this.removeSourceFromPriceScale(e), e.onTagsChanged && e.onTagsChanged().unsubscribe(this, this.onSourceTagsChanged), (0, se.isPriceDataSource)(e) && !t && this._processMainSourceChange(), this._tagsChanged.fire(), r && (0, se.isPriceDataSource)(e) && this.recalculatePriceScale(r, (0, F.dataSourceChangeEvent)(e.id())), this._invalidateSourcesCache()
				}
				hasDataSource(e) {
					return this._sourcesById.has(e.id())
				}
				hasPriceDataSource(e) {
					return this._priceSourcesById.has(e.id())
				}
				dataSources() {
					return this.m_dataSources
				}
				priceDataSources() {
					return this._priceDataSources
				}
				symbolSources() {
					return this._symbolSources
				}
				replaceSource(e, t, i) {
					const s = this.m_mainDataSource === e,
						o = e.zorder();
					this.insertDataSource(t, i, o), this.removeDataSource(e, s), this._sourcesById.set(t.id(), t), (0, se.isPriceDataSource)(t) && this._priceSourcesById.set(t.id(), t), s && (this.m_mainDataSource = t, this._processMainSourceChange())
				}
				findSuitableScale(e, t, i) {
					return this._priceScaleSelectionStrategy.findSuitableScale(this, e, t, i)
				}
				createNewPriceScaleIfPossible() {
					return this._priceScaleSelectionStrategy.createNewPriceScaleIfPossible(this)
				}
				canCreateNewPriceScale() {
					return this._priceScaleSelectionStrategy.canCreateNewPriceScale(this)
				}
				isOverlay(e) {
					const t = e.priceScale();
					return null === t || "overlay" === this.priceScalePosition(t)
				}
				recalculate(e) {
					this._leftPriceScales.forEach((t => this.recalculatePriceScale(t, e))), this._rightPriceScales.forEach((t => this.recalculatePriceScale(t, e)));
					for (const t of this.m_dataSources) this.isOverlay(t) && !(0, f.isLineTool)(t) && this.recalculatePriceScale(t.priceScale(), e);
					this.updateAllViews(e), this._model.updatePane(this)
				}
				updateAllViews(e) {
					for (const t of this.m_dataSources) t.updateAllViews(e);
					for (const t of this.model().customSources()) t.updateViewsForPane(this, e)
				}
				priceScalePosition(e) {
					return this._leftPriceScales.includes(e) ? "left" : this._rightPriceScales.includes(e) ? "right" : "overlay"
				}
				createPriceScaleAtPosition(e, t) {
					const i = this.properties().childs().axisProperties.state();
					i.autoScale = !0;
					const s = new he.PriceScale(this.model().properties().childs().scalesProperties, i);
					return s.setHeight(this.height()), Ee(s, this._defaultTopMargin(), this._defaultBottomMargin()), this._placePriceScale(s, e, t), s
				}
				removePriceScale(e) {
					e.modeChanged().unsubscribeAll(this), e.priceRangeChanged().unsubscribeAll(this), e.internalHeightChanged().unsubscribeAll(this), e === this._lockedPriceScale && (this._lockedPriceScale = null, this._currentPriceScaleRatio = null);
					const t = this._leftPriceScales.indexOf(e); - 1 !== t && (this._leftPriceScales[t].invalidateMargins(), this._leftPriceScales.splice(t, 1));
					const i = this._rightPriceScales.indexOf(e);
					if (-1 !== i && (this._rightPriceScales[i].invalidateMargins(), this._rightPriceScales.splice(i, 1)), null === e.mainSource()) {
						const t = e.dataSources().length;
						0 !== t && Le.logError("Invalid priceScale state: empty mainSource but non-empty data sources=" + t)
					}
					this._onPriceScalesChanged.fire()
				}
				priceScaleIndex(e, t) {
					switch (t) {
						case "left":
							return this.leftPriceScales().indexOf(e);
						case "right":
							return this.rightPriceScales().indexOf(e)
					}
				}
				move(e, t, i) {
					const s = e.priceScale();
					this.removeSourceFromPriceScale(e),
						t.addDataSource(e), e.setPriceScale(t), t.invalidateMargins(), this._processMainSourceChange(), this._invalidateSourcesCache(), e.isIncludedInAutoScale() && (null !== s && this.recalculatePriceScale(s, (0, F.dataSourceChangeEvent)(e.id())), this.recalculatePriceScale(t, (0, F.dataSourceChangeEvent)(e.id()))), this._onPriceScalesChanged.fire()
				}
				setZOrders(e) {
					e.forEach(((e, t) => {
						t.setZorder(e)
					})), this._invalidateSourcesCache(), 0 === this._bulkActions.activeCounter && this._dataSourcesCollectionChanged.fire(), this.model().lightUpdate()
				}
				isMainPane() {
					return this.hasDataSource(this.model().mainSeries())
				}
				isLast() {
					const e = this.model().panes();
					return e[e.length - 1] === this
				}
				newStudyZOrder() {
					return (0, me.newStudyZOrder)(this._priceDataSources)
				}
				newLineToolZOrder(e) {
					return (0, me.newLineToolZOrder)(this.m_dataSources, e)
				}
				model() {
					return this._model
				}
				containsMainSeries() {
					return this._sourcesById.has(this.model().mainSeries().id())
				}
				applyPriceScaleRatio(e, t) {
					var i;
					null !== this._lockedPriceScale && this._lockedPriceScale !== e || this._currentPriceScaleRatio === t || !this.isMainPane() || null === this._lockedPriceScale && e !== (null === (i = this.mainDataSource()) || void 0 === i ? void 0 : i.priceScale()) || (this._setNewPriceRangeByScaleRatio(e, t, this._mainSourceVisiblePriceRange(e), !0, !0), null !== this._lockedPriceScale ? this._tryToApplyNewPriceScaleRatio() : e.isLog() || this.model().mainSeriesScaleRatioPropertyOnChanged())
				}
				sendToBack(e) {
					const t = this.sourcesByGroup().allExceptSpecialSources();
					this._batchReorder(e, t[0], me.moveBeforeSource)
				}
				bringToFront(e) {
					const t = this.sourcesByGroup().allExceptSpecialSources();
					this._batchReorder(e, t[t.length - 1], me.moveAfterSource)
				}
				sendBackward(e) {
					const t = this.sourcesByGroup().allIncludingHidden(),
						i = t.indexOf(e[0]);
					if (0 === i) this.bringToFront(e);
					else {
						const s = t[i - 1];
						this.insertBefore(e, s)
					}
				}
				bringForward(e) {
					const t = this.sourcesByGroup().allExceptSpecialSources(),
						i = t.indexOf(e[e.length - 1]);
					if (i === t.length - 1) this.sendToBack(e);
					else {
						const s = t[i + 1];
						this.insertAfter(e, s)
					}
				}
				insertAfter(e, t) {
					this._batchReorder(e, t, me.moveAfterSource)
				}
				insertBefore(e, t) {
					this._batchReorder(e, t, me.moveBeforeSource)
				}
				maximized() {
					return this._maximized
				}
				collapsed() {
					return this._collapsed
				}
				getPriceScaleById(e) {
					const t = this.m_dataSources.find((t => {
						var i;
						return (null === (i = t.priceScale()) || void 0 === i ? void 0 : i.id()) === e
					}));
					return void 0 === t ? null : t.priceScale()
				}
				priceScaleSelectionStrategy() {
					return this._priceScaleSelectionStrategy
				}
				setPriceScaleSelectionStrategy(e) {
					this._priceScaleSelectionStrategy = e, e.apply(this)
				}
				findTargetPriceAxisViews(e, t, i, s) {
					if ((0, g.isDataSource)(e) && this.model().paneForSource(e) !== this) return [];
					const o = e.priceScale();
					if (t === o) return i;
					if (null === o) return [];
					if ("overlay" === this.priceScalePosition(o)) return t === this.defaultPriceScale() ? i : [];
					const r = this.priceScalePosition(t);
					if (r !== this.priceScalePosition(o)) return [];
					const n = "left" === r ? this.leftPriceScales() : this.rightPriceScales();
					return n.indexOf(t) < n.indexOf(o) ? s : []
				}
				actionNoScaleIsEnabled(e) {
					return !(!this.isOverlay(e) && (0, se.isPriceDataSource)(e)) || this._nonOverlayPricesSourcesCount() > 1
				}
				properties() {
					return this._properties
				}
				setPriceAutoScale(e, t) {
					e.setMode({
						autoScale: t
					}), this.timeScale().isEmpty() || this.recalculatePriceScale(e, (0, F.viewportChangeEvent)())
				}
				state(e, t, i, s, o, r) {
					var n, a;
					const l = {
							sources: [],
							mainSourceId: null === (n = this.m_mainDataSource) || void 0 === n ? void 0 : n.id(),
							stretchFactor: this._stretchFactor,
							leftAxisesState: [],
							rightAxisesState: [],
							overlayPriceScales: {},
							priceScaleRatio: this._currentPriceScaleRatio
						},
						c = new Map,
						h = e => {
							if (c.has(e)) return c.get(e);
							let n = null;
							const a = i && !e.isSavedInStudyTemplates() || (0, v.isAlertLabel)(e) || !e.state || (0, f.isLineTool)(e) && r || !(n = e.state(t, o)) || !e.isSavedInChart(Boolean(t)) || s && (0, f.isLineTool)(e) && e.isActualSymbol && !e.isActualSymbol() || e.isPhantom() ? null : n;
							return c.set(e, a), a
						};
					if (e) {
						l.sources = [];
						for (let e = 0; e < this.m_dataSources.length; e++) {
							const t = h(this.m_dataSources[e]);
							null !== t && l.sources.push(t)
						}
					}
					const d = e => null !== c.get(e),
						u = e => !r || !(0, f.isLineTool)(e);
					l.leftAxisesState = this._leftPriceScales.map((e => ({
						state: e.state(),
						sources: e.dataSources().filter(d).filter(u).map((e => e.id()))
					}))), l.rightAxisesState = this._rightPriceScales.map((e => ({
						state: e.state(),
						sources: e.dataSources().filter(d).filter(u).map((e => e.id()))
					}))), l.overlayPriceScales = {};
					for (const e of this.m_dataSources)
						if (this.isOverlay(e) && e.isSavedInChart(Boolean(t))) {
							const t = e.priceScale();
							l.overlayPriceScales[e.id()] = null !== (a = null == t ? void 0 : t.state()) && void 0 !== a ? a : null
						} return l
				}
				restoreState(e, t, i, s, r, n) {
					s = s || {}, e.stretchFactor && (this._stretchFactor = e.stretchFactor);
					const a = {};
					if (e.sources) {
						const o = e.sources.filter((e => {
								var t;
								return !!e && ("MainSeries" === e.type || (!(null === (t = e.points) || void 0 === t ? void 0 : t.some((e => null === e.time_t || !isFinite(e.time_t)))) || (Le.logNormal("Dropped invalid " + e.type + ". Reason: non-numeric point time"), !1)))
							})),
							l = o.findIndex(pe.isMainSeriesState); - 1 !== l && this.model().mainSeries().setObsoleteZOrder(o[l].zorder), i < 3 && (0, me.reorderDataSourcesStateZOrder)(o);
						const c = -1 !== this.m_dataSources.indexOf(this._model.mainSeries());
						this.clearSeries(Boolean(n)), this.m_mainDataSource = null, c && this._addSourceToCollections(this._model.mainSeries(), n), (() => {
							const t = o.find((t => t.id === e.mainSourceId));
							if (void 0 === t) return void Le.logWarn("There is no main source with id " + e.mainSourceId + ", total sources=" + o.length);
							if (!window.TradingView[t.type] || !(0, f.isLineToolName)(t.type)) return void Le.logNormal("The type of main source is not line tool - fix is unnecessary");
							let i = null;
							for (const e of o)
								if (!window.TradingView[t.type] || !(0, f.isLineToolName)(e.type)) {
									if (null !== i) return void Le.logWarn("Pane contains more than 1 possibly main sources - auto fix cannot be applied");
									i = e
								} if (null === i) return void Le.logWarn("Pane contains only line tools - possible we need to remove this pane?");
							const s = e.mainSourceId;
							let r = 0;
							e.mainSourceId = i.id, o.forEach((e => {
								e.ownerSource === s && (e.ownerSource = null == i ? void 0 : i.id, r += 1)
							})), Le.logNormal("Auto fix broken pane is applied, changed line tools=" + r + ", changed from=" + s + " to=" + i.id)
						})();
						for (const e of o)
							if ("study_Sessions" === e.type) {
								this.model().sessions().restoreOldState(e, t);
								break
							}
						for (const e of o) "study_Sessions" !== e.type && (null === this._model.dataSourceForId(e.id) || "MainSeries" === e.type ? (a[e.id] = e.ownerSource, (0, pe.isMainSeriesState)(e) ? this._restoreMainSeries(e, t, c, s, r, n) : (0, pe.isStudyState)(e) ? this.restoreStudy(e, t, s, n) : (0, pe.isLineToolState)(e) ? (e.state && (e.state.zOrderVersion = 2), this.restoreLineTool(e, t, void 0, n)) : "ChartEventsSource" === e.type && this._restoreSpecialSource(e, t, n)) : Le.logError("Duplicate id while restoring pane: " + e.type + "," + e.id))
					}
					const l = new Set,
						c = (e, t) => {
							e.priceScale() !== t && (this.removeSourceFromPriceScale(e), e.setPriceScale(t), t.addDataSource(e))
						},
						h = (e, t, i) => {
							if (l.has(e)) return;
							l.add(e);
							const s = i.m_showSymbolLabels;
							void 0 !== s && e === this.model().mainSeries() && this.model().properties().childs().scalesProperties.childs().showSymbolLabels.setValue(s), this._model.children(e, !0).forEach((e => h(e, t, i))), c(e, t)
						},
						d = e => {
							const t = (0, B.defaults)("chartproperties").paneProperties.axisProperties,
								i = new he.PriceScale(this.model().properties().childs().scalesProperties, t);
							return i.restoreState(e.state), e.sources.forEach((e => {
								const s = this.dataSourceForId(e);
								s && h(s, i, t)
							})), 0 === i.dataSources().length ? null : i
						},
						u = e => e.map(d).filter((e => null !== e));
					let _;
					if (e.leftAxisesState) _ = u(e.leftAxisesState);
					else {
						const t = d({
							state: e.leftAxisState,
							sources: e.leftAxisSources
						});
						_ = null !== t ? [t] : []
					}
					let m;
					if (this._leftPriceScales.slice().forEach((e => this.removePriceScale(e))), this._leftPriceScales = [], _.forEach((e => this._placePriceScale(e, "left"))), e.rightAxisesState) m = u(e.rightAxisesState);
					else {
						const t = d({
							state: e.rightAxisState,
							sources: e.rightAxisSources
						});
						m = null !== t ? [t] : []
					}
					this._rightPriceScales.slice().forEach((e => this.removePriceScale(e))), this._rightPriceScales = [], m.forEach((e => this._placePriceScale(e, "right"))), this._currentPriceScaleRatio = e.priceScaleRatio || e.leftPriceScaleRatio || e.rightPriceScaleRatio || null;
					const p = new Map;
					for (const t of this.m_dataSources) {
						if (l.has(t)) continue;
						let i;
						if (e.overlayPriceScales && e.overlayPriceScales[t.id()]) {
							let s = e.overlayPriceScales[t.id()];
							p.has(null == s ? void 0 : s.id) ? i = p.get(null == s ? void 0 : s.id) : (s = (0, o.ensure)(s), i = new he.PriceScale(this._model.properties().childs().scalesProperties), i.setHeight(this._height), s.m_isAutoScale = !0, s.m_isLog = !1, s.m_isPercentage = !1, s.m_isLockScale = !1, i.restoreState(s), p.set(s.id, i))
						} else i = new he.PriceScale(this._model.properties().childs().scalesProperties), i.setHeight(this._height);
						c(t, i)
					}
					for (const e of Object.keys(a)) {
						const t = a[e],
							i = this.dataSourceForId(e);
						t && i && null === i.ownerSource() && i.setOwnerSource(this.dataSourceForId(t))
					}
					if (e.mainSourceId && !this.containsMainSeries() && (this.m_mainDataSource = this.dataSourceForId(e.mainSourceId)), !this.m_mainDataSource)
						for (const e of this.m_dataSources)
							if ((0, se.isPriceDataSource)(e)) {
								this.m_mainDataSource = e;
								break
							} for (const e of this.m_dataSources)
						if ((0, f.isLineTool)(e)) e.ownerSource() || e.setOwnerSource(this.mainDataSource()), e.isFixed() && e.restoreFixedPoints();
						else if ((0, G.isStudy)(e)) {
						const t = e.properties().childs();
						!e.ownerSource() && t.linkedToSeries && t.linkedToSeries.value() && e.setOwnerSource(this.model().mainSeries())
					}
					this._updateMargins(), this._cachedOrderedSources.clear()
				}
				onPriceScalesChanged() {
					return this._onPriceScalesChanged
				}
				setPaneSize(e) {
					let t;
					switch (e) {
						case "large":
							t = 1;
							break;
						case "medium":
							t = .6;
							break;
						case "small":
							t = .3;
							break;
						case "tiny":
							t = .15;
							break;
						default:
							throw new Error("Unknown size enum value: " + e)
					}
					this._stretchFactor = 1e3 * t
				}
				stretchFactor() {
					return this._stretchFactor
				}
				setStretchFactor(e) {
					this._stretchFactor = e
				}
				customSources(e) {
					return this.model().customSources(e)
				}
				createDrawingsCaches() {
					0
				}
				clearDrawingCaches() {
					0
				}
				executionsPositionController() {
					return null
				}
				width() {
					return this._width
				}
				height() {
					return this._height
				}
				setHeight(e) {
					this._height = e, this._leftPriceScales.forEach((t => t.setHeight(e))), this._rightPriceScales.forEach((t => t.setHeight(e)));
					for (let t = 0; t < this.m_dataSources.length; t++) {
						const i = this.m_dataSources[t];
						this.isOverlay(i) && i.priceScale() && (0, o.ensureNotNull)(i.priceScale()).setHeight(e)
					}
					this.updateAllViews((0, F.viewportChangeEvent)())
				}
				setWidth(e) {
					this._width = e, this.updateAllViews((0, F.viewportChangeEvent)())
				}
				onTagsChanged() {
					return this._tagsChanged
				}
				onDestroyed() {
					return this._destroyed
				}
				dataSourcesCollectionChanged() {
					return this._dataSourcesCollectionChanged
				}
				symbolSourceCollectionChanged() {
					return this._symbolSourceCollectionChanged
				}
				symbolSourceResolved() {
					return this._symbolSourceResolved
				}
				symbolSourceResolvingActive() {
					return this._symbolSourceResolvingActive
				}
				sourcePropertiesChanged() {
					return this._sourcePropertiesChanged
				}
				sourceZOrderChanged() {
					return this._sourcesZOrderChanged
				}
				lineToolsForArea(e) {
					const t = this.height(),
						i = this.width(),
						s = this.logicalRectToPixels(e);
					return [...this.m_dataSources, ...this.model().multiPaneSources(this)].filter(f.isLineTool).filter((e => (e.paneViews(this) || []).some((e => {
						const o = e.renderer(t, i);
						return o && o.doesIntersectWithBox && o.doesIntersectWithBox(s)
					}))))
				}
				logicalRectToPixels(e) {
					const t = this.defaultPriceScale(),
						i = this.timeScale(),
						s = (0, o.ensureNotNull)((0, o.ensureNotNull)(t.mainSource()).firstValue()),
						n = t.priceToCoordinate(e.p1.price, s),
						a = i.indexToCoordinate(e.p1.index),
						l = t.priceToCoordinate(e.p2.price, s),
						c = i.indexToCoordinate(e.p2.index),
						h = new r.Point(Math.min(a, c), Math.min(n, l)),
						d = new r.Point(Math.max(a, c), Math.max(n, l));
					return (0, r.box)(h, d)
				}
				timeScale() {
					return this._timeScale
				}
				restoreLineTool(e, t, i, s, r) {
					var n, a, c, h, d, u, _, m, p, g, S, v;
					delete e.state.lastUpdateTime, e.state.intervalsVisibilities = (0, Pe.mergeIntervalVisibilitiesDefaults)(e.state.intervalsVisibilities), i = void 0 === i || i, Te.LineToolElliott.migrateState(e), "LineToolGannComplex" !== (v = e).type || void 0 !== v.version && 1 !== v.version || (v.type = "LineToolGannFixed");
					const b = e.type,
						y = e.id,
						C = e.state,
						w = i ? e.zorder : this.newLineToolZOrder();
					(0, o.assert)((0, f.isLineToolName)(b), "invalid data source type:" + b + " (expected to be a Line Tool)");
					let T, P, M = null;
					if ((0, pe.isStudyLineToolState)(e)) {
						M = this._model.studyVersioning();
						const i = M.patchPointsBasedStudyState(e);
						e = i;
						const o = i.metaInfo;
						if (Object.assign(o, Se.StudyMetaInfo.parseIdString(null == o ? void 0 : o.fullId)),
							!t && o) {
							const t = o.productId;
							if (!(null === (n = window.pro) || void 0 === n ? void 0 : n.hasPackage(t))) {
								const t = new te.StudyLineToolStub(this._model, e, o.shortDescription);
								return t.setId(y), this._addSourceToCollections(t, s), void 0 !== w && t.setZorder(w), t.setFailed((0, l.t)("not authorized")), null
							}
						}
						const r = M.updateMetaInfo(o) || o;
						P = (0, f.createStudyLineToolProperties)(b, o, r, C, M), T = (0, f.createLineTool)(b, this._model, P, r, !0)
					} else P = (0, f.createLineToolProperties)(b, C, this._model), t ? null === (a = P.child("fixedSize")) || void 0 === a || a.setValue(!1) : null === (c = P.child("fixedSize")) || void 0 === c || c.setValue(!0), T = (0, f.createLineTool)(b, this._model, P, null, !0);
					T.setId(y), T.linkKey().setValue(e.linkKey || null);
					const x = e.alertId;
					x && T.canHasAlert() && R.enabled("alerts") && !this._model.readOnly() && !this._model.isJustClonedChart() && T.setAlert(x, {
						noChartSave: !0
					});
					let I = null !== (h = e.indexes) && void 0 !== h ? h : [];
					if (I = I.slice(0, null !== (u = null === (d = e.points) || void 0 === d ? void 0 : d.length) && void 0 !== u ? u : I.length), T.isFixed() ? e.positionPercents && T.restorePositionPercents(e.positionPercents) : e.points && T.restorePoints(e.points, I, t), T instanceof Me.LineToolBarsPattern || T instanceof xe.LineToolCallout || T instanceof Ie.LineToolTrendAngle || T instanceof Ae.LineToolGhostFeed || T instanceof ke.LineToolParallelChannel || T instanceof J.LineToolTweet || T instanceof ee.LineToolIdea) null === (m = (_ = T).restoreData) || void 0 === m || m.call(_, e);
					else if (t && (0, pe.isStudyLineToolState)(e) && T.restoreData) {
						const t = e;
						M && (t.graphics = M.patchPointsBasedStudyData(t.metaInfo, t.graphics)), null === (p = T.restoreData) || void 0 === p || p.call(T, t)
					}
					const A = null == e.version ? 1 : e.version,
						k = null == T.version ? 1 : T.version;
					if (A !== k && (null === (S = (g = T).migrateVersion) || void 0 === S || S.call(g, A, k, {
							pane: this,
							model: this._model,
							properties: P
						})), void 0 !== w && T.setZorder(w), r)(0, f.prepareLineToolPropertiesByOwnerSource)(T.properties(), r), T.setOwnerSource(r);
					else {
						const t = e.ownerSource ? this.dataSourceForId(e.ownerSource) : null;
						T.setOwnerSource(t)
					}
					return void 0 !== e.sharingMode && T.share(e.sharingMode), this._addSourceToCollections(T, s), this._cachedOrderedSources.clear(), T
				}
				restoreStudy(e, t, i, s) {
					if (t && void 0 === e.data && void 0 === e.nonSeriesData && void 0 === e.indexes) return Le.logError("Cannot restore (skipping) study without data " + e.id + ", " + e.metaInfo.id), null;
					const o = e.id,
						r = e.state,
						n = e.zorder,
						a = e.ownerSource;
					let l = (0, ve.clone)(e.metaInfo);
					if (Object.assign(l, Se.StudyMetaInfo.parseIdString(l.id)), function(e) {
							return "Script$TV_EARNINGS@tv-scripting" === e || "Script$TV_DIVIDENDS@tv-scripting" === e || "Script$TV_SPLITS@tv-scripting" === e || "ESD$TV_EARNINGS@tv-scripting" === e || "ESD$TV_DIVIDENDS@tv-scripting" === e || "ESD$TV_SPLITS@tv-scripting" === e || "Earnings@tv-basicstudies" === e || "Dividends@tv-basicstudies" === e || "Splits@tv-basicstudies" === e || "BarSetContinuousRollDates@tv-basicstudies" === e
						}(l.id) && !t) return Le.logNormal("Skipping study " + l.id), null;
					let c = r;
					const h = this._model.studyVersioning(),
						d = h.patchPropsStateAndMetaInfo(c, l, {
							oldShowStudyLastValueProperty: t && !i.showStudyLastValueProperty
						});
					c = d.propsState, l = d.metaInfo;
					const u = new T.StudyStub(this._model, e, l.shortDescription);
					let _;
					u.setId(o), u.setZorder(n);
					const m = i => {
						u.setStatus({
							type: fe.StudyStatusType.Undefined
						});
						const s = i || new Se.StudyMetaInfo(l),
							r = Ce.instance(this._model),
							n = n => {
								var a;
								const d = (0, we.prepareStudyPropertiesForLoadChart)(l, i, c, null, h),
									m = (0, G.createStudy)(this._model, d, n || this._model.mainSeries(), s);
								if (m.setId(o), m.setOwnFirstValue(null !== (a = e.ownFirstValue) && void 0 !== a ? a : null), t) {
									const t = e,
										{
											data: i,
											nsData: s,
											indexes: o
										} = h.patchStudyData(l, t.data, t.nonSeriesData, t.indexes);
									m.restoreData(i, s, o)
								}
								this._model.replaceStudyStub(u, m) || (_ = m), r.add(o, m)
							};
						a && e.state.isChildStudy ? r.get(a).then(n) : n()
					};
					if (t) m(null);
					else {
						const e = h.updateMetaInfoAsync(l);
						e.sync ? m(e.result) : e.result.then(m).catch((e => u.setFailed("error: " + e)))
					}
					const p = null != _ ? _ : u;
					if (p) {
						p.setZorder(n);
						const t = e.metaInfo.linkedToSeries ? this._model.mainSeries() : a ? this.dataSourceForId(a) : null;
						p.setOwnerSource(t), this._addSourceToCollections(p, s), this._processMainSourceChange()
					}
					return this._cachedOrderedSources.clear(), p
				}
				clipboardLineToolOwnerSource(e) {
					const t = this.dataSourceForId(e);
					if (null !== t) {
						const e = t.ownerSource();
						if (null !== e && null !== e.firstValue()) return e
					}
					const i = this.mainDataSource();
					if (null !== i && null !== i.firstValue()) return i;
					for (const e of this.dataSources())
						if ((0, se.isPriceDataSource)(e) && null !== e.firstValue()) return e;
					return null
				}
				realignLineTools(e) {
					var t;
					let i = !1;
					for (const s of this.m_dataSources) !(0, f.isLineTool)(s) || void 0 !== e && (null === (t = s.ownerSource()) || void 0 === t ? void 0 : t.symbolSource()) !== e || (s.realign(), s.updateAllViews((0, F.dataSourceChangeEvent)(s.id())), i = !0);
					return i && this._invalidateSourcesCache(), i
				}
				startScalePrice(e, t) {
					e.startScale(t)
				}
				scalePriceTo(e, t) {
					e.scaleTo(t), this.updateAllViews((0, F.viewportChangeEvent)())
				}
				endScalePrice(e) {
					e.endScale()
				}
				startScrollPrice(e, t) {
					e.startScroll(t)
				}
				scrollPriceTo(e, t) {
					e.scrollTo(t), this.updateAllViews((0, F.viewportChangeEvent)())
				}
				endScrollPrice(e) {
					e.endScroll()
				}
				resetPriceScale(e) {
					const t = this.timeScale().visibleBarsStrictRange();
					e.isLockScale() || e.setMode({
						autoScale: !0
					}), e.recalculatePriceRange(t), this.updateAllViews((0, F.viewportChangeEvent)())
				}
				restorePriceScaleState(e, t) {
					e.restoreState(t), this.updateAllViews((0, F.viewportChangeEvent)())
				}
				beginInsertManyLineDataSources() {
					this._isInInsertManyDataSourcesState = !0, this._lastLineDataSourceZOrder = null
				}
				endInsertManyLineDataSources() {
					this._isInInsertManyDataSourcesState = !1, this._lastLineDataSourceZOrder = null; {
						const e = (0, o.ensureNotNull)(this.model().alertsWatcher());
						for (const t of this.m_dataSources) e.syncSourceAlertLabels(t)
					}
				}
				removeSourceFromPriceScale(e) {
					const t = e.priceScale();
					if (null !== t) {
						const i = t.dataSources();
						i.indexOf(e) >= 0 && t.removeDataSource(e), 0 === i.length && this.removePriceScale(t)
					}
				}
				_invalidateSourcesCache() {
					this._cachedOrderedSources.clear(), this._leftPriceScales.forEach((e => e.invalidateSourcesCache())), this._rightPriceScales.forEach((e => e.invalidateSourcesCache()))
				}
				_processMainSourceChange() {
					let e = !1;
					if (null === this.m_mainDataSource)
						for (const t of this.m_dataSources)
							if ((0,
									se.isPriceDataSource)(t) && !this.isOverlay(t) && (!t.properties().linkedToSeries || !t.properties().linkedToSeries.value())) {
								this.m_mainDataSource = t, e = !0;
								break
							} if (this.m_mainDataSource && e) {
						let e = this.m_dataSources.filter(f.isLineTool);
						e = (0, re.sortSources)(e);
						for (const t of e) this.move(t, (0, o.ensureNotNull)(this.m_mainDataSource.priceScale()), !0)
					} else if (!this.m_mainDataSource || this.isOverlay(this.m_mainDataSource) && 0 === this._nonOverlayPricesSourcesCount()) {
						let e = null;
						if (this.m_dataSources.includes(this._model.mainSeries())) e = this._model.mainSeries();
						else
							for (const t of this.m_dataSources)
								if ((0, se.isPriceDataSource)(t) && this.isOverlay(t) && t.showInObjectTree()) {
									e = t;
									break
								} if (null !== e) {
							const t = this.m_mainDataSource === e;
							this.m_mainDataSource = e;
							const i = this.createNewPriceScaleIfPossible();
							if (t && e === this._model.mainSeries()) {
								const t = (0, o.ensureNotNull)(e.priceScale());
								this._model.children(e, !0).forEach((e => {
									this.removeSourceFromPriceScale(e), i.addDataSource(e), e.setPriceScale(i)
								})), this.removePriceScale(t)
							}
							this.move(e, i, !0), this.recalculatePriceScale(e.priceScale(), (0, F.globalChangeEvent)())
						}
					}
				}
				_addSourceToCollections(e, t) {
					this.m_dataSources.push(e), this._sourcesById.set(e.id(), e), this._invalidateSourcesCache();
					const i = () => {
						this._sourcePropertiesChanged.fire(e)
					};
					e.properties().subscribe(this, i), e.zOrderChanged().subscribe(this, (t => this._sourcesZOrderChanged.fire(e, t))), (0, f.isLineTool)(e) && (e.normalizedPointsChanged().subscribe(this, i), e.fixedPointsChanged().subscribe(this, i), e.hasAlert.subscribe(i), e.sharingMode().subscribe(i), e.linkKey().subscribe(i), this._sourceWatchedValuesSubscriptions.set(e.id(), i));
					const s = (0, _e.isSymbolSource)(e) ? e : null;
					(0, se.isPriceDataSource)(e) && (this._priceSourcesById.set(e.id(), e), e.currencyChanged().subscribe(this, (() => this._invalidateSourcesCache())), e.unitChanged().subscribe(this, (() => this._invalidateSourcesCache())), this._priceDataSources.push(e), null !== s && (this._symbolSources.push(s), s.symbolResolved().subscribe(this, (() => this._symbolSourceResolved.fire(e))), s.symbolResolvingActive().subscribe(this._recalcSymbolSourceResolvingActive), s.symbolHibernated().subscribe(this._onSymbolSourceCollectionChanged), this._recalcSymbolSourceResolvingActive(), this._onSymbolSourceCollectionChanged())), e.isMultiPaneAvailable() && this.model().addMultiPaneSource(e), t || 0 !== this._bulkActions.activeCounter || this._dataSourcesCollectionChanged.fire()
				}
				_removeSourceFromCollections(e, t) {
					const i = this.m_dataSources[e];
					i.properties().unsubscribeAll(this), i.zOrderChanged().unsubscribeAll(this), this.m_dataSources.splice(e, 1), this._sourcesById.delete(i.id());
					const s = i.id();
					if ((0, f.isLineTool)(i) && (i.normalizedPointsChanged().unsubscribeAll(this), i.fixedPointsChanged().unsubscribeAll(this), this._sourceWatchedValuesSubscriptions.has(s))) {
						const e = this._sourceWatchedValuesSubscriptions.get(s);
						i.hasAlert.unsubscribe(e), i.linkKey().unsubscribe(e)
					}
					this._invalidateSourcesCache();
					const r = (0, _e.isSymbolSource)(i) ? i : null;
					if ((0, se.isPriceDataSource)(i)) {
						this._priceSourcesById.delete(i.id()), i.currencyChanged().unsubscribeAll(this),
							i.unitChanged().unsubscribeAll(this);
						const e = this._priceDataSources.indexOf(i);
						if ((0, o.assert)(-1 !== e), this._priceDataSources.splice(e, 1), null !== r) {
							const e = this._symbolSources.indexOf(r);
							(0, o.assert)(-1 !== e, "Source is not found"), this._symbolSources.splice(e, 1), r.symbolResolved().unsubscribeAll(this), r.symbolResolvingActive().unsubscribe(this._recalcSymbolSourceResolvingActive), r.symbolHibernated().unsubscribe(this._onSymbolSourceCollectionChanged), this._recalcSymbolSourceResolvingActive(), this._onSymbolSourceCollectionChanged()
						}
					}
					i.isMultiPaneAvailable() && this.model().removeMultiPaneSource(i), t || 0 !== this._bulkActions.activeCounter || this._dataSourcesCollectionChanged.fire()
				}
				_recalculatePriceScaleByScaleRatio(e) {
					this.isMainPane() && e === this._lockedPriceScale && (null !== this._currentPriceScaleRatio ? this._applyOldScaleRatioToPriceScale() : this._tryToApplyNewPriceScaleRatio())
				}
				_defaultBottomMargin() {
					return .01 * this.properties().childs().bottomMargin.value()
				}
				_defaultTopMargin() {
					return .01 * this.properties().childs().topMargin.value()
				}
				_updateMargins() {
					const e = this._defaultTopMargin(),
						t = this._defaultBottomMargin();
					for (const i of this._leftPriceScales) Ee(i, e, t);
					for (const i of this._rightPriceScales) Ee(i, e, t);
					for (const i of this.m_dataSources)
						if (this.isOverlay(i)) {
							const s = i.priceScale();
							null !== s && (Ee(s, e, t), this.recalculatePriceScale(s, (0, F.viewportChangeEvent)()))
						} for (const e of this._leftPriceScales) this.recalculatePriceScale(e, (0, F.viewportChangeEvent)());
					for (const e of this._rightPriceScales) this.recalculatePriceScale(e, (0, F.viewportChangeEvent)());
					this.updateAllViews((0, F.viewportChangeEvent)())
				}
				_batchReorder(e, t, i) {
					i(this.sourcesByGroup().allExceptSpecialSources(), e, t), this._invalidateSourcesCache(), this._dataSourcesCollectionChanged.fire(), this.model().fullUpdate()
				}
				_placePriceScale(e, t, i) {
					if ("overlay" === t) return void e.invalidateMargins();
					const s = "left" === t ? this._leftPriceScales : this._rightPriceScales,
						r = void 0 === i ? s.length : i;
					s.splice(r, 0, e), e.modeChanged().subscribe(this, this._onPriceScaleModeChanged.bind(this, e)), e.internalHeightChanged().subscribe(this, this._recalculatePriceScaleByScaleRatio.bind(this, e)), e.priceRangeChanged().subscribe(this, this._recalculateTimeScaleByScaleRatio.bind(this, e)), e.priceRangeChanged().subscribe(this, this._onPriceScaleSetMinMaxPriceRange.bind(this, e)), e.isLockScale() && ((0, o.assert)(null === this._lockedPriceScale), this._lockedPriceScale = e, this._currentPriceScaleRatio = null), e.invalidateMargins(), this._onPriceScalesChanged.fire()
				}
				_onPriceScaleModeChanged(e, t, i) {
					if (i.lockScale && (this._lockedPriceScale !== e && null !== this._lockedPriceScale && this._lockedPriceScale.setMode({
							lockScale: !1
						}), this._lockedPriceScale = e, this._currentPriceScaleRatio = (0, de.scaleRatio)(this.timeScale(), e)), t.lockScale && !i.lockScale && (this._lockedPriceScale = null, this._currentPriceScaleRatio = null), t.percentage === i.percentage && t.indexedTo100 === i.indexedTo100) return;
					const s = this.timeScale().visibleBarsStrictRange();
					null !== s && (e.recalculatePriceRange(s), e.updateAllViews((0, F.viewportChangeEvent)()))
				}
				_applyOldScaleRatioToPriceScale() {
					this._isRecalculatingScales || null === this._currentPriceScaleRatio || null === this._lockedPriceScale || (this._isRecalculatingScales = !0, this._setNewPriceRangeByScaleRatio(this._lockedPriceScale, this._currentPriceScaleRatio, this._mainSourceVisiblePriceRange(this._lockedPriceScale)), this._isRecalculatingScales = !1)
				}
				_setNewPriceRangeByScaleRatio(e, t, i, s, o) {
					const r = (0, de.priceRangeByScaleRatio)(e, this.timeScale().barSpacing(), t);
					e.setPriceRange(null !== r ? r : i, s, o)
				}
				_applyOldScaleRatioToTimeScale() {
					this._isRecalculatingScales || null === this._currentPriceScaleRatio || (this._isRecalculatingScales = !0, this._setNewBarSpacingByScaleRatio(), this._isRecalculatingScales = !1)
				}
				_tryToApplyNewPriceScaleRatio() {
					const e = (0, o.ensureNotNull)(this._lockedPriceScale),
						t = (0, de.scaleRatio)(this.timeScale(), e);
					this._currentPriceScaleRatio === t || e.isLog() || (this._currentPriceScaleRatio = t, this.model().mainSeriesScaleRatioPropertyOnChanged())
				}
				_recalculateTimeScaleByScaleRatio(e) {
					e === this._lockedPriceScale && (null !== this._currentPriceScaleRatio ? this._applyOldScaleRatioToTimeScale() : this._tryToApplyNewPriceScaleRatio())
				}
				_setNewBarSpacingByScaleRatio() {
					const e = this.timeScale().getValidBarSpacing((0, de.barSpacingByScaleRatio)((0, o.ensureNotNull)(this._lockedPriceScale), this._currentPriceScaleRatio));
					this.timeScale().isValidBarSpacing(e) && this.timeScale().setBarSpacing(e)
				}
				_mainSourceVisiblePriceRange(e) {
					const t = this.timeScale().visibleBarsStrictRange();
					return null !== t ? (0, o.ensureNotNull)((0, o.ensureNotNull)(e.mainSource()).priceRange(t.firstBar(), t.lastBar())) : new ue.PriceRange(-.5, .5)
				}
				_setMinMaxPriceRange() {
					const e = (0, o.ensureNotNull)(this._lockedPriceScale),
						t = (0, de.priceRangeByScaleRatio)(e, this.timeScale().maxBarSpacing(), this._currentPriceScaleRatio),
						i = (0, de.priceRangeByScaleRatio)(e, this.timeScale().minBarSpacing(), this._currentPriceScaleRatio);
					null !== t && e.setMaxPriceRange(t), null !== i && e.setMinPriceRange(i)
				}
				_onPriceScaleSetMinMaxPriceRange(e) {
					e === this._lockedPriceScale && this._setMinMaxPriceRange()
				}
				_nonOverlayPricesSourcesCount() {
					return this.m_dataSources.filter((e => (!e.properties().linkedToSeries || !e.properties().linkedToSeries.value()) && ((0, se.isPriceDataSource)(e) && e.showInObjectTree() && !this.isOverlay(e)))).length
				}
				_restoreMainSeries(e, t, i, s, o, r) {
					const n = e.id,
						a = e.state;
					if (a && o && (a.style = o.style || a.style, a.interval = o.interval || a.interval, o.symbol && o.symbol !== a.symbol && (a.symbol = o.symbol, delete a.currencyId, delete a.unitId)), a && ["candleStyle", "hollowCandleStyle", "haStyle"].forEach((e => {
							a[e] && (a[e].wickUpColor = a[e].wickUpColor || a[e].wickColor, a[e].wickDownColor = a[e].wickDownColor || a[e].wickColor)
						})), a && (a.statusViewStyle = a.statusViewStyle || {}, !a.statusViewStyle.symbolTextSource)) {
						const e = !!a.statusViewStyle.showSymbolAsDescription;
						a.statusViewStyle.symbolTextSource = e ? "ticker" : "description"
					}
					if (a && (a.extendedHours ? a.sessionId = "extended" : a.sessionId || (a.sessionId = "regular"), delete a.extendedHours), !i) {
						const e = this._model.mainSeries();
						this._model.mainPane().removeDataSource(e, !1, r), this._addSourceToCollections(e, r)
					}
					const l = this.model().mainSeries(),
						c = l.properties().childs();
					this.m_mainDataSource = l;
					const h = a && a.style ? a.style : void 0;
					if (6 === h && "ATR" === c.pnfStyle.childs().inputs.childs().style.value() ? c.pnfStyle.childs().inputs.childs().style.setValueSilently("Traditional") : 4 === h && "ATR" === c.renkoStyle.childs().inputs.childs().style.value() && c.renkoStyle.childs().inputs.childs().style.setValueSilently("Traditional"), a && !a.hasOwnProperty("showSessions") && (a.showSessions = !1), a && void 0 === a.settlementAsClose && (a.settlementAsClose = !1), a && t && (a.showCountdown = !1), a && (t && !("showSeriesLastValueProperty" in s) && "showLastValue" in a && this._model.properties().childs().scalesProperties.childs().showSeriesLastValue.setValue(a.showLastValue), delete a.showLastValue), a) {
						const t = {
								haStyle: (0, V.chartStyleStudyId)(8, !0),
								renkoStyle: (0, V.chartStyleStudyId)(4, !0),
								pbStyle: (0, V.chartStyleStudyId)(7, !0),
								kagiStyle: (0, V.chartStyleStudyId)(5, !0),
								pnfStyle: (0, V.chartStyleStudyId)(6, !0),
								rangeStyle: (0, V.chartStyleStudyId)(11, !0)
							},
							i = this._model.studyVersioning(),
							s = l.styleStudyInfos(),
							o = Object.keys(ge.SYMBOL_STRING_DATA);
						for (let r = 0; r < o.length; r++) {
							const n = ge.STYLE_SHORT_NAMES[o[r]] + "Style",
								l = n in e ? e[n].studyId : t[n],
								c = a[n];
							if (null == c) continue;
							const h = c.inputs,
								d = Se.StudyMetaInfo.parseIdString(l),
								u = s[n].studyId,
								_ = Se.StudyMetaInfo.parseIdString(u),
								m = i.updateStudyInputs(d.id, d.version, _.version, h, null);
							c.inputs = m
						}
					}
					const d = l.sessionId();
					l.restoreState(e, t), this.changeSourceId(l, n), l.sessionId() !== d && c.sessionId.listeners().fire(c.sessionId)
				}
				_restoreSpecialSource(e, t, i) {
					if ("ChartEventsSource" !== e.type) return;
					const s = ie.ChartEventsSource.createFromState(e, t, this._model);
					s && (s.setId(e.id), this._addSourceToCollections(s, i), e.zorder && s.setZorder(e.zorder))
				}
			}
			var Ne = i(876242),
				Be = i(3008),
				Oe = i(466915),
				Re = i(198796),
				Ve = i(612826),
				We = i(699882);
			const Fe = (0, $.getLogger)("Chart.TimePoints");
			class ze {
				constructor() {
					this._zoffset = 0, this._items = []
				}
				clear() {
					this._zoffset = 0, this._items = []
				}
				size() {
					return this._items.length
				}
				firstIndex() {
					return this._offsetToIndex(0)
				}
				lastIndex() {
					return this._offsetToIndex(this._items.length - 1)
				}
				merge(e, t, i) {
					if (0 === i.length) return Fe.logError("merge: 'values' does not contain any time points"), [];
					if (t > this._zoffset && e + t > 0) return Fe.logError("merge: when the first time point index is updated, we should fill the time points starting from the first one"), [];
					if (0 === this._items.length) return this._items = i.slice(), this._zoffset = t, [{
						change: "rebuild",
						index: this._validOffsetToIndex(0)
					}];
					const s = e + this._zoffset;
					if (s < 0) {
						const o = Math.abs(s);
						if (i.length < o) return Fe.logError("merge: 'values' does not contain enough time points to fill in the new items. 'index': " + e.toString() + ", previous 'zoffset': " + this._zoffset.toString() + ", new 'zoffset': " + t.toString() + ", 'values.length': " + i.length), [];
						this._items = new Array(o).concat(this._items), this._zoffset = t;
						for (let s = 0; s < i.length; ++s) this._items[e + s + t] = i[s];
						return [{
							change: "rebuild",
							index: this._validOffsetToIndex(0)
						}]
					}
					const o = [];
					let r = s;
					for (; r < this._items.length && r - s < i.length; ++r) this._items[r] = i[r - s], o.push({
						change: "update",
						index: this._validOffsetToIndex(r),
						value: i[r - s]
					});
					const n = s + i.length;
					if (n > this._items.length) {
						const e = n - this._items.length;
						for (let t = r; t < r + e; ++t) {
							const e = this._items.length;
							this._items.push(i[t - s]), o.push({
								change: "append",
								index: this._validOffsetToIndex(e),
								value: i[t - s]
							})
						}
					} else {
						for (let e = n; e < this._items.length; ++e) o.push({
							change: "remove",
							index: this._validOffsetToIndex(e),
							value: this._items[e]
						});
						this._items.length = n
					}
					return this._zoffset = t, o
				}
				addTail(e, t) {
					for (let i = t ? 1 : 0; i < e.length; i++) this._items.push(e[i])
				}
				remove(e) {
					const t = this._indexToOffset(e);
					if (null === t) return [];
					const i = this._items.splice(t),
						s = [];
					for (let t = 0; t < i.length; t++) s.push({
						change: "remove",
						index: e + t,
						value: i[t]
					});
					return s
				}
				valueAt(e) {
					const t = this._indexToOffset(e);
					return null !== t ? this._items[t] : null
				}
				indexOf(e, t) {
					if (this._items.length < 1) return null;
					if (e > this._items[this._items.length - 1]) return t ? this._validOffsetToIndex(this._items.length - 1) : null;
					for (let i = 0; i < this._items.length; ++i) {
						if (e === this._items[i]) return this._validOffsetToIndex(i);
						if (e < this._items[i]) return t ? this._validOffsetToIndex(i) : null
					}
					return null
				}
				state() {
					return {
						items: this._items,
						zoffset: this._zoffset
					}
				}
				restoreState(e) {
					null !== e && (this._items = e.items, this._zoffset = e.zoffset)
				}
				roughTime(e, t = null) {
					const i = this.valueAt(e);
					if (null !== i) return i;
					const s = this._items;
					if (!s.length || s.length < 2) return null;
					const o = s.length - 1,
						r = this._validOffsetToIndex(0),
						n = this._validOffsetToIndex(o),
						a = s[0],
						l = s[o],
						c = (l - a) / (n - r);
					if (e < r) {
						return a - (r - e) * c
					}
					if (e > n) {
						const i = e - n;
						if (i < 500 && null != t) return t(l, i);
						return l + i * c
					}
					return null
				}
				roughIndex(e, t = null) {
					const i = this._items;
					if (!i.length || i.length < 2) return null;
					const s = i.length - 1,
						o = this._validOffsetToIndex(0),
						r = this._validOffsetToIndex(s),
						n = i[0],
						a = i[s];
					if (e >= n && e <= a) return this.closestIndexLeft(e);
					const l = (a - n) / (r - o);
					if (e < n) {
						const t = n - e;
						return o - Math.round(t / l)
					}
					if (e > a) {
						const i = e - a;
						let s = Math.trunc(i / l);
						if (s < 500 && null !== t) {
							const i = t(a, e);
							i.success && (s = i.result)
						}
						return r + s
					}
					return null
				}
				closestIndexLeft(e) {
					const t = this._items;
					if (!t.length) return null;
					if (Number.isNaN(e)) return null;
					let i = t.length - 1;
					if (e >= t[i]) return this._validOffsetToIndex(i);
					let s = 0;
					const o = t[s];
					if (e < o) return null;
					if (e === o) return this._validOffsetToIndex(s);
					for (; i > s + 1;) {
						const o = s + i >> 1,
							r = t[o];
						if (r > e) i = o;
						else {
							if (!(r < e)) return r === e ? this._validOffsetToIndex(o) : null;
							s = o
						}
					}
					return this._validOffsetToIndex(s)
				}
				_validOffsetToIndex(e) {
					return e - this._zoffset
				}
				_offsetToIndex(e) {
					return 0 <= e && e < this.size() ? this._validOffsetToIndex(e) : null
				}
				_indexToOffset(e) {
					const t = e + this._zoffset;
					return 0 <= t && t < this.size() ? t : null
				}
			}
			const Ue = new Map([
				[0, .1],
				[11, .1],
				[1, .35],
				[9, .35],
				[12, .35],
				[8, .35]
			]);
			class He {
				constructor(e, t) {
					this._styleSpecificRanges = new Map, this._logicalRange = e, this._defaultStyle = t
				}
				strictRange(e) {
					if (null === this._logicalRange) return null;
					void 0 === e && (e = this._defaultStyle);
					let t = this._styleSpecificRanges.get(e);
					if (void 0 === t) {
						const i = (Ue.get(e) || 0) / 2;
						t = new Ve.BarsRange(Math.floor(this._logicalRange.left() + i), Math.ceil(this._logicalRange.right() - i)), this._styleSpecificRanges.set(e, t)
					}
					return t
				}
				logicalRange() {
					return this._logicalRange
				}
				isValid() {
					return null !== this._logicalRange
				}
				static invalid() {
					return new He(null, 1)
				}
			}
			var Ge = i(126844),
				je = i(121195);
			class qe {
				constructor(e, t = 50) {
					this._actualSize = 0, this._usageTick = 1, this._oldestTick = 1, this._cache = new Map, this._tick2Labels = new Map, this._format = e, this._maxSize = t
				}
				format(e) {
					const t = this._cache.get(e.valueOf());
					if (void 0 !== t) return t.string;
					if (this._actualSize === this._maxSize) {
						const e = this._tick2Labels.get(this._oldestTick);
						this._tick2Labels.delete(this._oldestTick), this._cache.delete((0, o.ensureDefined)(e)), this._oldestTick++, this._actualSize--
					}
					const i = this._format(e);
					return this._cache.set(e.valueOf(), {
						string: i,
						tick: this._usageTick
					}), this._tick2Labels.set(this._usageTick, e.valueOf()), this._actualSize++, this._usageTick++, i
				}
			}
			var Ke = i(381269);
			let Ye;
			var Xe = i(932255),
				Ze = i(820187),
				$e = i(535818);
			const Qe = {
					preserveBarSpacing: !1,
					lockVisibleTimeRangeOnResize: !1,
					rightBarStaysOnScroll: !0,
					minBarSpacing: .5
				},
				Je = R.enabled("low_density_bars"),
				et = Je ? 1 : 2,
				tt = (0, $.getLogger)("Chart.TimeScale");
			class it {
				constructor(e, t) {
					this._width = 0, this._widthChanged = new(q()), this._rightOffset = 10, this._rightOffsetChanged = new(q()), this._maxRightOffsetChanged = new(q()), this._defaultRightOffset = new(Y())(10), this._baseIndex = null, this._leftEdgeIndex = null, this._barSpacingChanged = new(q()), this._barSpacing = 6, this._visibleBars = He.invalid(), this._visibleBarsInvalidated = !0, this._visibleBarsChanged = new(q()), this._logicalRangeChanged = new(q()), this._points = new ze, this._tickMarks = new Ge.Tickmarks, this._onScroll = new(q()), this._resetDelegate = new(q()), this._scrollStartPoint = null, this._scaleStartPoint = null, this._commonTransitionStartState = null, this._formattedBySpan = new Map, this._requestingMoreData = !1, this._requestedTickmarksCount = 0, this._endOfData = !1, this._lockBarsAndLogicalRangeEvents = !1, this._options = (0, Re.deepExtend)({}, Qe, t), this._model = e, this._scalesProperties = e.properties().childs().scalesProperties, this._defaultRightOffset.subscribe((e => {
						this.setRightOffset(e)
					})), this._options.preserveBarSpacing && (this._barSpacing = this._scalesProperties.childs().barSpacing.value() || 6), this._barSpacingChanged.subscribe(this, this._maxRightOffsetOnChanged), this._widthChanged.subscribe(this, this._maxRightOffsetOnChanged)
				}
				destroy() {
					this._barSpacingChanged.unsubscribeAll(this), this._barSpacingChanged.destroy(), this._widthChanged.unsubscribeAll(this), this._widthChanged.destroy()
				}
				isEmpty() {
					return 0 === this._width || !this.canNormalize()
				}
				canNormalize() {
					return this._points.size() > 0
				}
				update(e, t, i, s) {
					this._visibleBarsInvalidated = !0, i.length > 0 && this._points.merge(e, t, i), this._tickMarks.merge(s), this._correctOffset()
				}
				addTail(e, t, i) {
					this._tickMarks.removeTail(t);
					const s = e.params,
						r = (0, o.ensureDefined)(this._tickMarks.maxIndex) + (i ? 0 : 1);
					for (let e = 0; e < s.marks.length; e++) s.marks[e].index = r + e;
					this._tickMarks.addTail(s.marks), this._points.addTail(s.changes, i);
					const n = this._rightOffset - s.changes.length;
					this._updateRightOffset(n)
				}
				state(e) {
					const t = {
						m_barSpacing: this.barSpacing(),
						m_rightOffset: e ? this._rightOffset : this._defaultRightOffset.value()
					};
					return e && (t.points = this._points.state(),
						t.tickmarks = this._tickMarks.state(), t.width = this._width), t
				}
				restoreState(e, t) {
					if (void 0 === e.m_barSpacing) return void tt.logDebug("restoreState: invalid state");
					if (void 0 === e.m_rightOffset) return void tt.logDebug("restoreState: invalid state");
					let i = e.m_barSpacing;
					const s = e.m_rightOffset < 0 && !t ? this.rightOffsetDefaultValue() : e.m_rightOffset,
						o = s < 0 ? this.rightOffsetDefaultValue() : Math.round(s);
					this._defaultRightOffset.setValue(o), this._rightOffset = s, t && (this._requestedTickmarksCount = 1 / 0, this._endOfData = !0, this._points.restoreState(e.points || null), this._tickMarks.restoreState(e.tickmarks || null), e.width && this._width > 0 && (i *= this._width / e.width)), this._tryToUpdateBarSpacing(this._barSpacing, i), this._correctOffset(), this._rightOffsetChanged.fire(this._rightOffset)
				}
				marks() {
					if (this.isEmpty()) return null;
					const e = this._barSpacing,
						t = 5 * ((this._scalesProperties.childs().fontSize.value() || 0) + 4),
						i = Math.round(t / e),
						s = (0, o.ensureNotNull)(this.visibleBarsStrictRange()),
						r = Math.max(s.firstBar(), s.firstBar() - i),
						n = Math.max(s.lastBar(), s.lastBar() - i),
						a = this._tickMarks.build(e, t),
						l = [];
					for (const e of a) {
						if (!(r <= e.index && e.index <= n)) continue;
						const t = this._tickMarks.indexToTime(e.index);
						null !== t && l.push({
							coord: this.indexToCoordinate(e.index),
							label: this.formatLabel(t, e.span),
							span: e.span,
							major: e.label >= je.DAY_SPAN
						})
					}
					return l
				}
				visibleBarsStrictRange() {
					return this._visibleBarsInvalidated && (this._visibleBarsInvalidated = !1, this._updateVisibleBars()), this._visibleBars.strictRange()
				}
				visibleBarsStrictRangeChanged() {
					return this._visibleBarsChanged
				}
				logicalRangeChanged() {
					return this._logicalRangeChanged
				}
				tickMarks() {
					return this._tickMarks
				}
				points() {
					return this._points
				}
				width() {
					return this._width
				}
				setWidth(e, t) {
					if (!Number.isFinite(e) || e <= 0) return void tt.logWarn(`setWidth: invalid argument: ${e}`);
					if (this._width === e) return;
					if (this._visibleBarsInvalidated = !0, (t || this._options.lockVisibleTimeRangeOnResize) && this._width) {
						const t = this._barSpacing * e / this._width;
						this._tryToUpdateBarSpacing(this._barSpacing, t)
					} else this._width && this.setBarSpacing(this._barSpacing);
					if (null !== this._leftEdgeIndex) {
						if ((0, o.ensureNotNull)(this.visibleBarsStrictRange()).firstBar() <= this._leftEdgeIndex) {
							const t = this._width - e;
							this._rightOffset -= Math.round(t / this._barSpacing) + 1
						}
					}
					this._width = e, this._widthChanged.fire(e);
					const i = this._rightOffset;
					this._correctOffset(), this._rightOffset !== i && this._rightOffsetChanged.fire(this._rightOffset), this._requestMoreData()
				}
				setLeftEdgeFix(e) {
					this._leftEdgeIndex = e;
					const t = this.visibleBarsStrictRange();
					if (null === t) return;
					const i = t.firstBar() - e;
					if (i < 0) {
						const e = this._rightOffset - i - 1;
						this.scrollToOffsetAnimated(e, 500)
					}
				}
				indexToCoordinate(e) {
					if (this.isEmpty()) return 0;
					if (!(0, ve.isInteger)(e)) return 0;
					const t = this.baseIndex() + this._rightOffset - e;
					return this._width - (t + .5) * this._barSpacing - 1
				}
				indexToUserTime(e) {
					return this._tickMarks.indexToTime(e)
				}
				timePointToIndex(e) {
					return this._points.indexOf(e, !0)
				}
				indexToTimePoint(e) {
					return this._points.valueAt(e)
				}
				timeToCoordinate(e) {
					const t = this._points.closestIndexLeft(e);
					if (null === t) return null;
					const i = (0,
							o.ensureNotNull)(this._points.valueAt(t)),
						s = this.indexToCoordinate(t);
					if (s <= 0 || s >= this._width) return null;
					const r = this.barSpacing(),
						n = this.baseIndex(),
						a = s + (e - i) / ((0, o.ensureNotNull)(this._points.valueAt(n)) - (0, o.ensureNotNull)(this._points.valueAt(n - 1))) * r + 1;
					return a <= 0 || a >= this._width ? null : a
				}
				barIndexesToCoordinates(e) {
					const t = this.baseIndex();
					for (const i of e) {
						const e = i.time,
							s = t + this._rightOffset - e,
							o = this._width - (s + .5) * this._barSpacing - 1;
						i.time = o
					}
				}
				timedValuesToCoordinates(e, t) {
					var i, s;
					const o = this.baseIndex() + this._rightOffset,
						r = this._width - o * this._barSpacing - .5 * this._barSpacing - 1,
						n = null !== (i = null == t ? void 0 : t.startItemIndex) && void 0 !== i ? i : 0,
						a = null !== (s = null == t ? void 0 : t.endItemIndex) && void 0 !== s ? s : e.length;
					for (let t = n; t < a; t++) {
						const i = e[t];
						i.x = r + i.x * this._barSpacing
					}
				}
				indexesToCoordinates(e, t) {
					if (this.isEmpty()) return;
					void 0 === t && (t = e.length);
					const i = this.baseIndex() + this._rightOffset,
						s = this._width - i * this._barSpacing - .5 * this._barSpacing - 1,
						o = this._barSpacing,
						r = e;
					for (let i = 0; i < t; ++i)(0, ve.isInteger)(e[i]) ? r[i] = s + e[i] * o : r[i] = 0
				}
				rightOffsetForTimePoint(e) {
					const t = this.timeToCoordinate(e);
					return null === t ? null : this._rightOffsetForCoordinate(t)
				}
				scrollToRealtime(e, t) {
					let i = this._defaultRightOffset.value();
					i < 0 && (i = this.rightOffsetDefaultValue());
					const s = () => {
						void 0 !== t && t(), this._requestMoreData()
					};
					if (e) {
						const e = this._rightOffset,
							t = this.maxRightOffset();
						t > 0 && i > t && (i = t);
						const o = this._model;
						(0, Be.doAnimate)({
							from: e,
							to: i,
							duration: 1e3,
							easing: Ne.easingFunc.easeInOutQuint,
							onComplete: s,
							onStep: (e, t) => {
								this._visibleBarsInvalidated = !0, this._updateRightOffset(t), o.recalculateAllPanes((0, F.viewportChangeEvent)()), o.lightUpdate(), o.recalcVisibleRangeStudies()
							}
						})
					} else this._visibleBarsInvalidated = !0, this._updateRightOffset(i), s()
				}
				scrollToFirstBar() {
					this._model.gotoTime(new Date("1800-01-01").getTime())
				}
				scrollToOffsetAnimated(e, t) {
					if (!isFinite(e)) throw new RangeError("offset is required and must be finite number");
					const i = void 0 === t ? 400 : t;
					if (!isFinite(i) || i <= 0) throw new RangeError("animationDuration (optional) must be finite positive number");
					const s = this._rightOffset,
						o = Date.now(),
						r = () => {
							this._visibleBarsInvalidated = !0;
							const t = (Date.now() - o) / i;
							if (t >= 1) return this._updateRightOffset(e), this._visibleBarsInvalidated = !0, this._model.recalculateAllPanes((0, F.viewportChangeEvent)()), void this._model.lightUpdate();
							const n = s + (e - s) * t;
							this._updateRightOffset(n), this._model.recalculateAllPanes((0, F.viewportChangeEvent)()), setTimeout(r, 20)
						};
					r()
				}
				defaultRightOffset() {
					return this._defaultRightOffset
				}
				rightOffsetDefaultValue() {
					return 10
				}
				barSpacing() {
					return this._barSpacing
				}
				setBarSpacing(e) {
					Number.isFinite(e) ? (e = this.getValidBarSpacing(e), this._tryToUpdateBarSpacing(this._barSpacing, e) && (this._correctOffset(), this._options.preserveBarSpacing && ((0, M.saveDefaultProperties)(!0), this._scalesProperties.childs().barSpacing.setValue(this._barSpacing), (0, M.saveDefaultProperties)(!1)), this._model.recalculateAllPanes((0, F.viewportChangeEvent)()), this._model.lightUpdate())) : tt.logWarn(`setBarSpacing: invalid argument: ${e}`)
				}
				barSpacingChanged() {
					return this._barSpacingChanged
				}
				getValidBarSpacing(e) {
					return null == e && (e = this.barSpacing()), e < this.minBarSpacing() ? this.minBarSpacing() : e > this.maxBarSpacing() ? this.maxBarSpacing() : e
				}
				isValidBarSpacing(e) {
					return e >= this.minBarSpacing() && e <= this.maxBarSpacing()
				}
				preserveBarSpacing() {
					return this._options.preserveBarSpacing
				}
				normalizeBarIndex(e) {
					let t = 0,
						i = 0;
					const s = this.baseIndex(),
						r = (0, o.ensureNotNull)(this._points.firstIndex());
					return e < r ? (t = (0, o.ensureNotNull)(this._points.valueAt(r)), i = e - r) : e > s ? (t = (0, o.ensureNotNull)(this._points.valueAt(s)), i = e - s) : (t = (0, o.ensureNotNull)(this._points.valueAt(e)), i = 0), {
						time_t: t,
						offset: i
					}
				}
				denormalizeTimePoint(e) {
					const t = this._points.indexOf(e.time_t, !1);
					if (null !== t) return t + e.offset
				}
				rightOffset() {
					return this._rightOffset
				}
				rightOffsetChanged() {
					return this._rightOffsetChanged
				}
				minRightOffset() {
					const e = this.points().firstIndex(),
						t = this._baseIndex;
					if (null === e || null === t) return null;
					if (null !== this._leftEdgeIndex) {
						const e = this.width() / this._barSpacing;
						return this._leftEdgeIndex - t + e - 1
					}
					return e - t - 1 + et
				}
				maxRightOffset() {
					return this.width() / this._barSpacing - et
				}
				maxRightOffsetChanged() {
					return this._maxRightOffsetChanged
				}
				onReset() {
					return this._resetDelegate
				}
				scrollStartPoint() {
					return this._scrollStartPoint
				}
				baseIndex() {
					return this._baseIndex || 0
				}
				zoom(e, t, i) {
					if (!Number.isFinite(e) || !Number.isFinite(t)) return void tt.logWarn(`zoom: invalid arguments: ${e}, ${t}, ${i}`);
					const s = this.coordinateToIndex(e),
						o = this.barSpacing(),
						r = o + t * (o / 10);
					this.setBarSpacing(r);
					(void 0 !== i ? !i : this._options.rightBarStaysOnScroll) || this.setRightOffset(this.rightOffset() - .5 + (s - this._coordinateToFloatIndex(e))), this._requestMoreData()
				}
				zoomToBarsRange(e, t) {
					if (null !== this._leftEdgeIndex && (e = Math.max(e, this._leftEdgeIndex)), t <= e) return;
					const i = this.baseIndex(),
						s = this._rightOffset;
					this._rightOffset = t - i;
					const o = Math.max(t - e + 1, et);
					this.setBarSpacing(this.width() / o), this._visibleBarsInvalidated = !0, this._correctOffset(), this._rightOffset !== s && this._rightOffsetChanged.fire(this._rightOffset), this._requestMoreData()
				}
				coordinateToIndex(e) {
					return Math.ceil(this._coordinateToFloatIndex(e))
				}
				coordinateToVisibleIndex(e) {
					let t;
					if (0 === e) {
						const e = this._coordinateToFloatIndex(-1);
						t = Math.floor(e) + 1
					} else t = this.coordinateToIndex(e);
					const i = this.visibleBarsStrictRange();
					return null === i || i.contains(t) || (t = Math.min(Math.max(i.firstBar(), t), i.lastBar())), t
				}
				canZoomIn() {
					return this.barSpacing() < this.maxBarSpacing()
				}
				canZoomOut() {
					return this.barSpacing() > this._options.minBarSpacing
				}
				minBarSpacing() {
					return this._options.minBarSpacing
				}
				maxBarSpacing() {
					const e = this.width();
					return Je ? e : e / et
				}
				minVisibleBarCount() {
					return et
				}
				resetRightOffset() {
					this.setRightOffset(this._defaultRightOffset.value())
				}
				reset() {
					this._visibleBarsInvalidated = !0, this._points = new ze, this._scrollStartPoint = null, this._scaleStartPoint = null, this._clearCommonTransitionsStartState(), this._tickMarks.reset(), this._leftEdgeIndex = null, this._resetDelegate.fire(), this.disconnect()
				}
				disconnect() {
					this._requestingMoreData = !1, this._requestedTickmarksCount = 0, this._endOfData = !1
				}
				setBaseIndex(e) {
					Number.isFinite(e) ? (this._visibleBarsInvalidated = !0, this._baseIndex = e, this._correctOffset()) : tt.logDebug(`setBaseIndex: invalid argument: ${e}`)
				}
				resetBaseIndex() {
					this._visibleBarsInvalidated = !0, this._baseIndex = null
				}
				setRightOffset(e) {
					Number.isFinite(e) ? (this._visibleBarsInvalidated = !0, this._updateRightOffset(e)) : tt.logWarn(`setRightOffset: invalid argument: ${e}`)
				}
				correctBarSpacing() {
					this.isEmpty() || this.points().size() < this.width() / this.barSpacing() && (this.setRightOffset(this._defaultRightOffset.value()), this.setBarSpacing(this.width() / (this.points().size() + this.rightOffset())))
				}
				logicalRange() {
					return this._visibleBarsInvalidated && (this._visibleBarsInvalidated = !1, this._updateVisibleBars()), this._visibleBars.logicalRange()
				}
				restoreDefault() {
					this._visibleBarsInvalidated = !0, this._lockBarsAndLogicalRangeEvents = !0;
					const e = this._visibleBars;
					this.setBarSpacing(6), this.resetRightOffset(), this._lockBarsAndLogicalRangeEvents = !1, this._fireVisibleBarsChangedIfRequired(e, this._visibleBars), this._requestMoreData()
				}
				startScale(e) {
					this._scrollStartPoint && this.endScroll(), null === this._scaleStartPoint && null === this._commonTransitionStartState && (this.isEmpty() || (this._scaleStartPoint = e, this._saveCommonTransitionsStartState()))
				}
				scaleTo(e) {
					if (null === this._commonTransitionStartState) return;
					const t = (0, Oe.clamp)(this._width - e, 0, this._width),
						i = (0, Oe.clamp)(this._width - (0, o.ensureNotNull)(this._scaleStartPoint), 0, this._width);
					0 !== t && 0 !== i && this.setBarSpacing(this._commonTransitionStartState.barSpacing * t / i)
				}
				endScale() {
					null !== this._scaleStartPoint && (this._scaleStartPoint = null, this._clearCommonTransitionsStartState(), this._requestMoreData())
				}
				startScroll(e) {
					null === this._scrollStartPoint && null === this._commonTransitionStartState && (this.isEmpty() || (this._scrollStartPoint = e, this._saveCommonTransitionsStartState()))
				}
				scrollTo(e) {
					if (this._visibleBarsInvalidated = !0, null === this._scrollStartPoint) return;
					const t = (this._scrollStartPoint - e) / this.barSpacing(),
						i = (0, o.ensureNotNull)(this._commonTransitionStartState).rightOffset + t;
					this._updateRightOffset(i), this._onScroll.fire()
				}
				endScroll() {
					null !== this._scrollStartPoint && (this._scrollStartPoint = null, this._clearCommonTransitionsStartState(), this._requestMoreData())
				}
				formatLabel(e, t) {
					const i = "24-hours" === Xe.timeHoursFormatProperty.value() ? t.toString() : `${t}_ampm`;
					let s = this._formattedBySpan.get(i);
					return void 0 === s && (s = new qe((e => this.formatLabelImpl(e, t))), this._formattedBySpan.set(i, s)), s.format(new Date(e))
				}
				formatLabelImpl(e, t) {
					if (!(e && e instanceof Date)) return "incorrect time";
					const i = function(e, t) {
						if (e < je.MINUTE_SPAN && t) return "TimeWithSeconds";
						if (e < je.DAY_SPAN && t) return "Time";
						if (e < je.WEEK_SPAN) return "DayOfMonth";
						if (e < je.MONTH_SPAN) return "DayOfMonth";
						if (e < je.YEAR_SPAN) return "Month";
						return "Year"
					}(t, !this._model.mainSeries().isDWM());
					return null !== Ke.customFormatters.tickMarkFormatter ? Ke.customFormatters.tickMarkFormatter(e, i) : function(e, t) {
						switch (t) {
							case "TimeWithSeconds":
							case "Time":
								const i = "TimeWithSeconds" === t ? (0, $e.getHourMinuteSecondFormat)() : (0, $e.getHourMinuteFormat)();
								return new Ze.TimeFormatter(i).format(e);
							case "DayOfMonth":
								return e.getUTCDate().toString();
							case "Month":
								return (void 0 === Ye && (Ye = [(0, l.t)("Jan"), (0, l.t)("Feb"), (0, l.t)("Mar"), (0, l.t)("Apr"), (0, l.t)("May", {
									context: "short"
								}), (0, l.t)("Jun"), (0, l.t)("Jul"), (0, l.t)("Aug"), (0, l.t)("Sep"), (0, l.t)("Oct"), (0, l.t)("Nov"), (0, l.t)("Dec")]), Ye)[e.getUTCMonth()];
							case "Year":
								return e.getUTCFullYear().toString()
						}
					}(e, i)
				}
				onScroll() {
					return this._onScroll
				}
				invalidateVisibleBars() {
					this._visibleBarsInvalidated = !0
				}
				onTimeScaleCompleted(e) {
					if (this._requestingMoreData = !1, this._endOfData = e, R.enabled("fix_left_edge") && this._endOfData) {
						const e = this._points.firstIndex();
						null !== e && this.setLeftEdgeFix(e)
					}
					this._requestMoreData()
				}
				requestMoreHistoryPoints(e) {
					this._model.mainSeries().requestMoreData(e)
				}
				_requestMoreData() {
					this._requestFutureTickmarksIfNeeded(), this._requestHistoryPointsIfNeeded()
				}
				_requestFutureTickmarksIfNeeded() {
					this._model.mainSeries().requestMoreData()
				}
				_requestHistoryPointsIfNeeded() {
					this._model.mainSeries().requestMoreData()
				}
				_requestHistoryPoints(e) {
					this._model.chartApi().isConnected().value() && (this._requestingMoreData ? tt.logNormal("Skipping loading more data due active loading") : (this._requestingMoreData = !0, this._model.chartApi().requestMoreData(e)))
				}
				_updateVisibleBars() {
					const e = this._visibleBars;
					if (this.isEmpty()) return void(this._visibleBars.isValid() && (this._visibleBars = He.invalid(), this._visibleBarsChanged.fire(null, e.strictRange()), this._logicalRangeChanged.fire(null, e.logicalRange())));
					const t = this.baseIndex(),
						i = this.width() / this._barSpacing,
						s = this._rightOffset + t,
						o = s - i + 1;
					Number.isFinite(o) && Number.isFinite(s) ? (this._visibleBars = new He(new We.LogicalRange(o, s), this._model.mainSeries().style()), this._lockBarsAndLogicalRangeEvents || this._fireVisibleBarsChangedIfRequired(e, this._visibleBars)) : tt.logWarn(`updateVisibleBars error: baseIndex: ${t}, barSpacing: ${this._barSpacing}, rightOffset: ${this._rightOffset}`)
				}
				_fireVisibleBarsChangedIfRequired(e, t) {
					Ve.BarsRange.compare(e.strictRange(), t.strictRange()) || this._visibleBarsChanged.fire(t.strictRange(), e.strictRange()), We.LogicalRange.compare(e.logicalRange(), t.logicalRange()) || this._logicalRangeChanged.fire(t.logicalRange(), e.logicalRange())
				}
				_rightOffsetForCoordinate(e) {
					return (this._width - 1 - e) / this._barSpacing
				}
				_correctOffset() {
					const e = this.maxRightOffset();
					this._rightOffset > e && (this._rightOffset = e, this._visibleBarsInvalidated = !0);
					const t = this.minRightOffset();
					null !== t && this._rightOffset < t && (this._rightOffset = t, this._visibleBarsInvalidated = !0)
				}
				_tryToUpdateBarSpacing(e, t) {
					return e !== t && (this._visibleBarsInvalidated = !0, this._barSpacing = t, this._barSpacingChanged.fire(t), !0)
				}
				_coordinateToFloatIndex(e) {
					const t = this._rightOffsetForCoordinate(e),
						i = this.baseIndex() + this.rightOffset() - t;
					return Math.round(1e6 * i) / 1e6
				}
				_saveCommonTransitionsStartState() {
					this._commonTransitionStartState = {
						barSpacing: this.barSpacing(),
						rightOffset: this.rightOffset()
					}
				}
				_clearCommonTransitionsStartState() {
					this._commonTransitionStartState = null
				}
				_maxRightOffsetOnChanged() {
					this._maxRightOffsetChanged.fire(this.maxRightOffset())
				}
				_updateRightOffset(e) {
					const t = this._rightOffset;
					this._rightOffset = e, this._correctOffset(), this._rightOffset !== t && this._rightOffsetChanged.fire(this._rightOffset), this._model.recalculateAllPanes((0, F.viewportChangeEvent)()), this._model.lightUpdate()
				}
			}
			var st = i(715303),
				ot = i(504122),
				rt = i(940448),
				nt = i(19851);
			class at {
				constructor(e) {
					this._onChanged = new(q()), this._groups = [], this._groups = e || [], this._groups.forEach((e => {
						e.onChanged().subscribe(null, (t => this._onChanged.fire(e.id, t)))
					}))
				}
				groups() {
					return this._groups.filter((e => e.isActualSymbol()))
				}
				groupsForAllSymbols() {
					return this._groups
				}
				createGroup(e, t, i) {
					t = t || this._generateNextName();
					const s = new nt.LineToolsGroup(e, t, i);
					this._groups.push(s), s.onChanged().subscribe(null, (e => this._onChanged.fire(s.id, e)));
					const o = {
						visibilityChanged: !1,
						lockedChanged: !1,
						titleChanged: !1,
						isActualIntervalChanged: !1,
						affectedLineTools: e.map((e => e.id()))
					};
					return this._onChanged.fire(s.id, o), s
				}
				addGroup(e) {
					this._groups.push(e), e.onChanged().subscribe(null, (t => this._onChanged.fire(e.id, t))), this._onChanged.fire(e.id)
				}
				removeGroup(e) {
					const t = this._groups.findIndex((t => t.id === e.id));
					this._groups.splice(t, 1), this._onChanged.fire(e.id)
				}
				groupForId(e) {
					return this._groups.find((t => t.id === e)) || null
				}
				groupForLineTool(e) {
					return this._groups.find((t => t.containsLineTool(e))) || null
				}
				removeLineTools(e) {
					this._groups.forEach((t => {
						const i = e.filter(t.containsLineTool.bind(t));
						i.length && t.excludeLineTools(i)
					}));
					this._groups.filter((e => 0 === e.lineTools().length)).forEach((e => this.removeGroup(e)))
				}
				state(e) {
					return {
						groups: (e ? this._groups.filter((e => e.isActualSymbol())) : this._groups).map((e => e.state()))
					}
				}
				onChanged() {
					return this._onChanged
				}
				fireChangedAll() {
					this._groups.forEach((e => {
						this._onChanged.fire(e.id)
					}))
				}
				static fromState(e, t) {
					const i = [];
					for (const s of t.groups) {
						const t = nt.LineToolsGroup.fromState(e, s);
						null !== t && i.push(t)
					}
					return new at(i)
				}
				_generateNextName() {
					const e = new Set(this.groups().map((e => e.name())));
					for (let t = 1;; t++) {
						const i = `Group ${t}`,
							s = `Group_${t}`;
						if (!e.has(i) && !e.has(s)) return i
					}
				}
			}
			var lt = i(393987),
				ct = i.n(lt),
				ht = i(566190);
			let dt = null;

			function ut(e) {
				return Boolean(e.symbolInfo.timezone) && Boolean(e.symbolInfo.session)
			}
			class _t {
				constructor(e, t) {
					var i, s;
					this._sourceTargetBarBuilder = null, this._cache = new Map, this._source = e, this._sourceSession = ht.SessionInfo.fromState(e.session), this._target = t, this._targetSession = ht.SessionInfo.fromState(t.session), this._isResolutionTheSame = P.Interval.isEqual(e.resolution, t.resolution), this._isSessionTheSame = (i = e.symbolInfo, s = t.symbolInfo, i.timezone === s.timezone && i.session === s.session && i.session_holidays === s.session_holidays && i.corrections === s.corrections), this._shouldCorrectTradingDay = P.Interval.isDWM(e.resolution) && !this._isSessionTheSame
				}
				sourceTimeToTargetTime(e) {
					if (this._isSessionTheSame && this._isResolutionTheSame) return e;
					if (!ut(this._source) || !ut(this._target)) return e;
					let t = this._cache.get(e);
					if (void 0 === t) {
						let i = 1e3 * e;
						if (this._shouldCorrectTradingDay) {
							let e = ct().utc_to_cal(this._sourceSession.timezone, i);
							e = this._sourceSession.spec.correctTradingDay(e);
							const t = new Date(e);
							ct().set_hms(t, 0, 0, 0, 0, this._sourceSession.timezone), i = t.valueOf()
						}
						const s = this._sourceTargetBuilder();
						s.moveTo(i);
						const o = s.indexOfBar(i);
						t = s.startOfBar(Math.max(0, o)) / 1e3, this._cache.set(e, t)
					}
					return t
				}
				_sourceTargetBuilder() {
					if (null === this._sourceTargetBarBuilder) {
						const e = this._isSessionTheSame ? this._targetSession : (null === dt && (dt = new ht.SessionInfo("Etc/UTC", "24x7")), dt);
						this._sourceTargetBarBuilder = (0, ht.newBarBuilder)(this._target.resolution, this._targetSession, e)
					}
					return this._sourceTargetBarBuilder
				}
			}
			var mt = i(308170),
				pt = i(314802),
				gt = i(919346);
			const St = "#000000";
			var vt = i(125226);
			var ft = i(769393);
			const bt = (0, $.getLogger)("Chart.ESDWatcher"),
				yt = (0, vt.isFeatureEnabled)("show_continuous_contract_switches"),
				Ct = new Map([
					["esdShowDividends", "Dividends@tv-basicstudies"],
					["esdShowSplits", "Splits@tv-basicstudies"],
					["esdShowEarnings", "Earnings@tv-basicstudies"]
				]);
			yt && Ct.set("showContinuousContractSwitches", "BarSetContinuousRollDates@tv-basicstudies");
			class wt {
				constructor(e) {
					this._cancellationTokens = new Map, this._model = e, this._subscribeOnProperties(), this.syncESDStudies()
				}
				destroy() {
					Ct.forEach(((e, t) => {
						this._model.mainSeries().properties().childs()[t].unsubscribeAll(this), this._cancelPendingInsertion(e), this._removeAllStudies(e)
					}))
				}
				syncESDStudies() {
					bt.logNormal("Force syncing studies"), Ct.forEach(((e, t) => {
						this._cancelPendingInsertion(e), this._removeAllStudies(e);
						this._model.mainSeries().properties().childs()[t].value() && this._insertStudy(e)
					}))
				}
				_subscribeOnProperties() {
					Ct.forEach(((e, t) => {
						this._model.mainSeries().properties().childs()[t].subscribe(this, (i => {
							const s = i.value();
							bt.logNormal(`${t} has been changed to ${s}`);
							const o = this._getStudy(e);
							s && null === o ? this._insertStudy(e) : s || (this._cancelPendingInsertion(e), null !== o && (this._model.removeSource(o), bt.logNormal(`${e} has been removed`)))
						}))
					}))
				}
				_getStudy(e) {
					return this._model.allStudies().find((t => t.metaInfo().id === e)) || null
				}
				_insertStudy(e) {
					this._cancelPendingInsertion(e);
					const t = this._model.createStudyInserter({
						type: "java",
						studyId: e
					});
					t.setForceOverlay(!0);
					const i = function() {
						const e = {
							cancelled: !1,
							cancel: () => {
								e.cancelled = !0
							}
						};
						return e
					}();
					this._cancellationTokens.set(e, i), bt.logNormal(`Inserting ${e}`), t.insert(void 0, i).then((() => {
						bt.logNormal(`Inserting ${e} is succeeded`)
					})).catch((e => {
						e !== ft.InsertionErrorCode.Cancelled && bt.logError("Error: " + e)
					})).then((() => {
						this._cancellationTokens.get(e) === i && this._cancellationTokens.delete(e)
					}))
				}
				_removeAllStudies(e) {
					this._model.allStudies().filter((t => t.metaInfo().id === e)).forEach((e => this._model.removeSource(e)))
				}
				_cancelPendingInsertion(e) {
					const t = this._cancellationTokens.get(e);
					void 0 !== t && (t.cancel(), this._cancellationTokens.delete(e), bt.logNormal(`Inserting ${e} has been cancelled`))
				}
			}
			var Tt = i(295786);
			class Pt {
				constructor(e) {
					this._alertLabelsBySource = new Map, this._alertsByAlertSeriesId = new Map, this._alertSeriesIdByAlert = new Map, this._alertLabelsOwnerSourcesByAlert = new Map, this._chartModel = e
				}
				destroy() {
					this.removeAllAlertLabels()
				}
				removeAllAlertLabels() {
					const e = this._alertLabelsBySource;
					this._alertLabelsBySource = new Map,
						this._alertsByAlertSeriesId.clear(), this._alertSeriesIdByAlert.clear(), this._alertLabelsOwnerSourcesByAlert.clear(), e.forEach((e => {
							e.forEach((e => this._chartModel.removeSource(e)))
						}))
				}
				removeSourceAlertLabels(e) {
					for (const t of this._getAlertLabelsBySource(e)) this.removeAlertLabel(t)
				}
				syncSourceAlertLabels(e) {
					if (!(0, se.isPriceDataSource)(e) || !e.hasStateForAlert()) return;
					for (const t of this._getAlertLabelsBySource(e)) t.alertOwnerSource().idForAlert() === t.alertSeriesId() || t.alert().isOHLC() || this.removeAlertLabel(t);
					const t = this._alertsByAlertSeriesId.get(e.idForAlert()),
						i = this._getAlertLabelsBySource(e);
					void 0 !== t && t.forEach((e => {
						i.some((t => t.alert() === e)) || this._updateAlertLabelsByAlert(e, (0, o.ensureDefined)(this._alertSeriesIdByAlert.get(e)))
					}));
					const s = (0, o.ensureNotNull)(this._chartModel.paneForSource(e));
					for (const t of this._getAlertLabelsBySource(e)) {
						const i = this._chartModel.paneForSource(t);
						i !== s ? (null !== i && i.removeDataSource(t), s.addDataSource(t, (0, o.ensureNotNull)(e.priceScale()), !1)) : e.priceScale() !== t.priceScale() && s.move(t, (0, o.ensureNotNull)(e.priceScale()))
					}
				}
				detachSourceAlertLabels(e) {
					for (const t of this._getAlertLabelsBySource(e)) this._chartModel.detachSource(t)
				}
				removeAlertLabel(e) {
					const t = e.alertOwnerSource(),
						i = this._alertLabelsBySource.get(t);
					void 0 !== i && (i.delete(e), 0 === i.size && this._alertLabelsBySource.delete(t));
					const s = e.alert(),
						o = this._alertLabelsOwnerSourcesByAlert.get(s);
					void 0 !== o && (o.delete(t), 0 === o.size && this._alertLabelsOwnerSourcesByAlert.delete(s)), this._chartModel.removeSource(e)
				}
				addAlert(e, t) {
					(0, o.assert)(!this._alertSeriesIdByAlert.has(e), "Alert is already added on the chart"), this._alertSeriesIdByAlert.set(e, t);
					let i = this._alertsByAlertSeriesId.get(t);
					void 0 === i && (i = new Set, this._alertsByAlertSeriesId.set(t, i)), i.add(e), this._updateAlertLabelsByAlert(e, t)
				}
				removeAlert(e) {
					const t = this._alertLabelsOwnerSourcesByAlert.get(e);
					void 0 !== t && t.forEach((t => {
						const i = this._alertLabelsBySource.get(t);
						void 0 !== i && i.forEach((t => {
							t.alert() === e && this.removeAlertLabel(t)
						}))
					}));
					const i = (0, o.ensureDefined)(this._alertSeriesIdByAlert.get(e));
					this._alertSeriesIdByAlert.delete(e);
					const s = this._alertsByAlertSeriesId.get(i);
					void 0 !== s && s.delete(e)
				}
				_findPanes(e) {
					const t = [];
					for (const i of this._chartModel.panes()) {
						const s = i.priceDataSources(),
							o = new Set;
						for (const t of s) t.hasStateForAlert() && t.idForAlert() === e && o.add(t);
						o.size > 0 && t.push({
							pane: i,
							sources: o
						})
					}
					return t
				}
				_addLabelToPane(e, t, i, s) {
					const o = new v.AlertLabel(this._chartModel, e, s, Tt.invokeAlertEditor);
					i.addDataSource(o, s.priceScale(), !1);
					let r = this._alertLabelsBySource.get(s);
					void 0 === r && (r = new Set, this._alertLabelsBySource.set(s, r)), r.add(o);
					let n = this._alertLabelsOwnerSourcesByAlert.get(e);
					void 0 === n && (n = new Set, this._alertLabelsOwnerSourcesByAlert.set(e, n)), n.add(s)
				}
				_updateAlertLabelsByAlert(e, t) {
					const i = this._findPanes(t);
					if (i.length)
						for (const s of i) s.sources.forEach((i => this._addLabelToPane(e, t, s.pane, i)));
					else if (e.isOHLC()) {
						const i = this._chartModel.mainSeries();
						this._addLabelToPane(e, t, (0, o.ensureNotNull)(this._chartModel.paneForSource(i)), i)
					}
					this._chartModel.lightUpdate()
				}
				_getAlertLabelsBySource(e) {
					const t = this._alertLabelsBySource.get(e);
					return void 0 === t ? [] : Array.from(t)
				}
			}
			var Mt = i(3452),
				xt = i(629588),
				It = i(560507),
				At = i(833813),
				kt = i(721386),
				Lt = i(483306),
				Et = i(492747);

			function Dt(e, t) {
				return e.code < t.code ? -1 : e.code > t.code ? 1 : 0
			}
			class Nt {
				constructor(e) {
					this._convertibleItems = e, this._idsToItems = new Map;
					for (const t of e) this._idsToItems.set(t.id, t)
				}
				convertible(e) {
					return void 0 !== this._idsToItems.get(e)
				}
				item(e) {
					var t;
					return null !== (t = this._idsToItems.get(e)) && void 0 !== t ? t : null
				}
				size() {
					return this._convertibleItems.length
				}
				filterConvertible(e, t) {
					const i = this._convertibleItems.filter(function(e, t) {
						return i => !e.has(i.id) && t(i.id)
					}(e, t));
					return i.sort(Dt), i
				}
			}
			class Bt {
				constructor(e) {
					this._allGroups = new Set, this._idToName = new Map, this._idToDescription = new Map, this._groupedUnitIds = new Map, this._groupedUnits = new Map, this._groupById = new Map, this._size = 0, this._units = e;
					for (const t in e)
						if (e.hasOwnProperty(t)) {
							this._allGroups.add(t), this._groupedUnitIds.set(t, new Set(e[t].map((e => e.id)))), this._groupedUnits.set(t, e[t]);
							for (const i of e[t]) this._size++, this._idToName.set(i.id, i.name), this._idToDescription.set(i.id, i.description), this._groupById.set(i.id, t)
						}
				}
				unitsChanged(e) {
					return this._units !== e
				}
				size() {
					return this._size
				}
				name(e) {
					return this._idToName.get(e) || e
				}
				description(e) {
					return this._idToDescription.get(e) || e
				}
				unitGroupById(e) {
					return this._groupById.get(e) || null
				}
				allGroups() {
					return new Set(this._allGroups)
				}
				unitsByGroups(e) {
					const t = [];
					return e.forEach((e => {
						const i = this._groupedUnits.get(e);
						void 0 !== i && t.push({
							name: e,
							units: i
						})
					})), t
				}
				convertible(e, t) {
					for (const i of t) {
						const t = this._groupedUnitIds.get(i);
						if (void 0 !== t && t.has(e)) return !0
					}
					return !1
				}
			}
			var Ot = i(793751);
			class Rt {
				constructor(e) {
					this._source = null, this._sourcePane = null, this._currentToolSupportsPhantomMode = !1, this._model = e
				}
				destroy() {
					this._source = null, this._sourcePane = null
				}
				source() {
					return this._source
				}
				onToolChanged() {
					this._removeSource();
					const e = this._model.currentTool();
					this._currentToolSupportsPhantomMode = (0, f.isLineToolName)(e) && (0, f.supportsPhantomMode)(e)
				}
				onCursorPositionUpdated() {
					if (!this._currentToolSupportsPhantomMode) return;
					const e = this._model.crossHairSource();
					if (this._sourcePane !== e.pane && this._removeSource(), null === e.pane || !(0, Ot.isNumber)(e.index) || !(0, Ot.isNumber)(e.price)) return void this._removeSource();
					const t = {
						index: e.index,
						price: e.price
					};
					null !== this._source ? this._source.setPoint(0, t) : (this._source = this._model.createLineTool(e.pane, t, this._model.currentTool(), void 0, null), this._sourcePane = e.pane)
				}
				_removeSource() {
					null !== this._source && (this._model.removeSource(this._source), this._source = null, this._sourcePane = null)
				}
			}
			var Vt = i(752280),
				Wt = i(285055),
				Ft = i(359266),
				zt = i(298438);

			function Ut(e, t) {
				const i = e.bars().valueAt(t);
				if (null === i) return;
				let s;
				if (null !== e.priceSource()) s = [e.barFunction()(i)];
				else if (12 === e.style()) s = [i[2], i[3]];
				else s = [i[1], i[2], i[3], i[4]];
				return s
			}
			class Ht {
				constructor() {
					this._lastValue = null
				}
				align(e, t, i) {
					this._lastValue = null;
					let s = e;
					if (!(0, zt.magnetEnabled)().value()) return s;
					const r = i.mainDataSource();
					if (null === r) return s;
					const n = r.model().mainSeries();
					if (r !== n) return s;
					const a = n.priceScale();
					if (a.isEmpty()) return s;
					const l = Ut(n, t);
					if (!l) return s;
					const c = (0, o.ensure)(n.firstValue()),
						h = l.map((e => ({
							y: a.priceToCoordinate(e, c),
							price: e
						}))),
						d = a.priceToCoordinate(e, c);
					h.sort(((e, t) => Math.abs(e.y - d) - Math.abs(t.y - d)));
					const u = h[0];
					return ((0, zt.magnetMode)().value() === Ft.MagnetMode.StrongMagnet || Math.abs(u.y - d) < 50) && (s = u.price, this._lastValue = s), s
				}
				lastValue() {
					return this._lastValue
				}
				resetLastValue() {
					this._lastValue = null
				}
			}
			var Gt = i(294766),
				jt = i(62949),
				qt = i(72461),
				Kt = i(164149);
			class Yt {
				constructor() {
					this._data = null
				}
				setData(e) {
					this._data = e
				}
				draw(e, t) {
					if (null === this._data) return;
					const i = t.pixelRatio,
						s = Math.max(1, Math.floor(i));
					e.lineWidth = s;
					const o = Math.ceil(this._data.h * i),
						r = Math.ceil(this._data.w * i);
					if (e.save(), e.lineCap = "butt", this._data.vertLinesVisible) {
						e.strokeStyle = this._data.vertLinesColor, (0, qt.setLineStyle)(e, this._data.vertLineStyle);
						for (const t of this._data.timeMarks) {
							const s = Math.round(t.coord * i);
							(0, Kt.drawVerticalLine)(e, s, 0, o)
						}
					}
					if (this._data.horzLinesVisible) {
						e.strokeStyle = this._data.horzLinesColor, (0, qt.setLineStyle)(e, this._data.horzLineStyle);
						for (const t of this._data.priceMarks) {
							const s = Math.round(t.coord * i);
							(0, Kt.drawHorizontalLine)(e, s, 0, r)
						}
					}
					e.restore()
				}
				hitTest(e) {
					return null
				}
			}
			class Xt {
				constructor(e) {
					this._renderer = new Yt, this._pane = e
				}
				update() {}
				renderer() {
					const e = this._pane.defaultPriceScale(),
						t = this._pane.model().timeScale();
					if (e.isEmpty() || t.isEmpty()) return null;
					const i = this._pane.model().properties().childs().paneProperties.childs(),
						s = t.marks(),
						o = {
							horzLinesVisible: !0,
							vertLinesVisible: !0,
							horzLinesColor: i.horzGridProperties.childs().color.value(),
							vertLinesColor: i.vertGridProperties.childs().color.value(),
							horzLineStyle: i.horzGridProperties.childs().style.value(),
							vertLineStyle: i.vertGridProperties.childs().style.value(),
							priceMarks: e.marks(),
							timeMarks: null !== s ? s : [],
							w: this._pane.width(),
							h: this._pane.height()
						};
					return this._renderer.setData(o), this._renderer
				}
			}
			class Zt extends jt.DataSource {
				id() {
					return "grid"
				}
				paneViews(e) {
					return [new Xt(e)]
				}
			}
			var $t = i(498424);
			class Qt extends $t.PriceAxisView {
				constructor(e, t, i) {
					super(), this._source = e, this._priceScale = t, this._priceProvider = i, this._properties = e.model().properties().childs().scalesProperties
				}
				setHitTestData(e) {
					this._hitTestData = e
				}
				additionalPadding(e) {
					return 0
				}
				_updateRendererData(e, t, i) {
					e.visible = !1, t.visible = !1;
					const s = this._priceScale,
						o = s.mainSource(),
						r = null !== o ? o.firstValue() : null;
					if (!this._isVisible() || s.isEmpty() || null === r) return;
					const n = this._priceProvider(s);
					if (null === n) return;
					i.background = this._bgColor(), i.textColor = this.generateTextColor(i.background);
					const a = this.additionalPadding(s.fontSize());
					i.additionalPaddingTop = a, i.additionalPaddingBottom = a, i.coordinate = s.priceToCoordinate(n, r), e.text = s.formatPrice(n, r), e.visible = !0, t.visible = !0, t.hitTestData = this._hitTestData
				}
			}
			const Jt = {
					normalBgColor: a.colorsPalette["color-cold-gray-750"],
					hoveredBgColor: a.colorsPalette["color-cold-gray-600"]
				},
				ei = {
					normalBgColor: a.colorsPalette["color-cold-gray-900"],
					hoveredBgColor: a.colorsPalette["color-cold-gray-650"]
				};
			class ti extends Qt {
				additionalPadding(e) {
					return 2 / 12 * e
				}
				_isVisible() {
					return this._properties.childs().showPriceScaleCrosshairLabel.value() && this._source.visible && null !== this._source.pane
				}
				_bgColor() {
					return this._getThemedColors().normalBgColor
				}
				_updateRendererData(e, t, i) {
					const s = t.visible;
					super._updateRendererData(e, t, i), this._source.isHovered() ? t.backgroung = this._getThemedColors().hoveredBgColor : t.backgroung = void 0, s || (t.visible = s)
				}
				_getThemedColors() {
					return this._source.model().isDark() ? Jt : ei
				}
			}
			class ii extends Qt {
				_isVisible() {
					return null !== this._source.measurePane().value()
				}
				_bgColor() {
					return this._properties.childs().axisLineToolLabelBackgroundColorCommon.value()
				}
			}
			var si = i(613648),
				oi = i(110933),
				ri = i(240025),
				ni = i(593379),
				ai = i(829770),
				li = i(588746),
				ci = i(291246),
				hi = i(921270),
				di = i(381554),
				ui = i(1891);

			function _i(e) {
				const t = e.priceScale();
				return null === t ? 0 : t.isPercentage() || t.isIndexedTo100() ? 2 : 1
			}
			class mi extends si.PanePriceAxisView {
				constructor(e, t, i, s, o) {
					super(e, t, s), this._crossHairMenuCachedState = null, this._hasActions = !1, this._tooltipText = null, this._gaOrigin = "CH menu", this._crosshairPriceAxisView = e, e.setPaneRendererLabelIcon(0), this._crosshair = t, this._scale = i, this._options = o, (0, oi.waitTradingService)().then((() => {
						this._crossHairMenuCachedState = null
					}))
				}
				_updateImpl(e, t) {
					super._updateImpl(e, t);
					const i = this._crosshair.y,
						s = this._chartModel.properties().childs().scalesProperties.childs().fontSize.value(),
						o = this._chartModel.timeScale().width(),
						r = this._crosshair.model().priceAxisRendererOptions(),
						n = s + 2 * this._crosshairPriceAxisView.additionalPadding(s) + r.paddingTop + r.paddingBottom,
						a = n,
						l = i - n / 2,
						c = o - a,
						h = this._crosshair.pane,
						d = this._mainDataSourceOnPane(),
						u = d && d.symbolSource(),
						_ = !!u && (u.isConvertedToOtherCurrency() || u.isConvertedToOtherUnit());
					if (null !== d) {
						const e = _i(d),
							t = d.idForAlert(),
							i = this._chartModel.isInReplay(),
							s = this._crossHairMenuCachedState;
						null !== s && s.id === t && s.priceScale === e && s.isCurrencyOrUnitConverted === _ && s.isInReplay === i || (this._updateTooltipAndActionsAvaliability(d, e, _), this._crossHairMenuCachedState = {
							id: t,
							priceScale: e,
							isCurrencyOrUnitConverted: _,
							isInReplay: i
						})
					}
					null !== d && (0, _e.isSymbolSource)(d) && d.symbol();
					const m = null !== h && (h.maximized().value() || !h.collapsed().value()) && this._hasActions;
					this._crosshairPriceAxisView.setPaneLabelVisible(m);
					const p = null !== h && 0 !== h.leftPriceScales().length && m,
						g = null !== h && 0 !== h.rightPriceScales().length && m,
						S = o - a / 2,
						v = this._tooltipText ? {
							text: this._tooltipText,
							rect: {
								x: S,
								y: l,
								w: 0,
								h: 0
							}
						} : void 0;
					this._data = {
						left: p,
						right: g,
						xl: 0,
						xr: c,
						y: l,
						containerWidth: a,
						containerHeight: n,
						clickHandler: this._handleClick.bind(this),
						tooltip: v
					}, this._crosshairPriceAxisView.setHitTestData(this._data)
				}
				_priceScale() {
					return this._scale
				}
				_updateTooltipAndActionsAvaliability(e, t, i) {
					this._tooltipText = null, this._hasActions = !1;
					if (!(1 === t)) return;
					const s = !this._chartModel.isInReplay(),
						o = !i && e.alertCreationAvailable() && s,
						r = !this._options.disableDrawHorizLineMenuAction,
						n = !i && e === this._chartModel.mainSeries() && Boolean((0,
							oi.tradingService)()) && s;
					let a = 0;
					n && a++, o && a++, r && a++;
					let c = 0;
					1 === a && (o ? (c = 1, this._tooltipText = (0, l.t)("Add alert")) : this._tooltipText = n ? (0, l.t)("Create order") : (0, l.t)("Add Horizontal Line")), this._crosshairPriceAxisView.setPaneRendererLabelIcon(c), this._hasActions = 0 !== a
				}
				_handleClick(e, t, i) {
					if (R.enabled("widget") && R.enabled("referral_program_for_widget_owners")) return void(0, ci.showGoToTradingViewReferralDialog)({
						feature: "plusMenu"
					});
					(0, d.trackEvent)(this._gaOrigin, "click");
					const s = this._mainDataSourceOnPane(),
						o = null !== s && (0, _e.isSymbolSource)(s) ? s.symbol() : null,
						r = {
							pageX: i.pageX,
							pageY: i.pageY,
							clientX: i.clientX,
							clientY: i.clientY,
							screenX: i.screenX,
							screenY: i.screenY,
							price: this._crosshair.price,
							symbol: o
						};
					_.emit("onPlusClick", r), this._getMenuItems(t).then((s => {
						const o = s[0];
						1 !== s.length || o.isDisabled() ? s.length > 0 && this._showContextMenu(s, e, i, t) : o.execute()
					}))
				}
				_getMenuItems(e) {
					const t = this._options.disableTradingMenuActions ? null : (0, oi.tradingService)(),
						i = (0, o.ensureNotNull)(this._crosshair.pane).mainDataSource(),
						s = !this._chartModel.isInReplay(),
						r = s,
						n = i === this._chartModel.mainSeries() && Boolean(t) && s,
						a = r ? this._createAlertMenuItems(e) : Promise.resolve([]),
						l = n ? this._createTradingMenuItems() : Promise.resolve([]);
					return Promise.all([a, l]).then((([e, i]) => {
						i.length > 0 && (0, o.ensureNotNull)(t).trackEvent(this._gaOrigin, "click");
						const s = this._createAddHorizontalLineMenuItem(),
							r = e.length > 0 && i.length > 0;
						return [...e, r ? new ai.Separator : null, ...i, (e.length > 0 || i.length > 0) && s.length > 0 ? new ai.Separator : null, ...s].filter((e => null !== e))
					}))
				}
				_createAlertMenuItems(e) {
					if (null === this._crosshair.pane) return Promise.resolve([]);
					const t = this._crosshair.pane.mainDataSource();
					if (null === t) return Promise.resolve([]);
					const i = t.symbolSource();
					if (!!i && (i.isConvertedToOtherCurrency() || i.isConvertedToOtherUnit())) return Promise.resolve([]);
					const s = this._crosshair.y;
					if (this._options.menuForMainSourceOnly) {
						if (t.alertCreationAvailable() && t.isVisible()) {
							const e = this._getActionAddAlert({
								source: t,
								y: s,
								isDisabled: !1
							});
							return Promise.resolve(null === e ? [] : [e])
						}
						return Promise.resolve([])
					}
					const r = (0, o.ensureNotNull)(this._crosshair.pane).sourcesByGroup();
					let n = ("left" === e ? r.leftPriceScalesSources() : r.rightPriceScalesSources()).filter((e => (0, se.isPriceDataSource)(e) && e.alertCreationAvailable() && e.isVisible()));
					return n.reverse(), n = (0, S.moveToHead)(n, this._chartModel.mainSeries()), (0, hi.filterAccessibleDataSources)(n).then((e => {
						const t = new Set(e),
							i = [];
						for (const e of n) {
							const o = this._getActionAddAlert({
								source: e,
								y: s,
								isDisabled: !t.has(e)
							});
							null !== o && i.push(o)
						}
						return i
					}))
				}
				_createTradingMenuItems() {
					const e = this._crosshair.y,
						t = (0, oi.tradingService)();
					if (null === t || null === this._crosshair.pane) return Promise.resolve([]);
					const i = this._crosshair.pane.mainDataSource();
					if (null === i) return Promise.resolve([]);
					const s = i.symbolSource(),
						o = !!s && (s.isConvertedToOtherCurrency() || s.isConvertedToOtherUnit()),
						r = _i(i);
					return o || 1 !== r ? Promise.resolve([]) : (0, ri.createTradeContext)(i, e).then((e => t.chartContextMenuActions(e, {
						onlyMainActions: !0,
						gaOrigin: this._gaOrigin
					})))
				}
				_createAddHorizontalLineMenuItem() {
					if (null === this._crosshair.pane) return [];
					const e = this._crosshair.pane.mainDataSource();
					if (null === e) return [];
					const t = this._crosshair.y,
						i = this._getActionAddHorizontalLine({
							source: e,
							y: t,
							pane: this._crosshair.pane
						});
					return null === i ? [] : [i]
				}
				_getActionAddAlert(e) {
					const {
						source: t,
						y: i,
						isDisabled: s
					} = e, o = this._getValue(t, i);
					if (null === o) return null;
					const r = this._formatValue(o, t),
						n = (0, _e.isSymbolSource)(t) ? t.symbolTitle(!0, !0) : t.title(!0, {}, !0),
						a = {
							label: (0, l.t)("Add alert for {title}").format({
								title: n
							}) + ` (${r})`,
							icon: di
						};
					return s ? a.disabled = !0 : a.onExecute = () => this._addAlert(o, t), new li.TVAction(a)
				}
				_getActionAddHorizontalLine(e) {
					if (this._options.disableDrawHorizLineMenuAction) return null;
					const {
						source: t,
						y: i,
						pane: s
					} = e, o = this._getValue(t, i);
					if (null === o) return null;
					const r = this._formatValue(o, t),
						n = {
							actionId: "Chart.Crosshair.PlusButton.DrawHorizontalLine",
							label: (0, l.t)("Draw Horizontal Line on") + ` ${r}`,
							icon: ni
						};
					return n.onExecute = () => this._addHorizontalLineTool(s, o), new ai.Action(n)
				}
				_getValue(e, t) {
					const i = e.priceScale(),
						s = e.firstValue();
					if (null === i || null === s) return null;
					return i.isPercentage() || i.isIndexedTo100() ? null : i.coordinateToPrice(t, s)
				}
				_formatValue(e, t) {
					return t.formatter().format(e)
				}
				_addAlert(e, t) {
					window.runOrSignIn((() => {
						const i = {
							dataSourceHub: this._chartModel,
							silent: !0,
							actionSource: "crosshair_menu"
						};
						(0, f.isLineTool)(t) ? i.drawing = t: (i.series = t, i.value = e), (0, Tt.invokeAlertEditorWithOnlineSeries)(i), (0, d.trackEvent)(this._gaOrigin, "alert")
					}), {
						source: this._gaOrigin
					})
				}
				_addHorizontalLineTool(e, t) {
					this._chartModel.undoModel().createLineTool({
						pane: e,
						point: {
							price: t,
							index: 0
						},
						linetool: "LineToolHorzLine"
					})
				}
				_showContextMenu(e, t, i, s) {
					const r = "left" === s;
					setTimeout((() => {
						const t = (0, o.ensureDefined)(this._data),
							s = r ? t.xl : t.xr,
							n = i.localX - s,
							a = i.clientX - n,
							l = i.clientX - n + t.containerWidth;
						ui.ContextMenuManager.showMenu(e, {
							clientX: r ? a : l,
							clientY: i.clientY - t.containerHeight / 2,
							boxHeight: t.containerHeight,
							attachToXBy: r ? "left" : "right",
							attachToYBy: "auto-strict"
						}, void 0, {
							menuName: "CrosshairMenuView"
						})
					}))
				}
				_mainDataSourceOnPane() {
					const e = this._crosshair.pane;
					return null !== e ? e.mainDataSource() : null
				}
			}
			var pi = i(345185),
				gi = i(420808),
				Si = i(218718);
			class vi {
				constructor(e) {
					this._data = e
				}
				hitTest(e) {
					return void 0 === this._data.clickHandler ? null : new Si.HitTestResult(Si.HitTestResult.CUSTOM, {
						clickHandler: this._data.clickHandler,
						tapHandler: this._data.clickHandler
					})
				}
				draw(e, t) {
					const i = t.pixelRatio,
						s = this._data.vertLinesVisible,
						o = this._data.horzLinesVisible;
					if (!s && !o) return;
					e.save(), e.lineWidth = Math.max(1, Math.floor(this._data.lineWidth * i)), e.strokeStyle = this._data.color, e.fillStyle = this._data.color, e.lineCap = "butt", (0, qt.setLineStyle)(e, this._data.lineStyle);
					const r = Math.round(this._data.x * i),
						n = Math.round(this._data.y * i),
						a = Math.ceil(this._data.w * i),
						l = Math.ceil(this._data.h * i);
					s && r >= 0 && (0, Kt.drawVerticalLine)(e, r, 0, l), o && n >= 0 && (0, Kt.drawHorizontalLine)(e, n, 0, a), this._data.drawCenter && (e.beginPath(), e.arc(r, n, Math.round(3 * i), 0, 2 * Math.PI, !0), e.fillStyle = this._data.color, e.fill()), e.restore()
				}
			}
			const fi = a.colorsPalette["color-tv-blue-500"];
			class bi {
				constructor(e, t) {
					this._rendererData = {}, this._renderer = new vi(this._rendererData), this._source = e, this._pane = t
				}
				update() {}
				renderer(e, t) {
					const i = 0 !== this._source.selectPointMode().value(),
						s = this._source.visible && (this._source.areLinesVisible || i) && !this._source.linesShouldBeHidden(),
						r = this._rendererData;
					if (!s || null === this._pane) return null;
					const n = this._source.paneForPointSelect(),
						a = null !== n ? this._source.pane === n && this._pane === n : this._pane === this._source.pane;
					if (i && this._source.isOnHoveredChartWidget() && a) {
						const e = (0, o.ensureNotNull)(this._source.pointToSelect());
						r.color = this._source.lineColor() || fi, r.lineWidth = 1, r.lineStyle = pi.LINESTYLE_SOLID, r.horzLinesVisible = !0, r.vertLinesVisible = !0, r.drawCenter = !1, "time" === e ? r.horzLinesVisible = !1 : "price" === e && (r.vertLinesVisible = !1)
					} else {
						const e = this._source.properties(),
							t = this._source.model().currentTool(),
							i = (0, gi.lastMouseOrTouchEventInfo)(),
							s = i.isTouch && !i.stylus && ((0, f.isLineToolName)(t) || (0, mt.toolIsMeasure)(t));
						let o;
						o = s ? fi : e.childs().color.value();
						const n = e.childs().transparency.value();
						!s && n > 0 && (o = (0, kt.generateColor)(o, n)), r.color = o, r.horzLinesVisible = this._pane === this._source.pane && (this._pane.maximized().value() || !this._pane.collapsed().value()), r.vertLinesVisible = !0, r.lineWidth = e.childs().width.value(), r.lineStyle = e.childs().style.value(), r.drawCenter = s && this._pane === this._source.pane
					}
					return r.w = this._pane.width(), r.h = this._pane.height(), r.x = void 0 !== this._source.lockedX && isFinite(this._source.lockedX) && this._source.lockedX || this._source.x, r.y = this._source.y, this._renderer
				}
			}
			var yi = i(819589);
			const Ci = {
				backgroundColor: (0, kt.generateColor)(a.colorsPalette["color-tv-blue-500"], 70),
				borderColor: (0, kt.generateColor)(a.colorsPalette["color-tv-blue-500"], 20)
			};
			class wi {
				constructor(e) {
					this._renderer = new yi.RectangleRenderer, this._rectangle = null, this._crosshair = e
				}
				update() {
					const e = this._crosshair.selection();
					null !== e && null !== this._crosshair.pane ? this._rectangle = this._crosshair.pane.logicalRectToPixels(e) : this._rectangle = null
				}
				renderer(e, t) {
					if (!this._rectangle) return null;
					const i = {
						backcolor: Ci.backgroundColor,
						color: Ci.borderColor,
						fillBackground: !0,
						linewidth: 1,
						points: [this._rectangle.min, this._rectangle.max],
						extendLeft: !1,
						extendRight: !1
					};
					return this._renderer.setData(i), this._renderer
				}
			}
			var Ti = i(143498),
				Pi = i(965513),
				Mi = i(635363),
				xi = i(401172),
				Ii = i(591419),
				Ai = i(821555),
				ki = i(115653),
				Li = i(717611),
				Ei = i(963985);
			const Di = (0, l.t)("{count} bars"),
				Ni = (0, l.t)("Vol"),
				Bi = new Pi.PercentageFormatter,
				Oi = new xi.TimeSpanFormatter,
				Ri = new Ii.VolumeFormatter,
				Vi = (0, a.getHexColorByName)("color-tv-blue-500"),
				Wi = (0, a.getHexColorByName)("color-ripe-red-400"),
				Fi = {
					bgColorPositive: (0, kt.generateColor)(Vi, 80),
					bgColorNegative: (0, kt.generateColor)(Wi, 80),
					colorPositive: (0, a.getHexColorByName)("color-tv-blue-600"),
					colorNegative: (0, a.getHexColorByName)("color-ripe-red-400"),
					labelBgColorPositive: Vi,
					labelBgColorNegative: Wi
				};
			class zi {
				constructor(e, t) {
					this._pipFormatter = null, this._lastSymbolInfo = null, this._horzTrenRenderer = new Ai.TrendLineRenderer, this._vertTrenRenderer = new Ai.TrendLineRenderer, this._bgRenderer = new yi.RectangleRenderer,
						this._labelRenderer = new ki.TextRenderer, this._p1 = null, this._p2 = null, this._label = null, this._source = e, this._pane = t
				}
				update(e) {
					const [t, i] = this._source.measurePoints();
					if (void 0 === i) return this._p1 = null, void(this._p2 = null);
					const s = (0, o.ensureNotNull)(this._source.measurePane().value()),
						n = t.price,
						a = i.price,
						l = i.price - n,
						c = i.index - t.index,
						h = (0, Ti.forceLTRStr)("" + c),
						d = (0, o.ensureNotNull)(s.mainDataSource());
					let u = (0, o.ensureNotNull)(d.formatter()).format(l);
					if (Math.abs(n) > 1e-8) {
						const e = l / Math.abs(n);
						u += " (" + Bi.format(100 * e) + ")"
					}
					const _ = (0, Ti.forceLTRStr)(u);
					this._label = _ + "\n" + Di.format({
						count: h
					});
					const m = (0, o.ensureNotNull)(d.firstValue()),
						p = this._source.model().timeScale().indexToCoordinate(t.index),
						g = this._source.model().timeScale().indexToCoordinate(i.index),
						S = s.defaultPriceScale().priceToCoordinate(n, m),
						v = s.defaultPriceScale().priceToCoordinate(a, m);
					this._p1 = new r.Point(p, S), this._p2 = new r.Point(g, v);
					const f = this._source.model().timeScale().indexToUserTime(t.index),
						b = this._source.model().timeScale().indexToUserTime(i.index);
					let y = null;
					if (null !== f && null !== b) {
						const e = this._pane.model().mainSeries().symbolInfo();
						null !== e && e !== this._lastSymbolInfo && (this._pipFormatter = new Mi.PipFormatter(e.pricescale, e.minmov, e.type, e.minmove2), this._lastSymbolInfo = e), y = (b.valueOf() - f.valueOf()) / 1e3
					}
					const C = this._pipFormatter ? this._pipFormatter.format(l) : null,
						w = null !== C ? " , " + C : "",
						T = null !== y ? Oi.format(y) : null,
						P = null !== T ? ", " + (0, Ti.startWithLTR)(T) : "";
					this._label = (0, Ti.forceLTRStr)(_ + w) + "\n" + Di.format({
						count: h
					}) + P;
					const M = this._source.measureVolume();
					Number.isNaN(M) || (this._label += `\n${Ni} ${Ri.format(M)}`);
					const x = a < n ? Fi.bgColorNegative : Fi.bgColorPositive,
						I = a < n ? Fi.colorNegative : Fi.colorPositive,
						A = a < n ? Fi.labelBgColorNegative : Fi.labelBgColorPositive,
						L = {
							points: [this._p1, this._p2],
							linewidth: 0,
							fillBackground: !0,
							color: x,
							backcolor: x,
							extendLeft: !1,
							extendRight: !1
						};
					this._bgRenderer.setData(L);
					const E = this._p1.add(this._p2).scaled(.5); {
						const e = Math.round(E.y),
							t = new r.Point(this._p1.x, e),
							i = new r.Point(this._p2.x, e),
							s = {
								points: [t, i],
								color: I,
								linewidth: 1,
								linestyle: pi.LINESTYLE_SOLID,
								extendleft: !1,
								extendright: !1,
								leftend: Ei.LineEnd.Normal,
								rightend: Math.abs(t.x - i.x) >= 50 ? Ei.LineEnd.Arrow : Ei.LineEnd.Normal
							};
						this._horzTrenRenderer.setData(s)
					} {
						const e = Math.round(E.x),
							t = new r.Point(e, this._p1.y),
							i = new r.Point(e, this._p2.y),
							s = {
								points: [t, i],
								color: I,
								linewidth: 1,
								linestyle: pi.LINESTYLE_SOLID,
								extendleft: !1,
								extendright: !1,
								leftend: Ei.LineEnd.Normal,
								rightend: Math.abs(t.y - i.y) >= 50 ? Ei.LineEnd.Arrow : Ei.LineEnd.Normal
							};
						this._vertTrenRenderer.setData(s)
					}
					const D = {
							x: 0,
							y: 10
						},
						N = .5 * (this._p1.x + this._p2.x),
						B = this._p2.y,
						O = new r.Point(N, B),
						R = (V = (0, o.ensureNotNull)(this._label), {
							points: [O],
							text: V,
							color: "#FFFFFF",
							horzAlign: "center",
							vertAlign: "middle",
							font: k.CHART_FONT_FAMILY,
							offsetX: D.x,
							offsetY: D.y,
							bold: !1,
							italic: !1,
							fontsize: 12,
							padding: 8,
							highlightBorder: !1,
							backgroundColor: A,
							backgroundTransparency: 10,
							backgroundVertInflate: 5,
							backgroundHorzInflate: 5,
							backgroundRoundRect: 4
						});
					var V;
					this._labelRenderer.setData(R);
					const W = this._labelRenderer.measure(),
						F = (0,
							ki.calculateLabelPosition)(W, this._p1, this._p2, D, this._pane.height());
					this._labelRenderer.setPoints([F])
				}
				renderer() {
					if (null === this._p1 || null === this._p2) return null;
					const e = new Li.CompositeRenderer;
					return e.append(this._bgRenderer), e.append(this._horzTrenRenderer), e.append(this._vertTrenRenderer), e.append(this._labelRenderer), e
				}
			}
			var Ui = i(380047);
			class Hi extends Ui.ScaledPaneRenderer {
				constructor(e) {
					super(), this._data = e
				}
				hitTest(e) {
					return null
				}
				_drawImpl(e) {
					e.translate(this._data.x - this._data.width / 2, this._data.y - this._data.height / 2), e.strokeStyle = "rgba(153,153,153,.3)", e.lineWidth = 2, e.beginPath(), this._drawShackle(e), e.stroke(), e.closePath(), e.strokeStyle = "rgba(153,153,153,.7)", e.lineWidth = 1, e.beginPath(), e.rect(0, this._data.height - this._data.bodyHeight + .5, this._data.width, this._data.bodyHeight), e.closePath(), e.stroke(), e.translate(0, -1), e.strokeStyle = "#777", e.beginPath(), this._drawShackle(e), e.stroke(), e.closePath(), e.fillStyle = "rgba(255,255,255,.7)", e.beginPath(), e.rect(1, this._data.height - this._data.bodyHeight + 1.5, this._data.width - 2, this._data.bodyHeight - 2), e.fill(), e.beginPath(), e.rect(.5, this._data.height - this._data.bodyHeight + 1, this._data.width - 1, this._data.bodyHeight - 1), e.stroke(), e.closePath(), e.fillStyle = "#777", e.fillRect(this._data.width / 2 - .5, this._data.height - this._data.bodyHeight / 2, 1, 2)
				}
				_drawShackle(e) {
					const t = (this._data.width - 3) / 2,
						i = this._data.height - this._data.bodyHeight;
					e.moveTo(1.5, t), e.arc(this._data.width / 2, t, t, Math.PI, 2 * Math.PI), i > t && (e.moveTo(1.5, t), e.lineTo(1.5, i), e.moveTo(this._data.width - 1.5, t), e.lineTo(this._data.width - 1.5, i))
				}
			}
			class Gi {
				constructor(e, t, i) {
					this._horzVisible = !1, this._source = e, this._pane = t, this._axis = i || "x"
				}
				update() {}
				renderer(e, t) {
					const i = this._source.visible && this._source.areLinesVisible,
						s = (0, mt.lockTimeAxis)().value(),
						r = i && this._horzVisible,
						n = i || s;
					if ("y" === this._axis && !r || !n) return null;
					const a = "y" === this._axis ? this._pane.width() - 4.5 : (0, o.ensureDefined)(this._source.lockedX) + 1,
						l = "y" === this._axis ? this._source.y : this._pane.height() - 5.5 - 1;
					return new Hi({
						x: a,
						y: l,
						width: 9,
						height: 11,
						bodyHeight: 7
					})
				}
			}
			var ji = i(638456),
				qi = i(733133),
				Ki = i(734906);
			class Yi extends Ki.DataWindowView {
				constructor(e) {
					super(), this._invalidated = !0, this._dateItem = new Ki.DataWindowItem("", (0, l.t)("Date"), ""), this._timeItem = new Ki.DataWindowItem("", (0, l.t)("Time"), ""), this._model = e, this._items.push(this._dateItem), this._items.push(this._timeItem)
				}
				update() {
					this._invalidated = !0
				}
				items() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._items
				}
				_updateImpl() {
					const e = this._model.mainSeries().isDWM();
					if (this._timeItem.setVisible(!e), this._timeItem.setValue(""), this._dateItem.setValue(""), this._model.timeScale().isEmpty()) return;
					let t = this._model.crossHairSource().appliedIndex();
					if (!(0, Ot.isNumber)(t)) {
						const e = this._model.mainSeries().data().last();
						if (null === e) return;
						t = e.index
					}
					const i = this._model.timeScale().indexToUserTime(t);
					null !== i && (this._dateItem.setValue(this._model.dateFormatter().format(i)), e || this._timeItem.setValue(this._model.timeFormatter().format(i)))
				}
			}
			var Xi = i(642053);
			const Zi = a.colorsPalette["color-tv-blue-500"],
				$i = (0, l.t)("Re", {
					context: "Replay"
				});
			class Qi extends Xi.TimeAxisView {
				constructor(e, t, i, s = !1) {
					super(e), this._indexProvider = i, this._highlighted = s, this._source = t, this._properties = e.properties().childs().scalesProperties
				}
				_getText(e) {
					if (this._source.isReplaySelection()) {
						const t = this._model.timeScale().indexToUserTime(e);
						return null !== t ? `${$i}: ${this._model.dateTimeFormatter().format(t)}` : ""
					}
					return super._getText(e)
				}
				_getBgColor() {
					if (this._source.isReplaySelection()) return Zi;
					const e = this._model.isDark();
					return this._highlighted ? this._properties.childs().axisLineToolLabelBackgroundColorCommon.value() : e ? a.colorsPalette["color-cold-gray-750"] : a.colorsPalette["color-cold-gray-900"]
				}
				_getIndex() {
					return this._model.crossHairSource().visible ? this._indexProvider() : null
				}
				_isVisible() {
					return this._properties.childs().showTimeScaleCrosshairLabel.value()
				}
			}
			var Ji = i(262203);
			const es = new Path2D("M14.02 4.54C11.9 2.4 8.5 3 6.62 4.87l-1.8 1.79 2.13 2.12 1.79-1.79c1.04-1.04 2.45-1.04 3.16-.33.7.7.7 2.12-.34 3.16l-1.78 1.79 2.12 2.12 1.79-1.79c1.87-1.87 2.45-5.28.33-7.4Zm-2.83 9.9L9.07 12.3l-.19.19-1.93 1.94 2.12 2.12 1.94-1.94.18-.18ZM6.24 9.48 4.12 7.36 2 9.5l2.12 2.12 2.12-2.12Z"),
				ts = new Path2D("M13.46 14.02c2.13-2.12 1.54-5.53-.33-7.4l-1.79-1.8-2.12 2.13 1.79 1.79c1.04 1.04 1.04 2.45.33 3.16-.7.7-2.12.7-3.16-.34L6.39 9.78 4.27 11.9l1.79 1.79c1.87 1.87 5.28 2.45 7.4.33Zm-9.9-2.83L5.7 9.07 5.5 8.9 3.56 6.95 1.44 9.07l1.94 1.94.18.18Zm4.95-4.95 2.13-2.12L8.5 2 6.4 4.12l2.12 2.12Z");
			class is {
				constructor() {
					this._data = null
				}
				setData(e) {
					this._data = e
				}
				draw(e, t) {
					if (!this._data) return;
					e.save();
					const i = t.pixelRatio;
					let s, o, r;
					if (0 === this._data.positioning) s = 8, o = -26, r = es;
					else s = 8, o = 8, r = ts;
					e.translate((this._data.point.x + s) * i, (this._data.point.y + o) * i), e.scale(i, i), e.fillStyle = "#2962FF", e.fill(r), e.restore()
				}
				hitTest(e, t) {
					return null
				}
			}
			class ss {
				constructor(e, t) {
					this._invalidated = !0, this._renderer = new is, this._source = e, this._pane = t
				}
				update() {
					this._invalidated = !0
				}
				renderer(e, t) {
					return this._invalidated && (this._updateImpl(e, t), this._invalidated = !1), this._renderer
				}
				_updateImpl(e, t) {
					this._renderer.setData(null);
					const i = this._source.model().magnet().lastValue(),
						s = this._pane.mainDataSource();
					if (null === s) return;
					const o = s.model().mainSeries();
					if (!this._source.isOnHoveredChartWidget() || s !== o || !(0, zt.magnetEnabled)().value() || null === i) return;
					const n = function(e, t, i) {
						const s = e.firstValue();
						if (null === s) return null;
						const o = e.priceScale(),
							n = t.model().timeScale();
						let a = new r.Point(t.originX(), t.originY());
						const l = n.coordinateToIndex(a.x),
							c = Ut(e, l);
						if (void 0 === c) return null;
						const h = o.coordinateToPrice(a.y, s);
						let d;
						if (1 === c.length)
							if (13 === e.style())
								if (h < c[0]) {
									const e = n.indexToCoordinate(l),
										t = o.priceToCoordinate(c[0], s);
									a = new r.Point(e, t), d = 0
								} else d = h >= c[0] ? 0 : 1;
						else d = h >= c[0] ? 0 : 1;
						else {
							const e = Math.min(...c),
								t = Math.max(...c);
							if (h >= t) d = 0;
							else if (h <= e) d = 1;
							else {
								const c = n.indexToCoordinate(l);
								let h;
								i >= (t + e) / 2 ? (d = 0, h = o.priceToCoordinate(t, s)) : (d = 1, h = o.priceToCoordinate(e, s)), a = new r.Point(c, h)
							}
						}
						o.isInverted() && (d = 0 === d ? 1 : 0);
						return {
							point: a,
							positioning: d
						}
					}(o, this._source, i);
					this._renderer.setData(n)
				}
			}
			const os = {
					menuEnabled: !1,
					menuForMainSourceOnly: !1,
					disableTradingMenuActions: !1,
					disableDrawHorizLineMenuAction: !1
				},
				rs = (0, vt.isFeatureEnabled)("show_magnet_near_cursor");
			class ns extends jt.DataSource {
				constructor(e, t, i) {
					super(), this.pane = null, this.price = NaN, this.index = NaN, this.visible = !0, this.areLinesVisible = !0, this.x = NaN, this.y = NaN, this._measurePane = new(Y())(null), this._startMeasurePoint = null, this._endMeasurePoint = null, this._lastValidMeasurePoint = null, this._isOnHoveredChartWidget = !1, this._selectPointMode = new(Y())(0), this._selectionPane = null, this._selectionView = new wi(this), this._selectionStartPoint = null, this._measurePaneView = null, this._timeLockPaneView = null, this._priceAxisViews = new Map, this._panePriceAxisViews = new Map, this._startMeasurePriceAxisViews = new Map, this._endMeasurePriceAxisViews = new Map, this._originX = NaN, this._originY = NaN, this._subscribed = !1, this._movedDelegate = new(q()), this._pointSelectedDelegate = new(q()), this._requestedPoint = null, this._paneForRequestedPoint = null, this._selectLineColor = null, this._volumeCalculator = null, this._model = e, this._options = Object.assign({}, os, i || {}), this._linesShouldBeHidden = this._model.readOnly(), this._dataWindowView = new Yi(e), this.setSelectionEnabled(!1);
					const s = e => t => t === (0, o.ensureNotNull)(this._measurePane.value()).defaultPriceScale() ? e() : null;
					this._currentPosPriceProvider = e => {
						const t = (0, o.ensureNotNull)(this.pane);
						if (e === t.defaultPriceScale()) return this.price;
						const i = (0, o.ensureNotNull)(t.defaultPriceScale().mainSource()).firstValue();
						if (null === i) return null;
						const s = t.defaultPriceScale().priceToCoordinate(this.price, i),
							r = (0, o.ensureNotNull)(e.mainSource()).firstValue();
						return null === r ? null : e.coordinateToPrice(s, r)
					}, this._startMeasurePriceProvider = s((() => (0, o.ensureNotNull)(this._startMeasurePoint).price)), this._endMeasurePriceProvider = s((() => (0, o.ensureNotNull)(this._lastMeasurePoint()).price)), this._properties = t;
					this._timeAxisView = new Qi(e, this, (() => this.appliedIndex()), !1), this._startMeasureTimeAxisView = new Qi(e, this, (() => (0, o.ensureNotNull)(this._startMeasurePoint).index), !0), this._endMeasureTimeAxisView = new Qi(e, this, (() => (0, o.ensureNotNull)(this._lastMeasurePoint()).index), !0), e.readOnly() || mt.cursorTool.subscribe((e => this.areLinesVisible = "arrow" !== e), {
						callWithLast: !0
					})
				}
				destroy() {
					null !== this._volumeCalculator && this._volumeCalculator.destroy(), this._measurePane.setValue(null)
				}
				moved() {
					return this._movedDelegate
				}
				originX() {
					return this._originX
				}
				originY() {
					return this._originY
				}
				saveOriginCoords(e, t) {
					this._originX = e, this._originY = t
				}
				clearOriginCoords() {
					this._originX = NaN, this._originY = NaN
				}
				currentPoint() {
					return new r.Point(this.x, this.y)
				}
				model() {
					return this._model
				}
				appliedIndex() {
					return Number.isFinite(this.lockedIndex) ? this.lockedIndex : this.index
				}
				startMeasurePoint() {
					return this._startMeasurePoint || null
				}
				endMeasurePoint() {
					return this._endMeasurePoint || null
				}
				measureVolume() {
					if (null === this._volumeCalculator) return NaN;
					const [e, t] = this.measurePoints();
					return void 0 === t ? NaN : this._volumeCalculator.volume(e.index, t.index)
				}
				measurePane() {
					return this._measurePane.readonly()
				}
				startMeasuring(e, t) {
					this._startMeasurePoint = e, this._measurePane.setValue(t), t.containsMainSeries() && ((0, o.assert)(null === this._volumeCalculator), this._volumeCalculator = new Ji.SeriesTimeRangeVolumeCalculator(this.model().mainSeries())), this._model.updatePane(t)
				}
				finishMeasure(e) {
					this._endMeasurePoint = e
				}
				clearMeasure() {
					this._measurePane.setValue(null), delete this._startMeasurePoint, delete this._endMeasurePoint, delete this._lastValidMeasurePoint, this._model.lightUpdate(), null !== this._volumeCalculator && (this._volumeCalculator.destroy(), this._volumeCalculator = null)
				}
				measurePoints() {
					const e = [(0, o.ensureNotNull)(this._startMeasurePoint)],
						t = this._lastMeasurePoint();
					return null !== t && e.push(t), e
				}
				startSelection(e) {
					this._selectionStartPoint = this.currentLogicalPoint(), this._selectionPane = e
				}
				clearSelection() {
					this._selectionStartPoint = null, this._selectionPane = null
				}
				selection() {
					return this._selectionStartPoint ? {
						p1: this._selectionStartPoint,
						p2: this.currentLogicalPoint()
					} : null
				}
				currentLogicalPoint() {
					return {
						index: this.appliedIndex(),
						price: this.price
					}
				}
				selectPointMode() {
					return this._selectPointMode
				}
				lineColor() {
					return this._selectLineColor
				}
				cancelRequestSelectPoint() {
					0 !== this._selectPointMode.value() && this._setSelectPointModeState(0)
				}
				requestSelectPoint(e) {
					(0, o.assert)(!this._selectPointMode.value(), "Point already requested");
					const {
						pointType: t,
						pane: i,
						lineColor: s = null,
						selectPointMode: r = 2
					} = e;
					i && ((0, o.assert)(-1 !== this._model.panes().indexOf(i), "Chartmodel doesn't contains specified pane"), this._paneForRequestedPoint = i, this._model.panesCollectionChanged().subscribe(this, this._paneCollectionChanged)), this._selectLineColor = s, this._requestedPoint = t, this._setSelectPointModeState(r)
				}
				onPointSelected() {
					return this._pointSelectedDelegate
				}
				trySelectCurrentPoint() {
					const e = (0, o.ensureNotNull)(this._requestedPoint);
					if (!this._model.mainSeries().bars().contains(this.index) && "price" !== e) return;
					const t = (0, o.ensureNotNull)(this.pane);
					if (this._paneForRequestedPoint && this._paneForRequestedPoint !== t) return;
					let i, s;
					if ("price" === e || (i = this._model.timeScale().indexToTimePoint(this.index), null !== i)) {
						if ("time" !== e) {
							const e = t.mainDataSource();
							if (null === e) return;
							const i = e.firstValue(),
								o = e.priceScale();
							if (null === i || null === o) return;
							s = o.coordinateToPrice(this.y, i)
						}
						this._setSelectPointModeState(0), this._pointSelectedDelegate.fire({
							time: i,
							price: s
						}, t)
					}
				}
				isOnHoveredChartWidget() {
					return this._isOnHoveredChartWidget
				}
				setOnHoveredChartWidget(e) {
					this._isOnHoveredChartWidget = e
				}
				isReplaySelection() {
					const e = this._selectPointMode.value();
					return this._isOnHoveredChartWidget && 1 === e
				}
				clearPosition() {
					this.visible = !1, this.index = NaN, this.price = NaN, this.x = NaN, this.y = NaN, this.pane = null, this.clearOriginCoords()
				}
				setPosition(e, t, i) {
					return this._subscribed || (this._model.mainSeries().onRestarted().subscribe(this, this.clearMeasure), this._subscribed = !0), this.setLockedPosition(i), this.visible = !0, this._tryToUpdateViews(e, t, i)
				}
				setLinesShouldBeHidden(e) {
					this._linesShouldBeHidden = e
				}
				linesShouldBeHidden() {
					return this._linesShouldBeHidden
				}
				handleContextMenuEvent(e) {
					this._selectPointMode.value() && this._setSelectPointModeState(0)
				}
				properties() {
					return this._properties
				}
				priceAxisViews(e, t) {
					const i = null === this._requestedPoint || "time" !== this._requestedPoint || !this._isOnHoveredChartWidget,
						s = [];
					return this.pane === e && i && s.push(this._createPriceAxisViewOnDemand(this._priceAxisViews, this._panePriceAxisViews, e, t, this._currentPosPriceProvider, ti, !0)[0]), this._startMeasurePoint && s.push(this._createPriceAxisViewOnDemand(this._startMeasurePriceAxisViews, null, e, t, this._startMeasurePriceProvider, ii)[0]), this._lastMeasurePoint() && s.push(this._createPriceAxisViewOnDemand(this._endMeasurePriceAxisViews, null, e, t, this._endMeasurePriceProvider, ii)[0]), s
				}
				timeAxisViews() {
					const e = [],
						t = null === this._requestedPoint || "price" !== this._requestedPoint || !this._isOnHoveredChartWidget;
					return !this._linesShouldBeHidden && (this.visible || (0, mt.lockTimeAxis)().value()) && t && e.push(this._timeAxisView), this._startMeasurePoint && e.push(this._startMeasureTimeAxisView), this._lastMeasurePoint() && e.push(this._endMeasureTimeAxisView), e
				}
				paneViews(e) {
					if (void 0 === e) return null;
					const t = [new bi(this, e)];
					if (rs && t.push(new ss(this, e)), e === this._selectionPane && t.push(this._selectionView), e === this._measurePane.value() && (null === this._measurePaneView && (this._measurePaneView = new zi(this, e)), this._measurePaneView.update((0, F.dataSourceChangeEvent)(this.id())), t.push(this._measurePaneView)), qi.addPlusButtonProperty.value()) {
						const i = e === this.pane,
							s = !ji.CheckMobile.any() || window.screen.width >= 320,
							o = mt.tool.value(),
							r = (0, f.isLineToolName)(o),
							n = null !== this._model.lineBeingEdited() || null !== this._model.lineBeingCreated() || this._model.sourcesBeingMoved().length > 0 || null !== this._model.customSourceBeingMoved() || (0, mt.toolIsMeasure)(o);
						if (i && this._isOnHoveredChartWidget && !this._selectPointMode.value() && s && !r && !n) {
							const i = e.mainDataSource();
							if (null !== i) {
								const s = i.priceScale();
								if (null !== s) {
									const i = this._createPriceAxisViewOnDemand(this._priceAxisViews, this._panePriceAxisViews, e, s, this._currentPosPriceProvider, ti, !0)[1];
									null !== i && t.push(i)
								}
							}
						}
					}
					return (0, mt.lockTimeAxis)().value() && (null === this._timeLockPaneView && (this._timeLockPaneView = new Gi(this, e)), t.push(this._timeLockPaneView)), t
				}
				dataWindowView() {
					return this._dataWindowView
				}
				updateAllViews(e) {
					this._priceAxisViews.forEach((t => {
						t.forEach((t => t.update(e)))
					})), this._panePriceAxisViews.forEach((t => {
						t.forEach((t => t.update(e)))
					})), this._startMeasurePoint && (this._startMeasurePriceAxisViews.forEach((t => {
						t.forEach((t => t.update(e)))
					})), this._startMeasureTimeAxisView.update(e)), this._lastMeasurePoint() && (this._endMeasurePriceAxisViews.forEach((t => {
						t.forEach((t => t.update(e)))
					})), this._endMeasureTimeAxisView.update(e)), this._timeAxisView.update(e), this._selectionView.update(), this._dataWindowView.update()
				}
				setLockedPosition(e) {
					delete this.lockedIndex, delete this.lockedX, e !== this._measurePane.value() && (0, mt.lockTimeAxis)().value() && (this.lockedIndex = this._model.timeScale().points().roughIndex(mt.lockTimeAxisTime.value()), null !== this.lockedIndex && (this.lockedX = this._model.timeScale().indexToCoordinate(this.lockedIndex)))
				}
				isMenuEnabled() {
					return this._options.menuEnabled
				}
				isHoveredEnabled() {
					return qi.addPlusButtonProperty.value()
				}
				isHovered() {
					return this._model.hoveredSource() === this
				}
				pointToSelect() {
					return this._requestedPoint
				}
				paneForPointSelect() {
					return this._paneForRequestedPoint
				}
				_lastMeasurePoint() {
					return this._endMeasurePoint ? this._endMeasurePoint : (null !== this.pane && this._measurePane.value() === this.pane && (this._lastValidMeasurePoint = {
						price: this._model.magnet().align(this.price, this.index, this.pane),
						index: this.index
					}), this._lastValidMeasurePoint || null)
				}
				_createPriceAxisViewOnDemand(e, t, i, s, r, n, a = !1) {
					let l = e.get(i),
						c = null !== t ? t.get(i) : void 0;
					void 0 === l && (l = new Map, e.set(i, l), this._options.menuEnabled && null !== t && (c = new Map, t.set(i, c)), a && i.onDestroyed().subscribe(this, (() => this._onPaneDestroyed(i))));
					let h = l.get(s);
					if (void 0 === h) {
						if (h = new n(this, s, r), l.set(s, h), void 0 !== c) {
							const e = new mi(h, this, s, this._model, this._options);
							c.set(s, e)
						}
						a && s.lastSourceRemoved().subscribe(this, (() => this._onPriceScaleCleared(s)))
					}
					let d = null;
					return void 0 !== c && (d = (0, o.ensureDefined)(c.get(s))), [h, d]
				}
				_onPaneDestroyed(e) {
					e.onDestroyed().unsubscribeAll(this), this._priceAxisViews.delete(e), this._panePriceAxisViews.delete(e), this._startMeasurePriceAxisViews.delete(e), this._endMeasurePriceAxisViews.delete(e)
				}
				_onPriceScaleCleared(e) {
					e.lastSourceRemoved().unsubscribeAll(this), this._priceAxisViews.forEach((t => t.delete(e))), this._panePriceAxisViews.forEach((t => t.delete(e))), this._startMeasurePriceAxisViews.forEach((t => t.delete(e))), this._endMeasurePriceAxisViews.forEach((t => t.delete(e)))
				}
				_tryToUpdateViews(e, t, i) {
					return !!this._tryToUpdateData(e, t, i) && (this.updateAllViews((0, F.dataSourceChangeEvent)(this.id())), this._movedDelegate.fire({
						index: this.index,
						price: this.price
					}), !0)
				}
				_tryToUpdateData(e, t, i) {
					const s = this.x,
						r = this.y,
						n = this.price,
						a = this.index,
						l = this.pane,
						c = this._priceScaleByPane(i);
					if (this.index = e, this.x = isNaN(e) ? NaN : this._model.timeScale().indexToCoordinate(e), null !== c && null !== i) {
						this.pane = i, this.price = t;
						const e = (0, o.ensureNotNull)(i.mainDataSource()).firstValue();
						this.y = null === e ? NaN : c.priceToCoordinate(t, e)
					} else this.pane = null, this.price = NaN, this.y = NaN;
					return s !== this.x || r !== this.y || a !== this.index || n !== this.price || l !== this.pane
				}
				_priceScaleByPane(e) {
					return e && !e.defaultPriceScale().isEmpty() ? e.defaultPriceScale() : null
				}
				_setSelectPointModeState(e) {
					0 === e && (this._requestedPoint = null, this._selectLineColor = null, this._paneForRequestedPoint && (this._paneForRequestedPoint = null, this._model.panesCollectionChanged().unsubscribe(this, this._paneCollectionChanged))), mt.isPointSelectedNow.setValue(0 !== e), this._selectPointMode.setValue(e), this._model.lightUpdate()
				}
				_paneCollectionChanged(e) {
					const t = this._paneForRequestedPoint;
					null !== t && -1 === e.indexOf(t) && this.cancelRequestSelectPoint()
				}
			}
			var as = i(404703),
				ls = i(990997),
				cs = i(507942),
				hs = i(194543);
			const ds = new(i(277036).TranslatedString)("remove deselected empty line tools", (0, l.t)("remove deselected empty line tools")),
				us = (0, $.getLogger)("Chart.ChartModel");

			function _s(e, t) {
				const i = e.indexOf(t);
				return -1 !== i && (e.splice(i, 1), !0)
			}

			function ms(e) {
				var t, i;
				for (let s = e.length; s--;) {
					const o = e[s].dataSources();
					for (let e = o.length; e--;) null === (t = o[e].dataWindowView()) || void 0 === t || t.update();
					const r = e[s].priceDataSources();
					for (let e = r.length; e--;) null === (i = r[e].legendView()) || void 0 === i || i.update()
				}
			}
			const ps = {
					isSnapshot: !1,
					readOnly: !1,
					watermarkEnabled: !0,
					shiftVisibleRangeOnNewBar: !0,
					currencyConversionEnabled: !1,
					unitConversionEnabled: !1,
					countdownEnabled: !0,
					lastPriceAnimationEnabled: !0,
					onWidget: !1,
					hideIdeas: !1
				},
				gs = (0, vt.isFeatureEnabled)("sync_daterange_with_right_margin");
			class Ss {
				constructor(e, t, i, o, r, n, a, l, h, d) {
					this._onRearrangePanes = new(q()), this._lineToolsGroupModel = new at, this._sourcesBeingMoved = [], this._activeItemBeingMoved = null, this._lineBeingEdited = null, this._linePointBeingEdited = null, this._linePointBeingChanged = null, this._customSourceBeingMovedHitTestData = null, this._customSourceBeingMoved = null, this._dataSourceCollectionChanged = new(q()), this._sourceProperitesChanged = new(q()), this._sourceZOrderChanged = new(q()), this._symbolSourceResolved = new(q()), this._symbolSourceResolvingActive = new(Y())(!1), this._adjustForDividendsAvailability = new(Y())(0), this._adjustForDividendsEnabled = new(Y())(!1), this._sessions = null, this._currentTool = "", this._lineBeingCreated = null, this._paneBeingCreatedLineOn = null, this._lineCancelled = new(q()), this._phantomSourceContainer = new Rt(this), this._destroyed = !1, this._isSettingsExternalPosition = !1, this._isTimeScrolling = !1, this._magnet = new Ht, this._scrollingState = null, this._modelIntervals = [], this._rendererOptionsProvider = new L(this), this._cachedStudiesMaxOffset = 0, this._panes = [], this._tagsChanged = new(q()), this._strategySources = [], this._strategySourcesChange = new(q()), this._activeStrategySource = new(Y())(null), this._paneCollapsingAvailable = new(Y())(!1), this._panesCollectionChanged = new(q()), this._scrollEnabled = R.enabled("chart_scroll"), this._zoomEnabled = R.enabled("chart_zoom"), this._isScalesResetAvailableChanged = new(q()), this._isScalesResetAvailable = !1, this._esdWatcher = null, this._alertsWatcher = null, this._hoveredSource = null, this._hoveredSourceChanged = new(q()), this._lastHoveredHittestData = null, this._lastSelectedHittestData = null, this._topmostCustomSources = [], this._fgCustomSources = [], this._bgCustomSources = [], this._allCustomSources = [], this._customSourcesMap = new Map, this._multiPaneSources = [], this._showLegendProperty = new(I()), this._id = (0, Q.guid)(), this._chartSaveTime = null, this._availableCurrenciesList = null, this._availableCurrencies = new Nt([]), this._availableUnitsObject = null, this._availableUnits = new Bt({}), this._shouldBeSavedEvenIfHidden = !1, this._watchedThemeSpawn = c.watchedTheme.spawn(), this._gradientColorsCache = null, this._recalcVRStudiesParams = {}, this._recalcColorStudiesParams = {}, this._recalcVisibleRangeStudiesImplDebounced = (0, s.default)(this._recalcVisibleRangeStudiesImpl.bind(this, this._recalcVRStudiesParams), 500), this._recalcColorStudiesImplDebounced = (0, s.default)(this._recalcColorStudiesImpl.bind(this, this._recalcColorStudiesParams), 250), this._width = 0, this._resetScales = new(q()), this._chartThemeLoaded = new(q()), this._selection = new y,
						this._selectedSourceChanged = new(q()), this._symbolSourceCollectionChanged = new(q()), this._gridSource = new Zt, this._syncPointCache = new Map, this._lastAppliedGotoTimeRange = null, this._lastGotoTimeRange = null, this._clearSelection = () => {
							this._lastSelectedHittestData = null, this._selection.clear()
						}, this._removeSourceFromSelection = e => {
							this._selection.remove(e)
						}, this._addSourceToSelection = (e, t) => {
							const i = this._selection.isSelected(e);
							i && this._lastSelectedHittestData === t || e && !e.isSelectionEnabled() || (this._lastSelectedHittestData = t || null, i || this._selection.add(e))
						}, this._recalcSymbolResolvingActive = () => {
							for (const e of this._panes)
								if (e.symbolSourceResolvingActive().value()) return void this._symbolSourceResolvingActive.setValue(!0);
							this._symbolSourceResolvingActive.setValue(!1)
						}, this._recalcAdjustForDividendsAvailibility = () => {
							var e, t, i, s;
							if (this._symbolSourceResolvingActive.value()) return void this._adjustForDividendsAvailability.setValue(0);
							const o = this.mainSeries();
							switch (null !== (t = null === (e = o.symbolInfo()) || void 0 === e ? void 0 : e.allowed_adjustment) && void 0 !== t ? t : "none") {
								case "dividends":
									return void this._adjustForDividendsAvailability.setValue(2);
								case "splits":
									return void this._adjustForDividendsAvailability.setValue(1);
								case "any":
									return void this._adjustForDividendsAvailability.setValue(3)
							}
							for (const e of this.symbolSources()) {
								if (e.symbolHibernated().value() || e === o) continue;
								if ("any" === (null !== (s = null === (i = e.symbolInfo()) || void 0 === i ? void 0 : i.allowed_adjustment) && void 0 !== s ? s : "none")) return void this._adjustForDividendsAvailability.setValue(3)
							}
							this._adjustForDividendsAvailability.setValue(0)
						}, this._recalcAdjustForDividendsEnabled = () => {
							switch (this._adjustForDividendsAvailability.value()) {
								case 2:
									return void this._adjustForDividendsEnabled.setValue(!0);
								case 0:
								case 1:
									return void this._adjustForDividendsEnabled.setValue(!1)
							}
							this._adjustForDividendsEnabled.setValue(this.mainSeries().properties().childs().dividendsAdjustment.value())
						}, this._recalcPaneCollapsingAvailable = e => {
							let t = this._panes.filter((e => !e.collapsed().value())).length;
							0 === t && e && this._panes.length > 0 && (this._panes[0].collapsed().setValue(!1), t = 1), this._paneCollapsingAvailable.setValue(t > 1)
						}, this._chartApi = e, this._invalidateHandler = t, this._undoModel = n, this._properties = i, this._options = (0, ve.merge)((0, ve.clone)(ps), l), this._collapsedWV = h, this._isAutoSaveEnabled = d, this._studiesMetaInfoRepository = r, this._readOnly = this._options.readOnly, this._isSnapshot = this._options.isSnapshot, this._alertsWatcher = new Pt(this), this._chartSaveTime = (new Date).valueOf(), this._backgroundColor = new(Y())(this._getBackgroundColor()), this._backgroundTopColor = new(Y())(this._getBackgroundColor(!0)), this._properties.childs().paneProperties.childs().background.subscribe(this, this._updateBackgroundColor), this._properties.childs().paneProperties.childs().backgroundType.subscribe(this, this._updateBackgroundColor), this._properties.childs().paneProperties.childs().backgroundGradientStartColor.subscribe(this, this._updateBackgroundColor),
						this._properties.childs().paneProperties.childs().backgroundGradientEndColor.subscribe(this, this._updateBackgroundColor), this._backgroundColor.subscribe(this.recalcColorStudies.bind(this, !1)), this._backgroundTopColor.subscribe(this.recalcColorStudies.bind(this, !1)), this._watchedThemeSpawn.subscribe(this._updateBackgroundColor.bind(this)), this._symbolSourceResolvingActive.subscribe(this._recalcAdjustForDividendsAvailibility), this.setStudiesMetaData(this._studiesMetaInfoRepository.getInternalMetaInfoArray(), this._studiesMetaInfoRepository.getMigrations()), (0, mt.init)();
					const u = this._readOnly ? new(I())((0, B.defaults)("chartproperties.paneProperties.crossHairProperties")) : this._properties.childs().paneProperties.childs().crossHairProperties;
					this.m_crossHairSource = new ns(this, u, this._options.crossHair), this.m_crossHairSource.selectPointMode().subscribe((e => {
						if (0 !== e && this.lineBeingCreated()) {
							const e = mt.tool.value();
							this.cancelCreatingLine(), mt.tool.setValue(e)
						}
					})), this._tagsChanged = new(q());
					const _ = new M.DefaultProperty("chartproperties.mainSeriesProperties");
					_.addExclusion("minTick"), _.addExclusion("priceAxisProperties.lockScale"), _.addExclusion("priceAxisProperties.percentage"), _.addExclusion("priceAxisProperties.indexedTo100"), _.addExclusion("priceAxisProperties.isInverted"), _.addExclusion("priceAxisProperties.log"), _.addExclusion("priceAxisProperties.logDisabled"), _.addExclusion("priceAxisProperties.percentageDisabled"), _.addExclusion("priceAxisProperties.autoScaleDisabled"), _.merge(i.childs().mainSeriesProperties.state()), this._timeScale = new it(this, this._options.timeScale);
					const m = {
						countdownEnabled: this._options.countdownEnabled,
						lastPriceAnimationEnabled: this._options.lastPriceAnimationEnabled
					};
					this.m_mainSeries = new as.Series(this, _, m, o), this.m_mainSeries.onStyleChanged().subscribe(this._timeScale, this._timeScale.invalidateVisibleBars);
					const p = () => this.fullUpdate();
					this.m_mainSeries.properties().childs().showCountdown.subscribe(this, (() => {
						this.m_mainSeries.updateAllViews((0, F.dataSourceChangeEvent)(this.m_mainSeries.id())), p()
					})), (0, Z.currencyUnitVisibilityProperty)().subscribe(this, p), this._timeScale.visibleBarsStrictRangeChanged().subscribe(this.m_mainSeries, this.m_mainSeries.clearHighLowPriceCache), this._timeScale.visibleBarsStrictRangeChanged().subscribe(this.m_mainSeries, this.m_mainSeries.clearAveragePriceCache), this.createPane(void 0, {
						axisProperties: _.childs().priceAxisProperties.state(["autoScale"])
					}), this._adjustForDividendsAvailability.subscribe(this._recalcAdjustForDividendsEnabled), this.mainSeries().properties().childs().dividendsAdjustment.subscribe(this, this._recalcAdjustForDividendsEnabled), this._recalcAdjustForDividendsEnabled(), this._boundUpdateStudiesMaxOffset = this._updateStudiesMaxOffset.bind(this), this.mainSeries().dataEvents().seriesTimeFrame().subscribe(this, ((e, t, i, s) => {
						if (null !== this._lastAppliedGotoTimeRange && null !== i && s && (0, Wt.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i)) {
							const e = this.appliedTimeFrame().value();
							null !== e && !this._lastAppliedGotoTimeRange.actual && (0,
								Wt.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, e.val) && this.appliedTimeFrame().setValue(null), this._lastAppliedGotoTimeRange = null
						}
					})), this.mainSeries().dataEvents().completed().subscribe(this, (() => {
						null === this._lastAppliedGotoTimeRange && null !== this._lastGotoTimeRange && (this.gotoTimeRange(this._lastGotoTimeRange.from, this._lastGotoTimeRange.to), this._lastGotoTimeRange = null)
					}))
				}
				setStudiesMetaData(e, t) {
					this._studiesMetaData = e, this._studyVersioning = new(w())(this._studiesMetaData, t)
				}
				restart() {
					this._chartApi.switchTimezone(this.timezone()), this._timeScale.reset(), this.m_mainSeries.restart();
					for (const e of this.dataSources()) e.restart && e !== this.m_mainSeries && e.restart();
					this.sessions().restart()
				}
				version() {
					return 3
				}
				collapsed() {
					return this._collapsedWV
				}
				chartSaveTime() {
					return this._chartSaveTime
				}
				setChartSaveTime(e) {
					this._chartSaveTime = e
				}
				destroy() {
					this._phantomSourceContainer.destroy(), this._hoveredSourceChanged.destroy(), null !== this._watermarkSource && (this._watermarkSource.destroy(), this._watermarkSource = null), Array.from(this._customSourcesMap.keys()).forEach(this._removeCustomSource, this), (0, o.assert)(0 === this._topmostCustomSources.length), (0, o.assert)(0 === this._fgCustomSources.length), (0, o.assert)(0 === this._bgCustomSources.length), (0, o.assert)(0 === this._allCustomSources.length), (0, o.assert)(0 === this._customSourcesMap.size), null !== this._esdWatcher && (this._esdWatcher.destroy(), this._esdWatcher = null), null !== this._alertsWatcher && (this._alertsWatcher.destroy(), this._alertsWatcher = null), this._properties.childs().paneProperties.childs().background.unsubscribeAll(this), this._properties.childs().paneProperties.childs().backgroundType.unsubscribeAll(this), this._properties.childs().paneProperties.childs().backgroundGradientEndColor.unsubscribeAll(this), this._properties.childs().paneProperties.childs().backgroundGradientStartColor.unsubscribeAll(this), this._watchedThemeSpawn.destroy(), this._lastHoveredHittestData = null, this._lastSelectedHittestData = null, (0, Z.currencyUnitVisibilityProperty)().unsubscribeAll(this), this._destroyed = !0
				}
				undoModel() {
					return this._undoModel
				}
				onData(e) {
					switch (e.method) {
						case "timescale_update": {
							const t = e.params;
							this._updateTimeScale({
								index: t.index,
								zoffset: t.zoffset,
								values: t.changes,
								indexDiffs: t.index_diff,
								baseIndex: t.baseIndex,
								marks: t.marks,
								clearFlag: t.clear
							});
							break
						}
						case "timescale_completed": {
							const t = Boolean(e.params[0]);
							this._timeScale.onTimeScaleCompleted(t);
							break
						}
					}
				}
				addStrategySource(e, t) {
					1 !== t && -1 === this._strategySources.indexOf(e) && (this._strategySources.push(e), this._strategySourcesChange.fire(t), this.setActiveStrategySource(e))
				}
				removeStrategySource(e, t) {
					if (1 === t) return;
					const i = this._strategySources.indexOf(e);
					if (-1 !== i) {
						if (this._strategySources.splice(i, 1)[0] === this._activeStrategySource.value() && this.unsetActiveStrategySource(), this._strategySources.length > 0) {
							const e = this._strategySources[this._strategySources.length - 1];
							this.setActiveStrategySource(e)
						}
						this._strategySourcesChange.fire(t)
					}
				}
				setActiveStrategySource(e) {
					-1 !== this._strategySources.indexOf(e) && this._activeStrategySource.setValue(e)
				}
				unsetActiveStrategySource() {
					this._activeStrategySource.setValue(null)
				}
				activeStrategySource() {
					return this._activeStrategySource
				}
				strategySources() {
					return this._strategySources
				}
				strategySourcesChange() {
					return this._strategySourcesChange
				}
				setScrollEnabled(e) {
					this._scrollEnabled = e
				}
				scrollEnabled() {
					return this._scrollEnabled
				}
				setZoomEnabled(e) {
					this._zoomEnabled = e
				}
				zoomEnabled() {
					return this._zoomEnabled
				}
				zoomToViewport(e, t, i, s, o) {
					this.setTimeViewport(e, t);
					let r = Math.min(i, s),
						n = Math.max(i, s);
					const a = o.defaultPriceScale();
					a.isPercentage() || a.setMode({
						autoScale: !1
					}), a.isLog() && (r = a.priceToLogical(r), n = a.priceToLogical(n)), a.setPriceRange(new ue.PriceRange(r, n)), this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.invalidate(this._paneInvalidationMask(o, X.InvalidationLevel.Light)), this._setScalesResetAvailable(!0)
				}
				setTimeViewport(e, t) {
					const i = this.appliedTimeFrame().value();
					null !== this._lastAppliedGotoTimeRange && null !== i && (0, Wt.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i.val) && !this._lastAppliedGotoTimeRange.actual || (this.timeScale().zoomToBarsRange(e, t), this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.recalcVisibleRangeStudies(), this.lightUpdate())
				}
				onTagsChanged() {
					return this._tagsChanged
				}
				canZoomIn() {
					return this._timeScale.canZoomIn() && this._zoomEnabled
				}
				canZoomOut() {
					return this._timeScale.canZoomOut() && this._zoomEnabled
				}
				onPaneTagsChanged() {
					this._tagsChanged.fire()
				}
				panesCollectionChanged() {
					return this._panesCollectionChanged
				}
				dataSourceCollectionChanged() {
					return this._dataSourceCollectionChanged
				}
				symbolSourceCollectionChanged() {
					return this._symbolSourceCollectionChanged
				}
				symbolSourceResolved() {
					return this._symbolSourceResolved
				}
				symbolSourceResolvingActive() {
					return this._symbolSourceResolvingActive
				}
				adjustForDividendsAvailability() {
					return this._adjustForDividendsAvailability
				}
				adjustForDividendsEnabled() {
					return this._adjustForDividendsEnabled
				}
				paneCollapsingAvailable() {
					return this._paneCollapsingAvailable
				}
				sourcePropertiesChanged() {
					return this._sourceProperitesChanged
				}
				sourceZOrderChanged() {
					return this._sourceZOrderChanged
				}
				zoomTime(e, t, i) {
					if (!this._zoomEnabled) return;
					const s = this.timeScale();
					if (s.isEmpty() || 0 === t) return;
					const o = s.width();
					e = Math.max(1, Math.min(e, o - 2)), s.zoom(e, t, i), this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.lightUpdate(), this.recalcVisibleRangeStudies(), this._setScalesResetAvailable(!0)
				}
				linePointBeingEdited() {
					return this._linePointBeingEdited
				}
				activeItemBeingMoved() {
					return this._activeItemBeingMoved
				}
				linePointBeingChanged() {
					return this._linePointBeingChanged
				}
				updateAllPaneViews(e) {
					for (const t of this._panes) t.updateAllViews(e);
					for (const t of this.barsMarksSources()) t.updateAllViews(e)
				}
				dataSources() {
					const e = [this.crossHairSource()];
					for (const t of this._panes)
						for (const i of t.dataSources()) e.push(i);
					return e
				}
				priceDataSources() {
					const e = [];
					for (const t of this._panes)
						for (const i of t.priceDataSources()) e.push(i);
					return e
				}
				symbolSources() {
					const e = [];
					for (const t of this._panes)
						for (const i of t.symbolSources()) e.push(i);
					return e
				}
				selection() {
					return this._selection
				}
				selectionMacro(e, t = !1) {
					const i = this.selection().allSources();
					e({
						removeSourceFromSelection: this._removeSourceFromSelection,
						addSourceToSelection: this._addSourceToSelection,
						clearSelection: this._clearSelection,
						selection: this.selection.bind(this)
					});
					const s = (0, S.subtract)(i, this.selection().allSources()),
						o = (0, S.subtract)(this.selection().allSources(), i);
					o.concat(i).forEach((e => e.updateAllViews((0, F.selectionChangeEvent)())));
					let r = [];
					s.forEach((e => {
						if ((0, f.isLineTool)(e)) {
							const i = e.hasAlert.value() && e.getAlertSync();
							i && i.set("selected", !1), !t && e.shouldBeRemovedOnDeselect() && r.push(e)
						}
					})), o.forEach((e => {
						const t = (0, f.isLineTool)(e) && e.hasAlert && e.hasAlert.value() && e.getAlertSync();
						t && t.set("selected", !0)
					})), r = r.filter((e => null !== this.dataSourceForId(e.id()))), r.length > 0 && this._undoModel.removeSources(r, !1, ds), this.lightUpdate(), (s.length > 0 || o.length > 0) && this._selectedSourceChanged.fire()
				}
				onSelectedSourceChanged() {
					return this._selectedSourceChanged
				}
				checkLineToolSelection() {
					const e = this.selection().allSources();
					this._selection.checkLineToolSelection(), e.length !== this.selection().allSources().length && this._selectedSourceChanged.fire()
				}
				lineToolsGroupModel() {
					return this._lineToolsGroupModel
				}
				restoreLineToolsGroups(e) {
					this._lineToolsGroupModel = at.fromState(this, e)
				}
				realignLineTools(e) {
					for (const t of this._panes)(void 0 === e || t.hasDataSource(e)) && t.realignLineTools(e) && this._dataSourceCollectionChanged.fire(t)
				}
				isSnapshot() {
					return this._isSnapshot
				}
				onWidget() {
					return this._options.onWidget
				}
				hideIdeas() {
					return this._options.hideIdeas
				}
				updateSource(e) {
					const t = this._invalidationMaskForSource(e);
					null !== t && this.invalidate(t)
				}
				updateSourcePriceScale(e) {
					const t = this._invalidationMaskForSourcePriceScale(e);
					null !== t && this.invalidate(t)
				}
				updatePane(e) {
					this.invalidate(this._paneInvalidationMask(e))
				}
				replaceStudyStub(e, t) {
					const i = this.paneForSource(e);
					if (null === i) return !1;
					const s = e.priceScale(),
						o = e.zorder(),
						r = e.ownerSource();
					return this.paneForSource(e) === i ? i.replaceSource(e, t, s) : (i.insertDataSource(t, s, o), this.removeSource(e)), t.setOwnerSource(r), this.dataSources().forEach((i => {
						i.ownerSource() === e && i.setOwnerSource(t)
					})), t.start(), this.recalculatePane(i, (0, F.dataSourceChangeEvent)(t.id())), this.fullUpdate(), !0
				}
				insertStudyStub(e) {
					const t = this.mainSeries(),
						i = (0, o.ensureNotNull)(this.paneForSource(t)),
						s = new T.StudyStub(this, null, e),
						r = i.createPriceScaleAtPosition("overlay");
					return i.addDataSource(s, r, !1), this.recalculatePane(i, (0, F.dataSourceChangeEvent)(s.id())), this.fullUpdate(), s
				}
				removeStudyStub(e) {
					const t = this.dataSourceForId(e);
					return null === t ? (us.logNormal("StudyStub id=" + e + " is not found in chart model"), !1) : (this.removeSource(t), !0)
				}
				setHoveredSource(e, t = null) {
					const i = this._hoveredSource !== e;
					if (!i && this._lastHoveredHittestData === t) return;
					this._lastHoveredHittestData = t;
					let s = null;
					if (this._hoveredSource) {
						this._hoveredSource.updateAllViews((0, F.selectionChangeEvent)()), s = new X.InvalidationMask(X.InvalidationLevel.Cursor);
						const e = this._invalidationMaskForSource(this._hoveredSource, X.InvalidationLevel.Light);
						null !== e && s.merge(e)
					}
					if (this._hoveredSource = e, e) {
						e.updateAllViews((0,
							F.selectionChangeEvent)()), s || (s = new X.InvalidationMask(X.InvalidationLevel.Cursor));
						const t = this._invalidationMaskForSource(e, X.InvalidationLevel.Light);
						null !== t && s.merge(t)
					}
					s && this.invalidate(s), i && this._hoveredSourceChanged.fire(e)
				}
				properties() {
					return this._properties
				}
				disconnect() {
					this.sessions().stop();
					for (const e of this.dataSources()) e.disconnect && e.disconnect();
					this._timeScale.disconnect()
				}
				gridSource() {
					return this._gridSource
				}
				hoveredSource() {
					return this._hoveredSource
				}
				hoveredSourceChanged() {
					return this._hoveredSourceChanged
				}
				lastHittestData() {
					return this._lastHoveredHittestData
				}
				lastSelectedHittestData() {
					return this._lastSelectedHittestData
				}
				syncTimeWithModel(e, t) {
					const i = this.mainSeries().syncModel();
					if (null === i) return;
					const s = 1e3 * this.createSyncPoint(e, i.syncSourceTarget()).sourceTimeToTargetTime(t / 1e3),
						o = (0, lt.get_timezone)(this.timezone());
					let r = (0, lt.utc_to_cal)(o, s);
					this.mainSeries().isDWM() && (r = i.getSession().spec.correctTradingDay(r), (0, lt.set_hms)(r, 0, 0, 0, 0, (0, lt.get_timezone)("Etc/UTC"))), this._gotoTimeImpl(r.getTime(), {
						centerIfVisible: !1
					})
				}
				gotoTime(e) {
					return this._gotoTimeImpl(e, {
						centerIfVisible: !0
					})
				}
				recalculatePane(e, t) {
					null == e || e.recalculate(t)
				}
				recalculateAllPanes(e) {
					this._panes.forEach((t => t.recalculate(e))), this.updateAllPaneViews(e), this.crossHairSource().updateAllViews(e)
				}
				gotoTimeRange(e, t) {
					const i = this.timeScale(),
						s = i.tickMarks(),
						r = this.mainSeries();
					if (void 0 === s.minIndex) return;
					let n = e,
						a = t;
					const l = r.symbolInfo();
					if (null !== l) {
						let i = this.properties().childs().timezone.value();
						"exchange" === i && (i = l.timezone);
						const s = (0, lt.get_timezone)(i),
							o = (0, lt.utc_to_cal)(s, e),
							c = (0, lt.utc_to_cal)(s, t);
						if (r.isDWM()) {
							const e = (0, lt.get_timezone)("Etc/UTC");
							(0, lt.set_hms)(o, 0, 0, 0, 0, e), (0, lt.set_hms)(c, 0, 0, 0, 0, e)
						}
						n = o.getTime(), a = c.getTime()
					}
					const c = (0, o.ensureDefined)(s.maxIndex),
						h = (0, o.ensureNotNull)(s.indexToTime((0, o.ensureDefined)(s.minIndex))).valueOf();
					if (h - n <= 0 && h - a <= 0) {
						const e = (e, t) => e < t,
							t = e => (0, o.ensureNotNull)(s.indexToTime(e)).valueOf(),
							r = (0, S.lowerboundExt)(t, n, e, s.nearestIndex(n), c);
						let l = (0, S.lowerboundExt)(t, a, e, s.nearestIndex(a), c);
						if (this._lastGotoTimeRange = null, null !== this._lastAppliedGotoTimeRange && (this._lastAppliedGotoTimeRange.actual = !1), gs) {
							const e = i.baseIndex();
							if (r + Math.max(l - r + 1, i.minVisibleBarCount()) > e) {
								const t = i.defaultRightOffset().value();
								l - e < t && (l = e + t)
							}
						}
						if (r !== l) i.zoomToBarsRange(r, l), this.lightUpdate();
						else {
							this.startScrollTime(0);
							const e = ((0, o.ensureNotNull)(i.logicalRange()).left() - r + 1) * i.barSpacing();
							this.scrollTimeTo(e), this.endScrollTime()
						}
					} else {
						const i = {
							type: "time-range",
							from: e / 1e3,
							to: t / 1e3
						};
						null === this._lastAppliedGotoTimeRange ? (this._lastAppliedGotoTimeRange = {
							range: i,
							actual: !0
						}, r.loadDataTo(i)) : (0, Wt.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i) || (this._lastGotoTimeRange = {
							from: e,
							to: t
						})
					}
				}
				paneForSource(e) {
					if (!(0, g.isDataSource)(e)) return Array.from(this._customSourcesMap.values()).includes(e) ? this.paneForSource(this.mainSeries()) : null;
					for (let t = this._panes.length - 1; t >= 0; t--)
						if (this._panes[t].hasDataSource(e)) return this._panes[t];
					return e instanceof Lt.BarsMarksContainer ? this.paneForSource(this.mainSeries()) : null
				}
				mainPane() {
					for (const e of this._panes)
						if (e.isMainPane()) return e;
					throw new Error("Main pane is not found")
				}
				lastPane() {
					return this._panes[this._panes.length - 1]
				}
				removeSource(e, t) {
					this.selectionMacro((t => t.removeSourceFromSelection(e)), !0), this._hoveredSource === e && (this._hoveredSource = null, this._lastHoveredHittestData = null), this._sourcesBeingMoved.includes(e) && (this._sourcesBeingMoved = this._sourcesBeingMoved.filter((t => t !== e)), this._sourcesBeingMoved.length || (this._activeItemBeingMoved = null)), e === this._lineBeingEdited && (this._lineBeingEdited = null, mt.isToolEditingNow.setValue(!1)), e === this._lineBeingCreated && (this._lineBeingCreated = null, mt.isToolCreatingNow.setValue(!1)), e.stop && e.stop();
					(0, o.ensureNotNull)(this.alertsWatcher()).removeSourceAlertLabels(e);
					const i = this.detachSource(e),
						s = this.mainSeries().priceScale();
					return (0, G.isStudy)(e) && (0, _e.isSymbolSource)(e) && e.priceScale() === s && s.isPercentage() && 1 === s.seriesLikeSources().length && s.setMode({
						percentage: !1
					}), this.fullUpdate(), this._invalidateBarColorerCaches(), (0, G.isStudy)(e) && ((0, _.emit)("study_event", e.id(), "remove"), e.isChildStudy() && e.parentSource().unsetChild(e), e.maxOffset().unsubscribe(this._boundUpdateStudiesMaxOffset)), e.destroy && e.destroy(), (0, f.isLineTool)(e) && (e.removeAlert(), (0, _.emit)("drawing_event", e.id(), "remove")), i
				}
				allStudies(e) {
					const t = e ? e => (0, G.isStudy)(e) && !(0, G.isESDOrRollDatesStudy)(e) : G.isStudy;
					return this._getAllSources(t)
				}
				findNonOverlayStudyWithGroupingKey(e, t) {
					const i = void 0 !== t ? [t] : this._panes;
					for (const t of i) {
						const i = t.dataSources().find((i => (0, G.isStudy)(i) && i.metaInfo().groupingKey === e && !t.isOverlay(i)));
						if (void 0 !== i) return {
							pane: t,
							study: i
						}
					}
					return null
				}
				movePaneUp(e) {
					this.movePane(e, e - 1)
				}
				movePaneDown(e) {
					this.movePane(e, e + 1)
				}
				movePane(e, t) {
					const i = this._panes[e];
					this._panes.splice(e, 1), this._panes.splice(t, 0, i), this._panesCollectionChanged.fire(this._panes), this._onRearrangePanes.fire(), this.invalidate(X.InvalidationMask.panesOrder())
				}
				backgroundColor() {
					return this._backgroundColor
				}
				backgroundTopColor() {
					return this._backgroundTopColor
				}
				backgroundColorAtYPercentFromTop(e) {
					const t = this.backgroundColor().value(),
						i = this.backgroundTopColor().value();
					if (t === i) return t;
					if (e = Math.max(0, Math.min(100, Math.round(100 * e))), null === this._gradientColorsCache || this._gradientColorsCache.topColor !== i || this._gradientColorsCache.bottomColor !== t) this._gradientColorsCache = {
						topColor: i,
						bottomColor: t,
						colors: new Map
					};
					else {
						const t = this._gradientColorsCache.colors.get(e);
						if (void 0 !== t) return t
					}
					const s = (0, kt.gradientColorAtPercent)(i, t, e / 100);
					return this._gradientColorsCache.colors.set(e, s), s
				}
				backgroundCounterColor() {
					const e = this.backgroundColor().value();
					if (void 0 === this._lastBackgroundColor || void 0 === this._lastOriginalColor || e !== this._lastBackgroundColor) {
						const t = (0, n.rgbToBlackWhiteString)((0, n.parseRgb)(e), 150);
						this._lastBackgroundColor = e, this._lastOriginalColor = "black" === t ? "white" : "black"
					}
					return this._lastOriginalColor
				}
				isDark() {
					return "white" === this.backgroundCounterColor()
				}
				defaultResolutions() {
					return this.chartApi().defaultResolutions()
				}
				availableCurrencies() {
					const e = this._getAvailableCurrencies();
					return e.length !== this._availableCurrencies.size() && (this._availableCurrencies = new Nt(e)), this._availableCurrencies
				}
				currencyConversionEnabled() {
					return this._options.currencyConversionEnabled
				}
				availableUnits() {
					const e = this._getAvailableUnits();
					return this._availableUnits.unitsChanged(e) && (this._availableUnits = new Bt(e)), this._availableUnits
				}
				unitConversionEnabled() {
					return this._options.unitConversionEnabled
				}
				resetDeferredStudies() {
					Ce.instance(this).reset()
				}
				isJustClonedChart() {
					return this._undoModel.isJustClonedChart()
				}
				studyTemplate(e, t, i) {
					const s = {
						panes: [],
						version: this.version()
					};
					for (const e of this.panes()) s.panes.push(e.state(!0, !1, !0));
					const o = this.mainSeries();
					return e && (s.symbol = o.symbol(), this.currencyConversionEnabled() && i && (s.currency = o.currency()), this.unitConversionEnabled() && i && (s.unit = o.unit())), t && (s.interval = o.interval()), s
				}
				restoreLineToolState(e, t, i) {
					e.restorePoints(t.points, t.indexes || []), e.properties().merge(t.state), e.restoreData && e.restoreData(t), e.linkKey().setValue(t.linkKey || null), e.createServerPoints(), this.fullUpdate();
					const s = e.linkKey().value();
					null !== s && i && (0, mt.restoreLineToolState)({
						model: this,
						linkKey: s,
						state: t
					})
				}
				preferences() {
					return (0, cs.preferencesByWhiteList)(this, this.mainSeries())
				}
				restoreTheme(e, t, i) {
					e.mainSourceProperties.hollowCandleStyle || (e.mainSourceProperties.hollowCandleStyle = e.mainSourceProperties.candleStyle), this._undoModel.chartLoadTheme(e, t, i)
				}
				onResetScales() {
					return this._resetScales
				}
				startMovingSources(e, t, i, s, r, n) {
					this._sourcesBeingMoved = e, this._activeItemBeingMoved = i;
					let a = !1;
					if (this._sourcesBeingMoved.forEach((e => {
							!a && (0, G.isStudy)(e) && (a = !0);
							const l = (0, o.ensureNotNull)(this.paneForSource(e)),
								c = (0, f.isLineTool)(e),
								h = c && e.linkKey().value();
							if (!1 !== h && null !== h && s.has(h) && c && e.isFixed()) {
								const t = (0, o.ensureDefined)(s.get(h)),
									a = {
										screen: this._percentPositionToPoint(t, l)
									};
								e.startMoving(a, i, r, n)
							} else e.startMoving(t, i, r, n);
							const d = this._paneInvalidationMask(l, X.InvalidationLevel.Light);
							this.invalidate(d)
						})), !n) {
						const s = e.filter(f.isLineTool).filter((e => e.linkKey().value() && e.isSynchronizable())).map((e => e.linkKey().value()));
						if (s.length && t.logical) {
							const n = this.externalTimeStamp(t.logical.index),
								a = {
									linkKeys: s,
									model: this,
									symbol: this.mainSeries().symbol(),
									point: {
										price: t.logical.price,
										timeStamp: n
									},
									activeItem: null !== i ? i : void 0,
									envState: r,
									pointPositionPercents: new Map
								};
							e.forEach((e => {
								if ((0, f.isLineTool)(e)) {
									const i = e.linkKey().value();
									if (i && e.isSynchronizable() && e.isFixed()) {
										const s = (0, o.ensureNotNull)(this.paneForSource(e));
										a.pointPositionPercents.set(i, this._pointToPercentPosition((0, o.ensureDefined)(t.screen), s))
									}
								}
							})), (0, mt.startMovingLineTool)(a)
						}
					}
					mt.isToolMovingNow.setValue(!0), a && mt.isStudyEditingNow.setValue(!0)
				}
				moveSources(e, t, i, s) {
					if (this._sourcesBeingMoved.filter((e => !e.isLocked || !e.isLocked())).forEach((r => {
							const n = (0, f.isLineTool)(r) ? r.linkKey().value() : null;
							if (null !== n && t.has(n)) {
								const e = (0, o.ensureNotNull)(this.paneForSource(r)),
									a = (0,
										o.ensureDefined)(t.get(n)),
									l = {
										screen: this._percentPositionToPoint(a, e)
									};
								r.move(l, this._activeItemBeingMoved, i, s)
							} else r.move(e, this._activeItemBeingMoved, i, s)
						})), this.lightUpdate(), !s && e.logical) {
						const t = this._sourcesBeingMoved.filter(f.isLineTool).filter((e => e.isSynchronizable() && !!e.linkKey().value())).map((e => e.linkKey().value())),
							s = this.externalTimeStamp(e.logical.index),
							r = {
								linkKeys: t,
								model: this,
								point: {
									price: e.logical.price,
									timeStamp: s
								},
								envState: i,
								pointPositionPercents: new Map
							};
						this._sourcesBeingMoved.filter(f.isLineTool).forEach((t => {
							if (t.linkKey().value() && t.isSynchronizable() && t.isFixed()) {
								const i = (0, o.ensureNotNull)(this.paneForSource(t));
								r.pointPositionPercents.set(t.linkKey().value(), this._pointToPercentPosition((0, o.ensureDefined)(e.screen), i))
							}
						})), (0, mt.moveLineTool)(r)
					}
				}
				endMovingSources(e, t, i) {
					const s = this._sourcesBeingMoved.map((s => {
							const r = (0, o.ensureNotNull)(this.paneForSource(s)),
								n = s.endMoving(e, t, i),
								a = this._paneInvalidationMask(r, X.InvalidationLevel.Light);
							return a.invalidateAll(X.InvalidationLevel.Light), this.invalidate(a), n
						})),
						r = this._sourcesBeingMoved.filter(f.isLineTool).filter((e => e.isSynchronizable() && !!e.linkKey().value())).map((e => e.linkKey().value())),
						n = this._sourcesBeingMoved.filter(f.isLineTool).filter((e => e.isSynchronizable() && !!e.linkKey)).map((e => {
							const t = {
								points: e.normalizedPoints(),
								interval: this.mainSeries().interval()
							};
							return e.isFixed() && (t.pointPositionPercents = e.calcPositionPercents()), t
						}));
					r.length && (0, mt.finishMovingLineTool)({
						linkKeys: r,
						model: this,
						finalStates: n,
						changes: s
					}), this._sourcesBeingMoved = [], this._activeItemBeingMoved = null, mt.isToolMovingNow.setValue(!1), mt.isStudyEditingNow.setValue(!1)
				}
				sourcesBeingMoved() {
					return this._sourcesBeingMoved
				}
				setMovingCustomSource(e, t) {
					this._customSourceBeingMoved = e, this._customSourceBeingMovedHitTestData = null !== t ? {
						beingMoved: !1,
						...t
					} : null
				}
				processingCustomSourceMove() {
					null !== this._customSourceBeingMovedHitTestData && (this._customSourceBeingMovedHitTestData.beingMoved = !0)
				}
				customSourceMovingHitTestData() {
					return this._customSourceBeingMovedHitTestData
				}
				customSourceBeingMoved() {
					return null !== this._customSourceBeingMovedHitTestData && this._customSourceBeingMovedHitTestData.beingMoved ? this._customSourceBeingMoved : null
				}
				width() {
					return this._width
				}
				setWidth(e, t) {
					this._width = e, this._timeScale.setWidth(e, t);
					for (const t of this._panes) t.setWidth(e);
					this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.recalcVisibleRangeStudies()
				}
				setPaneHeight(e, t) {
					e.setHeight(t), this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.lightUpdate()
				}
				isScalesResetAvailableChanged() {
					return this._isScalesResetAvailableChanged
				}
				isScalesResetAvailable() {
					return this._isScalesResetAvailable
				}
				panes() {
					return this._panes
				}
				paneForId(e) {
					return this._panes.find((t => t.id() === e)) || null
				}
				createPane(e, t, i) {
					const s = this._undoModel.chartWidget();
					s.isMaximizedPane() && s.toggleMaximizePane(null);
					const o = this._properties.childs().paneProperties;
					t && o.merge(t);
					const r = new De(this._timeScale, o, this, i);
					return void 0 !== e ? this._panes.splice(e, 0, r) : this._panes.push(r),
						r.onTagsChanged().subscribe(this, Ss.prototype.onPaneTagsChanged), r.dataSourcesCollectionChanged().subscribe(this, (() => this._dataSourceCollectionChanged.fire(r))), r.symbolSourceCollectionChanged().subscribe(this, (() => this._onSymbolSourceCollectionChanged(r))), r.sourcePropertiesChanged().subscribe(this, (e => this._sourceProperitesChanged.fire(r, e))), r.sourceZOrderChanged().subscribe(this, (e => this._sourceZOrderChanged.fire(r, e))), r.symbolSourceResolved().subscribe(this, (e => this._symbolSourceResolved.fire(r, e))), r.symbolSourceResolvingActive().subscribe(this._recalcSymbolResolvingActive), r.collapsed().subscribe(this._recalcPaneCollapsingAvailable), this._recalcPaneCollapsingAvailable(), this._panesCollectionChanged.fire(this._panes), this.invalidate(X.InvalidationMask.panesOrder()), r
				}
				removePane(e) {
					const t = this._undoModel.chartWidget();
					t.isMaximizedPane() && t.toggleMaximizePane(null);
					const i = e;
					i.destroy();
					const s = this._panes.indexOf(i); - 1 !== s && (this._panes.splice(s, 1), e.dataSourcesCollectionChanged().unsubscribeAll(this), e.symbolSourceCollectionChanged().unsubscribeAll(this), e.sourcePropertiesChanged().unsubscribeAll(this), e.onTagsChanged().unsubscribeAll(this), e.symbolSourceResolved().unsubscribeAll(this), i.symbolSourceResolvingActive().unsubscribe(this._recalcSymbolResolvingActive), e.collapsed().unsubscribe(this._recalcPaneCollapsingAvailable), this._recalcPaneCollapsingAvailable(!0));
					this.crossHairSource().pane === e && this.clearCurrentPosition(), this._panesCollectionChanged.fire(this._panes), this.invalidate(X.InvalidationMask.panesOrder())
				}
				changePanesHeight(e, t) {
					if (this._panes.length < 2) return;
					(0, o.assert)(e >= 0 && e < this._panes.length, "Invalid pane index");
					const i = this._panes[e],
						s = this._panes.reduce(((e, t) => e + t.stretchFactor()), 0),
						r = this._panes.reduce(((e, t) => e + t.height()), 0),
						n = r - 30 * (this._panes.length - 1);
					t = Math.min(n, Math.max(30, t));
					const a = s / r,
						l = i.height();
					i.setStretchFactor(t * a);
					let c = t - l,
						h = this._panes.length - 1;
					for (const e of this._panes)
						if (e !== i) {
							const t = Math.min(n, Math.max(30, e.height() - c / h));
							c -= e.height() - t, h -= 1;
							const i = t * a;
							e.setStretchFactor(i)
						} this.fullUpdate()
				}
				clearCurrentPosition() {
					const e = this.crossHairSource();
					e.clearPosition(), (0, o.ensureNotNull)(e.dataWindowView()).update(), ms(this._panes), this.invalidate(X.InvalidationMask.cursor());
					const t = this._undoModel.chartWidget();
					t.chartWidgetCollection().syncCrosshair(null, t.id()), this._phantomSourceContainer.onCursorPositionUpdated()
				}
				setAndSaveCurrentPosition(e, t, i, s) {
					this.crossHairSource().saveOriginCoords(e, t), this.setCurrentPosition(e, t, i, s)
				}
				setCurrentPosition(e, t, i, s) {
					let r = NaN;
					const n = this._timeScale.coordinateToVisibleIndex(e),
						a = i.defaultPriceScale();
					let l = null;
					!a.isEmpty() && Number.isFinite(t) && (l = (0, o.ensureNotNull)(i.mainDataSource()).firstValue(), null !== l && (r = a.coordinateToPrice(t, l)));
					const c = this.crossHairSource(),
						h = 0 !== c.selectPointMode().value(),
						d = this.currentTool(),
						u = this.mainSeries(),
						_ = c.index,
						m = c.price,
						p = h || mt.isStudyEditingNow.value(),
						g = this._lineBeingCreated || this._lineBeingEdited || (0, f.isLineToolName)(d) || (0, mt.toolIsMeasure)(d) || p;
					!this._isSettingsExternalPosition && g ? (r = this._magnet.align(r, n, i), null !== l && this._setCorrectedPositionToCrosshair(n, r, i)) : this._magnet.resetLastValue();
					let S = null;
					if (isNaN(r) || (S = i), this._isTimeScrolling) {
						if (!this._isSettingsExternalPosition && h) {
							const e = u.bars().firstIndex(),
								t = u.bars().lastIndex();
							if (null !== e && null !== t) {
								const s = Math.min(Math.max(n, e), t);
								s !== n && this._setCorrectedPositionToCrosshair(s, r, i)
							}
						} else c.setPosition(c.index, r, S);
						return
					}
					c.setOnHoveredChartWidget(!0), c.setPosition(n, r, S), (0, o.ensureNotNull)(c.dataWindowView()).update(), ms(this._panes);
					const v = u.syncModel();
					if (this.crossHairSource().startMeasurePoint() || this._lineBeingCreated ? this.lightUpdate() : this.invalidate(X.InvalidationMask.cursor()), this._lineBeingCreated) {
						const e = this._lineBeingCreated.linkKey().value();
						if (!this._isSettingsExternalPosition) {
							const t = this._lineBeingCreated.setLastPoint({
								index: n,
								price: r
							}, s);
							if (this._lineBeingCreated.updateAllViews((0, F.dataSourceChangeEvent)(this._lineBeingCreated.id())), t.price === r && t.index === n || this._setCorrectedPositionToCrosshair(t.index, t.price, i), v && e) {
								const i = this._timeScale.points().roughTime(t.index, v.projectTime.bind(v));
								(0, mt.setLineToolLastPoint)({
									model: this,
									linkKey: e,
									point: {
										timeStamp: (0, o.ensureNotNull)(i),
										price: t.price
									}
								})
							}
						}
					}
					if (!this._isSettingsExternalPosition && null !== this._lineBeingEdited && null !== this._linePointBeingEdited) {
						const e = {
							index: n,
							price: r
						};
						this.changeLinePoint(e, s);
						const t = this._lineBeingEdited.alignCrossHairToAnchor(this._linePointBeingEdited) ? this._lineBeingEdited.getPoint(this._linePointBeingEdited) : e;
						null !== t && this._setCorrectedPositionToCrosshair(t.index, t.price, i)
					}
					if (!this._isSettingsExternalPosition && p) {
						const e = u.bars().firstIndex(),
							t = u.bars().lastIndex();
						if (null !== e && null !== t) {
							const s = Math.min(Math.max(n, e), t);
							s !== n && this._setCorrectedPositionToCrosshair(s, r, i)
						}
					}(_ !== n || m !== r) && this._syncCrosshair(s)
				}
				setExternalPosition(e, t) {
					let i;
					const s = this.crossHairSource();
					if (s.setOnHoveredChartWidget(!1), null !== e && (0, ve.isNumber)(e.timeStamp)) {
						const t = this.mainSeries().syncModel();
						if (t) {
							const s = this.createSyncPoint(e.syncSourceTarget, t.syncSourceTarget()).sourceTimeToTargetTime(e.timeStamp);
							i = this._timeScale.points().roughIndex(s, t.distance.bind(t))
						}
					}
					if (null !== e && null != i && Number.isFinite(i)) {
						this._isSettingsExternalPosition = !0;
						const r = (0, o.ensureNotNull)(this.paneForSource(this.mainSeries())),
							n = this._timeScale.indexToCoordinate(i),
							a = (0, o.ensureNotNull)(r.mainDataSource()).firstValue();
						if (null !== a) {
							let i = NaN;
							void 0 !== e.price && Number.isFinite(e.price) && (i = this.mainSeries().priceScale().priceToCoordinate(e.price, a)), s.clearOriginCoords(), this.setCurrentPosition(n, i, r, t)
						}
						return s.setOnHoveredChartWidget(!1), void(this._isSettingsExternalPosition = !1)
					}
					s.clearPosition(), (0, o.ensureNotNull)(s.dataWindowView()).update(), ms(this._panes), this.invalidate(X.InvalidationMask.cursor())
				}
				startScaleTime(e) {
					this._timeScale.startScale(e)
				}
				scaleTimeTo(e) {
					this._timeScale.scaleTo(e), this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.lightUpdate(), this._setScalesResetAvailable(!0)
				}
				endScaleTime() {
					this._timeScale.endScale(), this.lightUpdate(), this.recalcVisibleRangeStudies()
				}
				resetTimeScale() {
					this._timeScale.restoreDefault(), this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.recalcVisibleRangeStudies(), this.lightUpdate(), this._resetScales.fire(), this._setScalesResetAvailable(!1)
				}
				startScalePrice(e, t, i) {
					e.startScalePrice(t, i)
				}
				scalePriceTo(e, t, i) {
					e.scalePriceTo(t, i), this.mainSeries().priceScale().isLockScale() ? this.lightUpdate() : this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light)), this._setScalesResetAvailable(!0)
				}
				endScalePrice(e, t) {
					e.endScalePrice(t), this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
				}
				startTwoPointsScalePrice(e, t, i, s) {
					t.startTwoPointsScale(i, s)
				}
				twoPointsScalePriceTo(e, t, i, s) {
					t.twoPointsScale(i, s), this.invalidate(this._paneInvalidationMask(e)), this._setScalesResetAvailable(!0)
				}
				endTwoPointsScalePrice(e, t) {
					t.endTwoPointsScale(), this.invalidate(this._paneInvalidationMask(e))
				}
				resetPriceScale(e, t) {
					this._setScalesResetAvailable(!1), e.resetPriceScale(t), this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
				}
				restorePriceScaleState(e, t, i) {
					e.restorePriceScaleState(t, i), this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
				}
				currentTool() {
					return this._currentTool
				}
				setCurrentTool(e) {
					this._currentTool !== e && ((0, f.isLineToolName)(e) && this.selectionMacro((e => {
						e.clearSelection()
					})), this._currentTool = e, this._phantomSourceContainer.onToolChanged())
				}
				detachSource(e) {
					const t = this.paneForSource(e);
					return !!t && (t.removeDataSource(e), t.isEmpty() ? (this._lineBeingCreated && t === this._paneBeingCreatedLineOn && this.cancelCreatingLine(), this.removePane(t), !0) : (this.fullUpdate(), !1))
				}
				onRearrangePanes() {
					return this._onRearrangePanes
				}
				finishLineTool(e) {
					const t = e.linkKey().value();
					(0, mt.drawOnAllCharts)().value() && null !== t && e.isSynchronizable() && (0, mt.finishLineTool)({
						linkKey: t,
						model: this
					})
				}
				startChangingLinetool(e, t, i, s, r) {
					this._lineBeingEdited = e, this._linePointBeingChanged = t || null, this._linePointBeingEdited = void 0 === i ? null : i, this._lineBeingEdited.startChanging(i, t, r), mt.isToolEditingNow.setValue(!0);
					const n = (0, o.ensureNotNull)(this.paneForSource(e));
					this._lineBeingEdited.startDragPoint && void 0 !== i && void 0 !== t && this._lineBeingEdited.startDragPoint(i, t), r || void 0 === i || void 0 === t || this._lineBeingEdited.setPoint(i, t, s, r), this._lineBeingEdited.updateAllViews((0, F.dataSourceChangeEvent)(this._lineBeingEdited.id()));
					const a = this._paneInvalidationMask(n, X.InvalidationLevel.Light);
					this.invalidate(a);
					const l = e.linkKey().value();
					if (l && e.isSynchronizable() && void 0 !== i && void 0 !== t) {
						const e = (0, o.ensureNotNull)(this.externalTimeStamp(t.index));
						(0, mt.startChangingLineTool)({
							linkKey: l,
							model: this,
							symbol: this.mainSeries().symbol(),
							point: {
								price: t.price,
								timeStamp: e
							},
							pointIndex: i,
							envState: s || null
						})
					}
				}
				createLineTool(e, t, i, s, n, a, l) {
					if ((0, o.assert)((0, f.isLineToolName)(i), `Cannot create unknown line tool: ${i}`), s) {
						const e = {
								...hs.intervalsVisibilitiesDefaults
							},
							t = s.childs().intervalsVisibilities.state();
						(0, ve.merge)(e, null != t ? t : {});
						const o = s.state();
						o.intervalsVisibilities = e,
							s = (0, f.createLineToolProperties)(i, o, this)
					}
					const c = (0, f.createLineTool)(i, this, s, null, void 0, l);
					if ("LineToolExecution" !== i) {
						const e = "LineToolIcon" === i ? c.properties().childs().icon.value().toString(16).toUpperCase() : void 0;
						(0, d.trackEvent)("drawings", "Study_Drawing_" + i, e)
					}
					const h = !c.linkKey().value() && !n;
					a = (0, o.ensureDefined)(a || (0, o.ensureNotNull)(e.mainDataSource())), s || (0, f.prepareLineToolPropertiesByOwnerSource)(c.properties(), a), c.setOwnerSource(a);
					const u = a.priceScale();
					if (e.addDataSource(c, u, !1), (0, mt.drawOnAllCharts)().value()) {
						const e = c.isSynchronizable() ? n || (0, Q.randomHash)() : null;
						c.linkKey().setValue(e)
					} else c.linkKey().setValue(n);
					let _;
					if (c.isFixed()) {
						const i = (0, o.ensureNotNull)((0, o.ensureNotNull)(e.mainDataSource()).firstValue()),
							s = this._timeScale.indexToCoordinate(t.index),
							n = (0, o.ensureNotNull)(u).priceToCoordinate(t.price, i);
						_ = c.addFixedPoint(new r.Point(s, n))
					} else _ = c.addPoint(t);
					return _ || (this._lineBeingCreated = c, this._paneBeingCreatedLineOn = e, mt.isToolCreatingNow.setValue(!0)), h && c.enableCurrentIntervalVisibility(), this.fullUpdate(), c
				}
				endChangingLinetool(e, t) {
					const i = (0, o.ensureNotNull)(this._lineBeingEdited),
						s = i.endChanging(!1, e, t);
					this._lineBeingEdited = null, mt.isToolEditingNow.setValue(!1), this._linePointBeingEdited = null, this._linePointBeingChanged = null, this.lightUpdate();
					const r = {
							points: i.normalizedPoints(),
							interval: this.mainSeries().interval()
						},
						n = i.linkKey().value();
					null !== n && i.isSynchronizable() && !t && (0, mt.finishChangingLineTool)({
						model: this,
						linkKey: n,
						symbol: this.mainSeries().symbol(),
						finalState: r,
						changes: s
					})
				}
				continueCreatingLine(e, t, i, s) {
					const r = (0, o.ensureNotNull)(this._lineBeingCreated),
						n = r.addPoint(e, t, i);
					r.updateAllViews((0, F.dataSourceChangeEvent)(r.id()));
					const a = new X.InvalidationMask(X.InvalidationLevel.Light);
					return n && (this._paneBeingCreatedLineOn = null, this._lineBeingCreated = null, mt.isToolCreatingNow.setValue(!1)), this.invalidate(a), n
				}
				cancelCreatingLine() {
					if (!this._lineBeingCreated) return;
					const e = this._lineBeingCreated;
					this.removeSource(this._lineBeingCreated), this._lineBeingCreated = null, this._lineCancelled.fire(), mt.isToolCreatingNow.setValue(!1), (0, mt.drawOnAllCharts)().value() && e.isSynchronizable() && (0, mt.cancelLineTool)({
						model: this
					})
				}
				lineBeingCreated() {
					return this._lineBeingCreated
				}
				paneBeingCreatedLineOn() {
					return this._paneBeingCreatedLineOn
				}
				lineCancelled() {
					return this._lineCancelled
				}
				isPhantomLine(e) {
					return this._phantomSourceContainer.source() === e
				}
				changeLinePoint(e, t, i) {
					const s = (0, o.ensureNotNull)(this._lineBeingEdited),
						r = (0, o.ensureNotNull)(this._linePointBeingEdited);
					let n = e.price,
						a = e.index;
					if (s.setPoint(r, e, t, i), !i) {
						const t = s.alignCrossHairToAnchor(r) ? s.getPoint(r) : e;
						null !== t && (a = t.index, n = t.price)
					}
					s.updateAllViews((0, F.dataSourceChangeEvent)(s.id())), this.lightUpdate();
					const l = s.linkKey().value();
					if (!i && null !== l && s.isSynchronizable()) {
						const e = (0, o.ensureNotNull)(this._linePointBeingChanged),
							i = {
								indexesChanged: a !== e.index,
								pricesChanged: n !== e.price
							},
							c = s.getChangePointForSync(r);
						if (null !== c) {
							const e = this.externalTimeStamp(a);
							null !== e && (n = c.price, (0, mt.changeLineTool)({
								linkKey: l,
								model: this,
								symbol: this.mainSeries().symbol(),
								point: {
									price: n,
									timeStamp: e
								},
								envState: t,
								changes: i
							}))
						}
					}
				}
				changeLinePoints(e, t, i) {
					const s = e.points(),
						r = e.linkKey().value();
					!i && r && e.isSynchronizable() && t.forEach(((t, i) => {
						const n = s[i],
							a = n.price !== t.price,
							l = n.index !== t.index;
						if (e.getChangePointForSync(i)) {
							const e = (0, o.ensureNotNull)(this.externalTimeStamp(t.index));
							(0, mt.changeLineTool)({
								linkKey: r,
								model: this,
								symbol: this.mainSeries().symbol(),
								point: {
									price: t.price,
									timeStamp: e
								},
								changes: {
									pricesChanged: a,
									indexesChanged: l
								}
							})
						}
					})), e.setPoints(t), e.updateAllViews((0, F.dataSourceChangeEvent)(e.id())), this.lightUpdate()
				}
				startScrollTime(e) {
					this._timeScale.startScroll(e), this._isTimeScrolling = !0
				}
				scrollTimeTo(e) {
					this._timeScale.scrollTo(e), this.recalculateAllPanes((0, F.viewportChangeEvent)()), this.lightUpdate(), this._setScalesResetAvailable(!0)
				}
				endScrollTime() {
					this._timeScale.endScroll(), this.lightUpdate(), this.recalcVisibleRangeStudies(), this._isTimeScrolling = !1
				}
				startScrollPrice(e, t, i) {
					e.startScrollPrice(t, i)
				}
				scrollPriceTo(e, t, i) {
					e.scrollPriceTo(t, i), this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
				}
				endScrollPrice(e, t) {
					e.endScrollPrice(t), this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
				}
				addCustomSource(e, t, i = p.CustomSourceLayer.Foreground) {
					this._customSourcesMap.has(e) && us.logWarn(`Attempt to add the same custom source multiple time "${e}"`), us.logNormal(`Adding custom source "${e}"`);
					const s = t(e, this);
					switch (i) {
						case p.CustomSourceLayer.Background:
							this._bgCustomSources.push(s);
							break;
						case p.CustomSourceLayer.Foreground:
							this._fgCustomSources.push(s);
							break;
						case p.CustomSourceLayer.Topmost:
							this._topmostCustomSources.push(s);
							break;
						default:
							throw new Error(`Unknown custom sources layer ${i}`)
					}
					this._allCustomSources.push(s), this._customSourcesMap.set(e, s), this.lightUpdate()
				}
				removeCustomSource(e) {
					this._removeCustomSource(e), this.lightUpdate()
				}
				hasCustomSource(e) {
					return this._customSourcesMap.has(e)
				}
				customSourceForName(e) {
					return this._customSourcesMap.get(e) || null
				}
				customSourceName(e) {
					let t = null;
					return this._customSourcesMap.forEach(((i, s) => {
						i === e && (t = s)
					})), t
				}
				customSources(e) {
					switch (e) {
						case p.CustomSourceLayer.Background:
							return this._bgCustomSources;
						case p.CustomSourceLayer.Foreground:
							return this._fgCustomSources;
						case p.CustomSourceLayer.Topmost:
							return this._topmostCustomSources;
						default:
							return this._allCustomSources
					}
				}
				addMultiPaneSource(e) {
					this._multiPaneSources.push(e), this.lightUpdate()
				}
				removeMultiPaneSource(e) {
					const t = this._multiPaneSources.indexOf(e); - 1 === t ? us.logWarn("Attempt to remove multi-pane source which does not exist in the model") : this._multiPaneSources.splice(t, 1), this.lightUpdate()
				}
				multiPaneSources(e) {
					return this._multiPaneSources.filter((t => !e.hasDataSource(t)))
				}
				dateTimeFormatter() {
					return this._dateTimeFormatter
				}
				dateFormatter() {
					return this._dateFormatter
				}
				timeFormatter() {
					return this._timeFormatter
				}
				sessions() {
					return (0, o.ensureNotNull)(this._sessions)
				}
				createSessions(e) {
					(0, o.assert)(null === this._sessions, "Sessions are already created"),
					this.addCustomSource("sessions", ((t, i) => (this._sessions = new H(t, i, e), this._sessions.start(), this._sessions)), p.CustomSourceLayer.Background)
				}
				createPrePostMarket(e) {
					this.addCustomSource("prePostMarket", ((t, i) => new Mt.PrePostMarket(t, i, e)))
				}
				theme() {
					const e = this.properties().childs().paneProperties.state();
					delete e.topMargin, delete e.bottomMargin;
					const t = this.mainSeries().state().state;
					t && (delete t.symbol, delete t.interval, delete t.currencyId, delete t.unitId);
					const i = {
						mainSourceProperties: t,
						sessions: this.sessions().properties().state(),
						chartProperties: {
							paneProperties: e,
							scalesProperties: this.properties().childs().scalesProperties.state()
						},
						version: this.version()
					};
					return i.version = this.version(), i
				}
				onChartThemeLoaded() {
					return this._chartThemeLoaded
				}
				chartThemeLoaded() {
					this._chartThemeLoaded.fire()
				}
				state(e, t, i, s) {
					var o;
					const r = this.publishedChartsTimelineSource(),
						n = this.properties().childs(),
						a = n.tradingProperties.state(),
						l = {
							panes: this._panes.map((o => o.state(!0, e, !1, t, i, s))),
							timeScale: this._timeScale.state(e),
							chartProperties: {
								paneProperties: n.paneProperties.state(),
								scalesProperties: n.scalesProperties.state(),
								publishedChartsTimelineProperties: r ? r.state(e) : void 0,
								chartEventsSourceProperties: null === (o = n.chartEventsSourceProperties) || void 0 === o ? void 0 : o.state(),
								tradingProperties: a,
								priceScaleSelectionStrategyName: n.priceScaleSelectionStrategyName.value()
							},
							sessions: this.sessions().state(e),
							version: this.version(),
							timezone: this.timezone(),
							shouldBeSavedEvenIfHidden: this._shouldBeSavedEvenIfHidden
						};
					return s || (l.lineToolsGroups = this.lineToolsGroupModel().state(t)), l
				}
				restoreState(e, t, i) {
					Ce.instance(this).reset();
					const s = {};
					if (!e.panes) return void us.logDebug("ChartModel.restoreState: invalid state");
					if (!Array.isArray(e.panes)) return void us.logDebug("ChartModel.restoreState: invalid state");
					if (e.panes.length < 1) return void us.logDebug("ChartModel.restoreState: invalid state");
					if (this._shouldBeSavedEvenIfHidden = void 0 === e.shouldBeSavedEvenIfHidden || e.shouldBeSavedEvenIfHidden, e.chartProperties && !e.chartProperties.timezone && (e.chartProperties.timezone = e.timezone), e.chartProperties) {
						const i = (0, B.factoryDefaults)("chartproperties").scalesProperties;
						(0, ve.merge)(i, e.chartProperties.scalesProperties), !("showLastValue" in i) || "showSeriesLastValue" in i || "showStudyLastValue" in i || (i.showSeriesLastValueProperty = i.showLastValue, i.showStudyLastValueProperty = i.showLastValue), "showSeriesLastValue" in i && (s.showSeriesLastValueProperty = !0), "showStudyLastValue" in i && (s.showStudyLastValueProperty = !0), (!this.isSnapshot() && !this.readOnly() && "showCurrency" in i || "showUnit" in i) && (0, Z.migrateShowCurrencyAndShowUnitProperties)(i.showCurrency, i.showUnit), e.chartProperties.paneProperties.vertGridProperties = e.chartProperties.paneProperties.vertGridProperties || (0, ve.clone)(e.chartProperties.paneProperties.gridProperties), e.chartProperties.paneProperties.horzGridProperties = e.chartProperties.paneProperties.horzGridProperties || (0, ve.clone)(e.chartProperties.paneProperties.gridProperties),
							"backgroundType" in e.chartProperties.paneProperties || (e.chartProperties.paneProperties.backgroundType = Et.ColorType.Solid), "separatorColor" in e.chartProperties.paneProperties || (e.chartProperties.paneProperties.separatorColor = (0, h.getThemedColor)("color-chart-page-bg")), this._properties.childs().paneProperties.mergeAndFire(e.chartProperties.paneProperties), this._properties.childs().scalesProperties.mergeAndFire(i), e.chartProperties.timezone && this._properties.childs().timezone.setValue(e.chartProperties.timezone), e.chartProperties.chartEventsSourceProperties && this._properties.hasChild("chartEventsSourceProperties") && this._properties.childs().chartEventsSourceProperties.mergeAndFire(e.chartProperties.chartEventsSourceProperties), e.chartProperties.tradingProperties && this._properties.hasChild("tradingProperties") && (void 0 === e.chartProperties.tradingProperties.horizontalAlignment && (e.chartProperties.tradingProperties.horizontalAlignment = (o = e.chartProperties.tradingProperties.lineLength) <= 40 ? p.TradingSourcesHorizontalAlignment.Right : o >= 60 ? p.TradingSourcesHorizontalAlignment.Left : p.TradingSourcesHorizontalAlignment.Center), this._properties.childs().tradingProperties.mergeAndFire(e.chartProperties.tradingProperties)), this._timeScale.restoreState(e.timeScale, t), this._updateDateTimeFormatter()
					}
					var o;
					if (e.timeScale && this._timeScale.restoreState(e.timeScale, t), !this.readOnly()) {
						const t = this._getExceedingChildStudies(e.panes);
						if (t.length) {
							for (let i = e.panes.length - 1; i >= 0; --i) {
								const s = e.panes[i];
								for (let e = s.sources.length - 1; e >= 0; --e) {
									const i = s.sources[e];
									~t.indexOf(i) && s.sources.splice(e, 1)
								}
								s.sources.length || e.panes.splice(i, 1)
							}
							setTimeout((() => (0, xt.createGoProDialog)({
								feature: "studyOnStudy"
							})), 500)
						}
					}
					const r = e.version || 0,
						n = e.panes;
					this.panes()[0].restoreState(n[0], t, r, s, i, !0);
					let a = 1;
					for (let o = 1; o < e.panes.length; o++) {
						const n = e.panes[o];
						if (0 === n.sources.length) {
							us.logWarn("Empty pane detected - restoring is skipped. idx=" + o + ", state=" + JSON.stringify(n));
							continue
						}
						const l = this.panes()[a] || this.createPane();
						l.restoreState(n, t, r, s, i, !0), l.mainDataSource() ? a += 1 : this.removePane(l)
					}
					if (e.chartProperties && e.chartProperties.publishedChartsTimelineProperties) {
						const i = this.publishedChartsTimelineSource();
						i && i.restoreData(e.chartProperties.publishedChartsTimelineProperties, t)
					}
					this._invalidateBarColorerCaches();
					const l = this.dataSources();
					let c = 0;
					for (let e = 0; e < l.length; e++) {
						const t = l[e];
						(0, f.isLineTool)(t) && (c++, t.calcIsActualSymbol())
					}
					this.updateTimeScaleBaseIndex(), this.recalculateAllPanes((0, F.globalChangeEvent)()), this.fullUpdate(), this.syncESD();
					let d = m.TVLocalStorage.getItem("linetools_limit") || 1e3;
					return window.is_authenticated && window.user && window.user.settings && (d = window.user.settings.linetools_limit || d), e.sessions && this.sessions().restoreState(e.sessions, t), e.lineToolsGroups && (this._lineToolsGroupModel = at.fromState(this, e.lineToolsGroups)), c > d && c % 100 == 0 ? {
						lines_limit_exceeded: !0,
						line_tools_count: c
					} : (this.panes().forEach((e => this._dataSourceCollectionChanged.fire(e))), this._lineToolsGroupModel.fireChangedAll(), {})
				}
				shouldBeSavedEvenIfHidden() {
					return this._shouldBeSavedEvenIfHidden
				}
				setShouldBeSavedEvenIfHidden(e) {
					this._shouldBeSavedEvenIfHidden = e
				}
				externalTimeStamp(e) {
					const t = this.mainSeries().syncModel();
					return this.timeScale().points().roughTime(e, t && t.projectTime.bind(t))
				}
				syncESD() {
					null !== this._esdWatcher && this._esdWatcher.syncESDStudies()
				}
				recalcVisibleRangeStudies(e) {
					this._recalcVRStudiesParams.force = this._recalcVRStudiesParams.force || Boolean(e), this._recalcVisibleRangeStudiesImplDebounced()
				}
				recalcColorStudies(e) {
					this._recalcColorStudiesParams.force = this._recalcColorStudiesParams.force || Boolean(e), this._recalcColorStudiesImplDebounced()
				}
				alertsWatcher() {
					return this._alertsWatcher
				}
				showLegend() {
					return this._showLegendProperty
				}
				id() {
					return this._id
				}
				recalculatePriceRangeOnce() {
					const e = this.mainSeries();
					for (const t of this._panes)
						for (const i of t.priceDataSources()) i.symbolSource() === e && i.disablePriceRangeReady()
				}
				invalidate(e) {
					var t;
					null === (t = this._invalidateHandler) || void 0 === t || t.call(this, e)
				}
				appliedTimeFrame() {
					return this._appliedTimeFrame.appliedTimeFrame()
				}
				barsMarksSources() {
					return this._barsMarksSources
				}
				barMarksSourceForId(e) {
					for (const t of this._barsMarksSources)
						if (t.id() === e) return t;
					return null
				}
				createSyncPoint(e, t) {
					return (0, ls.getDefault2Lazy)(this._syncPointCache, e.uniqueId, t.uniqueId, (() => new _t(e, t)))
				}
				isAutoSaveEnabled() {
					return this._isAutoSaveEnabled
				}
				studyAwareDefaultRightOffset() {
					return Math.max(this._timeScale.defaultRightOffset().value(), this._cachedStudiesMaxOffset)
				}
				clearAllStudies() {
					this.dataSources().forEach((e => {
						var t;
						return null === (t = e.clearData) || void 0 === t ? void 0 : t.call(e)
					}))
				}
				_updateStudiesMaxOffset() {
					const e = Math.max(...this.allStudies().map((e => e.maxOffset().value())));
					this._cachedStudiesMaxOffset = e;
					const t = this._timeScale.rightOffset();
					t < 0 || this._timeScale.setRightOffset(Math.max(t, e))
				}
				_updateBaseIndex(e, t) {
					const i = this._timeScale,
						s = i.baseIndex(),
						o = i.visibleBarsStrictRange(),
						r = i.logicalRange();
					if (null !== r && t) {
						const t = r.contains(s),
							n = e - s;
						let a = t ? null : i.rightOffset() - n;
						if (!this._options.shiftVisibleRangeOnNewBar && t) {
							const e = i.indexToCoordinate(s) + i.barSpacing() / 2 + 1,
								t = s - r.left() + n,
								l = e / t;
							if (l >= i.minBarSpacing()) {
								i.setBarSpacing(l);
								a = i.width() / l - t
							} else(null == o ? void 0 : o.lastBar()) !== s && (a = i.rightOffset() - n)
						}
						null !== a && i.setRightOffset(a)
					}
					i.setBaseIndex(e)
				}
				_createESDWatcher() {
					this._esdWatcher = new wt(this)
				}
				_updateDateTimeFormatter() {
					const e = rt.dateFormatProperty.value(),
						t = new ot.DateFormatter(e);
					if (this._dateFormatter = t, this.mainSeries().isDWM()) this._dateTimeFormatter = t, this._timeFormatter = new Ze.TimeFormatter((0, $e.getHourMinuteFormat)());
					else {
						const t = P.Interval.parse(this.mainSeries().interval()),
							i = (0, $e.getTimeFormatForInterval)(t);
						this._dateTimeFormatter = new st.DateTimeFormatter({
							dateFormat: e,
							timeFormat: i,
							dateTimeSeparator: "   "
						}), this._timeFormatter = new Ze.TimeFormatter(i)
					}
				}
				_setScalesResetAvailable(e) {
					this._isScalesResetAvailable !== e && (this._isScalesResetAvailable = e, this._isScalesResetAvailableChanged.fire())
				}
				_invalidationMaskForSource(e, t = X.InvalidationLevel.Light) {
					if (e === this.crossHairSource()) return X.InvalidationMask.cursor();
					if (this._watermarkSource === e) return this._paneInvalidationMask((0, o.ensureNotNull)(this.paneForSource(this.mainSeries())), t);
					if (-1 !== this._allCustomSources.indexOf(e)) {
						const e = new X.InvalidationMask;
						return e.invalidateAll(t), e
					}
					if (!(0, g.isDataSource)(e)) return null;
					if (e.isMultiPaneEnabled()) return new X.InvalidationMask(t);
					const i = this.paneForSource(e);
					return null !== i ? this._paneInvalidationMask(i, t) : null
				}
				_paneInvalidationMask(e, t = X.InvalidationLevel.Light) {
					const i = new X.InvalidationMask,
						s = this._panes.indexOf(e);
					return i.invalidateAllPane(s, t), i
				}
				_invalidationMaskForSourcePriceScale(e, t = X.InvalidationLevel.Light) {
					if (!(0, g.isDataSource)(e)) return new X.InvalidationMask(t);
					const i = this.paneForSource(e);
					if (null === i) return null;
					let s = e.priceScale();
					if (null === s) return null;
					const o = this._panes.indexOf(i);
					let r = i.priceScalePosition(s);
					if ("overlay" === r) {
						const e = this._panes[o].defaultPriceScale();
						s = e, r = i.priceScalePosition(e)
					}
					const n = i.priceScaleIndex(s, r);
					if (void 0 === n) return null;
					const a = new X.InvalidationMask;
					return a.invalidatePriceScale(o, r, n, t), a
				}
				_removeCustomSource(e) {
					const t = this._customSourcesMap.get(e);
					if (void 0 === t) return void us.logWarn(`Attempt to remove custom source which does not exist in the model - "${e}"`);
					us.logNormal(`Removing custom source "${e}"`), this.selectionMacro((e => {
						e.removeSourceFromSelection(t)
					})), this._hoveredSource === t && this.setHoveredSource(null), this._customSourceBeingMoved === t && this.setMovingCustomSource(null, null);
					const i = _s(this._bgCustomSources, t),
						s = _s(this._fgCustomSources, t),
						r = _s(this._topmostCustomSources, t),
						n = _s(this._allCustomSources, t);
					(0, o.assert)(i || s || r, "Source should be presented in one of the layers"), (0, o.assert)(n, "Source should be presented in the array"), this._customSourcesMap.delete(e), t.destroy()
				}
				_updateShowLegendProperty() {
					const e = this._properties.childs().paneProperties.childs().legendProperties.childs().showLegend,
						t = this._showLegendProperty;
					if (e.value()) t.setValue(!0);
					else {
						for (const e of this._panes) {
							let i = 0;
							for (const s of e.priceDataSources())
								if (s !== this.mainSeries() && null !== s.statusView() && (i++, i > 1)) return void t.setValue(!1)
						}
						t.setValue(!0)
					}
				}
				_pointToPercentPosition(e, t) {
					return {
						x: e.x / this._timeScale.width(),
						y: e.y / (0, o.ensureNotNull)((0, o.ensureNotNull)(t.mainDataSource()).priceScale()).height()
					}
				}
				_percentPositionToPoint(e, t) {
					const i = e.x * this._timeScale.width(),
						s = e.y * (0, o.ensureNotNull)((0, o.ensureNotNull)(t.mainDataSource()).priceScale()).height();
					return new r.Point(i, s)
				}
				_recalcVisibleRangeStudiesImpl(e) {
					var t, i, s;
					if (e.timerId = null, this.timeScale().isEmpty()) return;
					const o = this.timeScale().visibleBarsStrictRange();
					if (null === o) return;
					const r = this.mainSeries().bars(),
						n = r.search(o.firstBar(), Vt.PlotRowSearchMode.NearestRight),
						a = r.search(o.lastBar(), Vt.PlotRowSearchMode.NearestLeft),
						l = r.lastIndex(),
						c = n ? n.index : void 0,
						h = a ? a.index : void 0,
						d = c === e.oldStartVisibleIndex,
						u = h === e.oldEndVisibleIndex;
					if (d && u && !e.force) return;
					e.force = !1, e.oldStartVisibleIndex = void 0 !== c ? c : NaN, e.oldEndVisibleIndex = void 0 !== h ? h : NaN;
					const _ = {
							first_visible_bar_time: 1e3 * (null !== (t = null == n ? void 0 : n.value[0]) && void 0 !== t ? t : 0),
							last_visible_bar_time: 1e3 * (null !== (i = null == a ? void 0 : a.value[0]) && void 0 !== i ? i : 0),
							subscribeRealtime: (null == a ? void 0 : a.index) === l
						},
						m = null !== (s = e.studies) && void 0 !== s ? s : this.priceDataSources();
					e.studies = void 0;
					for (const e of m)
						if ((0, G.isStudy)(e)) {
							const t = e.metaInfo().inputs,
								i = [];
							for (const e of t) _.hasOwnProperty(e.id) && i.push(e.id);
							const s = e.properties().childs().inputs;
							for (const e of i) s.childs()[e].setValueSilently(_[e]);
							i.length > 0 && s.listeners().fire(s)
						}
				}
				_recalcColorStudiesImpl(e) {
					var t;
					e.timerId = null;
					const i = this.backgroundColorAtYPercentFromTop(.5),
						s = this.isDark() ? a.colorsPalette["color-cold-gray-200"] : a.colorsPalette["color-cold-gray-900"],
						o = i === e.oldBgColor,
						r = s === e.oldFgColor;
					if (o && r && !e.force) return;
					e.force = !1, e.oldBgColor = i, e.oldFgColor = s;
					const n = {
							__chart_bgcolor: i,
							__chart_fgcolor: s
						},
						l = null !== (t = e.studies) && void 0 !== t ? t : this.priceDataSources();
					e.studies = void 0;
					for (const e of l)
						if ((0, G.isStudy)(e)) {
							const t = e.metaInfo().inputs,
								i = [];
							for (const e of t) n.hasOwnProperty(e.id) && i.push(e.id);
							const s = e.properties().childs().inputs;
							for (const e of i) s.childs()[e].setValueSilently(n[e]);
							i.length > 0 && s.listeners().fire(s)
						}
				}
				_getAllSources(e) {
					const t = [];
					for (const i of this._panes) {
						const s = i.sourcesByGroup().all();
						for (const i of s) e(i) && t.push(i)
					}
					return t
				}
				_invalidateBarColorerCaches() {
					this.mainSeries().invalidateBarColorerCache()
				}
				_updateTimeScale(e) {
					var t, i;
					const {
						index: s,
						zoffset: o,
						values: r,
						indexDiffs: n,
						baseIndex: a,
						marks: l,
						clearFlag: c
					} = e;
					if (c) {
						this._timeScale.reset();
						for (const e of this.dataSources()) null === (t = e.clearData) || void 0 === t || t.call(e)
					}
					if (n.length > 0)
						for (const e of this.dataSources()) null === (i = e.moveData) || void 0 === i || i.call(e, n);
					const h = this._timeScale.indexToTimePoint(this._timeScale.baseIndex()),
						d = this._timeScale.canNormalize();
					this._timeScale.update(s, o, r, l);
					let u = "ChartModel.prototype._updateTimeScale(" + s + "," + o + "," + r.length + "," + n.length + "," + l.length + "," + c + ")";
					if (u += "TimeScale: {first:" + this._timeScale.points().firstIndex() + ",last:" + this._timeScale.points().lastIndex() + "}", null === a) {
						this._timeScale.resetBaseIndex();
						const e = this._timeScale.rightOffset();
						this._timeScale.setRightOffset(Math.max(e, this._cachedStudiesMaxOffset))
					} else if (void 0 !== a) {
						const e = this._timeScale.indexToTimePoint(a),
							t = null !== h && null !== e && e > h;
						this._updateBaseIndex(a, t)
					}
					if (us.logDebug(u), !d && d !== this._timeScale.canNormalize())
						for (const e of this.dataSources()) !(0, f.isLineTool)(e) || e.isFixed() || e.isSourceHidden() || e.processHibernate();
					this.recalculateAllPanes((0, F.globalChangeEvent)()), this.lightUpdate()
				}
				_getAvailableCurrencies() {
					return !this.currencyConversionEnabled() || this.isSnapshot() ? [] : (0, ve.isArray)(this._availableCurrenciesList) ? this._availableCurrenciesList : (null !== this._availableCurrenciesList || (this._availableCurrenciesList = this.chartApi().availableCurrencies(), this._availableCurrenciesList.then((e => {
						this._destroyed || (this._availableCurrenciesList = e, this.fullUpdate())
					})).catch((e => {
						us.logWarn(`An error occurred while getting currencies config: ${e}`)
					}))), [])
				}
				_getAvailableUnits() {
					return !this.unitConversionEnabled() || this.isSnapshot() ? {} : this._availableUnitsObject instanceof Promise || null === this._availableUnitsObject ? (null !== this._availableUnitsObject || (this._availableUnitsObject = this.chartApi().availableUnits(), this._availableUnitsObject.then((e => {
						this._destroyed || (this._availableUnitsObject = e, this.fullUpdate())
					})).catch((e => {
						us.logWarn(`An error occurred while getting units config: ${e}`)
					}))), {}) : this._availableUnitsObject
				}
				_getBackgroundColor(e) {
					const t = this._properties.childs().paneProperties.childs();
					if (t.backgroundType.value() === Et.ColorType.Gradient) {
						const i = t.backgroundGradientStartColor.value(),
							s = t.backgroundGradientEndColor.value();
						return function(e, t, i) {
							if ((0, h.getCurrentTheme)().name === gt.StdTheme.Dark && (0, pt.isOnMobileAppPage)("old") && (0, h.isStdThemedDefaultValue)("chartProperties.paneProperties.backgroundGradientStartColor", e, gt.StdTheme.Dark) && (0, h.isStdThemedDefaultValue)("chartProperties.paneProperties.backgroundGradientEndColor", t, gt.StdTheme.Dark)) return St;
							return i ? e : t
						}(i, s, Boolean(e))
					}
					const i = t.background.value();
					return function(e) {
						if ((0, h.getCurrentTheme)().name === gt.StdTheme.Dark && (0, pt.isOnMobileAppPage)("old") && (0, h.isStdThemedDefaultValue)("chartProperties.paneProperties.background", e, gt.StdTheme.Dark)) return St;
						return e
					}(i)
				}
				_updateBackgroundColor() {
					this._backgroundColor.setValue(this._getBackgroundColor()), this._backgroundTopColor.setValue(this._getBackgroundColor(!0))
				}
				_syncCrosshair(e) {
					if (!this._isSettingsExternalPosition) {
						const t = this._undoModel.chartWidget(),
							i = this._undoModel.mainSeries(),
							s = i.syncModel(),
							o = this._undoModel.crossHairSource(),
							r = o.pane;
						if (null !== s && null !== r) {
							const n = {
								timeStamp: this._timeScale.points().roughTime(o.index, s.projectTime.bind(s)),
								syncSourceTarget: s.syncSourceTarget()
							};
							r.mainDataSource() === i && (n.price = o.price, n.symbol = i.symbol());
							let a = this._lineBeingCreated || null !== this._linePointBeingEdited || Boolean(this._sourcesBeingMoved.length);
							a = a && (0, mt.drawOnAllCharts)().value(), t.chartWidgetCollection().syncCrosshair(n, t.id(), a, e)
						}
						this._phantomSourceContainer.onCursorPositionUpdated()
					}
				}
				_gotoTimeImpl(e, t) {
					const i = this.timeScale(),
						s = this.mainSeries();
					let r;
					if (void 0 !== e) {
						if (this._scrollingState && this._scrollingState.deferred.reject(), r = (0, u.createDeferredPromise)(), !s.isDWM()) {
							const t = s.symbolInfo();
							if (null !== t) {
								let i = this.properties().childs().timezone.value();
								"exchange" === i && (i = t.timezone);
								const o = (0, lt.cal_to_utc)((0, lt.get_timezone)(i), new Date(e)),
									r = (0, Gt.createTimeToBarTimeAligner)(s.interval(), t)(o);
								e = (0, lt.utc_to_cal)((0, lt.get_timezone)(i), r).getTime()
							}
						}
						this._scrollingState = {
							targetDate: e,
							deferred: r,
							centerIfVisible: t.centerIfVisible
						}
					} else {
						if (!this._scrollingState) return us.logError("scrollTo called without an argument"), Promise.reject();
						e = this._scrollingState.targetDate, r = this._scrollingState.deferred
					}
					if (void 0 === i.tickMarks().minIndex) return r.resolve(void 0), r.promise;
					let n = ((e, t) => {
						if ((e => (0, o.ensureNotNull)(i.tickMarks().indexToTime((0,
								o.ensureDefined)(i.tickMarks().minIndex))).valueOf() - e)(t) < 0) {
							let r = i.tickMarks().nearestIndex(t);
							const n = s.bars().lastIndex();
							if (null === n) return null;
							r = Math.min(r, n);
							let a = (0, o.ensureNotNull)(i.tickMarks().indexToTime(r)).valueOf();
							for (; a < t && r < n;) r++, a = (0, o.ensureNotNull)(i.tickMarks().indexToTime(r)).valueOf();
							const l = (0, o.ensureNotNull)(i.visibleBarsStrictRange()),
								c = l.lastBar() - l.firstBar();
							return !e && l.contains(r) || i.zoomToBarsRange(r - c / 2, r + c / 2), {
								timestamp: (0, o.ensureNotNull)(i.indexToTimePoint(r))
							}
						}
						return null
					})(this._scrollingState.centerIfVisible, this._scrollingState.targetDate);
					if (!n) {
						const t = (0, o.ensureDefined)(i.tickMarks().minIndex),
							r = (0, o.ensureNotNull)(i.visibleBarsStrictRange()),
							a = r.lastBar() - r.firstBar();
						if (s.requestMoreDataAvailable()) {
							const t = i.tickMarks().estimateLeft(e);
							i.requestMoreHistoryPoints(Math.ceil(t + a / 2))
						} else i.zoomToBarsRange(t - a / 2, t + a / 2), n = {
							timestamp: (0, o.ensureNotNull)(i.indexToTimePoint(t)),
							eod: !0
						}
					}
					return n && (this.fullUpdate(), this._scrollingState = null, r.resolve(n)), r.promise
				}
				_setCorrectedPositionToCrosshair(e, t, i) {
					this.crossHairSource().setPosition(e, t, i)
				}
				_onSymbolSourceCollectionChanged(e) {
					this._recalcAdjustForDividendsAvailibility(), this._symbolSourceCollectionChanged.fire(e)
				}
				_getExceedingChildStudies(e) {
					var t, i;
					let s = [];
					for (let t = 0; t < e.length; ++t) s = s.concat(e[t].sources || []);
					let o = 0,
						r = 1;
					r = null !== (i = null === (t = (0, It.getConfig)(At.ProductFeatures.STUDY_ON_STUDY)) || void 0 === t ? void 0 : t.child_limit) && void 0 !== i ? i : 1;
					const n = [],
						a = {};
					let l = 0,
						c = 1e6;
					for (; s.length && --c;) {
						const e = s[l];
						(e.ownerSource && a[e.ownerSource] || !e.ownerSource) && (a[e.id] = e, s.splice(s.indexOf(e), 1), e.ownerSource && (0, pe.isStudyState)(e) && e.state && e.state.isChildStudy && ++o > r && n.push(e)), l = (l + 1) % s.length
					}
					return n
				}
			}
		},
		356129: (e, t, i) => {
			"use strict";
			i.d(t, {
				ChartUndoModelBase: () => es
			});
			var s = i(685459),
				o = i.n(s),
				r = i(316230),
				n = i(588537),
				a = i(86441),
				l = i(575932),
				c = i(277036),
				h = i(876242),
				d = i(451902),
				u = i(970028),
				_ = i(36047),
				m = i(878667),
				p = i(72833);
			class g extends p.UndoCommand {
				constructor(e, t, i, s, o, r) {
					super(r), this._model = e, this._paneIndex = e.panes().indexOf(t), this._targetPosition = s, this._targetIndex = o, this._scaleId = i.id(), this._sourcePosition = t.priceScalePosition(i), "overlay" !== this._sourcePosition && (this._sourceIndex = t.priceScaleIndex(i, this._sourcePosition))
				}
				redo() {
					const e = this._model.panes()[this._paneIndex],
						t = (0, n.ensureNotNull)(e.getPriceScaleById(this._scaleId));
					e.movePriceScale(t, this._targetPosition, this._targetIndex), this._model.fullUpdate()
				}
				undo() {
					const e = this._model.panes()[this._paneIndex],
						t = (0, n.ensureNotNull)(e.getPriceScaleById(this._scaleId));
					e.movePriceScale(t, this._sourcePosition, this._sourceIndex), this._model.fullUpdate()
				}
			}
			var S = i(540968);
			class v extends p.UndoCommand {
				constructor(e, t, i, s) {
					super(s), this._createdIds = [], this._model = e, this._withoutShift = i, this._origStates = t.map((e => e.state(!0)));
					const o = e.lineToolsGroupModel();
					this._origGroups = t.map((e => {
						const t = o.groupForLineTool(e);
						return t && t.id
					}))
				}
				redo() {
					const e = this._model.lineToolsGroupModel(),
						t = this._origStates.map(((t, i) => {
							const s = (0,
									n.ensureNotNull)(this._model.dataSourceForId(t.id)),
								o = 0 === this._createdIds.length ? void 0 : (0, n.ensureDefined)(this._createdIds[i]),
								r = (0, S.cloneLineTool)(this._model, s, !this._withoutShift, o),
								a = (0, n.ensureNotNull)(s.priceScale());
							(0, n.ensureNotNull)(this._model.paneForSource(s)).addDataSource(r, a, !1);
							const l = this._origGroups[i];
							if (null !== l) {
								const t = e.groupForId(l);
								t && t.addLineTools([r])
							}
							return this._model.updateSource(r), r
						}));
					0 === this._createdIds.length && (this._createdIds = t.map((e => e.id()))), this._model.selectionMacro((e => {
						e.clearSelection(), t.forEach((t => {
							e.addSourceToSelection(t)
						}))
					})), this._model.setShouldBeSavedEvenIfHidden(!0)
				}
				undo() {
					const e = this._model.lineToolsGroupModel();
					this._createdIds.forEach((t => {
						const i = (0, n.ensureNotNull)(this._model.dataSourceForId(t)),
							s = e.groupForLineTool(i);
						null !== s && s.excludeLineTool(i), this._model.removeSource(i)
					}))
				}
				newIds() {
					return this._createdIds
				}
			}
			var f = i(69318),
				b = i(148976),
				y = i(270617),
				C = i(140662);
			class w extends p.UndoCommand {
				constructor(e, t, i, s = !0) {
					super(i, s), this._newStates = [], this._model = e, this._savedStates = t.map((e => e.state(!1)))
				}
				redo() {
					this._applyState(this._newStates)
				}
				undo() {
					0 === this._newStates.length && this.saveNewState(), this._applyState(this._savedStates)
				}
				saveNewState() {
					const e = this._savedStates.filter(y.notNull).map((e => (0, n.ensureNotNull)(this._model.dataSourceForId(e.id))));
					this._newStates = e.map((e => e.state(!1)))
				}
				_applyState(e) {
					for (const t of e)
						if (null !== t) {
							const e = this._model.dataSourceForId(t.id);
							if (null !== e)
								if ((0, C.isStudy)(e)) {
									const i = t.state.inputs,
										s = e.properties().childs().inputs.childs();
									for (const e in i) s[e] && s[e].setValue(i[e])
								} else this._model.restoreLineToolState(e, t, !0)
						}
				}
			}
			var T = i(167977),
				P = i(284330),
				M = i(534953),
				x = i(125226),
				I = i(985481);
			const A = new c.TranslatedString("create {tool}", (0, l.t)("create {tool}")),
				k = (0, x.isFeatureEnabled)("save_shared_line_tools");
			class L extends p.UndoCommand {
				constructor(e, t, i, s, o = 0, r) {
					super(A.format({
						tool: new c.TranslatedString(i, I.lineToolsLocalizedNames[i])
					}), !1), this._lineId = null, this._lineState = null, this._model = e, this._paneIndex = e.panes().indexOf(t), this._lineTool = i, this._ownerSourceId = s.id(), this._lineId = null != r ? r : null, this._drawOnAllChartsMode = o
				}
				startCreatingLine(e, t, i) {
					var s;
					const o = this._model.panes()[this._paneIndex],
						r = this._model.dataSourceForId(this._ownerSourceId),
						n = this._model.createLineTool(o, e, this._lineTool, t, i, r, null !== (s = this._lineId) && void 0 !== s ? s : void 0);
					return k && r === this._model.mainSeries() && n.share(this._drawOnAllChartsMode), this._lineId = n.id(), !this._model.lineBeingCreated()
				}
				continueCreatingLine(e, t, i, s) {
					const o = this._model.continueCreatingLine(e, t, i, s);
					return o && this._model.setShouldBeSavedEvenIfHidden(!0), o
				}
				line() {
					return null === this._lineId ? null : this._model.dataSourceForId(this._lineId)
				}
				undo() {
					const e = this.line();
					null !== e && (this._lineState = e.state(!1), this._model.removeSource(e), this._lineId = null)
				}
				redo() {
					if (null === this._lineState) return;
					const e = this._model.restoreSource(!1, this._paneIndex, null, (0, n.ensureNotNull)(this._lineState), null);
					null !== e && (this._lineId = e.id(), this._lineState = null,
						e.share(this._drawOnAllChartsMode))
				}
				drawOnAllCharts() {
					return 0 !== this._drawOnAllChartsMode
				}
			}
			var E = i(20870);
			const D = new c.TranslatedString("bring {title} to front", (0, l.t)("bring {title} to front")),
				N = new c.TranslatedString("send {title} to back", (0, l.t)("send {title} to back")),
				B = new c.TranslatedString("insert {title} after {targetTitle}", (0, l.t)("insert {title} after {targetTitle}")),
				O = new c.TranslatedString("insert {title} before {targetTitle}", (0, l.t)("insert {title} before {targetTitle}")),
				R = new c.TranslatedString("send {title} backward", (0, l.t)("send {title} backward")),
				V = new c.TranslatedString("bring {title} forward", (0, l.t)("bring {title} forward")),
				W = new c.TranslatedString("send group {title} backward", (0, l.t)("send group {title} backward")),
				F = new c.TranslatedString("bring group {title} forward", (0, l.t)("bring group {title} forward"));

			function z(e) {
				return new c.TranslatedString(e.name(), e.title())
			}
			class U extends p.UndoCommand {
				constructor(e, t, i) {
					super(i), this._sourcesByPanes = new Map, this._originalState = new Map, this._model = e, t.forEach((t => {
						const i = (0, n.ensureNotNull)(e.paneForSource(t)),
							s = e.panes().indexOf(i),
							o = this._sourcesByPanes.get(s) || [];
						o.push(t.id()), this._sourcesByPanes.set(s, o)
					})), Array.from(this._sourcesByPanes.keys()).forEach((t => {
						const i = e.panes()[t],
							s = new Map;
						i.sourcesByGroup().allIncludingHidden().forEach((e => {
							s.set(e.id(), e.zorder())
						})), this._originalState.set(t, s)
					}))
				}
				undo() {
					this._originalState.forEach(((e, t) => {
						const i = this._model.panes()[t],
							s = new Map;
						e.forEach(((e, t) => {
							const o = (0, n.ensureNotNull)(i.dataSourceForId(t));
							s.set(o, e)
						})), i.setZOrders(s)
					}))
				}
				redo() {
					this._sourcesByPanes.forEach(((e, t) => {
						const i = this._model.panes()[t],
							s = e.map((e => (0, n.ensureNotNull)(i.dataSourceForId(e))));
						this._paneOperation(i, s)
					}))
				}
			}
			class H extends U {
				constructor(e, t) {
					super(e, t, D.format({
						title: z(t[0])
					}))
				}
				_paneOperation(e, t) {
					e.bringToFront(t)
				}
			}
			class G extends U {
				constructor(e, t) {
					super(e, t, N.format({
						title: z(t[0])
					}))
				}
				_paneOperation(e, t) {
					e.sendToBack(t)
				}
			}
			class j extends U {
				constructor(e, t, i, s) {
					super(e, t, s), this._targetSource = i
				}
				_paneOperation(e, t) {
					e.insertAfter(t, this._targetSource)
				}
			}
			class q extends j {
				constructor(e, t, i) {
					super(e, t, i, B.format({
						title: z(t[0]),
						targetTitle: z(i)
					}))
				}
			}
			class K extends U {
				constructor(e, t, i, s) {
					super(e, t, s), this._targetSource = i
				}
				_paneOperation(e, t) {
					e.insertBefore(t, this._targetSource)
				}
			}
			class Y extends K {
				constructor(e, t, i) {
					super(e, t, i, O.format({
						title: z(t[0]),
						targetTitle: z(i)
					}))
				}
			}

			function X(e, t) {
				const i = t[0],
					s = e.sourcesByGroup().all().filter((e => e.zorder() < i.zorder()));
				if (0 === s.length) throw new Error("Cannot move backward source that alreadt on back");
				let o = s[s.length - 1];
				if ((0, S.isLineTool)(o)) {
					const t = e.model().lineToolsGroupModel().groupForLineTool(o);
					null !== t && (o = t.lineTools()[0])
				}
				return o
			}
			class Z extends K {
				constructor(e, t, i) {
					super(e, i, X(t, i), R.format({
						title: z(i[0])
					}))
				}
			}

			function $(e, t) {
				const i = t[t.length - 1],
					s = e.sourcesByGroup().allExceptSpecialSources().filter((e => e.zorder() > i.zorder()));
				if (0 === s.length) throw new Error("Cannot bring forward source that alreadt on back");
				let o = s[0];
				if ((0, S.isLineTool)(o)) {
					const t = e.model().lineToolsGroupModel().groupForLineTool(o);
					if (null !== t) {
						const e = t.lineTools();
						o = e[e.length - 1]
					}
				}
				return o
			}
			class Q extends j {
				constructor(e, t, i) {
					super(e, i, $(t, i), V.format({
						title: z(i[0])
					}))
				}
			}

			function J(e, t) {
				return (0, n.ensureNotNull)(e.paneForSource(t.lineTools()[0]))
			}
			class ee extends K {
				constructor(e, t) {
					super(e, t.lineTools(), X(J(e, t), t.lineTools()), W.format({
						title: t.name()
					}))
				}
			}
			class te extends j {
				constructor(e, t) {
					super(e, t.lineTools(), $(J(e, t), t.lineTools()), F.format({
						title: t.name()
					}))
				}
			}
			const ie = new c.TranslatedString("rearrange panes", (0, l.t)("rearrange panes"));
			class se extends p.UndoCommand {
				constructor(e, t, i) {
					super(ie), this._chartModel = e, this._index = t, (0, y.isNumber)(i) ? this._dstIndex = i : this._dstIndex = "up" === i ? t - 1 : t + 1
				}
				redo() {
					this._checkIndices() && this._chartModel.movePane(this._index, this._dstIndex)
				}
				undo() {
					this._checkIndices() && this._chartModel.movePane(this._dstIndex, this._index)
				}
				_checkIndices() {
					const e = this._chartModel.panes().length;
					return this._index >= 0 && this._index < e && this._dstIndex >= 0 && this._dstIndex < e
				}
			}
			var oe = i(558e3),
				re = i(984610),
				ne = i(346090),
				ae = i(749473),
				le = i(583912),
				ce = i(364019),
				he = i(194459);
			class de extends p.UndoCommand {
				constructor(e, t, i, s, o, r) {
					super(s), this._prevPriceAxisProps = {}, this._property = e, this._mainSeries = i, this._value = t, this._model = o, this._chartWidget = r
				}
				redo() {
					const e = this._mainSeries,
						t = e.properties().childs();
					t.style === this._property && e.isNeedRestart(this._value) && this._chartWidget.screen.show(), this._prevResolution = t.interval.value(), this._prevValue = this._property.value(), this._storePriceAxisProps(), (0, ne.saveDefaultProperties)(!0);
					const i = t.interval.value(),
						s = this._model.defaultResolutions(),
						o = (0, ce.getResolutionByChartStyle)(this._value, i, s);
					le.linking.interval.setValue(o), e.setChartStyleWithIntervalIfNeeded(this._value, o), (0, ae.setLastUsedStyle)(this._value, e.symbolInfo()), (0, ae.preparePriceAxisProperties)(t), (0, ne.saveDefaultProperties)(!1), this._invalidateModel()
				}
				undo() {
					const e = this._mainSeries;
					e.properties().childs().style === this._property && e.isNeedRestart(this._value) && this._chartWidget.screen.show(), (0, ne.saveDefaultProperties)(!0), e.setChartStyleWithIntervalIfNeeded(this._prevValue, this._prevResolution), this._restorePriceAxisProps(), le.linking.interval.setValue(this._prevResolution), (0, ne.saveDefaultProperties)(!1), this._invalidateModel()
				}
				_storePriceAxisProps() {
					const e = this._mainSeries.priceScale();
					this._prevPriceAxisProps = e.mode()
				}
				_restorePriceAxisProps() {
					this._mainSeries.priceScale().setMode(this._prevPriceAxisProps)
				}
				_invalidateModel() {
					this._model && (this._model.recalculateAllPanes((0, he.dataSourceChangeEvent)(this._model.mainSeries().id())), this._model.lightUpdate())
				}
			}
			var ue = i(509966),
				_e = i(273044);
			const me = new c.TranslatedString("change date range", (0, l.t)("change date range"));
			class pe extends p.UndoCommand {
				constructor(e, t) {
					super(me), this._modelsData = [], this._rangeOptions = t, this._modelsData.push({
						model: e,
						prevResolution: e.mainSeries().properties().childs().interval.value(),
						barSpacing: e.timeScale().barSpacing(),
						rightOffset: e.timeScale().rightOffset(),
						rangeOptions: e.appliedTimeFrame().value()
					})
				}
				redo() {
					const e = [];
					for (const t of this._modelsData) {
						const i = t.model.mainSeries(),
							s = i.properties().childs().interval;
						_e.Interval.isEqual(this._rangeOptions.res, s.value()) ? i.loadDataTo(this._rangeOptions.val) : (e.push(s), i.setDefaultTimeframe(this._rangeOptions.val), s.setValueSilently(this._rangeOptions.res))
					}
					for (const t of e) t.listeners().fire(t)
				}
				undo() {
					const e = [];
					for (const t of this._modelsData) {
						const i = t.model.mainSeries(),
							s = i.properties().childs().interval;
						t.prevResolution !== s.value() ? (e.push(s), null !== t.rangeOptions && i.setDefaultTimeframe(t.rangeOptions.val), s.setValueSilently(t.prevResolution)) : null !== t.rangeOptions && i.loadDataTo(t.rangeOptions.val);
						const o = t.model.timeScale();
						o.setBarSpacing(t.barSpacing), o.setRightOffset(t.rightOffset)
					}
					for (const t of e) t.listeners().fire(t)
				}
				canMerge(e) {
					return e instanceof pe && (0, ue.rangesAreEqual)(e._rangeOptions, this._rangeOptions)
				}
				merge(e) {
					if (!(e instanceof pe)) throw new Error("Invalid command to merge");
					this._modelsData = this._modelsData.concat(e._modelsData)
				}
			}
			var ge = i(3008),
				Se = i(19851);
			i(897116);
			class ve extends p.UndoCommand {
				constructor(e, t, i) {
					super(i), this._model = e, this._groupId = t.id, this._groupName = t.name(), this._lineToolsIds = t.lineTools().map((e => e.id()))
				}
				redo() {
					const e = (0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId));
					this._model.lineToolsGroupModel().removeGroup(e)
				}
				undo() {
					const e = this._lineToolsIds.map((e => this._model.dataSourceForId(e))),
						t = new Se.LineToolsGroup(e, this._groupName, this._groupId);
					this._model.lineToolsGroupModel().addGroup(t)
				}
			}
			const fe = new c.TranslatedString("create line tools group", (0, l.t)("create line tools group"));
			class be extends p.UndoCommand {
				constructor(e, t) {
					super(fe), this._groupId = null, this._model = e, this._sourcesIds = t.map((e => e.id()))
				}
				redo() {
					const e = this._sourcesIds.map((e => this._model.dataSourceForId(e))),
						t = null === this._groupId ? void 0 : this._groupId;
					this._groupId = this._model.lineToolsGroupModel().createGroup(e, this._title, t).id
				}
				undo() {
					const e = (0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId((0, n.ensureNotNull)(this._groupId)));
					this._model.lineToolsGroupModel().removeGroup(e)
				}
				createdGroupId() {
					return this._groupId
				}
			}
			const ye = new c.TranslatedString("add line tool(s) to group {group}", (0, l.t)("add line tool(s) to group {group}"));
			class Ce extends p.UndoCommand {
				constructor(e, t, i) {
					super(ye.format({
						group: t.name()
					})), this._model = e, this._groupId = t.id, this._lineToolsIds = i.map((e => e.id()))
				}
				redo() {
					const e = (0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId)),
						t = this._lineToolsIds.map((e => this._model.dataSourceForId(e)));
					e.addLineTools(t)
				}
				undo() {
					const e = this._lineToolsIds.map((e => this._model.dataSourceForId(e)));
					(0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId)).excludeLineTools(e)
				}
			}
			var we = i(359663);
			class Te extends p.UndoCommand {
				constructor(e, t, i, s, o) {
					super(i), this._targetObj = e, this._newValue = t, this._oldValue = this._targetObj.value(), this._model = s, o && this.setCustomFlag("doesnt_affect_save", !0)
				}
				redo() {
					(0,
						ne.saveDefaultProperties)(!0), this._targetObj.setValue(this._newValue), (0, ne.saveDefaultProperties)(!1), this._model.recalculateAllPanes((0, he.globalChangeEvent)()), this._model.lightUpdate()
				}
				undo() {
					(0, ne.saveDefaultProperties)(!0), this._targetObj.setValue(this._oldValue), (0, ne.saveDefaultProperties)(!1), this._model.recalculateAllPanes((0, he.globalChangeEvent)()), this._model.lightUpdate()
				}
			}
			class Pe extends p.UndoCommand {
				constructor(e, t, i, s) {
					super(s), this._chartModel = e, this._groupId = t.id, this._oldName = t.name(), this._newName = i
				}
				redo() {
					(0, n.ensureNotNull)(this._chartModel.lineToolsGroupModel().groupForId(this._groupId)).setName(this._newName)
				}
				undo() {
					(0, n.ensureNotNull)(this._chartModel.lineToolsGroupModel().groupForId(this._groupId)).setName(this._oldName)
				}
			}
			var Me = i(308170);
			class xe extends p.UndoCommand {
				constructor(e, t, i, s) {
					super(s), this._model = i, this._id = e.id(), this._targetSharingMode = t, this._originSharingMode = e.sharingMode().value()
				}
				redo() {
					const e = this._model.dataSourceForId(this._id);
					e && e.share(this._targetSharingMode)
				}
				undo() {
					const e = this._model.dataSourceForId(this._id);
					e && e.share(this._originSharingMode)
				}
			}
			const Ie = new c.TranslatedString("create line tools group from selection", (0, l.t)("create line tools group from selection")),
				Ae = new c.TranslatedString("removing line tools group {name}", (0, l.t)("removing line tools group {name}")),
				ke = new c.TranslatedString("add line tool {lineTool} to group {name}", (0, l.t)("add line tool {lineTool} to group {name}")),
				Le = new c.TranslatedString("make group {group} visible", (0, l.t)("make group {group} visible")),
				Ee = new c.TranslatedString("make group {group} invisible", (0, l.t)("make group {group} invisible")),
				De = new c.TranslatedString("lock group {group}", (0, l.t)("lock group {group}")),
				Ne = new c.TranslatedString("unlock group {group}", (0, l.t)("unlock group {group}")),
				Be = new c.TranslatedString("rename group {group} to {newName}", (0, l.t)("rename group {group} to {newName}"));
			class Oe {
				constructor(e) {
					this._lineToolsAffectChartInvalidation = new we.FeatureToggleWatchedValue("do_not_invalidate_chart_on_changing_line_tools", !1), this._environment = e
				}
				createGroupFromSelection() {
					const e = this._environment.model();
					(0, n.assert)(!e.selection().isEmpty(), "Cannot create group from empty selection");
					const t = (0, M.sortSources)(e.selection().lineDataSources());
					(0, n.assert)(t.length === e.selection().allSources().length, "A group could contain line tools only");
					const i = t.length > 1 || null !== this._environment.model().lineToolsGroupModel().groupForLineTool(t[0]),
						s = t.reduce(((e, t) => e.zorder() > t.zorder() ? e : t), t[0]);
					let o = s;
					const r = e.lineToolsGroupModel().groupForLineTool(s);
					if (null !== r) {
						const e = r.lineTools();
						o = e[e.length - 1]
					}
					this._environment.beginUndoMacro(Ie, this._lineToolsAffectChartInvalidation.value());
					const a = new Map,
						l = new Set;
					t.forEach((t => {
						const i = this._groupForLineTool(t);
						if (null === i) return;
						const s = a.get(i) || [];
						s.push(t), a.set(i, s);
						const o = (0, n.ensureNotNull)(e.paneForSource(t));
						l.add(o)
					})), (0, n.assert)(l.size <= 1, "All selected sources should be on the same pane"), a.forEach(((t, i) => {
						const s = new b.ExcludeLineToolsFromGroupUndoCommand(e, i, t);
						this._environment.pushUndoCommand(s)
					}));
					const c = new be(e, (0, M.sortSources)(t));
					if (this._environment.pushUndoCommand(c), i) {
						const i = new q(e, t, o);
						this._environment.pushUndoCommand(i)
					}
					this._environment.endUndoMacro();
					const h = (0, n.ensureNotNull)(c.createdGroupId());
					return (0, n.ensureNotNull)(e.lineToolsGroupModel().groupForId(h))
				}
				removeGroup(e) {
					const t = this._environment.model(),
						i = e.lineTools();
					this._environment.beginUndoMacro(Ae.format({
						name: e.name()
					}), this._lineToolsAffectChartInvalidation.value());
					const s = new ve(t, e, null);
					this._environment.pushUndoCommand(s);
					const o = new f.RemoveSourcesCommand(t, i, null);
					this._environment.pushUndoCommand(o);
					const r = t.mainSeries().symbol();
					i.forEach((e => {
						null !== e.linkKey().value() && (0, Me.removeLineTool)({
							withUndo: !0,
							model: t,
							symbol: r,
							sourceTitle: new c.TranslatedString(e.name(), e.title()),
							lineToolState: e.state(!1),
							linkKey: (0, n.ensureNotNull)(e.linkKey().value())
						})
					})), this._environment.endUndoMacro()
				}
				groups() {
					return this._environment.model().lineToolsGroupModel().groups()
				}
				excludeLineToolFromGroup(e, t) {
					const i = this._environment.model(),
						s = new b.ExcludeLineToolsFromGroupUndoCommand(i, e, [t]);
					s.setCustomFlag("doesnt_affect_save", this._lineToolsAffectChartInvalidation.value()), this._environment.pushUndoCommand(s)
				}
				addLineToolToGroup(e, t) {
					const i = this._environment.model(),
						s = i.lineToolsGroupModel().groupForLineTool(t);
					if (s === e) return;
					const o = ke.format({
						lineTool: new c.TranslatedString(t.name(), t.title()),
						name: e.name()
					});
					if (this._environment.beginUndoMacro(o, this._lineToolsAffectChartInvalidation.value()), null !== s && this._environment.pushUndoCommand(new b.ExcludeLineToolsFromGroupUndoCommand(i, s, [t])), (0, x.isFeatureEnabled)("save_shared_line_tools")) {
						const s = e.sharingMode().value();
						t.sharingMode().value() !== s && this._environment.pushUndoCommand(new xe(t, s, i, null))
					}
					this._environment.pushUndoCommand(new Ce(i, e, [t])), this._environment.endUndoMacro()
				}
				bringToFront(e) {
					const t = this._environment.model(),
						i = new H(t, e.lineTools());
					i.setCustomFlag("doesnt_affect_save", this._lineToolsAffectChartInvalidation.value()), this._environment.pushUndoCommand(i), this._environment.emitEvent("changeZOrder", [e.lineTools()])
				}
				sendToBack(e) {
					const t = this._environment.model(),
						i = new G(t, e.lineTools());
					i.setCustomFlag("doesnt_affect_save", this._lineToolsAffectChartInvalidation.value()), this._environment.pushUndoCommand(i), this._environment.emitEvent("changeZOrder", [e.lineTools()])
				}
				bringForward(e) {
					const t = this._environment.model(),
						i = new te(t, e);
					i.setCustomFlag("doesnt_affect_save", this._lineToolsAffectChartInvalidation.value()), this._environment.pushUndoCommand(i), this._environment.emitEvent("changeZOrder", [e.lineTools()])
				}
				sendBackward(e) {
					const t = this._environment.model(),
						i = new ee(t, e);
					i.setCustomFlag("doesnt_affect_save", this._lineToolsAffectChartInvalidation.value()), this._environment.pushUndoCommand(i), this._environment.emitEvent("changeZOrder", [e.lineTools()])
				}
				insertAfter(e, t) {
					const i = this._environment.model();
					let s;
					if (t instanceof Se.LineToolsGroup) {
						const e = t.lineTools();
						s = e[e.length - 1]
					} else s = t;
					const o = new q(i, e.lineTools(), s);
					this._environment.pushUndoCommand(o), this._environment.emitEvent("changeZOrder", [e.lineTools()])
				}
				insertBefore(e, t) {
					const i = this._environment.model();
					let s;
					if (t instanceof Se.LineToolsGroup) {
						s = t.lineTools()[0]
					} else s = t;
					const o = new Y(i, e.lineTools(), s);
					this._environment.pushUndoCommand(o), this._environment.emitEvent("changeZOrder", [e.lineTools()])
				}
				availableZOrderOperations(e) {
					const t = this._environment.model(),
						i = e.lineTools(),
						s = i[0],
						o = i[i.length - 1],
						r = (0, n.ensureNotNull)(t.paneForSource(i[0])).sourcesByGroup().allExceptSpecialSources(),
						a = r[0],
						l = r[r.length - 1];
					return {
						bringForwardEnabled: o !== l,
						bringToFrontEnabled: o !== l,
						sendBackwardEnabled: s !== a,
						sendToBackEnabled: s !== a
					}
				}
				setGroupVisibility(e, t) {
					const i = (t ? Le : Ee).format({
							group: e.name()
						}),
						s = this._environment.model();
					this._environment.beginUndoMacro(i, this._lineToolsAffectChartInvalidation.value()), e.lineTools().forEach((e => {
						const i = e.properties().visible,
							o = new Te(i, t, null, s);
						this._environment.pushUndoCommand(o)
					})), this._environment.endUndoMacro()
				}
				setGroupLock(e, t) {
					const i = (t ? De : Ne).format({
							group: e.name()
						}),
						s = this._environment.model();
					this._environment.beginUndoMacro(i, this._lineToolsAffectChartInvalidation.value()), e.lineTools().forEach((e => {
						const i = e.properties().frozen,
							o = new Te(i, t, null, s);
						this._environment.pushUndoCommand(o)
					})), this._environment.endUndoMacro()
				}
				setGroupName(e, t) {
					const i = this._environment.model(),
						s = Be.format({
							group: e.name(),
							newName: t
						}),
						o = new Pe(i, e, t, s);
					o.setCustomFlag("doesnt_affect_save", this._lineToolsAffectChartInvalidation.value()), this._environment.pushUndoCommand(o)
				}
				canBeGroupped(e) {
					const t = this._environment.model();
					return new Set(e.map((e => t.paneForSource(e)))).size <= 1
				}
				_groupForLineTool(e) {
					return this._environment.model().lineToolsGroupModel().groups().find((t => t.containsLineTool(e))) || null
				}
			}
			var Re = i(754061),
				Ve = i(648488),
				We = i(986607),
				Fe = i(676024);
			const ze = new c.TranslatedString("apply study template {template}", (0, l.t)("apply study template {template}"));

			function Ue(e) {
				for (const t of e.panes)
					for (const e of t.sources)
						if ((0, We.isMainSeriesState)(e)) return e.id;
				return null
			}
			class He extends p.UndoCommand {
				constructor(e, t, i) {
					var s, o;
					super(ze.format({
						template: i
					})), this._newSymbolParams = {}, this._model = e, this._templateContent = function(e, t) {
						const i = (0, Re.default)({}, e),
							s = (0, n.ensureNotNull)(Ue(i));
						for (const e of i.panes) {
							e.mainSourceId === s && (e.mainSourceId = t);
							for (const i of e.sources)
								if (i.id === s) {
									i.id = t;
									const o = e => {
										const i = e.indexOf(s); - 1 !== i && e.splice(i, 1, t)
									};
									if (e.leftAxisesState && e.rightAxisesState ? (e.leftAxisesState.forEach((e => o(e.sources))), e.rightAxisesState.forEach((e => o(e.sources)))) : (o(e.leftAxisSources), o(e.rightAxisSources)), e.overlayPriceScales) {
										const i = e.overlayPriceScales[s];
										i && (delete e.overlayPriceScales[s], e.overlayPriceScales[t] = i)
									}
								} else i.ownerSource === s && (i.ownerSource = t)
						}
						return i
					}(t, e.mainSeries().id()), this._initialState = e.studyTemplate(!0, !0, !0);
					const r = e.mainSeries();
					t.symbol && (this._newSymbolParams = {
						symbol: t.symbol,
						currency: null !== (s = t.currency) && void 0 !== s ? s : null,
						unit: null !== (o = t.unit) && void 0 !== o ? o : null
					}), t.interval && (this._newSymbolParams.interval = t.interval, this._newSymbolParams.style = (0, ae.getChartStyleByResolution)(t.interval, r.style())), this._initialSymbolParams = {
						symbol: r.symbol(),
						currency: r.currency(),
						unit: r.unit(),
						interval: r.interval(),
						style: r.style()
					}, this._initialState = e.studyTemplate(), this._initialGroupsState = e.lineToolsGroupModel().state()
				}
				redo() {
					this._model.mainSeries().setSymbolParams(this._newSymbolParams);
					const e = this._merge(this._templateContent).filter(S.isLineTool);
					this._model.lineToolsGroupModel().removeLineTools(e);
					const t = this._model.mainSeries().properties();
					(0, ae.preparePriceAxisProperties)(t), this._model.recalcVisibleRangeStudies(!0), this._model.setShouldBeSavedEvenIfHidden(!0)
				}
				undo() {
					this._model.mainSeries().setSymbolParams(this._initialSymbolParams), this._merge(this._initialState)
				}
				_merge(e) {
					const t = e.version || 0,
						i = this._model,
						s = i.mainSeries();
					(0, n.assert)(s.id() === Ue(e)), s.priceScale().properties().childs().lockScale.setValue(!1);
					const o = i.panes(),
						r = [];
					for (let e = o.length; e--;) {
						const t = o[e],
							i = t.containsMainSeries(),
							s = t.dataSources();
						for (let e = s.length; e--;) {
							const t = s[e];
							(!i || (0, C.isStudy)(t) && t.isRemovedByStudyTemplates()) && r.push(t)
						}
					}
					i.resetDeferredStudies();
					const a = (0, Ve.closeSourcesSet)(i, r);
					for (let e = 0; e < a.length; ++e) i.removeSource(a[e]);
					const l = e.panes;
					for (let e = 0; e < l.length; e++) {
						let s = -1;
						const r = (0, y.clone)(l[e]);
						r.sources.sort(((e, t) => e.zorder - t.zorder));
						for (let e = 0; e < r.sources.length; e++) {
							const t = r.sources[e];
							if ((0, We.isMainSeriesState)(t)) {
								delete t.state, s = e;
								break
							}
						}
						const a = s > -1,
							c = a ? o[e] : i.createPane(e);
						if (a && t < 3 && (0, Fe.reorderDataSourcesStateZOrder)(r.sources), c.restoreState(r, !1, t), null !== c.mainDataSource()) {
							const e = (0, n.ensureNotNull)(this._model.alertsWatcher());
							for (const t of c.dataSources()) e.syncSourceAlertLabels(t)
						} else i.removePane(c)
					}
					return i.syncESD(), s.priceScale().setMode({
						autoScale: !0
					}), i.startNotStartedStudies(), i.recalculateAllPanes((0, he.globalChangeEvent)()), i.fullUpdate(), a
				}
			}
			var Ge = i(911905),
				je = i(95935),
				qe = i(992179);
			const Ke = (0, Ge.getLogger)("Chart.ChartUndoModel"),
				Ye = new c.TranslatedString("paste drawing", (0, l.t)("paste drawing"));
			class Xe extends p.UndoCommand {
				constructor(e, t, i, s, o) {
					super(Ye), this._needCopyToOtherCharts = !1, this._sourceState = null, this._model = e, this._clipboardData = t, this._paneIndex = this._model.panes().indexOf(i || (0, n.ensureNotNull)(this._model.paneForSource(this._model.mainSeries()))), this._pasteWithData = !!s, this._keepZIndex = !!o
				}
				redo() {
					const e = this._model.panes()[this._paneIndex],
						t = (0, n.ensureNotNull)(e.clipboardLineToolOwnerSource(this._clipboardData.source.id));
					null === this._sourceState && (this._sourceState = this._getSourceState(t));
					const i = (0, n.ensureNotNull)(e.restoreLineTool(this._sourceState, this._pasteWithData, this._keepZIndex, void 0, t));
					(0, n.ensureNotNull)(t.priceScale()).addDataSource(i), this._clipboardData.centeredOnChart && i.centerPosition && i.centerPosition(), i.restoreFixedPoints(), i.createServerPoints();
					const s = (0, qe.isSymbolSource)(t) || t.metaInfo().is_price_study;
					this._needCopyToOtherCharts = Boolean(s && ((0, Me.drawOnAllCharts)().value() || i.linkKey().value() && i.isSynchronizable())), this._model.setShouldBeSavedEvenIfHidden(!0)
				}
				undo() {
					if (!this._sourceState) return void Ke.logError("This command was never executed - nothing to undo");
					const e = this.source();
					this._clipboardData.centeredOnChart && (this._clipboardData.centeredOnChart = !1, this._sourceState.points = e.normalizedPoints()), this._model.removeSource(e)
				}
				source() {
					return (0, n.ensureNotNull)(this._model.dataSourceForId((0, n.ensureNotNull)(this._sourceState).id))
				}
				needCopyToOtherCharts() {
					return this._needCopyToOtherCharts
				}
				_getSourceState(e) {
					const t = (0, y.clone)(this._clipboardData.source);
					delete t.state.symbol, null != t.linkKey && (t.linkKey = (0, je.randomHash)());
					const i = (0, n.ensureNotNull)(e.priceScale()),
						s = this._model,
						{
							symbol: o,
							currencyId: r,
							unitId: l
						} = this._clipboardData.source.state,
						c = (0, n.ensureNotNull)(e.symbolSource());
					let h = !1;
					!c.symbolSameAsCurrent(o) || (null !== r ? r !== (0, ae.symbolCurrency)(c.symbolInfo(), void 0, !0) : c.isConvertedToOtherCurrency()) || (null !== l ? l !== (0, ae.symbolUnit)(c.symbolInfo(), this._model.unitConversionEnabled()) : c.isConvertedToOtherUnit()) || ((0, qe.isSymbolSource)(e) ? h = !0 : (0, C.isStudy)(e) && (h = Boolean(e.metaInfo().is_price_study)));
					const d = e => {
							const t = e.x * s.timeScale().width(),
								o = e.y * i.height() - 40;
							return new a.Point(t, o)
						},
						u = (0, n.ensureNotNull)(e.firstValue());
					if (this._model.id() === this._clipboardData.modelId || !h)
						for (let e = 0; e < this._clipboardData.geometry.length; ++e) {
							const o = d(this._clipboardData.geometry[e]),
								r = s.timeScale().coordinateToIndex(o.x),
								n = s.timeScale().normalizeBarIndex(r);
							if (h) {
								const s = i.priceToCoordinate(t.points[e].price, u) + -40;
								n.price = i.coordinateToPrice(s, u)
							} else n.price = i.coordinateToPrice(o.y, u);
							t.points[e] = n
						}
					return t.id = (0, je.randomHashN)(6), t
				}
			}
			var Ze = i(999998),
				$e = i(160377),
				Qe = i(38300);
			const Je = new c.TranslatedString("change symbol", (0, l.t)("change symbol"));
			class et extends p.UndoCommand {
				constructor(e, t, i) {
					super(Je), this._sourceId = e.id(), this._newSymbolParams = {
						symbol: t,
						currency: null,
						unit: null
					}, this._prevSymbolParams = {
						symbol: e.symbol(),
						currency: e.currency(),
						unit: e.unit(),
						interval: e.interval(),
						style: e.style()
					}, this._chartWidget = i, this._showFade = e === i.model().mainSeries()
				}
				redo() {
					this._showFade && this._chartWidget.screen.show();
					this._symbolSource().setSymbolParams(this._newSymbolParams)
				}
				undo() {
					this._showFade && this._chartWidget.screen.show();
					this._symbolSource().setSymbolParams(this._prevSymbolParams)
				}
				_symbolSource() {
					return (0, n.ensureNotNull)(this._chartWidget.model().model().dataSourceForId(this._sourceId))
				}
			}
			var tt = i(345848),
				it = i(795896);
			const st = (0, Ge.getLogger)("Chart.ChartUndoModel"),
				ot = new c.TranslatedString("paste indicator", (0, l.t)("paste indicator"));
			class rt extends p.UndoCommand {
				constructor(e, t, i) {
					super(ot), this._sourceState = null, this._model = e, this._clipboardData = t, this._paneId = i
				}
				redo() {
					if (!this._sourceState) {
						const e = (0, y.clone)(this._clipboardData.source);
						e.id = (0, je.randomHashN)(6), this._sourceState = e
					}
					let e, t;
					e = this._paneId ? (0,
						n.ensureNotNull)(this._model.paneForId(this._paneId)) : this._sourceState.metaInfo.is_price_study ? (0, n.ensureNotNull)(this._model.paneForSource(this._model.mainSeries())) : this._model.createPane();
					const i = !e.mainDataSource();
					this._sourceState.zorder = e.newStudyZOrder();
					const s = (0, n.ensureNotNull)(e.restoreStudy(this._sourceState, !1));
					i || (t = this._sourceState.metaInfo.is_price_study ? t = this._model.mainSeries().priceScale() : this._paneId ? e.findSuitableScale(s) : e.defaultPriceScale(), t !== s.priceScale() && e.move(s, t)), (0, C.isStudy)(s) && s.start()
				}
				undo() {
					if (null === this._sourceState) return void st.logError("This command was never executed - nothing to undo");
					const e = (0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceState.id));
					this._model.removeSource(e)
				}
				state() {
					return this._sourceState
				}
			}
			class nt extends p.UndoCommand {
				constructor(e, t, i, s, o) {
					super(null, !1), this._model = e, this._paneA = t, this._paneB = i, this._prevStretchA = s, this._currStretchA = o
				}
				redo() {
					const e = this._paneA.stretchFactor() + this._paneB.stretchFactor();
					this._paneA.setStretchFactor(this._currStretchA), this._paneB.setStretchFactor(e - this._currStretchA), this._model.fullUpdate()
				}
				undo() {
					const e = this._paneA.stretchFactor() + this._paneB.stretchFactor();
					this._paneA.setStretchFactor(this._prevStretchA), this._paneB.setStretchFactor(e - this._prevStretchA), this._model.fullUpdate()
				}
			}
			var at = i(443527);
			const lt = new c.TranslatedString("move", (0, l.t)("move"));
			class ct extends p.UndoCommand {
				constructor(e, t, i, s) {
					super(lt, !1), this._endEvent = null, this._model = e, this._sourceId = t.id(), this._itemIndex = i, this._startEvent = s
				}
				move(e) {
					this._endEvent = e, this._move(e)
				}
				hasChanges() {
					return null !== this._endEvent
				}
				undo() {
					this._move(this._startEvent)
				}
				redo() {
					this._move((0, n.ensureNotNull)(this._endEvent))
				}
				_move(e) {
					const t = (0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceId));
					(0, n.assert)(void 0 !== t.moveItem, 'The method "moveItem" is not defined'), t.moveItem && t.moveItem(new a.Point(e.localX, e.localY), this._itemIndex, new at.EnvironmentState(e))
				}
			}
			var ht = i(247001);
			class dt extends p.UndoCommand {
				constructor(e, t, i, s, o, r, n, a, l, c, h, d) {
					super(d), this._studyId = null, this._paneState = null, this._chartModel = e, this._studyMetaInfo = t, this._props = s, this._addAsOverlay = o, this._parentId = null == r ? null : r.id(), this._inputs = i, this._targetZOrder = h, this._preferredPriceScale = n, this._allowChangeCurrency = a, this._allowChangeUnit = l, this._paneSize = c
				}
				redo() {
					const e = null === this._parentId ? void 0 : this._chartModel.dataSourceForId(this._parentId),
						t = this._chartModel.insertStudyWithParams(this._studyMetaInfo, this._inputs, this._targetZOrder, this._props, this._addAsOverlay, e, this._preferredPriceScale, this._allowChangeCurrency, this._allowChangeUnit, this._paneSize, null === this._studyId ? void 0 : this._studyId);
					if (this._studyId = t.id(), t.childStudyByRebind().subscribe(null, (() => (0, tt.trackEvent)("SOS", "Apply SOS", "Rebind SOS"))), (0, ht.trackStudies)(t, "add"), this._chartModel.setShouldBeSavedEvenIfHidden(!0), null !== this._paneState) {
						(0, n.ensureNotNull)(this._chartModel.paneForSource(t)).restoreState(this._paneState, !1, this._chartModel.version()),
							this._paneState = null
					}
				}
				undo() {
					const e = (0, n.ensureNotNull)(this._chartModel.dataSourceForId((0, n.ensureNotNull)(this._studyId))),
						t = (0, n.ensureNotNull)(this._chartModel.paneForSource(e)).state();
					this._chartModel.removeSource(e) && (this._paneState = t)
				}
				insertedStudy() {
					return this._chartModel.dataSourceForId((0, n.ensureNotNull)(this._studyId))
				}
			}
			var ut = i(587314),
				_t = i(471133),
				mt = i.n(_t),
				pt = i(705318),
				gt = i(433904),
				St = i(611688),
				vt = i(54013),
				ft = i(62802),
				bt = i(491458);
			var yt = i(194946),
				Ct = i(43159);
			class wt extends p.UndoCommand {
				constructor(e) {
					const {
						undoText: t,
						chartModel: i,
						lineToolsSynchronizer: s,
						linkKey: o,
						symbol: r,
						state: n,
						unlink: a
					} = e;
					super(t), this._chartModel = i, this._lineToolsSynchronizer = s, this._linkKey = o, this._symbol = r, this._state = n, this._unlink = a
				}
				redo() {
					const e = (0, S.lineToolByLinkKey)(this._chartModel, this._linkKey);
					e ? (this._unlink && e.detachAlert(), new Ct.RemoveLineDataSourcesUndoCommand({
						chartModel: this._chartModel,
						lineDataSourceIds: [e.id()],
						title: null
					}).redo()) : this._lineToolsSynchronizer.markSyncedLineToolAsDeleted(this._linkKey, this._symbol).then((e => {
						if (null !== e) {
							this._state.id = e;
							const t = (0, S.lineToolByLinkKey)(this._chartModel, this._linkKey);
							null !== t && t.setId(e)
						}
					}))
				}
				undo() {
					if (null === (0, S.lineToolByLinkKey)(this._chartModel, this._linkKey)) {
						const e = (0, n.ensureNotNull)(this._chartModel.paneForSource(this._chartModel.mainSeries())),
							t = this._chartModel.panes().indexOf(e);
						this._chartModel.restoreSource(!1, t, null, this._state, null)
					}
				}
			}
			var Tt = i(532962),
				Pt = i(573033);
			const Mt = new c.TranslatedString("zoom", (0, l.t)("zoom"));
			class xt extends p.UndoCommand {
				constructor(e, t, i, s, o, r) {
					super(Mt), this._barSpacing = null, this._rightBarsOffset = null, this._leftBarsOffset = null, this._priceMode = null, this._model = e, this._startBar = t, this._endBar = i, this._startPrice = s, this._endPrice = o, this._pane = r
				}
				redo() {
					const e = (0, n.ensureNotNull)(this._model.timeScale().visibleBarsStrictRange());
					this._leftBarsOffset = e.firstBar() - this._startBar, this._rightBarsOffset = e.lastBar() - this._endBar, this._barSpacing = this._model.timeScale().barSpacing(), this._priceMode = this._pane.defaultPriceScale().mode(), this._model.zoomToViewport(this._startBar, this._endBar, this._startPrice, this._endPrice, this._pane)
				}
				undo() {
					const e = this._model.timeScale(),
						t = this._pane.defaultPriceScale(),
						i = (0, n.ensureNotNull)(e.visibleBarsStrictRange());
					e.setBarSpacing((0, n.ensureNotNull)(this._barSpacing)), e.zoomToBarsRange(i.firstBar() + (0, n.ensureNotNull)(this._leftBarsOffset), i.lastBar() + (0, n.ensureNotNull)(this._rightBarsOffset)), t.setMode((0, n.ensureNotNull)(this._priceMode)), t.recalculatePriceRange((0, n.ensureNotNull)(e.visibleBarsStrictRange())), this._model.recalculateAllPanes((0, he.viewportChangeEvent)()), this._model.lightUpdate()
				}
			}
			const It = (0, Ge.getLogger)("Chart.ChartUndoModel"),
				At = new c.TranslatedString("zoom", (0, l.t)("zoom"));
			class kt extends p.UndoCommand {
				constructor(e, t, i) {
					super(At), this._baseCmd = e, this._zoomStack = t, this._inOut = i
				}
				undo() {
					if (this._inOut) {
						if (this._baseCmd !== this._zoomStack.head()) return void It.logDebug("zoom stack inconsistency");
						this._baseCmd.undo(), this._zoomStack.pop()
					} else this._baseCmd.redo(), this._zoomStack.push(this._baseCmd)
				}
				redo() {
					if (this._inOut) this._baseCmd.redo(), this._zoomStack.push(this._baseCmd);
					else {
						if (this._baseCmd !== this._zoomStack.head()) return void It.logDebug("zoom stack inconsistency");
						this._baseCmd.undo(), this._zoomStack.pop()
					}
				}
			}
			const Lt = new c.TranslatedString("stop syncing drawing", (0, l.t)("stop syncing drawing"));
			class Et extends p.UndoCommand {
				constructor(e, t) {
					super(Lt), this._model = e, this._sourceId = t.id(), this._linkKey = t.linkKey().value()
				}
				redo() {
					(0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceId)).linkKey().setValue(null)
				}
				undo() {
					(0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceId)).linkKey().setValue(this._linkKey)
				}
			}
			const Dt = new c.TranslatedString("restore defaults", (0, l.t)("restore defaults"));
			class Nt extends p.UndoCommand {
				constructor(e, t, i = Dt) {
					super(i), this._chartModel = e, this._defaultProperty = t, this._state = t.state()
				}
				redo() {
					this._chartModel.restoreFactoryDefaults(this._defaultProperty)
				}
				undo() {
					this._defaultProperty.mergeAndFire(this._state), this._chartModel.mainSeries().onChartStyleChanged()
				}
			}
			var Bt = i(194543);
			class Ot extends Nt {
				redo() {
					this._defaultProperty.hasChild("intervalsVisibilities") && this._defaultProperty.childs().intervalsVisibilities.mergeAndFire(Bt.intervalsVisibilitiesDefaults), super.redo()
				}
			}
			class Rt extends Ot {
				redo() {
					super.redo(), this._chartModel.recalcColorStudies(!0)
				}
				undo() {
					super.undo(), this._chartModel.recalcColorStudies(!0)
				}
			}
			var Vt = i(669415),
				Wt = i(198796),
				Ft = i(385518);

			function zt(e) {
				const {
					visible: t,
					...i
				} = e;
				return i
			}

			function Ut(e) {
				const {
					visible: t,
					...i
				} = e;
				return i
			}

			function Ht(e) {
				const {
					drawWick: t,
					drawBorder: i,
					drawBody: s,
					barColorsOnPrevClose: o,
					...r
				} = e;
				return r
			}

			function Gt(e) {
				const {
					drawWick: t,
					drawBorder: i,
					drawBody: s,
					...o
				} = e;
				return o
			}

			function jt(e) {
				const {
					drawWick: t,
					drawBorder: i,
					drawBody: s,
					showRealLastPrice: o,
					inputs: r,
					...n
				} = e;
				return n
			}

			function qt(e) {
				const {
					barColorsOnPrevClose: t,
					dontDrawOpen: i,
					thinBars: s,
					...o
				} = e;
				return o
			}

			function Kt(e) {
				const {
					showBorders: t,
					showLabels: i,
					drawBody: s,
					...o
				} = e;
				return o
			}

			function Yt(e) {
				const {
					linestyle: t,
					linewidth: i,
					styleType: s,
					priceSource: o,
					...r
				} = e;
				return r
			}

			function Xt(e) {
				const {
					linestyle: t,
					linewidth: i,
					priceSource: s,
					...o
				} = e;
				return o
			}

			function Zt(e) {
				const {
					inputs: t,
					...i
				} = e;
				return i
			}

			function $t(e) {
				const {
					inputs: t,
					...i
				} = e;
				return i
			}

			function Qt(e) {
				const {
					inputs: t,
					...i
				} = e;
				return i
			}

			function Jt(e) {
				const {
					inputs: t,
					...i
				} = e;
				return i
			}

			function ei(e) {
				const {
					topLineWidth: t,
					bottomLineWidth: i,
					baseLevelPercentage: s,
					priceSource: o,
					...r
				} = e;
				return r
			}

			function ti(e) {
				const {
					thinBars: t,
					inputs: i,
					...s
				} = e;
				return s
			}

			function ii(e) {
				const {
					visible: t,
					style: i,
					symbol: s,
					interval: o,
					sessionId: r,
					highLowAvgPrice: n,
					showCountdown: a,
					bidAsk: l,
					prePostMarket: c,
					priceAxisProperties: h,
					candleStyle: d,
					hollowCandleStyle: u,
					haStyle: _,
					barStyle: m,
					hiloStyle: p,
					lineStyle: g,
					areaStyle: S,
					renkoStyle: v,
					pbStyle: f,
					kagiStyle: b,
					pnfStyle: y,
					baselineStyle: C,
					rangeStyle: w,
					...T
				} = e;
				return {
					bidAsk: zt(l),
					prePostMarket: Ut(c),
					candleStyle: Ht(d),
					hollowCandleStyle: Gt(u),
					haStyle: jt(_),
					barStyle: qt(m),
					hiloStyle: Kt(p),
					lineStyle: Yt(g),
					areaStyle: Xt(S),
					renkoStyle: Zt(v),
					pbStyle: $t(f),
					kagiStyle: Qt(b),
					pnfStyle: Jt(y),
					baselineStyle: ei(C),
					rangeStyle: ti(w),
					...T
				}
			}

			function si(e) {
				const {
					scaleSeriesOnly: t,
					showSeriesLastValue: i,
					showStudyLastValue: s,
					showSymbolLabels: o,
					showBidAskLabels: r,
					showPrePostMarketPriceLabel: n,
					showStudyPlotLabels: a,
					showFundamentalNameLabel: l,
					showFundamentalLastValue: c,
					seriesLastValueMode: h,
					...d
				} = e;
				return d
			}

			function oi(e) {
				const {
					topMargin: t,
					bottomMargin: i,
					...s
				} = e;
				return s
			}
			const ri = new c.TranslatedString("apply chart theme", (0, l.t)("apply chart theme"));
			class ni extends p.UndoCommand {
				constructor(e, t, i) {
					var s, o, r;
					super(ri), this._model = e, this._newSessionProps = t.sessions || (0, Ft.factoryDefaults)("sessions"), ["candleStyle", "hollowCandleStyle", "haStyle"].forEach((e => {
						t.mainSourceProperties[e].wickUpColor = t.mainSourceProperties[e].wickUpColor || t.mainSourceProperties[e].wickColor, t.mainSourceProperties[e].wickDownColor = t.mainSourceProperties[e].wickDownColor || t.mainSourceProperties[e].wickColor
					})), t.chartProperties = null !== (s = t.chartProperties) && void 0 !== s ? s : {
						paneProperties: void 0,
						scalesProperties: void 0
					}, t.chartProperties.paneProperties.vertGridProperties = null !== (o = t.chartProperties.paneProperties.vertGridProperties) && void 0 !== o ? o : t.chartProperties.paneProperties.gridProperties, t.chartProperties.paneProperties.horzGridProperties = null !== (r = t.chartProperties.paneProperties.horzGridProperties) && void 0 !== r ? r : t.chartProperties.paneProperties.gridProperties;
					const n = this._model.properties().state().paneProperties.legendProperties;
					delete n.backgroundTransparency, t.chartProperties.paneProperties.legendProperties = {
						...t.chartProperties.paneProperties.legendProperties,
						...n
					};
					const a = (0, Ft.factoryDefaults)("chartproperties"),
						l = (0, Wt.deepExtend)({}, a, t.chartProperties);
					this._newChartProps = {
						paneProperties: oi(l.paneProperties),
						scalesProperties: si(l.scalesProperties)
					}, e.timeScale().preserveBarSpacing() && delete this._newChartProps.scalesProperties.barSpacing;
					const c = (0, Ft.factoryDefaults)("chartproperties.mainSeriesProperties"),
						h = (0, Wt.deepExtend)({}, c, t.mainSourceProperties);
					this._newSeriesProps = i ? h : ii(h);
					const d = e.properties().state();
					this._oldChartProps = {
						paneProperties: oi(d.paneProperties),
						scalesProperties: si(d.scalesProperties)
					};
					const u = e.mainSeries().properties().state();
					this._oldSeriesProps = i ? u : ii(u), this._oldSessionProps = this._model.sessions().properties().state()
				}
				undo() {
					this._merge(this._oldChartProps, this._oldSeriesProps, this._oldSessionProps), this._model.mainSeries().onChartStyleChanged(), this._model.updateScales(), this._model.chartThemeLoaded()
				}
				redo() {
					this._merge(this._newChartProps, this._newSeriesProps, this._newSessionProps), this._model.mainSeries().onChartStyleChanged(), this._model.updateScales(), this._model.chartThemeLoaded()
				}
				_merge(e, t, i) {
					var s, o, r, n;
					const a = this._model;
					(0, ne.saveDefaultProperties)(!0), e && (a.properties().childs().paneProperties.mergeAndFire(e.paneProperties), a.properties().childs().scalesProperties.mergeAndFire(e.scalesProperties)), "priceAxisProperties" in t && a.mainSeries().priceScale().setMode({
						autoScale: null === (s = t.priceAxisProperties) || void 0 === s ? void 0 : s.autoScale,
						percentage: null === (o = t.priceAxisProperties) || void 0 === o ? void 0 : o.percentage,
						log: null === (r = t.priceAxisProperties) || void 0 === r ? void 0 : r.log,
						lockScale: null === (n = t.priceAxisProperties) || void 0 === n ? void 0 : n.lockScale
					}), a.mainSeries().properties().mergeAndFire(t), a.mainSeries().properties().saveDefaults(), a.mainSeries().createPaneView(), a.mainSeries().invalidateBarStylesCache(), a.recalculateAllPanes((0, he.globalChangeEvent)()), a.fullUpdate(), a.properties().saveDefaults(), a.sessions().restoreState({
						properties: i
					}, !1), (0, ne.saveDefaultProperties)(!1)
				}
			}
			const ai = new c.TranslatedString("change resolution", (0, l.t)("change resolution"));
			class li extends p.UndoCommand {
				constructor(e, t, i) {
					let s;
					super(ai), this._sourceId = e.id();
					const o = (0, ae.isRangeStyle)(e.style()),
						r = _e.Interval.isRange(t);
					!o && r ? s = 11 : o && !r && (s = (0, ae.getLastUsedStyle)()), this._newSymbolParams = {
						interval: t,
						style: s
					}, this._prevSymbolParams = {
						symbol: e.symbol(),
						currency: e.currency(),
						unit: e.unit(),
						interval: e.interval(),
						style: e.style()
					}, this._chartWidget = i
				}
				redo() {
					this._chartWidget.screen.show();
					this._symbolSource().setSymbolParams(this._newSymbolParams)
				}
				undo() {
					this._chartWidget.screen.show();
					this._symbolSource().setSymbolParams(this._prevSymbolParams)
				}
				_symbolSource() {
					return (0, n.ensureNotNull)(this._chartWidget.model().model().dataSourceForId(this._sourceId))
				}
			}
			const ci = new c.TranslatedString("send {title} backward", (0, l.t)("send {title} backward")),
				hi = new c.TranslatedString("bring {title} forward", (0, l.t)("bring {title} forward")),
				di = new c.TranslatedString("insert {title} after {target}", (0, l.t)("insert {title} after {target}")),
				ui = new c.TranslatedString("insert {title} before {target}", (0, l.t)("insert {title} before {target}")),
				_i = new c.TranslatedString("cut {title}", (0, l.t)("cut {title}")),
				mi = new c.TranslatedString("cut sources", (0, l.t)("cut sources")),
				pi = new c.TranslatedString("remove {title}", (0, l.t)("remove {title}")),
				gi = new c.TranslatedString("remove drawings group", (0, l.t)("remove drawings group")),
				Si = new c.TranslatedString("move scale", (0, l.t)("move scale")),
				vi = new c.TranslatedString("stop syncing line tool(s)", (0, l.t)("stop syncing line tool(s)")),
				fi = new c.TranslatedString("zoom out", (0, l.t)("zoom out")),
				bi = new c.TranslatedString("zoom in", (0, l.t)("zoom in")),
				yi = new c.TranslatedString("move drawing(s)", (0, l.t)("move drawing(s)")),
				Ci = new c.TranslatedString("load default drawing template", (0, l.t)("load default drawing template")),
				wi = new c.TranslatedString("apply factory defaults to selected sources", (0, l.t)("apply factory defaults to selected sources")),
				Ti = new c.TranslatedString("change currency", (0, l.t)("change currency")),
				Pi = new c.TranslatedString("change unit", (0, l.t)("change unit")),
				Mi = new c.TranslatedString("clone line tools", (0, l.t)("clone line tools")),
				xi = new c.TranslatedString("merge up", (0, l.t)("merge up")),
				Ii = new c.TranslatedString("merge down", (0, l.t)("merge down")),
				Ai = new c.TranslatedString("merge to pane", (0, l.t)("merge to pane")),
				ki = new c.TranslatedString("unmerge up", (0, l.t)("unmerge up")),
				Li = new c.TranslatedString("unmerge down", (0,
					l.t)("unmerge down")),
				Ei = new c.TranslatedString("unmerge to new bottom pane", (0, l.t)("unmerge to new bottom pane")),
				Di = new c.TranslatedString("move {title} to new right scale", (0, l.t)("move {title} to new right scale")),
				Ni = new c.TranslatedString("move {title} to new left scale", (0, l.t)("move {title} to new left scale")),
				Bi = new c.TranslatedString("make {title} no scale (Full screen)", (0, l.t)("make {title} no scale (Full screen)")),
				Oi = new c.TranslatedString("scroll time", (0, l.t)("scroll time")),
				Ri = new c.TranslatedString("scale time", (0, l.t)("scale time")),
				Vi = new c.TranslatedString("reset time scale", (0, l.t)("reset time scale")),
				Wi = new c.TranslatedString("reset scales", (0, l.t)("reset scales")),
				Fi = new c.TranslatedString("create {tool}", (0, l.t)("create {tool}")),
				zi = new c.TranslatedString("change {pointIndex} point", (0, l.t)("change {pointIndex} point")),
				Ui = new c.TranslatedString("paste {title}", (0, l.t)("paste {title}")),
				Hi = new c.TranslatedString("insert {title}", (0, l.t)("insert {title}")),
				Gi = new c.TranslatedString("remove all studies", (0, l.t)("remove all studies")),
				ji = new c.TranslatedString("remove drawings", (0, l.t)("remove drawings")),
				qi = new c.TranslatedString("remove all studies and drawing tools", (0, l.t)("remove all studies and drawing tools")),
				Ki = new c.TranslatedString("turn line tools sharing off", (0, l.t)("turn line tools sharing off")),
				Yi = new c.TranslatedString("share line tools in layout", (0, l.t)("share line tools in layout")),
				Xi = new c.TranslatedString("share line tools globally", (0, l.t)("share line tools globally"));

			function Zi(e, t) {
				return {
					bringForwardEnabled: e.bringForwardEnabled || t.bringForwardEnabled,
					bringToFrontEnabled: e.bringToFrontEnabled || t.bringToFrontEnabled,
					sendBackwardEnabled: e.sendBackwardEnabled || t.sendBackwardEnabled,
					sendToBackEnabled: e.sendToBackEnabled || t.sendToBackEnabled
				}
			}

			function $i(e) {
				return new c.TranslatedString(e.name(), e.title())
			}
			const Qi = (0, x.isFeatureEnabled)("save_shared_line_tools");

			function Ji() {
				return Qi ? (0, Me.drawOnAllCharts)().value() ? 1 === (0, Me.drawOnAllChartsMode)().value() ? 1 : 2 : 0 : (0, Me.drawOnAllCharts)().value() ? 1 : 0
			}
			class es extends(o()) {
				constructor(e, t, i, s, o, r, n, a, l, c, h) {
					super(), this._createLineCommand = null, this._initialTimeScrollState = null, this._initialTimeScrollPos = null, this._scalePriceInfo = null, this._currentSourceMoveCommand = null, this._currentLineChangeCommand = null, this._currentCustomMoveCommand = null, this._zoomStack = new m.UndoStack, this._lineToolsDoNotAffectChartInvalidation = new we.FeatureToggleWatchedValue("do_not_invalidate_chart_on_changing_line_tools", !1), this._chartWidget = r, this.m_model = new(mt())(e, t, i, s, o, this, a, l, c, h), this._undoHistory = n, this._lineToolsGroupController = new Oe({
						model: this._model.bind(this),
						pushUndoCommand: this._pushUndoCommand.bind(this),
						beginUndoMacro: (e, t) => {
							this._undoHistory.beginUndoMacro(e).setCustomFlag("doesnt_affect_save", !!t)
						},
						endUndoMacro: this._undoHistory.endUndoMacro.bind(this._undoHistory),
						emitEvent: this.emitEvent.bind(this)
					})
				}
				undoHistory() {
					return this._undoHistory
				}
				setWatchedValue(e, t, i) {
					this._undoHistory.setWatchedValue(e, t, i)
				}
				lineToolsGroupController() {
					return this._lineToolsGroupController
				}
				mergeAllScales(e) {
					(0, _.mergeAllScalesAction)(this, e)
				}
				movePriceScale(e, t, i, s) {
					const o = new g(this._model(), e, t, i, s, Si);
					this._pushUndoCommand(o)
				}
				createLineTool({
					pane: e,
					point: t,
					linetool: i,
					properties: s,
					linkKey: o,
					ownerSource: r,
					disableSynchronization: a,
					sharingMode: l = Ji(),
					id: h
				}) {
					if (("LineToolRegressionTrend" === i || "LineToolAnchoredVWAP" === i) && !this.canCreateStudy()) return (0, d.showTooManyStudiesNotice)(), null;
					const u = Fi.format({
						tool: new c.TranslatedString(i, I.lineToolsLocalizedNames[i])
					});
					this.beginUndoMacro(u, this._lineToolsDoNotAffectChartInvalidation.value());
					const _ = !a;
					this._createLineCommand = new L(this._model(), e, i, r || (0, n.ensureNotNull)(e.mainDataSource()), l, h);
					const m = this._createLineCommand.startCreatingLine(t, s, o || null),
						p = (0, n.ensureNotNull)(this._createLineCommand.line());
					let g = null;
					if (m && (_ && this.finishLineTool(p), this._pushUndoCommand(this._createLineCommand), this._createLineCommand = null, g = {
							points: p.normalizedPoints(),
							interval: this.mainSeries().interval()
						}), _ && void 0 === o && (0, Me.drawOnAllCharts)().value() && p.isSynchronizable()) {
						const e = (0, n.ensureNotNull)(this.model().externalTimeStamp(t.index)),
							s = {
								point: {
									price: t.price,
									timeStamp: e
								},
								linetool: i,
								properties: p.properties(),
								symbol: this.mainSeries().symbol(),
								model: this.model(),
								linkKey: (0, n.ensureNotNull)(p.linkKey().value()),
								finalState: g,
								id: p.id()
							};
						p.isFixed() && (s.pointPositionPercents = p.calcPositionPercents()[0]), (0, Me.createLineTool)(s)
					}
					return this.endUndoMacro(), p
				}
				continueCreatingLine(e, t, i, s) {
					const o = (0, n.ensureNotNull)(this._createLineCommand);
					this.beginUndoMacro(o.text(), this._lineToolsDoNotAffectChartInvalidation.value());
					const r = (0, n.ensureNotNull)(this._model().lineBeingCreated()),
						a = o.continueCreatingLine(e, t, i, s);
					let l = null;
					if (a && (this.finishLineTool(r), this._pushUndoCommand(o), this._createLineCommand = null, l = {
							points: r.normalizedPoints(),
							interval: this.mainSeries().interval()
						}), o.drawOnAllCharts() && r.isSynchronizable()) {
						const i = (0, n.ensureNotNull)(this._model().externalTimeStamp(e.index));
						(0, Me.continueLineTool)({
							point: {
								price: e.price,
								timeStamp: i
							},
							envState: t,
							finalState: l,
							model: this._model()
						})
					}
					return this.endUndoMacro(), a
				}
				continueExternalLine(e, t, i) {
					const s = (0, n.ensureNotNull)(this._createLineCommand),
						o = s.continueCreatingLine(e, t, i);
					return o && (this._pushUndoCommand(s), this._createLineCommand = null), o
				}
				finishLineTool(e) {
					this._model().finishLineTool(e)
				}
				pasteImageAsLineTool(e, t, i, s) {
					const o = this._model().timeScale(),
						r = o.width(),
						a = i.height(),
						l = i.defaultPriceScale(),
						h = (0, n.ensureNotNull)((0, n.ensureNotNull)(l.mainSource()).firstValue()),
						d = {
							price: l.coordinateToPrice(a / 2, h),
							index: o.coordinateToIndex(r / 2)
						},
						u = (0, S.createLineToolProperties)("LineToolImage", void 0, this.model());
					void 0 !== s && u.childs().transparency.setValue(s);
					const _ = (0, n.ensureNotNull)(l.mainSource());
					(0, S.prepareLineToolPropertiesByOwnerSource)(u, _);
					const m = this.createLineTool({
						pane: i,
						point: d,
						linetool: "LineToolImage",
						properties: u
					});
					return m && (m.setBlobImageUrl(t), this.selectionMacro((e => {
							e.clearSelection(), e.addSourceToSelection(m, null)
						})),
						e.then((e => {
							m.properties().childs().url.setValue(e)
						})).catch((e => {
							const t = m.linkKey().value(),
								i = this.model();
							null !== t && (0, Me.removeLineTool)({
								withUndo: !1,
								model: i,
								linkKey: t,
								symbol: m.symbol(),
								sourceTitle: new c.TranslatedString(m.name(), m.title()),
								lineToolState: m.state(!1)
							}), i.removeSource(m)
						}))), m
				}
				loadRange(e) {
					this._pushUndoCommand(new pe(this._model(), e))
				}
				unlinkLines(e) {
					const t = this.model();
					this.beginUndoMacro(vi, this._lineToolsDoNotAffectChartInvalidation.value());
					for (const i of e) null !== i.linkKey().value() && (0, Me.removeLineTool)({
						withUndo: !0,
						model: this.model(),
						symbol: i.symbol(),
						linkKey: (0, n.ensureNotNull)(i.linkKey().value()),
						sourceTitle: $i(i),
						lineToolState: i.state(!1),
						unlink: !0
					}), this._pushUndoCommand(new Et(t, i));
					this.endUndoMacro()
				}
				zoomFromViewport() {
					const e = new kt((0, n.ensureDefined)(this._zoomStack.head()), this._zoomStack, !1);
					this._pushUndoCommand(e)
				}
				zoomToViewport(e, t, i, s, o) {
					const r = new xt(this.m_model, e, t, i, s, o),
						n = new kt(r, this._zoomStack, !0);
					this._pushUndoCommand(n)
				}
				zoomStack() {
					return this._zoomStack
				}
				hoveredSource() {
					return this.m_model.hoveredSource()
				}
				setProperty(e, t, i, s) {
					if (e && e.value() !== t) {
						const o = new Te(e, t, i, this.m_model, s);
						this._pushUndoCommand(o), this.emitEvent("setProperty")
					}
				}
				withMacro(e, t, i) {
					const s = this.beginUndoMacro(e, i);
					try {
						t()
					} finally {
						this.endUndoMacro()
					}
					return s
				}
				barsMarksSources() {
					return this.m_model.barsMarksSources()
				}
				barMarksSourceForId(e) {
					return this.m_model.barMarksSourceForId(e)
				}
				removeAllDrawingTools() {
					this.beginUndoMacro(ji, !0), this._removeAllDrawingToolsImpl(), this.endUndoMacro()
				}
				removeAllStudiesAndDrawingTools() {
					this.beginUndoMacro(qi), this._removeAllDrawingToolsImpl(), this._removeAllStudiesImpl(), this.endUndoMacro()
				}
				removeAllStudies() {
					this.beginUndoMacro(Gi), this._removeAllStudiesImpl(), this.endUndoMacro()
				}
				canZoomIn() {
					return this.model().canZoomIn()
				}
				canZoomOut() {
					return this.model().canZoomOut()
				}
				zoomOut() {
					const e = this.timeScale().width();
					if (this.canZoomOut()) {
						try {
							this.beginUndoMacro(fi)
						} catch (e) {
							return
						}(0, ge.doAnimate)({
							to: e / 5,
							onStep: e => {
								this.startScaleTime(0), this.scaleTimeTo(e), this.endScaleTime()
							},
							onComplete: () => this.endUndoMacro()
						})
					}
				}
				zoomIn() {
					const e = this.timeScale().width();
					if (this.canZoomIn()) {
						try {
							this.beginUndoMacro(bi)
						} catch (e) {
							return
						}(0, ge.doAnimate)({
							to: e / 5,
							onStep: e => {
								this.startScaleTime(e), this.scaleTimeTo(0), this.endScaleTime()
							},
							onComplete: () => this.endUndoMacro()
						})
					}
				}
				startMovingSources(e, t, i, s) {
					e.filter((e => e.doesMovingAffectsUndo())).length && (this._currentSourceMoveCommand = new w(this.model(), e, yi, !1), e.every(S.isLineTool) && this._currentSourceMoveCommand.setCustomFlag("doesnt_affect_save", this._lineToolsDoNotAffectChartInvalidation.value())), this.model().startMovingSources(e, t, i, new Map, s)
				}
				moveSources(e, t) {
					this.model().moveSources(e, new Map, t)
				}
				endMovingSource(e, t) {
					this.model().endMovingSources(e, void 0, t), null !== this._currentSourceMoveCommand && (this._currentSourceMoveCommand.saveNewState(), this._pushUndoCommand(this._currentSourceMoveCommand)), this._currentSourceMoveCommand = null
				}
				startChangingLinetool(e, t, i, s, o) {
					this._currentLineChangeCommand = new w(this.model(), [e], zi.format({
						pointIndex: i
					}), !1), this._currentLineChangeCommand.setCustomFlag("doesnt_affect_save", this._lineToolsDoNotAffectChartInvalidation.value()), this.model().startChangingLinetool(e, t, i, s, o)
				}
				changeLinePoint(e, t) {
					this.model().changeLinePoint(e, t)
				}
				endChangingLinetool(e) {
					this.model().endChangingLinetool(e), null !== this._currentLineChangeCommand && (this._currentLineChangeCommand.saveNewState(), this._pushUndoCommand(this._currentLineChangeCommand)), this._currentLineChangeCommand = null
				}
				setChartStyleProperty(e, t, i) {
					if (e.value() !== t) {
						const s = new de(e, t, this.mainSeries(), i, this.model(), this.chartWidget());
						this._pushUndoCommand(s), this.emitEvent("setChartStyleProperty"), (0, re.trackChartStyleChanged)(e.value())
					}
				}
				restorePropertiesForSource(e) {
					(0, S.isLineTool)(e) ? this._restoreLineToolFactoryDefaults(e): this._restoreStudyFactoryDefaults(e)
				}
				restoreLineToolsFactoryDefaults(e) {
					1 === e.length ? this._restoreLineToolFactoryDefaults(e[0]) : (this.beginUndoMacro(wi), e.forEach((e => this._restoreLineToolFactoryDefaults(e))), this.endUndoMacro())
				}
				restoreState(e, t, i) {
					return this.m_model.restoreState(e, t, i)
				}
				async clipboardCopy(e, t = this.selection().dataSources()) {
					if (!(0, St.enabled)("datasource_copypaste")) return;
					const i = t.filter((e => e.copiable()));
					if (0 === i.length) return;
					for (const e of i)
						if ((0, C.isStudy)(e) && e.isChildStudy()) throw new Error("Can not copy child study");
					const s = (0, E.clipboardDataForSources)(this._model().id(), i);
					return null !== s ? e.write({
						app: JSON.stringify(s),
						text: s.title
					}) : void 0
				}
				async clipboardCut(e, t = this.selection().dataSources()) {
					if (!(0, St.enabled)("datasource_copypaste")) return;
					const i = t.filter((e => e.copiable()));
					if (0 === i.length) return;
					await this.clipboardCopy(e, i);
					const s = i.filter((e => e.isUserDeletable()));
					if (0 === s.length) return;
					const o = (1 === s.length ? _i : mi).format({
						title: $i(s[0])
					});
					this.beginUndoMacro(o), this.m_model.selectionMacro((() => this.removeSources(s, !1, o)), !0), this.endUndoMacro()
				}
				async clipboardPaste(e, t) {
					let i = null;
					if ((0, St.enabled)("datasource_copypaste") && (i = i || await e.read(), i.app)) {
						const e = JSON.parse(i.app);
						if (null !== this.pasteSourceFromClip(t, e)) return
					}
					await this._processSpecialLineToolsContents(e, i, t)
				}
				applyStudyTemplate(e, t) {
					const i = new He(this._model(), e, t);
					this._pushUndoCommand(i)
				}
				startCustomMoving(e, t, i) {
					this._currentCustomMoveCommand = new ct(this.model(), e, t, i)
				}
				customMoveBeingProcessed() {
					return null !== this._currentCustomMoveCommand
				}
				processCustomMove(e) {
					(0, n.ensureNotNull)(this._currentCustomMoveCommand).move(e)
				}
				endCustomMoving() {
					null !== this._currentCustomMoveCommand && this._currentCustomMoveCommand.hasChanges() && (this._pushUndoCommand(this._currentCustomMoveCommand), this._currentCustomMoveCommand = null)
				}
				panes() {
					return this.m_model.panes()
				}
				cloneLineTools(e, t) {
					for (let t = 0; t < Math.min(5, e.length); ++t)(0, re.trackDrawingCloned)(e[t]);
					this.beginUndoMacro(Mi, this._lineToolsDoNotAffectChartInvalidation.value());
					const i = new v(this._model(), e, t, Mi);
					if (this._pushUndoCommand(i), (0, Me.drawOnAllCharts)().value()) {
						const e = i.newIds().map((e => (0,
							n.ensureNotNull)(this.model().dataSourceForId(e))));
						this.copyToOtherCharts(e)
					}
					return this.endUndoMacro(), this.emitEvent("cloneLineTools"), i.newIds()
				}
				removeSource(e, t, i) {
					this.lineBeingCreated() !== e ? this.removeSources([e], t, pi.format({
						title: $i(e)
					}), i) : this.cancelCreatingLine()
				}
				removeSelectedSources() {
					const e = this._model().selection().dataSources();
					if (!e.length) return;
					const t = (e.length > 1 ? gi : pi).format({
						title: $i(e[0])
					});
					this.removeSources(e, !1, t)
				}
				removeSources(e, t, i, s) {
					s || (e = e.filter((e => e.isUserDeletable())));
					const o = this._model(),
						r = o.lineToolsGroupModel(),
						a = e.every(S.isLineTool) && this._lineToolsDoNotAffectChartInvalidation.value();
					this.beginUndoMacro(i, a), o.selectionMacro((s => {
						const a = new Map;
						e.forEach((e => {
							if ((0, S.isLineTool)(e)) {
								const t = r.groupForLineTool(e);
								if (null !== t) {
									const i = a.get(t) || [];
									i.push(e), a.set(t, i)
								}
								null !== e.linkKey().value() && (0, Me.removeLineTool)({
									withUndo: !0,
									model: this.model(),
									linkKey: (0, n.ensureNotNull)(e.linkKey().value()),
									symbol: this.model().mainSeries().symbol(),
									lineToolState: e.state(!1),
									sourceTitle: $i(e)
								})
							}
						})), a.forEach(((e, t) => {
							const i = new b.ExcludeLineToolsFromGroupUndoCommand(o, t, e);
							this._pushUndoCommand(i)
						}));
						const l = new f.RemoveSourcesCommand(o, e, i),
							c = l.removedIds();
						this._pushUndoCommand(l), !t && c.length > 0 && (1 === c.length ? this.emitEvent("removeSource", [c[0]]) : this.emitEvent("removeSources", [c]))
					}), !0), this.endUndoMacro()
				}
				removeUnloadedLineTool({
					lineToolsSynchronizer: e,
					sourceTitle: t,
					linkKey: i,
					symbol: s,
					state: o,
					withUndo: r,
					unlink: n
				}) {
					const a = new wt({
						undoText: pi.format({
							title: t
						}),
						chartModel: this._model(),
						lineToolsSynchronizer: e,
						linkKey: i,
						symbol: s,
						state: o,
						unlink: n
					});
					r ? this._pushUndoCommand(a) : a.redo()
				}
				async scrollToLineTool(e) {
					const t = this.timeScale().logicalRange();
					if (null === t) return;
					const i = this.timeScale().barSpacing();
					let s = t.left();
					const o = e.points().map((e => e.index));
					let r = this.timeScale().points().firstIndex();
					const a = this.timeScale().points().lastIndex();
					if (null === r || null === a) return;
					const l = t.length() / 2;
					if (0 === o.length || o.some((e => t.contains(e)))) return;
					const c = () => {
						const t = e.points().map((e => e.index)),
							i = t.filter((e => e <= a)).reduce(((e, t) => null === e ? t : Math.max(e, t)), null);
						return null !== i ? i : t.reduce(((e, t) => Math.min(e, t)))
					};
					let d, u = c();
					if (r - l > u) {
						const t = e.points().map((e => e.time)).filter(y.notUndefined).map((e => e.valueOf() / 1e3));
						if (0 === t.length) return;
						const i = t.reduce(((e, t) => Math.min(e, t)), t[0]);
						await this.model().gotoTime(i), u = c();
						s = (0, n.ensureNotNull)(this.timeScale().logicalRange()).left(), r = (0, n.ensureNotNull)(this.timeScale().points().firstIndex())
					}
					r - l > u ? (d = (s - r + l) * i, this.mainSeries().setGotoDateResult({
						timestamp: (0, n.ensureNotNull)(this.timeScale().points().valueAt(r)),
						eod: !0
					})) : d = (s - u + 1 + l) * i, this.startScrollTime(0), (0, ge.doAnimate)({
						onStep: (e, t) => this.scrollTimeTo(t),
						from: 0,
						to: Math.round(d),
						easing: h.easingFunc.easeInOutCubic,
						duration: h.dur,
						onComplete: () => this.endScrollTime()
					})
				}
				mergeSourceUp(e) {
					const t = new P.MergeUpUndoCommand(this._model(), e, xi);
					this._mergeUnmergeSource(e, t)
				}
				mergeSourceDown(e) {
					const t = new P.MergeDownUndoCommand(this._model(), e, Ii);
					this._mergeUnmergeSource(e, t)
				}
				mergeToPane(e, t, i) {
					const s = this._model().panes().indexOf(t),
						o = new P.MergeToTargetPane(this._model(), e, s, Ai, i);
					this._mergeUnmergeSource(e, o)
				}
				unmergeSourceUp(e) {
					const t = new T.UnmergeUpUndoCommand(this._model(), e, ki);
					this._mergeUnmergeSource(e, t)
				}
				unmergeSourceDown(e) {
					const t = new T.UnmergeDownUndoCommand(this._model(), e, Li);
					this._mergeUnmergeSource(e, t)
				}
				unmergeToNewBottomPane(e) {
					const t = new T.UnmergeToNewBottomPane(this._model(), e, Ei);
					this._mergeUnmergeSource(e, t)
				}
				availableZOrderOperations(e) {
					const t = this._model().lineToolsGroupModel(),
						i = e.filter(S.isLineTool),
						s = i.map((e => t.groupForLineTool(e)));
					(0, n.assert)(new Set(s).size <= 1, "Cannot move line tools from different group");
					const o = 0 === s.length ? null : s[0];
					let r = {
						bringForwardEnabled: !1,
						bringToFrontEnabled: !1,
						sendBackwardEnabled: !1,
						sendToBackEnabled: !1
					};
					const a = new Set(i);
					for (const t of (0, M.sortSources)(e)) {
						if ((0, S.isLineTool)(t) && null !== o) {
							const e = (0, M.sortSources)(o.lineTools().filter((e => !a.has(e) || e === t)));
							r = Zi(r, {
								bringForwardEnabled: t !== e[e.length - 1],
								bringToFrontEnabled: t !== e[e.length - 1],
								sendBackwardEnabled: t !== e[0],
								sendToBackEnabled: t !== e[0]
							});
							continue
						}
						const e = (0, n.ensureNotNull)(this._model().paneForSource(t)).sourcesByGroup().allExceptSpecialSources();
						if (0 === e.length) continue;
						const i = t.zorder(),
							s = e[0].zorder(),
							l = e[e.length - 1].zorder();
						r = Zi(r, {
							bringForwardEnabled: i !== l,
							bringToFrontEnabled: i !== l,
							sendBackwardEnabled: i !== s,
							sendToBackEnabled: i !== s
						})
					}
					return r
				}
				sendToBack(e) {
					if (!this.availableZOrderOperations(e).sendToBackEnabled) throw new Error("Send to back operation is unavailable");
					let t = null;
					const i = e[0];
					if ((0, S.isLineTool)(i)) {
						const s = this._model().lineToolsGroupModel().groupForLineTool(i);
						if (null !== s) {
							const i = s.lineTools();
							t = new Y(this.model(), (0, M.sortSources)(e), i[0])
						}
					}
					null === t && (t = new G(this.model(), (0, M.sortSources)(e))), this._pushUndoCommand(t), this.emitEvent("changeZOrder", [e])
				}
				bringToFront(e) {
					if (!this.availableZOrderOperations(e).bringToFrontEnabled) throw new Error("Bring to front operation is unavailable");
					let t = null;
					const i = e[0];
					if ((0, S.isLineTool)(i)) {
						const s = this._model().lineToolsGroupModel().groupForLineTool(i);
						if (null !== s) {
							const i = s.lineTools();
							t = new q(this.model(), (0, M.sortSources)(e), i[i.length - 1])
						}
					}
					null === t && (t = new H(this.model(), (0, M.sortSources)(e))), this._pushUndoCommand(t), this.emitEvent("changeZOrder", [e])
				}
				sendBackward(e) {
					if (!this.availableZOrderOperations(e).sendBackwardEnabled) throw new Error("Send backward operation is unavailable");
					const t = ci.format({
						title: $i(e[0])
					});
					this._sendBackOrBringForward(t, (0, M.sortSources)(e), ((e, t) => new Z(this.model(), e, t)))
				}
				bringForward(e) {
					if (!this.availableZOrderOperations(e).bringForwardEnabled) throw new Error("Bring forward operation is unavailable");
					const t = hi.format({
						title: $i(e[0])
					});
					this._sendBackOrBringForward(t, (0, M.sortSources)(e), ((e, t) => new Q(this.model(), e, t)))
				}
				insertAfter(e, t) {
					e = (0, M.sortSources)(e);
					const i = di.format({
						title: $i(e[0]),
						target: $i(t)
					});
					this._insertAfterOrBefore(i, e, t, (() => new q(this.model(), e, t)))
				}
				insertBefore(e, t) {
					e = (0, M.sortSources)(e);
					const i = ui.format({
						title: $i(e[0]),
						target: $i(t)
					});
					this._insertAfterOrBefore(i, e, t, (() => new Y(this.model(), e, t)))
				}
				detachToRight(e, t) {
					(0, tt.trackEvent)("Chart", "Move to new right scale");
					const i = Di.format({
							title: $i(e)
						}),
						s = new Qe.MoveToNewPriceScaleUndoCommand(this.model(), e, t, "right", i);
					this._pushUndoCommand(s), this.emitEvent("moveSource", [e])
				}
				detachToLeft(e, t) {
					(0, tt.trackEvent)("Chart", "Move to new left scale");
					const i = Ni.format({
							title: $i(e)
						}),
						s = new Qe.MoveToNewPriceScaleUndoCommand(this.model(), e, t, "left", i);
					this._pushUndoCommand(s), this.emitEvent("moveSource", [e])
				}
				detachNoScale(e, t) {
					(0, tt.trackEvent)("Chart", "Make source no scale");
					const i = Bi.format({
							title: $i(e)
						}),
						s = new Qe.MoveToNewPriceScaleUndoCommand(this.model(), e, t, "overlay", i);
					this._pushUndoCommand(s), this.emitEvent("moveSource", [e])
				}
				moveToScale(e, t, i, s, o) {
					(0, tt.trackEvent)("Chart", "Move source to target scale"), this.beginUndoMacro(s);
					const r = new Qe.MoveToExistingPriceScaleUndoCommand(this.model(), e, t, i, s),
						n = o ? null : (0, it.sourceNewCurrencyOnPinningToPriceScale)(e, i, this._model()),
						a = o ? null : (0, pt.sourceNewUnitOnPinningToPriceScale)(e, i, this._model());
					this._pushUndoCommand(r), null !== n && this.setPriceScaleCurrency(i, n), null !== a && this.setPriceScaleUnit(i, a), this.endUndoMacro(), this.emitEvent("moveSource", [e])
				}
				startScrollTime(e) {
					const t = this.timeScale();
					this._initialTimeScrollState = {
						rightOffset: t.rightOffset(),
						barSpacing: t.barSpacing()
					}, this._initialTimeScrollPos = e, this.model().startScrollTime(e)
				}
				scrollTimeTo(e) {
					let t = !1;
					return null !== this._initialTimeScrollPos && null !== this._initialTimeScrollState && Math.abs(e - this._initialTimeScrollPos) > 20 && (this._pushUndoCommand(new oe.TimeScaleChangeUndoCommand(this.model(), this._initialTimeScrollState, Oi)), this._initialTimeScrollPos = null, this._initialTimeScrollState = null, t = !0), this.model().scrollTimeTo(e), t
				}
				endScrollTime() {
					this.model().endScrollTime(), this._initialTimeScrollPos = null, this._initialTimeScrollState = null
				}
				startScaleTime(e) {
					const t = this.timeScale(),
						i = {
							rightOffset: t.rightOffset(),
							barSpacing: t.barSpacing()
						};
					this._pushUndoCommand(new oe.TimeScaleChangeUndoCommand(this.model(), i, Ri)), this.model().startScaleTime(e)
				}
				scaleTimeTo(e) {
					this.model().scaleTimeTo(e)
				}
				endScaleTime() {
					this.model().endScaleTime()
				}
				resetTimeScale() {
					const e = this.timeScale(),
						t = {
							rightOffset: e.rightOffset(),
							barSpacing: e.barSpacing()
						};
					this._pushUndoCommand(new oe.TimeScaleChangeUndoCommand(this.model(), t, Vi)), this.model().resetTimeScale()
				}
				startScalePrice(e, t, i, s) {
					this._scalePriceInfo = {
						priceScaleState: t.state(),
						tryMergeConsecutiveScales: s
					}, this.model().startScalePrice(e, t, i)
				}
				scalePriceTo(e, t, i) {
					this.model().scalePriceTo(e, t, i)
				}
				endScalePrice(e, t) {
					this.model().endScalePrice(e, t);
					const i = (0, n.ensureNotNull)(this._scalePriceInfo);
					(0, r.default)(i.priceScaleState, t.state()) || this._pushUndoCommand(new gt.PriceScaleChangeUndoCommand(this.model(), e, t, i.priceScaleState, i.tryMergeConsecutiveScales)), this._scalePriceInfo = null
				}
				startTwoPointsScalePrice(e, t, i, s, o) {
					this._scalePriceInfo = {
						priceScaleState: t.state(),
						tryMergeConsecutiveScales: o
					}, this.model().startTwoPointsScalePrice(e, t, i, s)
				}
				twoPointsScalePriceTo(e, t, i, s) {
					this.model().twoPointsScalePriceTo(e, t, i, s)
				}
				endTwoPointsScalePrice(e, t) {
					this.model().endTwoPointsScalePrice(e, t);
					const i = (0, n.ensureNotNull)(this._scalePriceInfo);
					(0, r.default)(i.priceScaleState, t.state()) || this._pushUndoCommand(new gt.PriceScaleChangeUndoCommand(this.model(), e, t, i.priceScaleState, i.tryMergeConsecutiveScales)), this._scalePriceInfo = null
				}
				resetPriceScale(e, t) {
					const i = t.state();
					this.model().resetPriceScale(e, t), (0, r.default)(i, t.state()) || this._pushUndoCommand(new gt.PriceScaleChangeUndoCommand(this.m_model, e, t, i))
				}
				rearrangePanes(e, t) {
					const i = new se(this._model(), e, t);
					this._pushUndoCommand(i)
				}
				movePane(e, t) {
					const i = new se(this._model(), e, t);
					this._pushUndoCommand(i)
				}
				pasteSourceFromClip(e, t, i) {
					const s = t;
					if (!s || 0 === s.sources.length) return null;
					const o = e || (0, n.ensureNotNull)(this.model().paneForSource(this.mainSeries()));
					if (!s.sources.some((e => "drawing" !== e.type || null !== o.clipboardLineToolOwnerSource(e.source.id)))) return null;
					this.beginUndoMacro(Ui.format({
						title: s.title
					}));
					let r = 0;
					const a = [],
						l = [];
					for (const t of s.sources)
						if ("drawing" === t.type && null !== o.clipboardLineToolOwnerSource(t.source.id)) {
							const e = this.pasteLineTool(o, t);
							r < 5 && ((0, re.trackDrawingPasted)(e), r += 1), l.push(e), a.push(e)
						} else "study" === t.type && t.source && t.source.metaInfo && this.checkIfFeatureAvailable(new u.StudyMetaInfo(t.source.metaInfo)) && a.push(this.pasteStudy(t, i ? e : void 0));
					return l.length && this.selectionMacro((e => {
						e.clearSelection(), l.forEach((t => {
							e.addSourceToSelection(t, null)
						}))
					})), this.endUndoMacro(), a
				}
				pasteLineTool(e, t, i, s) {
					t.source.state.intervalsVisibilities = (0, Vt.mergeIntervalVisibilitiesDefaults)(t.source.state.intervalsVisibilities), (0, Vt.makeIntervalsVisibilitiesVisibleAtInterval)(t.source.state.intervalsVisibilities, _e.Interval.parse(this.model().mainSeries().interval()));
					const o = new Xe(this.model(), t, e, i, s);
					this._pushUndoCommand(o);
					const r = o.source();
					return o.needCopyToOtherCharts() && this.copyToOtherCharts([r]), this.selectionMacro((e => {
						e.clearSelection(), e.addSourceToSelection(r, null)
					})), r
				}
				pasteStudy(e, t) {
					const i = new rt(this.model(), e, null == t ? void 0 : t.id());
					this._pushUndoCommand(i);
					const s = (0, n.ensureNotNull)(i.state()).id;
					return (0, n.ensureNotNull)(this._model().dataSourceForId(s))
				}
				setPriceScaleCurrency(e, t) {
					const i = new Ze.SetPriceScaleCurrencyUndoCommand(e, t, this.chartWidget(), Ti);
					this._pushUndoCommand(i)
				}
				setPriceScaleUnit(e, t) {
					const i = new $e.SetPriceScaleUnitUndoCommand(e, t, this.chartWidget(), Pi);
					this._pushUndoCommand(i)
				}
				setSymbol(e, t) {
					e.symbol() !== t && this._pushUndoCommand(new et(e, t, this.chartWidget()))
				}
				setResolution(e, t) {
					_e.Interval.isEqual(e.interval(), t) || this._pushUndoCommand(new li(e, t, this.chartWidget()))
				}
				chartLoadTheme(e, t, i) {
					const s = new ni(this.model(), e, t);
					i ? s.redo() : this._pushUndoCommand(s)
				}
				isJustClonedChart() {
					return this._chartWidget.isJustClonedChart()
				}
				copyToOtherCharts(e) {
					const t = this.mainSeries(),
						i = t.syncModel(),
						s = this.timeScale();
					if (i)
						for (const o of e) {
							if (!o.isSynchronizable()) continue;
							const e = o.linkKey().value() || (0, je.randomHash)();
							o.linkKey().setValue(e);
							const r = o.state(!1),
								a = o.normalizedPoints(),
								l = o.properties().interval.value(),
								c = t.interval();
							let h;
							if (_e.Interval.isEqual(l, c)) h = a.map((e => {
								const t = (0, n.ensureNotNull)(s.timePointToIndex(e.time_t)) + e.offset;
								return {
									price: e.price,
									timeStamp: (0, n.ensureNotNull)(this.model().externalTimeStamp(t))
								}
							}));
							else {
								const e = i.createNewModelWithResolution(l);
								h = a.map((t => ({
									price: t.price,
									timeStamp: 0 === t.offset ? t.time_t : e.projectTime(t.time_t, t.offset)
								})))
							}
							const d = {
								...r,
								id: o.id(),
								linkKey: e,
								points: h,
								linetool: o.toolname,
								model: this.model(),
								symbol: t.symbol(),
								finalState: {
									points: a,
									interval: l
								},
								pointPositionPercents: o.isFixed() ? o.calcPositionPercents() : void 0,
								sharingMode: o.sharingMode().value()
							};
							(0, Me.copyLineTool)(d)
						}
				}
				addPaneStretchFactorUndoCommand(e, t, i, s) {
					const o = new nt(this.model(), e, t, i, s);
					this._pushUndoCommand(o)
				}
				paneForSource(e) {
					return this.m_model.paneForSource(e)
				}
				destroy() {
					this._lineToolsDoNotAffectChartInvalidation.destroy(), this.m_model.destroy()
				}
				moveSelectedToolsLeft() {
					return this._moveSelectedTools(2)
				}
				moveSelectedToolsUp() {
					return this._moveSelectedTools(0)
				}
				moveSelectedToolsRight() {
					return this._moveSelectedTools(3)
				}
				moveSelectedToolsDown() {
					return this._moveSelectedTools(1)
				}
				insertStudyWithoutCheck(e, t, i) {
					return this._insertStudy(e, t, {}, !1, void 0, void 0, void 0, void 0, void 0, null != i ? i : null, void 0)
				}
				saveLineToolState(e, t) {
					this._pushUndoCommand(new w(this.m_model, [e], t))
				}
				resetScales() {
					this.beginUndoMacro(Wi), this.resetTimeScale();
					for (const e of this.m_model.panes()) {
						for (const t of e.leftPriceScales()) this.resetPriceScale(e, t);
						for (const t of e.rightPriceScales()) this.resetPriceScale(e, t)
					}
					this.endUndoMacro(), this.m_model.recalculateAllPanes((0, he.viewportChangeEvent)())
				}
				shareLineTools(e, t) {
					const i = 0 === t ? Ki : 1 === t ? Yi : Xi;
					this.withMacro(i, (() => {
						this.unlinkLines(e), e.forEach((i => {
							const s = this.model().lineToolsGroupModel().groupForLineTool(i);
							if (s) {
								s.lineTools().every((t => e.includes(t))) || this.lineToolsGroupController().excludeLineToolFromGroup(s, i)
							}
							this.undoHistory().pushUndoCommand(new xe(i, t, this.model(), null))
						})), 0 !== t && this.copyToOtherCharts(e)
					}), !0)
				}
				_isCountedStudy(e) {
					return !["Volume@tv-basicstudies", "Compare@tv-basicstudies", "Overlay@tv-basicstudies"].includes(e.id) && !(0, Pt.isFundamentalStudyMetaInfo)(e)
				}
				_mergeUnmergeSource(e, t) {
					this.beginUndoMacro(t.text());
					const i = (0, n.ensureNotNull)(this._model().paneForSource(e)),
						s = new Set(i.sourcesByGroup().lineSources().filter((t => t.ownerSource() === e)));
					this._model().lineToolsGroupModel().groups().filter((e => {
						const t = e.lineTools().some((e => s.has(e))),
							i = e.lineTools().some((e => !s.has(e)));
						return t && i
					})).forEach((e => {
						this._pushUndoCommand(new b.ExcludeLineToolsFromGroupUndoCommand(this._model(), e, e.lineTools()))
					})), this._pushUndoCommand(t), this.endUndoMacro()
				}
				_insertStudy(e, t, i, s, o, r, a, l, c, h, d) {
					const u = Hi.format({
						title: e.description
					});
					this.beginUndoMacro(u);
					const _ = new dt(this.model(), e, t, i, s, o, r, a, l, c, h || null, u);
					this._pushUndoCommand(_);
					const m = _.insertedStudy();
					if (void 0 !== d) {
						const e = new ut.SetPriceScaleModeCommand(d, (0, n.ensureNotNull)(m.priceScale()), null, this.model());
						this._pushUndoCommand(e)
					}
					return this.endUndoMacro(), m
				}
				async _processSpecialLineToolsContents(e, t, i) {
					if (t = t || await e.read(), window.user.id && t.files) {
						const e = Array.from(t.files).find(yt.blobImageFilter);
						if (e) {
							const t = URL.createObjectURL(e),
								s = (0, yt.uploadImage)(e);
							return void 0 === i && (i = (0, n.ensureNotNull)(this._model().paneForSource(this.mainSeries()))), this.pasteImageAsLineTool(s, t, i), void await s
						}
					}
					t.text && (window.user.id && (0, vt.isTwitterUrl)(t.text) ? (0, vt.createTweetLineToolByUrl)(t.text, this, !0) : window.user.id && (0, Tt.isIdeaUrl)(t.text) ? (0, Tt.createIdeaLineToolByUrl)(t.text, this, !0) : function(e, t) {
						if (null === t.timeScale().logicalRange()) return null;
						const i = t.mainSeries(),
							s = i.priceScale(),
							o = t.timeScale(),
							r = (0, n.ensureNotNull)(t.model().paneForSource(i)),
							a = (0, n.ensureNotNull)((0, n.ensureNotNull)(s.mainSource()).firstValue()),
							l = o.coordinateToIndex(t.timeScale().width() / 2),
							c = r.height() / 2,
							h = {
								price: s.coordinateToPrice(c, a),
								time_t: (0, n.ensureNotNull)(o.indexToTimePoint(l)),
								offset: 0
							},
							d = r.newLineToolZOrder(!0),
							u = bt.LineToolText.createProperties().state();
						u.text = e;
						const _ = {
								type: "drawing",
								source: {
									id: (0, je.randomHashN)(6),
									zorder: d,
									type: "LineToolText",
									state: {
										interval: i.interval(),
										...u
									},
									symbol: i.symbol(),
									ownerSource: i.id(),
									points: [h]
								},
								geometry: [],
								modelId: t.model().id(),
								centeredOnChart: !0
							},
							m = t.pasteLineTool(r, _, !1, !1);
						ft.setValue("hint.pasteText", !0, {
							forceFlush: !0
						})
					}(t.text, this))
				}
				_insertAfterOrBefore(e, t, i, s) {
					const o = (0, n.ensureNotNull)(this._model().paneForSource(i));
					if (t.some((e => (0, S.isLineTool)(e) && this._model().paneForSource(e) !== o))) throw new Error("Cannot insert line tool after target on another pane");
					this.beginUndoMacro(e), t.forEach((e => {
						(0, n.ensureNotNull)(this.model().paneForSource(e)) !== o && this.mergeToPane(e, o)
					}));
					const r = s();
					this._pushUndoCommand(r), this.emitEvent("changeZOrder", [t]), this.endUndoMacro()
				}
				_sendBackOrBringForward(e, t, i) {
					const s = new Map;
					t.forEach((e => {
						const t = (0, n.ensureNotNull)(this._model().paneForSource(e)),
							i = s.get(t) || [];
						i.push(e), s.set(t, i)
					})), this.beginUndoMacro(e), s.forEach(((e, t) => {
						this._pushUndoCommand(i(t, e))
					})), this.endUndoMacro(), this.emitEvent("changeZOrder", [t])
				}
				_moveSelectedTools(e) {
					const t = this.model().selection().lineDataSources();
					if (0 === t.length) return !1;
					if ((0, Me.lockDrawings)().value()) return !0;
					const i = this.timeScale().visibleBarsStrictRange();
					if (null === i) return !1;
					const s = function(e) {
						const t = new Map;
						for (const i of e) {
							const e = i.ownerSource();
							if (null === e) continue;
							let s = t.get(e);
							if (void 0 === s) {
								const o = e.priceScale(),
									r = e.priceStep(),
									n = e.firstValue();
								if (null === o || null === r || null === n) continue;
								if (null === o.priceRange()) continue;
								s = {
									sources: [],
									priceScale: o,
									priceStep: r,
									startPrice: i.points()[0].price,
									firstValue: n
								}, t.set(e, s)
							}
							s.sources.push(i)
						}
						return t
					}(t);
					if (0 === s.size) return !1;
					this.beginUndoMacro(yi, this._lineToolsDoNotAffectChartInvalidation.value());
					const o = i.firstBar(),
						r = this.timeScale().indexToCoordinate(o),
						n = o + (3 === e ? 1 : 2 === e ? -1 : 0),
						l = this.timeScale().indexToCoordinate(n);
					return Me.isDirectionalMovementActive.setValue(!0), s.forEach((t => {
						const {
							startPrice: i,
							priceStep: s,
							priceScale: c,
							firstValue: h
						} = t, d = i + (0 === e ? s : 1 === e ? -s : 0), u = c.priceToCoordinate(i, h), _ = c.priceToCoordinate(d, h), m = {
							logical: {
								index: o,
								price: i
							},
							screen: new a.Point(r, u)
						}, p = {
							logical: {
								index: n,
								price: d
							},
							screen: new a.Point(l, _)
						};
						this.startMovingSources(t.sources, m, null), this.moveSources(p), this.endMovingSource(!1, !0)
					})), Me.isDirectionalMovementActive.setValue(!1), this.endUndoMacro(), !0
				}
				_restoreStudyFactoryDefaults(e) {
					const t = new Rt(this.m_model, e.properties());
					this._pushUndoCommand(t)
				}
				_restoreLineToolFactoryDefaults(e) {
					this.beginUndoMacro(Ci, this._lineToolsDoNotAffectChartInvalidation.value()), this.saveLineToolState(e, Ci);
					const t = new Ot(this.m_model, e.properties(), Ci);
					this._pushUndoCommand(t), this.saveLineToolState(e, Ci), this.endUndoMacro(), this.model().updateSource(e)
				}
				_removeAllDrawingToolsImpl(e) {
					this.selectionMacro((() => {
						this.lineBeingCreated() && this.cancelCreatingLine();
						this.dataSources().filter(S.isLineTool).filter((e => e.isActualSymbol() && e.isUserDeletable())).filter((t => !e || e === t.toolname)).forEach((e => this.removeSource(e, !1)))
					}), !0)
				}
				_removeAllStudiesImpl() {
					const e = this.dataSources(),
						t = e.filter(C.isStudy).filter((e => !e.isChildStudy() && e.removeByRemoveAllStudies())),
						i = e.filter(C.isStudyStub);
					t.concat(i).forEach((e => this.removeSource(e, !1)))
				}
			}
		},
		471133: (e, t, i) => {
			"use strict";
			var s = i(97639),
				o = i(588537).ensureNotNull,
				r = i(62802),
				n = i(411260).ChartModelBase,
				a = i(540968),
				l = a.isLineTool,
				c = a.isStudyLineTool,
				h = i(836966).Watermark,
				d = i(638456).CheckMobile,
				u = i(648684).PublishedChartsTimeline,
				_ = i(995850),
				m = i(920358).getPriceAlertsDispatcher,
				p = i(217540).isAlertResolutionEqual,
				g = i(388230).InvalidationMask,
				S = i(388230).InvalidationLevel;
			const {
				globalChangeEvent: v,
				dataSourceChangeEvent: f
			} = i(194459);
			var b = i(448874),
				y = b.Study,
				C = i(659251).NonSeriesStudy,
				w = i(140662),
				T = w.createStudy,
				P = w.isStudy,
				M = w.isFundamentalStudy,
				x = b.prepareStudyProperties,
				I = i(308170),
				A = i(346090).saveDefaultProperties,
				k = i(175239).MainSeriesScaleRatioProperty,
				L = i(510196).scaleRatio,
				E = i(131341).StudyInserter,
				D = i(940448).dateFormatProperty,
				N = i(932255).timeHoursFormatProperty,
				B = i(992179).isSymbolSource,
				O = i(795896).sourceNewCurrencyOnPinningToPriceScale,
				R = i(705318).sourceNewUnitOnPinningToPriceScale,
				V = i(251954),
				W = i(938391).StudyColorRotatorFactory,
				F = i(611688),
				z = i(788661).AppliedTimeFrame,
				U = !F.enabled("widget") || F.enabled("esdonwidget"),
				H = F.enabled("auto_enable_symbol_labels"),
				G = F.enabled("fix_left_edge");
			class j extends n {
				constructor(e, t, i, o, r, n, a, l, c, d) {
					super(e, t, i, o, r, n, a, l, c, d);
					var u = this,
						_ = this.m_mainSeries.properties(),
						m = this._panes[0];
					m.setStretchFactor(2 * m.stretchFactor()), this._properties.listeners().subscribe(this, j.prototype.propertyChangeHandler), this._properties.timezone.listeners().subscribe(null, (function() {
						u._chartApi && u._chartApi.isConnected().value() && u._chartApi.switchTimezone(u.timezone())
					})), m.addDataSource(this.m_mainSeries, this._panes[0].findSuitableScale(this.m_mainSeries)), this._mainSeriesScaleRatioProperty = new k(this), this.m_mainSeries.dataEvents().completed().subscribe(this, function() {
						if (this._scrollingState && this.gotoTime(),
							G && !this.m_mainSeries.requestMoreDataAvailable()) {
							var e = this.m_mainSeries.bars().first();
							null !== e && this._timeScale.setLeftEdgeFix(e.index)
						}
					}.bind(this)), this.m_mainSeries.onIntervalChanged().subscribe(this, (function() {
						this._recalcVRStudiesParams.oldStartVisibleIndex = NaN, this._recalcVRStudiesParams.oldEndVisibleIndex = NaN
					})), this.m_mainSeries.dataEvents().barReceived().subscribe(this, j.prototype.updateTimeScaleBaseIndex), this._readOnly || (_.addChild("priceAxisProperties", this.m_mainSeries.m_priceScale.properties()), this._properties.paneProperties.legendProperties.showStudyTitles.listeners().subscribe(this, (function(e) {
						e.value() || u._properties.paneProperties.legendProperties.showStudyArguments.setValue(!1)
					}))), this._barsMarksSources = a(this);
					for (var p = 0; p < this._barsMarksSources.length; p++) this._barsMarksSources[p].setOwnerSource(this.m_mainSeries);
					this._watermarkSource = this._options.watermarkEnabled ? new h(this, this.m_mainSeries) : null, I.hideAllDrawings().subscribe(this, this._onDrawingsVisibilityChanged), I.hideAllIndicators().subscribe(this, this._onIndicatorsVisibilityChanged), this._properties.scalesProperties.listeners().subscribe(this, j.prototype.fullUpdate), this._studyInserted = new s, this._studyShiftColorStartOffset = void 0, this._linePointBeingEdited = null, this._lineBeingEdited = null, D.subscribe(this, this._updateDateTimeFormatter), N.subscribe(this, this._updateDateTimeFormatter), this.mainSeries().properties().interval.subscribe(this, this._updateDateTimeFormatter), this._updateDateTimeFormatter(), this._studyColorRotatorFactory = new W(this), U && this._options.esdEnabled && this._createESDWatcher(), this._undoModel._chartWidget.onWidget() || this._initAlertsList(), this._dataSourceCollectionChanged.subscribe(this, this._updateShowLegendProperty.bind(this)), this._properties.paneProperties.legendProperties.showLegend.subscribe(this, this._updateShowLegendProperty), this._appliedTimeFrame = new z(this), this.mainSeries().onTimeFrameApplied().subscribe(this, (function(e) {
						var t = null !== e ? {
							res: this.mainSeries().interval(),
							val: e
						} : null;
						this.appliedTimeFrame().setValue(t)
					}))
				}
				applyPreferences(e) {
					for (var t in e) void 0 !== this._properties[t] && "m_mainSeries" !== this._properties[t] && this._properties[t].mergeAndFire(e[t]);
					void 0 !== e.timeScale && this._timeScale.defaultRightOffset().setValue(e.timeScale.defaultRightOffset), this._properties.saveDefaults(), this.m_mainSeries.applyPreferences(e.mainSeries), this.sessions().applyPreferences(e.sessions), this.recalculateAllPanes(v()), this.fullUpdate()
				}
				timezone() {
					return this._properties.timezone.value()
				}
				initConnection() {
					this._chartApi.switchTimezone(this.timezone())
				}
				updatePane(e) {
					var t = this._paneInvalidationMask(e);
					this.invalidate(t)
				}
				fullUpdate() {
					this.invalidate(g.full())
				}
				lightUpdate() {
					this.invalidate(g.light())
				}
				studiesMetaData() {
					return this._studiesMetaData
				}
				studyVersioning() {
					return this._studyVersioning
				}
				startNotStartedStudies() {
					if (!this.m_mainSeries.isStarted()) throw new Error("Cannot start studies: main series is not started");
					for (var e = this.dataSources(), t = 0; t < e.length; t++) P(e[t]) && !e[t].isStarted() && e[t].restart && e[t] !== this.m_mainSeries && e[t].restart()
				}
				readOnly() {
					return this._readOnly
				}
				chartApi() {
					return this._chartApi
				}
				propertyChangeHandler() {
					this.lightUpdate()
				}
				_onDrawingsVisibilityChanged(e) {
					for (var t = !1 === e.value(), i = this.dataSources(), s = 0; s < i.length; s++) {
						var o = i[s],
							r = l(o) && o.properties().visible.value();
						t && r ? V.emit("drawing_event", o.id(), "show") : !t && r && V.emit("drawing_event", o.id(), "hide")
					}
					this.selectionMacro((function(e) {
						e.clearSelection()
					}))
				}
				_onIndicatorsVisibilityChanged() {
					var e = this.allStudies().filter((function(e) {
						return e.properties().visible.value() && e.canBeHiddenByGlobalFlag()
					}));
					if (0 !== e.length) {
						for (var t = !1, i = 0; i < e.length; i++)
							if (this.selection().isSelected(e[i])) {
								t = !0;
								break
							} t ? this.selectionMacro((function(e) {
							e.clearSelection()
						})) : this.lightUpdate()
					}
				}
				mainSeries() {
					return this.m_mainSeries
				}
				timeScale() {
					return this._timeScale
				}
				watermarkSource() {
					return this._watermarkSource
				}
				crossHairSource() {
					return this.m_crossHairSource
				}
				publishedChartsTimelineSource() {
					for (var e = 0; e < this._barsMarksSources.length; ++e)
						if (this._barsMarksSources[e] instanceof u) return this._barsMarksSources[e];
					return null
				}
				priceScaleSlotsCount() {
					var e = 0,
						t = 0;
					this._panes.forEach((function(i) {
						e = Math.max(i.leftPriceScales().length, e), t = Math.max(i.rightPriceScales().length, t)
					}));
					var i = e + t;
					if (d.any()) {
						var s = this.paneForSource(this.mainSeries()),
							o = s.priceScalePosition(this.mainSeries().priceScale()),
							r = "right" === o;
						return "overlay" === o && (r = s.rightPriceScales().length > 0), r ? {
							left: 0,
							right: 1,
							totallySlots: i
						} : {
							left: 1,
							right: 0,
							totallySlots: i
						}
					}
					return {
						left: e,
						right: t,
						totallySlots: e + t
					}
				}
				setPriceAutoScale(e, t, i) {
					e.setPriceAutoScale(t, i), this.invalidate(this._paneInvalidationMask(e, S.Light))
				}
				updateScales(e, t) {
					this._undoModel._chartWidget._updateScalesActions()
				}
				mainSeriesScaleRatioProperty() {
					return this._mainSeriesScaleRatioProperty
				}
				mainSeriesScaleRatioPropertyOnChanged() {
					this._mainSeriesScaleRatioProperty.listeners().fire(this._mainSeriesScaleRatioProperty)
				}
				mainSeriesScaleRatio() {
					return L(this._timeScale, this.m_mainSeries.priceScale())
				}
				setMainSeriesScaleRatio(e) {
					this.paneForSource(this.m_mainSeries).applyPriceScaleRatio(this.m_mainSeries.priceScale(), e)
				}
				recalcStudyBasedLineTools() {
					this.dataSources().forEach((function(e) {
						c(e) && e.recalcStudyIfNeeded && e.recalcStudyIfNeeded()
					}))
				}
				restoreFactoryDefaults(e) {
					e.restoreFactoryDefaults(), this.recalcVisibleRangeStudies(!0)
				}
				orderedDataSources(e) {
					var t = [];
					t.push(this.m_crossHairSource);
					for (var i = 0; i < this._panes.length; i++) {
						var s = this._panes[i].sourcesByGroup().all().slice();
						e && s.reverse(), t = t.concat(s)
					}
					return t
				}
				dataSourceForId(e) {
					for (var t, i = 0; i < this._panes.length; ++i)
						if (t = this._panes[i].dataSourceForId(e)) return t;
					return null
				}
				children(e, t) {
					return this.dataSources().filter((function(i) {
						return (!0 !== t || !P(i) || !i.isChildStudy()) && i.ownerSource() === e
					}))
				}
				onSyncScrollNeeded(e) {
					var t = this._undoModel._chartWidget;
					if (t._chartWidgetCollection) {
						var i = this.mainSeries().syncModel();
						if (i) {
							var s = 1e3 * this._timeScale.points().roughTime(e, i.projectTime.bind(i));
							t._chartWidgetCollection.syncScroll(s, this)
						}
					}
				}
				updateTimeScaleBaseIndex(e) {
					var t = this.mainSeries().bars();
					t.isEmpty() || this._updateBaseIndex(o(t.lastIndex()), e && e.index > 0)
				}
				createStudyInserter(e) {
					return new E(e, this._studiesMetaInfoRepository, {
						createStudy: this.insertStudyWithParams.bind(this)
					})
				}
				insertStudyWithParams(e, t, i, s, o, n, a, l, c, h, d) {
					null == n && (n = this.mainSeries());
					var u = null;
					if (!o && void 0 !== e.groupingKey) {
						var _ = this.findNonOverlayStudyWithGroupingKey(e.groupingKey);
						null !== _ && (u = _.pane)
					}
					null === u && (o || e.is_price_study ? u = this.paneForSource(n) : (u = this.createPane(), void 0 !== h && u.setPaneSize(h))), "Compare@tv-basicstudies" === e.id && this.m_mainSeries.priceScale().setMode({
						log: !1,
						percentage: !0
					});
					var m = Object.assign({}, s, {
							inputs: t
						}),
						p = x(e, m, u, this.studyVersioning(), n),
						g = T(this, p, n, e, d);
					this._recalcVisibleRangeStudiesImpl({
						studies: [g],
						oldEndVisibleIndex: -1,
						oldStartVisibleIndex: -1,
						force: !0,
						timerId: null
					});
					var S = u.findSuitableScale(g, n, a);
					if (S === this.mainSeries().priceScale() && B(g)) {
						var v = l ? O(g, S, this, !0) : null,
							b = c ? R(g, S, this, !0) : null;
						null === v && null === b || g.setSymbolParams({
							currency: v || void 0,
							unit: b || void 0
						})
					}
					return B(g) && u.hasDataSource(this.mainSeries()) && H && !r.getBool("enable_symbol_labels_on_inserting_compare_once", !1) && (A(!0), this.properties().scalesProperties.showSymbolLabels.setValue(!0), A(!1), r.setValue("enable_symbol_labels_on_inserting_compare_once", !0)), g.start(), null !== i && u.id() === i.paneId ? u.insertDataSource(g, S, i.zorder) : u.addDataSource(g, S), g.properties().linkedToSeries && g.properties().linkedToSeries.value() && g.setOwnerSource(this.mainSeries()), this.recalculatePane(u, f(g.id())), this.fullUpdate(), this._invalidateBarColorerCaches(), this._recalcVisibleRangeStudiesImpl({
						studies: [g],
						force: !0
					}), this._recalcColorStudiesImpl({
						studies: [g],
						force: !0
					}), this._studyInserted.fire(g), this.alertsWatcher().syncSourceAlertLabels(g), g.maxOffset().subscribe(this._boundUpdateStudiesMaxOffset, {
						callWithLast: !0
					}), g
				}
				studyInserted() {
					return this._studyInserted
				}
				_unmergeAvailable(e) {
					return e === this.m_mainSeries || TradingView.isInherited(e.constructor, y) && !e.isLinkedToSeries() && !TradingView.isInherited(e.constructor, C) && e.showInObjectTree()
				}
				isMergeUpAvailableForSource(e) {
					return !!this._unmergeAvailable(e) && this.paneForSource(e) !== this.panes()[0]
				}
				isMergeDownAvailableForSource(e) {
					if (!this._unmergeAvailable(e)) return !1;
					var t = this.paneForSource(e),
						i = this.panes();
					return t !== i[i.length - 1]
				}
				isUnmergeAvailableForSource(e) {
					return !!this._unmergeAvailable(e) && this.paneForSource(e).dataSources().filter(this._unmergeAvailable, this).length > 1
				}
				lineBeingEdited() {
					return this._lineBeingEdited
				}
				linePointBeingEdited() {
					return this._linePointBeingEdited
				}
				calculateDefaultTags() {
					for (var e = [], t = this.dataSources(), i = 0; i < t.length; i++) {
						var s = t[i];
						s.tags && (e = e.concat(s.tags()))
					}
					return e
				}
				_sendTo(e, t) {
					var i = {},
						s = this;
					for (var o in e.forEach((function(e) {
							var t = s.paneForSource(e),
								o = s._panes.indexOf(t);
							i[o] || (i[o] = []), i[o].push(e)
						})), i) {
						t(s._panes[o], i[o])
					}
					this.fullUpdate()
				}
				sendToBack(e) {
					this._sendTo(e, (function(e, t) {
						e.sendToBack(t)
					}))
				}
				bringToFront(e) {
					this._sendTo(e, (function(e, t) {
						e.bringToFront(t)
					}))
				}
				allLineTools() {
					return this._getAllSources(l)
				}
				getStudyById(e) {
					var t = this.dataSourceForId(e);
					return null !== t && P(t) ? t : null
				}
				getLineToolById(e) {
					var t = this.dataSourceForId(e);
					return null !== t && l(t) ? t : null
				}
				_initAlertsList() {
					var e = this;
					return e._alertsListPromise || (e._alertsListPromise = m().then((function(t) {
						function i(t) {
							e.mainSeries().dataEvents().symbolResolved()[t](e, s), e.mainSeries().dataEvents().symbolError()[t](e, e._removeAllAlertLabelsFromChart), e.mainSeries().properties().interval[t](e, s)
						}

						function s() {
							t.ensureFullAlertsList({
								success: function() {
									e._alertsList.syncCollections()
								},
								error: function() {
									e._alertsList.reset()
								}
							})
						}
						return e._alertsList = new _([], {
							observableCollection: t.alerts,
							syncEvents: ["change:active", "change:crossInterval", "change:resolution", "change:symbol"],
							validator: function(t) {
								return (t.get("active") || t.isNew()) && p(t, e.mainSeries().interval()) && t.get("symbol") === e.mainSeries().actualSymbol()
							}
						}), e._alertsList.on("add", e._addAlertLabelToChart.bind(e)), e._alertsList.on("remove", e._removeAlertLabelFromChart.bind(e)), e._alertsList.on("reset", (function() {
							e.resetAlertList()
						})), e._alertsList.on("change:alertSeries", (function(t) {
							e._removeAlertLabelFromChart(t), e._addAlertLabelToChart(t)
						})), e._alertsList.syncCollections(), loginStateChange.subscribe(e, (function() {
							i(window.is_authenticated ? "subscribe" : "unsubscribe")
						})), window.is_authenticated && (i("subscribe"), s()), e._alertsList
					}))), this._alertsListPromise
				}
				_addAlertLabelToChart(e) {
					if (e.get("extra")) {
						var t = e.get("extra").alertSeries().id;
						this.alertsWatcher().addAlert(e, t)
					}
				}
				_removeAlertLabelFromChart(e) {
					this.alertsWatcher().removeAlert(e)
				}
				_removeAllAlertLabelsFromChart() {
					this.alertsWatcher().removeAllAlertLabels()
				}
				getAlertsList() {
					return this.readOnly() ? Promise.resolve(null) : this._alertsList ? Promise.resolve(this._alertsList) : this._initAlertsList()
				}
				resetAlertList() {
					if (this._alertsList) {
						var e = this._alertsList.models;
						this._removeAllAlertLabelsFromChart();
						for (var t = e.length - 1; t >= 0; t--) this._addAlertLabelToChart(e[t])
					}
				}
				setInterval(e, t) {
					var i = setInterval(e, t);
					return this._modelIntervals.push(i), i
				}
				clearInterval(e) {
					clearInterval(e);
					var t = this._modelIntervals.indexOf(e);
					t > -1 && this._modelIntervals.splice(t, 1)
				}
				clearIntervals() {
					for (var e = 0; e < this._modelIntervals.length; e++) clearInterval(this._modelIntervals[e]);
					this._modelIntervals = []
				}
				destroy() {
					this.mainSeries().properties().childs().showCountdown.unsubscribeAll(this), this.mainSeries().onTimeFrameApplied().unsubscribeAll(this), this.mainSeries().onIntervalChanged().unsubscribeAll(this), this._appliedTimeFrame.destroy();
					for (var e = 0; e < this._barsMarksSources.length; e++) this._barsMarksSources[e].destroy();
					this.clearIntervals(), I.hideAllDrawings().unsubscribe(this, this._onDrawingsVisibilityChanged), I.hideAllIndicators().unsubscribe(this, this._onIndicatorsVisibilityChanged), this.resetDeferredStudies();
					for (e = 0; e < this._barsMarksSources.length; e++) this._barsMarksSources[e].destroy();
					this.allStudies().forEach((e => this.removeSource(e)));
					for (e = 0; e < this._panes.length; e++) this._panes[e].destroy();
					this._panes.length = 0,
						this._sessions = null, this.m_mainSeries.onStyleChanged().unsubscribe(this._timeScale, this._timeScale.invalidateVisibleBars), this._timeScale.visibleBarsStrictRangeChanged().unsubscribe(this.m_mainSeries, this.m_mainSeries.clearHighLowPriceCache), this._timeScale.visibleBarsStrictRangeChanged().unsubscribe(this.m_mainSeries, this.m_mainSeries.clearAveragePriceCache), this._timeScale.destroy(), D.unsubscribe(this, this._updateDateTimeFormatter), N.unsubscribe(this, this._updateDateTimeFormatter), this.mainSeries().properties().interval.unsubscribe(this, this._updateDateTimeFormatter), this._trendLineStatsCache && this._trendLineStatsCache.destroy(), this._fibRetracementLabelsCache && this._fibRetracementLabelsCache.destroy(), this._alertsList && this._alertsList.destroy(), loginStateChange.unsubscribeAll(this), this._properties.paneProperties.legendProperties.showLegend.unsubscribeAll(this), this._dataSourceCollectionChanged.unsubscribeAll(this), this.m_crossHairSource.destroy(), super.destroy()
				}
				listUserStudies(e) {
					var t = [];
					e = e || {};
					for (var i = 0; i < this._panes.length; i++)
						for (var s = this._panes[i].dataSources(), o = 0; o < s.length; o++) {
							var r = s[o];
							if (P(r) && !M(r) && r.showInObjectTree()) {
								var n = r.metaInfo && r.metaInfo();
								if (n) {
									var a = n.id;
									if (e.dontCountVolume && "Volume@tv-basicstudies" === a) continue;
									if (e.dontCountCompare && "Compare@tv-basicstudies" === a) continue;
									if (e.dontCountOverlay && "Overlay@tv-basicstudies" === a) continue
								}
								t.push(n.shortDescription)
							}
						}
					return t
				}
				restoreSource(e, t, i, s, o) {
					var r, n;
					r = e ? this.createPane(t) : this.panes()[t];
					var a = s.type.toLowerCase().startsWith("study");
					if (!(n = a ? r.restoreStudy(s) : r.restoreLineTool(s))) return null;
					var l = null;
					if (o ? l = r.getPriceScaleById(o.id) : n.ownerSource() && (l = n.ownerSource().priceScale()), l) n.setPriceScale(l), l.addDataSource(n);
					else {
						l = r.createPriceScaleAtPosition(o.position, o.priceScaleIndex);
						o && o.id && l.setId(o.id), n.setPriceScale(l), l.addDataSource(n)
					}
					if (!e && i && i.overlayPriceScales) {
						var c = this.dataSources().filter((function(e) {
							return void 0 !== i.overlayPriceScales[e.id()]
						}));
						c.forEach(r.removeSourceFromPriceScale.bind(r));
						var h = new Map;
						c.forEach((function(e) {
							var t, s = i.overlayPriceScales[e.id()];
							h.has(s.id) ? t = h.get(s.id) : ((t = r.createPriceScaleAtPosition("overlay")).restoreState(s), h.set(s.id, t)), t.addDataSource(e), e.setPriceScale(t)
						}))
					}
					return n.start(), n.restore && n.restore(), e && r.restoreState(i, !1, this.version()), a && (this.recalculateAllPanes(f(n.id())), this.mainSeries().invalidateBarColorerCache(), this.fullUpdate()), a && this.alertsWatcher().syncSourceAlertLabels(n), n
				}
				selectPointMode() {
					return this.m_crossHairSource.selectPointMode()
				}
				cancelRequestSelectPoint() {
					this.m_crossHairSource.cancelRequestSelectPoint()
				}
				requestSelectPoint(e) {
					return this.m_crossHairSource.requestSelectPoint(e)
				}
				onPointSelected() {
					return this.m_crossHairSource.onPointSelected()
				}
				isSeriesStyleSupported(e) {
					return this.m_mainSeries.isStyleSupported(e)
				}
				getStudyShiftColorStartOffset() {
					return this._studyShiftColorStartOffset
				}
				setStudyShiftColorStartOffset(e) {
					this._studyShiftColorStartOffset = e
				}
				isInReplay() {
					return this.m_mainSeries.isInReplay()
				}
				onInReplayStateChanged() {
					return this.m_mainSeries.onInReplayStateChanged()
				}
				switchToReplay(e, t) {
					this.m_mainSeries.switchToReplay(e, t)
				}
				switchToRealtime() {
					this.m_mainSeries.switchToRealtime(), this._timeScale.resetRightOffset()
				}
				rendererOptionsProvider() {
					return this._rendererOptionsProvider
				}
				priceAxisRendererOptions() {
					return this._rendererOptionsProvider.options()
				}
				magnet() {
					return this._magnet
				}
				isPriceScaleVisible(e) {
					var t = this.paneForSource(e.mainSource()),
						i = t.priceScalePosition(e);
					if ("overlay" === i) return !0;
					var s = this.priceScaleSlotsCount();
					return t.priceScaleIndex(e, i) < s[i]
				}
				studyMetaInfoRepository() {
					return this._studiesMetaInfoRepository
				}
				studiesColorRotatorFactory() {
					return this._studyColorRotatorFactory
				}
			}
			e.exports = j
		},
		232252: (e, t, i) => {
			"use strict";
			var s = i(575932).t,
				o = i(277036).TranslatedString,
				r = i(291246).showGoToTradingViewReferralDialog,
				{
					trackGoProFeature: n
				} = i(405117),
				a = i(833813).ProductFeatures,
				l = i(560507).getConfig,
				c = i(560507).enabled,
				h = i(629588).createGoProDialog,
				d = i(809965).ProPlans,
				u = i(483601).PredefinedAction,
				_ = i(3008).doAnimate,
				m = i(356129).ChartUndoModelBase,
				p = i(346090).saveDefaultProperties,
				g = i(448874).Study,
				S = i(451902).showTooManyStudiesNotice,
				v = i(72833).UndoCommand,
				f = i(613763).ApplyLineToolTemplateUndoCommand,
				b = i(426297).SetPriceScaleSelectionStrategyCommand,
				y = i(467659).SetScaleRatioPropertiesCommand,
				C = i(131341).StudyInserter,
				w = i(345848).trackEvent,
				T = i(911905).getLogger("Chart.ChartUndoModel"),
				P = i(852545).RestoreDefaultsPreferencesUndoCommand,
				M = i(587314).SetPriceScaleModeCommand,
				x = i(433904).PriceScaleChangeUndoCommand,
				I = i(507942).preferencesByWhiteList,
				A = new o("move left", s("move left")),
				k = new o("move right", s("move right")),
				L = new o("toggle auto scale", s("toggle auto scale")),
				E = new o("toggle lock scale", s("toggle lock scale")),
				D = new o("toggle regular scale", s("toggle regular scale")),
				N = new o("toggle indexed to 100 scale", s("toggle indexed to 100 scale")),
				B = new o("toggle percentage scale", s("toggle percentage scale")),
				O = new o("toggle log scale", s("toggle log scale")),
				R = new o("invert scale", s("invert scale")),
				V = new o("remove pane", s("remove pane")),
				W = new o("apply all chart properties", s("apply all chart properties")),
				F = new o("set price scale selection strategy to {title}", s("set price scale selection strategy to {title}")),
				z = s("Cheers");
			class U extends v {
				constructor(e, t) {
					super(W), this._model = e, this._undoModel = e.undoModel(), this._newProperties = t,
						function(e, t) {
							var i = {
								hollowCandle: {
									related: "candle"
								}
							};
							for (var s in ["candleStyle", "hollowCandleStyle", "haStyle"].forEach((function(t) {
									e[t].wickUpColor = e[t].wickUpColor || e[t].wickColor, e[t].wickDownColor = e[t].wickDownColor || e[t].wickColor
								})), t.vertGridProperties = t.vertGridProperties || t.gridProperties, t.horzGridProperties = t.horzGridProperties || t.gridProperties, i)
								if (!e[s + "Style"]) {
									var o = e[i[s].related + "Style"];
									e[s + "Style"] = TradingView.clone(o)
								}
						}(this._newProperties.mainSeries, this._newProperties.paneProperties), this._oldProperties = I(e, e.mainSeries())
				}
				_merge(e) {
					p(!0), this._model.applyPreferences(e), p(!1)
				}
				redo() {
					this._merge(this._newProperties), this._model.mainSeries().onChartStyleChanged(),
						this._model.updateScales()
				}
				undo() {
					this._merge(this._oldProperties), this._model.mainSeries().onChartStyleChanged(), this._model.updateScales()
				}
			}
			t.ChartUndoModel = class extends m {
				constructor(e, t, i, s, o, r, n, a, l, c, h) {
					super(e, t, i, s, o, r, n, a, l, c, h), this.beginUndoMacro = (e, t) => {
						var i = n.beginUndoMacro(e);
						return i.setCustomFlag("doesnt_affect_save", t), i
					}, this.endUndoMacro = n.endUndoMacro.bind(n), this.createUndoCheckpoint = n.createUndoCheckpoint.bind(n), this.undoToCheckpoint = n.undoToCheckpoint.bind(n)
				}
				version() {
					return this.m_model.version()
				}
				createPane(e) {
					return this.m_model.createPane(e)
				}
				readOnly() {
					return this.m_model.readOnly()
				}
				restart() {
					this.m_model.restart()
				}
				disconnect() {
					this.m_model.disconnect()
				}
				studiesMetaData() {
					return this.m_model.studiesMetaData()
				}
				studyVersioning() {
					return this.m_model.studyVersioning()
				}
				chartModel() {
					return this._model()
				}
				_model() {
					return this.m_model
				}
				pushUndoCommand(e) {
					this._pushUndoCommand(e)
				}
				_pushUndoCommand(e) {
					this._undoHistory.pushUndoCommand(e)
				}
				startScrollPrice(e, t, i) {
					t.isAutoScale() || (this._initialPriceScrollState = t.state(), this._initialPriceScrollPos = i, this.chartModel().startScrollPrice(e, t, i))
				}
				scrollPriceTo(e, t, i) {
					t.isAutoScale() || (this._initialPriceScrollPos && Math.abs(this._initialPriceScrollPos - i) > 20 && (this.pushUndoCommand(new x(this.m_model, e, t, this._initialPriceScrollState)), delete this._initialPriceScrollState, delete this._initialPriceScrollPos), this.chartModel().scrollPriceTo(e, t, i))
				}
				endScrollPrice(e, t) {
					t.isAutoScale() || (delete this._initialPriceScrollState, delete this._initialPriceScrollPos, this.chartModel().endScrollPrice(e, t))
				}
				setPriceAutoScale(e, t, i) {
					this.pushUndoCommand(new x(this.m_model, e, t, t.state())), this.chartModel().setPriceAutoScale(e, t, i)
				}
				setWidth(e) {
					this.m_model.setWidth(e)
				}
				setPaneHeight(e, t) {
					this.m_model.setPaneHeight(e, t)
				}
				gridSource() {
					return this.m_model.gridSource()
				}
				watermarkSource() {
					return this.m_model.watermarkSource()
				}
				addAlertsSource(e) {
					return this.m_model.addAlertsSource(e)
				}
				alertsSources() {
					return this.m_model.alertsSources()
				}
				publishedChartsTimelineSource() {
					return this.m_model.publishedChartsTimelineSource()
				}
				crossHairSource() {
					return this.m_model.crossHairSource()
				}
				model() {
					return this.m_model
				}
				chartWidget() {
					return this._chartWidget
				}
				mainSeries() {
					return this.m_model.m_mainSeries
				}
				mainSeriesScaleRatioProperty() {
					return this.m_model.mainSeriesScaleRatioProperty()
				}
				timeScale() {
					return this.m_model.timeScale()
				}
				selectionMacro(e, t) {
					return this.m_model.selectionMacro(e, t)
				}
				setHoveredSource(e, t) {
					this.m_model.setHoveredSource(e, t)
				}
				selection() {
					return this.m_model.selection()
				}
				onSelectedSourceChanged() {
					return this.m_model.onSelectedSourceChanged()
				}
				activeStrategySource() {
					return this.m_model.activeStrategySource()
				}
				invalidate(e) {
					this.m_model.invalidate(e)
				}
				setCurrentPosition(e, t, i, s) {
					this.m_model.setCurrentPosition(e, t, i, s)
				}
				setAndSaveCurrentPosition(e, t, i, s) {
					this.m_model.setAndSaveCurrentPosition(e, t, i, s)
				}
				canCreateStudy(e) {
					return this.model().chartApi().chartApi().isCanCreateStudy(e)
				}
				checkIfFeatureAvailable(e, t) {
					var i = this.canCreateStudy(),
						s = t && t instanceof g;
					if (!this.readOnly() && s && (i = this.canCreateStudy(!0)), !i) return s ? h({
						feature: "studyOnStudy"
					}) : S(), !1;
					if (!this._isCountedStudy(e)) return !0;
					var o = this.m_model.listUserStudies({
							dontCountVolume: !0,
							dontCountOverlay: !0,
							dontCountCompare: !0
						}),
						_ = c(a.INDICATORS_ON_CHART) ? l(a.INDICATORS_ON_CHART).limit : 1 / 0;
					return o.length < _ || (TradingView.onWidget() ? r({
						feature: "indicators"
					}) : (n("studyLimit"), h({
						feature: "studyLimit",
						customParams: o,
						actions: [d.ProPremium, d.ProPremiumTrial].includes(window.user.pro_plan) ? [{
							text: z,
							action: u.Close
						}] : void 0
					})), !1)
				}
				createStudyInserter(e, t, i) {
					var s = this,
						o = null,
						r = {
							createStudy: function(e, t, i, r, n, a, l, c, h, d, u) {
								return s.checkIfFeatureAvailable(e, a) ? (w("studies", "Study_" + e.id), "Compare@tv-basicstudies" === e.id && w("compare", "symbol:" + t.symbol), s._insertStudy(e, t, r, n, a, l, c, h, d, o, u)) : (T.logNormal("Cannot insert study " + e.id), null)
							}
						};
					void 0 !== i && (r.createStub = function() {
						var e = s.m_model.insertStudyStub(i);
						return o = {
							targetPaneId: s.m_model.paneForSource(e).id(),
							targetZOrder: e.zorder()
						}, e.id()
					}, r.removeStub = function(e) {
						return s.m_model.removeStudyStub(e)
					});
					var n = new C(e, this.m_model._studiesMetaInfoRepository, r);
					return n.setParentSource(t), n
				}
				setProperties(e, t, i) {
					var s = this;
					this.beginUndoMacro(i), this.m_model.selectionMacro((function() {
						for (var o = 0; o < e.length; o++) s.setProperty(e[o], t[o], i)
					})), this.endUndoMacro()
				}
				setPriceScaleMode(e, t, i) {
					for (var s = Object.keys(e), o = t.mode(), r = !1, n = 0; n < s.length; n++)
						if (o[s[n]] !== e[s[n]]) {
							r = !0;
							break
						} if (r) {
						var a = new M(e, t, i, this.m_model);
						this.pushUndoCommand(a)
					}
				}
				setPriceScaleSelectionStrategy(e) {
					if (this.m_model.properties().priceScaleSelectionStrategyName.value() !== e) {
						w("Chart", "Change PriceScale Selection Strategy");
						var t = F.format({
							title: e
						});
						this.beginUndoMacro(t), this.setProperty(this.m_model.properties().priceScaleSelectionStrategyName, e, t);
						var i = new b(this.m_model, e, t);
						this.pushUndoCommand(i), this.endUndoMacro()
					}
				}
				setScaleRatioProperty(e, t, i) {
					if (e.value() !== t) {
						var s = new y(e, t, i, this.m_model);
						this.pushUndoCommand(s)
					}
				}
				lineBeingCreated() {
					return this.m_model.lineBeingCreated()
				}
				paneBeingCreatedLineOn() {
					return this.m_model.paneBeingCreatedLineOn()
				}
				cancelCreatingLine() {
					this.m_model.cancelCreatingLine()
				}
				lineCancelled() {
					return this.m_model.lineCancelled()
				}
				lineBeingEdited() {
					return this.m_model.lineBeingEdited()
				}
				sourcesBeingMoved() {
					return this.m_model.sourcesBeingMoved()
				}
				dataSources() {
					return this.m_model.dataSources()
				}
				orderedDataSources(e) {
					return this.m_model.orderedDataSources(e)
				}
				dataSourceForId(e) {
					return this.m_model.dataSourceForId(e)
				}
				state(e, t, i, s) {
					return this.m_model.state(e, t, i, s)
				}
				calculateDefaultTags() {
					return this.m_model.calculateDefaultTags()
				}
				onTagsChanged() {
					return this.m_model.onTagsChanged()
				}
				moveLeft() {
					try {
						this.beginUndoMacro(A)
					} catch (e) {
						return
					}
					var e = this.m_model.timeScale().width(),
						t = this;
					_({
						to: e / 5,
						onStep: function(e) {
							t.startScrollTime(e), t.scrollTimeTo(0), t.endScrollTime()
						},
						onComplete: function() {
							t.endUndoMacro()
						}
					})
				}
				moveRight() {
					try {
						this.beginUndoMacro(k)
					} catch (e) {
						return
					}
					var e = this.m_model.timeScale().width(),
						t = this;
					_({
						to: e / 5,
						onStep: function(e) {
							t.startScrollTime(0), t.scrollTimeTo(e),
								t.endScrollTime()
						},
						onComplete: function() {
							t.endUndoMacro()
						}
					})
				}
				scrollChart(e) {
					this.m_model.scrollEnabled() && (this.startScrollTime(0), this.scrollTimeTo(e), this.endScrollTime())
				}
				scrollChartByBar(e) {
					if (this.m_model.scrollEnabled()) {
						var t = e * this.m_model.timeScale().barSpacing();
						this.startScrollTime(0), this.scrollTimeTo(t), this.endScrollTime()
					}
				}
				restorePreferences() {
					var e = new P(this.model());
					this.pushUndoCommand(e)
				}
				applyPreferences(e) {
					var t = new U(this.model(), e);
					this.pushUndoCommand(t)
				}
				applyLineToolTemplate(e, t, i) {
					this.beginUndoMacro(i), this.saveLineToolState(e, i);
					var s = new f(e, t, i);
					this.pushUndoCommand(s), this.saveLineToolState(e, i), this.endUndoMacro(), this.model().updateSource(e)
				}
				getAlertsList() {
					return this.m_model.getAlertsList()
				}
				trackTime() {
					return this._chartWidget.trackTime()
				}
				isInReplay() {
					return this.m_model.isInReplay()
				}
				switchToReplay(e, t) {
					this._undoHistory.clearStack(), this.m_model.switchToReplay(e, t)
				}
				switchToRealtime() {
					this._undoHistory.clearStack(), this.m_model.switchToRealtime()
				}
				togglePriceScaleAutoScaleMode(e) {
					var t = {
						autoScale: !e.isAutoScale()
					};
					this.setPriceScaleMode(t, e, L)
				}
				togglePriceScaleLockScaleMode(e) {
					var t = {
						lockScale: !e.isLockScale()
					};
					this.setPriceScaleMode(t, e, E)
				}
				setPriceScaleRegularScaleMode(e) {
					this.setPriceScaleMode({
						log: !1,
						percentage: !1,
						indexedTo100: !1
					}, e, D)
				}
				togglePriceScaleIndexedTo100ScaleMode(e) {
					var t = {
						indexedTo100: !e.isIndexedTo100()
					};
					this.setPriceScaleMode(t, e, N)
				}
				togglePriceScalePercentageScaleMode(e) {
					var t = {
						percentage: !e.isPercentage()
					};
					this.setPriceScaleMode(t, e, B)
				}
				togglePriceScaleLogScaleMode(e) {
					var t = {
						log: !e.isLog()
					};
					this.setPriceScaleMode(t, e, O)
				}
				invertPriceScale(e) {
					var t = e.properties().isInverted;
					this.setProperty(t, !t.value(), R)
				}
				removePane(e) {
					var t = this.m_model.panes()[e].dataSources().slice();
					this.removeSources(t, !1, V)
				}
			}
		},
		795896: (e, t, i) => {
			"use strict";
			i.d(t, {
				sourceNewCurrencyOnPinningToPriceScale: () => o
			});
			var s = i(992179);

			function o(e, t, i, o) {
				let r = null;
				if (i.currencyConversionEnabled() && (0, s.isSymbolSource)(e)) {
					const s = i.availableCurrencies(),
						n = t.currency(s),
						a = e.currency();
					null !== n && null !== n.selectedCurrency && !n.allCurrenciesAreOriginal && n.selectedCurrency !== a && (o && null === a || null !== a && s.convertible(a)) && (r = n.selectedCurrency)
				}
				return r
			}
		},
		506656: (e, t, i) => {
			"use strict";
			i.d(t, {
				CustomSourceBase: () => s
			});
			class s {
				constructor(e, t) {
					this._id = e, this._model = t
				}
				id() {
					return this._id
				}
				isHoveredEnabled() {
					return !0
				}
				isSelectionEnabled() {
					return !1
				}
				priceScale() {
					return null
				}
				paneViews(e) {
					return []
				}
				labelPaneViews(e) {
					return []
				}
				priceAxisViews(e, t) {
					return []
				}
				updateViewsForPane(e, t) {
					e.containsMainSeries() && this.updateAllViews(t)
				}
			}
		},
		986607: (e, t, i) => {
			"use strict";
			i.d(t, {
				isMainSeriesState: () => o,
				isStudyState: () => r,
				isLineToolState: () => n,
				isStudyLineToolState: () => a
			});
			var s = i(540968);

			function o(e) {
				return "MainSeries" === e.type
			}

			function r(e) {
				return Boolean(e.type) && e.type.toLowerCase().startsWith("study")
			}

			function n(e) {
				return Boolean(e.type) && (0, s.isLineToolName)(e.type)
			}

			function a(e) {
				return Boolean(e.type) && (0, s.isStudyLineToolName)(e.type)
			}
		},
		443527: (e, t, i) => {
			"use strict";
			i.d(t, {
				EnvironmentState: () => o
			});
			var s = i(638456);
			class o {
				constructor(e, t = !1) {
					this._shift = !1, this._mod = !1, this._alt = !1, void 0 !== e && (this._shift = Boolean(e.shiftKey), this._mod = Boolean((0, s.isMac)() ? e.metaKey : e.ctrlKey), this._alt = Boolean(e.altKey)), this._isApiEvent = t
				}
				shift() {
					return this._shift
				}
				mod() {
					return this._mod
				}
				alt() {
					return this._alt
				}
				shiftOnly() {
					return this._shift && !this._mod && !this._alt
				}
				modOnly() {
					return this._mod && !this._shift && !this._alt
				}
				altOnly() {
					return this._alt && !this._shift && !this._mod
				}
				modShift() {
					return this._shift && this._mod && !this._alt
				}
				isApiEvent() {
					return this._isApiEvent
				}
				static create(e = !1, t = !1, i = !1) {
					return new o({
						shiftKey: e,
						ctrlKey: t,
						metaKey: t,
						altKey: i
					})
				}
			}
		},
		316017: (e, t, i) => {
			"use strict";
			i.d(t, {
				DateTimeWithTzFormatter: () => a
			});
			var s = i(684304),
				o = i(504122),
				r = i(820187);
			const n = {
				dateFormat: "MMM dd",
				timeFormat: r.hourMinuteFormat
			};
			class a {
				constructor(e = {}) {
					this._dateFormatter = null, this._timeFormatter = null, this._options = Object.assign({}, n, e), "" !== this._options.dateFormat && (this._dateFormatter = new o.DateFormatter(this._options.dateFormat)), this._options.timeFormat.length > 0 && (this._timeFormatter = new r.TimeFormatter(this._options.timeFormat)), this._timezone = this._options.timezone
				}
				format(e) {
					void 0 === this._tzOffset && void 0 !== this._timezone && (this._tzOffset = (0, s.parseTzOffset)(this._timezone, 1e3 * e));
					const t = this._tzOffset ? this._tzOffset : {
							offset: 0,
							string: "UTC"
						},
						i = 1e3 * e + t.offset,
						o = new Date(i),
						r = [];
					if (null !== this._dateFormatter && r.push(this._dateFormatter.format(o)), null !== this._timeFormatter) {
						const e = this._timeFormatter.format(o);
						r.push(e)
					}
					return r.push(t.string), r.join(" ")
				}
				setTimezone(e) {
					this._timezone = e, this._tzOffset = void 0
				}
			}
		},
		635363: (e, t, i) => {
			"use strict";
			i.d(t, {
				PipFormatter: () => o
			});
			var s = i(689765);
			class o extends s.PriceFormatter {
				constructor(e, t, i, s) {
					t || (t = 1), "forex" !== i && "cfd" !== i || !s ? (super(1), this._isForex = !1) : (super(s), this._isForex = !0), this._pipPriceScale = e, this._pipMinMove = t, this._pipMinMove2 = s
				}
				format(e, t, i) {
					let s = this._isForex ? this._pipMinMove2 : this._pipMinMove;
					return void 0 === s && (s = NaN), super.format(e * this._pipPriceScale / s, t, i)
				}
			}
		},
		401172: (e, t, i) => {
			"use strict";
			i.d(t, {
				TimeSpanFormatter: () => o
			});
			var s = i(575932);
			class o {
				format(e) {
					const t = e < 0;
					e = Math.abs(e);
					const i = Math.floor(e / 86400);
					e -= 86400 * i;
					const o = Math.floor(e / 3600);
					e -= 3600 * o;
					const r = Math.floor(e / 60);
					e -= 60 * r;
					let n = "";
					return i && (n += i + (0, s.t)("d", {
						context: "dates"
					}) + " "), o && (n += o + (0, s.t)("h", {
						context: "dates"
					}) + " "), r && (n += r + (0, s.t)("m", {
						context: "dates"
					}) + " "), e && (n += e + (0, s.t)("s", {
						context: "dates"
					}) + " "), t && (n = "-" + n), n.trim()
				}
			}
		},
		831845: (e, t, i) => {
			"use strict";

			function s(e) {
				return Boolean(e.showInObjectTree)
			}
			i.d(t, {
				isDataSource: () => s
			})
		},
		19851: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolsGroup: () => l
			});
			var s = i(97639),
				o = i.n(s),
				r = i(95935);

			function n(e) {
				return e.properties().visible.value()
			}

			function a(e) {
				return !n(e)
			}
			class l {
				constructor(e, t, i) {
					this._instanceId = (0, r.randomHashN)(6), this._onChanged = new(o()), this._lineToolsSet = new Set, this._lineTools = [...e], this._lineToolsSet = new Set(this._lineTools), this._name = t, this.id = i || (0, r.randomHashN)(6)
				}
				instanceId() {
					return this._instanceId
				}
				lineTools() {
					return this._lineTools
				}
				name() {
					return this._name
				}
				setName(e) {
					this._doAndFireOnChange((() => {
						this._name = e
					}))
				}
				isActualSymbol() {
					return this._lineTools.length > 0 && this._lineTools[0].isActualSymbol() && this._lineTools[0].isActualCurrency() && this._lineTools[0].isActualUnit()
				}
				symbol() {
					return this._lineTools[0].symbol()
				}
				currencyId() {
					var e;
					return null !== (e = this._lineTools[0].properties().childs().currencyId.value()) && void 0 !== e ? e : null
				}
				unitId() {
					var e;
					return null !== (e = this._lineTools[0].properties().childs().unitId.value()) && void 0 !== e ? e : null
				}
				sharingMode() {
					return this._lineTools[0].sharingMode()
				}
				share(e) {
					this._lineTools.forEach((t => t.share(e)))
				}
				containsLineTool(e) {
					return this._lineToolsSet.has(e)
				}
				addLineTools(e) {
					this._doAndFireOnChange((t => {
						e.forEach((e => this._lineToolsSet.add(e))), this._lineTools.push(...e), t.push(...e.map((e => e.id())))
					}))
				}
				excludeLineTool(e) {
					this._doAndFireOnChange((t => {
						this._lineToolsSet.delete(e);
						const i = this._lineTools.indexOf(e);
						this._lineTools.splice(i, 1), t.push(e.id())
					}))
				}
				excludeLineTools(e) {
					this._doAndFireOnChange((t => {
						const i = new Set(e);
						e.forEach((e => this._lineToolsSet.delete(e))), this._lineTools = this._lineTools.filter((e => !i.has(e))), t.push(...e.map((e => e.id())))
					}))
				}
				state() {
					return {
						id: this.id,
						name: this._name,
						tools: this._lineTools.map((e => e.id()))
					}
				}
				visibility() {
					const e = this._lineTools.some(n),
						t = this._lineTools.some(a);
					return e && !t ? "Visible" : t && !e ? "Invisible" : "Partial"
				}
				locked() {
					const e = this._lineTools.some((e => e.properties().frozen.value())),
						t = this._lineTools.some((e => !e.properties().frozen.value()));
					return e && !t ? "Locked" : t && !e ? "Unlocked" : "Partial"
				}
				isActualInterval() {
					const e = this._lineTools.some((e => e.isActualInterval())),
						t = this._lineTools.some((e => !e.isActualInterval()));
					return e && !t ? "IsActualInterval" : t && !e ? "IsNotActualInterval" : "Partial"
				}
				onChanged() {
					return this._onChanged
				}
				static fromState(e, t) {
					const i = [];
					for (const s of t.tools) {
						const t = e.dataSourceForId(s);
						null !== t && i.push(t)
					}
					return i.length > 0 ? new l(i, t.name, t.id) : null
				}
				_doAndFireOnChange(e) {
					const t = [],
						i = this.visibility(),
						s = this.locked(),
						o = this.name(),
						r = this.isActualInterval();
					e(t), this._onChanged.fire({
						affectedLineTools: t,
						visibilityChanged: i !== this.visibility(),
						lockedChanged: s !== this.locked(),
						titleChanged: o !== this.name(),
						isActualIntervalChanged: r !== this.isActualInterval()
					})
				}
			}
		},
		443275: (e, t, i) => {
			"use strict";
			i.d(t, {
				BarMarksTooltip: () => n
			});
			var s = i(588537);

			function o(e, t, i) {
				return new Promise((s => {
					i && e.classList.remove(i), e.classList.add(t);
					const o = i => {
						i.target === e && i.animationName === t && (e.removeEventListener(i.type, o), s(i))
					};
					e.addEventListener("animationend", o, !1), e.addEventListener("webkitAnimationEnd", o, !1), e.addEventListener("MSAnimationEnd", o, !1)
				}))
			}

			function r(e) {
				return o(e, "tv-transition--fade-in", "tv-transition--fade-out")
			}
			class n {
				constructor() {
					this._source = null, this._tooltipHovered = !1, this._layout = null, this._container = null, this._context = null, this._plateArrowSize = 14, this._handleTouchMouseLeave = e => {
						(0, s.ensureNotNull)(this._layout).contains(e.target) || this._clearHovered()
					}, this._setHovered = () => {
						this._tooltipHovered = !0,
							document.addEventListener("touchstart", this._handleTouchMouseLeave), r((0, s.ensureNotNull)(this._layout))
					}, this._clearHovered = () => {
						var e;
						this._tooltipHovered = !1, document.removeEventListener("touchstart", this._handleTouchMouseLeave), null === (e = this._source) || void 0 === e || e.onNeedRepaint.fire()
					}
				}
				showPlate(e, t) {
					if (this._currentId !== e.id || !this._layout || null === this._layout.parentNode) {
						this._currentId = e.id, this._createLayout();
						const i = (0, s.ensureNotNull)(this._layout);
						this._getContainer(t).appendChild(i), i.addEventListener("mouseenter", this._setHovered), i.addEventListener("mouseleave", this._clearHovered)
					}
					const i = (0, s.ensureNotNull)(this._layout);
					let o = Math.round(e.barWidth / 2);
					o > 15 && (o = 15), o < 10 && (o = 10), this._updatePlate(e);
					const r = t.canvas.getBoundingClientRect(),
						n = e.x - i.offsetWidth < this._plateArrowSize;
					let a = r.width - e.x + Math.round(e.barWidth / 2 + o);
					n && (a -= i.offsetWidth + 2 * this._plateArrowSize);
					const l = r.height,
						c = Math.min(Math.max(e.y, 20), l - i.offsetHeight - 10) + "px";
					i.classList.toggle("right", n), i.style.display = "block", i.style.top = c, i.style.right = a + "px", i.style.fontSize = o + "px"
				}
				hide(e) {
					const t = (0, s.ensureNotNull)(this._layout);
					var i;
					this._tooltipHovered ? r(t) : (i = t, o(i, "tv-transition--fade-out", "tv-transition--fade-in")).then((() => {
						t.remove(), e()
					}))
				}
				setSource(e) {
					this._source = e
				}
				removeLayout() {
					var e;
					this._tooltipHovered || null === (e = this._layout) || void 0 === e || e.remove()
				}
				toggleLayout(e) {
					(0, s.ensureNotNull)(this._layout).style.visibility = e ? "visible" : "hidden"
				}
				_getContainer(e) {
					return this._container && this._context === e || (this._context = e, this._container = e.canvas.parentElement), (0, s.ensureNotNull)(this._container)
				}
			}
		},
		483306: (e, t, i) => {
			"use strict";
			i.d(t, {
				BarsMarksContainer: () => P
			});
			var s = i(588537),
				o = i(911905),
				r = i(62802),
				n = i.n(r),
				a = i(611688),
				l = i(724145),
				c = i(97639),
				h = i.n(c),
				d = i(273044),
				u = i(270617),
				_ = i(749473);
			class m {
				constructor(e, t) {
					this.source = e, this._rendererFactory = t
				}
				update() {}
				renderer(e, t) {
					return this._rendererFactory(this.source)
				}
			}
			var p = i(380047),
				g = i(588427),
				S = i(86441),
				v = i(218718),
				f = i(934026);
			const b = {
				green: {
					border: "#78C143",
					background: "#8DDD54"
				},
				red: {
					border: "#CC4545",
					background: "#ED5A5A"
				},
				neutral: {
					border: "#EAC300",
					background: "#FFD400"
				},
				yellow: {
					border: "#EAC300",
					background: "#FFD400"
				},
				blue: {
					border: "#047ACE",
					background: "#0496FF"
				}
			};
			class y extends p.ScaledPaneRenderer {
				constructor(e, t) {
					super(), this._highlightByAuthor = !1, this._barWidth = e.barWidth, this._plates = e.plates, this._tooltip = e.tooltip, this._model = t
				}
				hitTest(e) {
					for (let t = this._plates.length - 1; t >= 0; --t) {
						const i = this._hitTestDot(this._plates[t], e);
						if (i) return i
					}
					return null
				}
				_drawImpl(e) {
					var t, i;
					e.save();
					for (let e = 0; e < this._plates.length; e++)
						if (this._plates[e].highlightByAuthor) {
							this._highlightByAuthor = !0;
							break
						} this._plates.forEach(this._drawItem.bind(this, e));
					const s = this._plates.map((e => this._plateTransform(e)));
					null === (t = this._tooltip) || void 0 === t || t.draw(s, e), null === (i = this._tooltip) || void 0 === i || i.endDraw(), e.restore()
				}
				_drawItem(e, t) {
					e.save(), this._highlightByAuthor && !t.highlightByAuthor && (e.globalAlpha = .4);
					const i = this._dotTransform(t);
					i.mine ? this._drawTriangle(e, i) : this._drawDot(e, i),
						e.restore()
				}
				_commonTransform(e) {
					const t = Math.max(1.4 * e.minSize, this._barWidth + 4),
						i = {
							up: -1,
							down: 1
						} [e.direction] * (e.yInverted ? -1 : 1) * (t * (e.order + .6) + .25 * t),
						s = e.y + i,
						o = (0, u.clone)(e.overridedTheme || b[e.theme]);
					return o.dotBorderWidth = e.hovered || e.highlightByAuthor ? 4 : 2, {
						id: e.id,
						theme: o,
						themeName: e.theme,
						x: Math.round(e.x + 1),
						y: Math.round(s),
						yInverted: e.yInverted,
						pinned: Boolean(e.pinned),
						hovered: Boolean(e.hovered)
					}
				}
				_dotTransform(e) {
					const t = Math.max(e.minSize / 2, .4 * this._barWidth),
						i = {
							...this._commonTransform(e),
							radius: t,
							label: e.label,
							labelFontColor: e.labelFontColor,
							labelFontSize: Math.ceil(Math.max(10, Math.min(t, 20)))
						};
					return this._model.updateDotData(e, i)
				}
				_plateTransform(e) {
					const t = this._commonTransform(e);
					return this._model.updatePlateData(e, t)
				}
				_drawTriangle(e, t) {
					e.strokeStyle = t.theme.border, e.fillStyle = t.theme.background, e.lineWidth = t.theme.dotBorderWidth || 2;
					const i = t,
						s = t.radius,
						o = Math.cos(Math.PI / 6) * s,
						r = Math.sin(Math.PI / 6) * s;
					e.translate(i.x, i.y);
					"up" === t.direction !== t.yInverted && e.rotate(Math.PI), t.public || (e.lineWidth /= 2), e.beginPath(), e.moveTo(0, -s), e.lineTo(o, r), e.lineTo(-o, r), e.lineTo(0, -s), e.closePath(), e.stroke(), t.public && e.fill()
				}
				_drawDot(e, t) {
					e.strokeStyle = t.theme.border, e.fillStyle = t.theme.background, e.lineWidth = t.theme.dotBorderWidth || 2, e.beginPath(), e.arc(t.x, t.y, t.radius, 0, 2 * Math.PI, !0), e.closePath(), e.stroke(), e.fill(), t.label && t.radius >= 7 && (e.textAlign = "center", e.textBaseline = "middle", e.font = "bold " + t.labelFontSize + "px " + g.CHART_FONT_FAMILY, e.fillStyle = t.labelFontColor, e.fillText(t.label, t.x, t.y))
				}
				_hitTestDot(e, t) {
					const i = this._dotTransform(e),
						s = new S.Point(i.x, i.y);
					return (0, f.pointInCircle)(t, s, Math.max(i.radius, 8)) ? new v.HitTestResult(v.HitTestResult.REGULAR, {
						activeItem: e
					}) : null
				}
			}
			var C = i(346090);
			const w = (0, o.getLogger)("Chart.BarsMarksContainer"),
				T = Math.round(new Date(2037, 0, 1).getTime() / 1e3);
			class P extends l.LineDataSource {
				constructor(e, t, i, o) {
					const r = e.onWidget();
					let c;
					if (c = r ? !e.hideIdeas() : !!a.enabled("bars_marks") && n().getBool("BarsMarksContainer.visibile", !1), t) t.merge({
						visible: c,
						frozen: !1
					});
					else {
						t = new C.DefaultProperty("barmarks", {
							visible: c,
							frozen: !1
						})
					}
					t.childs().visible.listeners().subscribe(null, (t => {
							r || e.isSnapshot() || !a.enabled("bars_marks") || n().setValue("BarsMarksContainer.visibile", !!t.value()), this._tooltip && this._tooltip.removeAll()
						})), l.LineDataSource._configureProperties(t), super(e, t, i, o), this.onNeedRepaint = new(h()), this._requests = [], this._marks = {}, this._loadedRange = null, this._getDataTimeout = null, this._collectedRange = null, this._lastRange = null, this._model.mainSeries().onSymbolIntervalChanged().subscribe(this, this.clearMarks), this._model.mainSeries().dataEvents().symbolResolved().subscribe(this, this.clearMarks), this._model.mainSeries().dataEvents().completed().subscribe(this, (() => {
							var e, t;
							const i = this._model.mainSeries().data();
							if (0 === i.size()) return;
							const o = (0, s.ensureNotNull)(i.first()).index,
								r = (0, s.ensureNotNull)(i.last()).index,
								n = this.timeScale();
							this.getData({
								start: null !== (e = n.indexToTimePoint(o)) && void 0 !== e ? e : 1 / 0,
								end: null !== (t = n.indexToTimePoint(r)) && void 0 !== t ? t : -1 / 0
							})
						})),
						this._initialize(), this._pinnedTooltips = {}, this._tooltip = this._createTooltipRenderer()
				}
				marks() {
					return this._marks
				}
				updateDotData(e, t) {
					return t
				}
				isAvailableInFloatingWidget() {
					return !1
				}
				pinTooltip(e, t) {
					this._pinnedTooltips[e] = t
				}
				timeScale() {
					return this._model.timeScale()
				}
				getIntervalInTicks() {
					const e = this._model.mainSeries().properties().childs().interval.value(),
						t = d.Interval.parse(e);
					if (!t.isValid()) throw new TypeError("Unexpected interval");
					return t.isRange() ? 60 : t.inMilliseconds() / 1e3
				}
				getVisibleTickMarksRange() {
					var e, t;
					if (this.timeScale().isEmpty()) return {
						start: 0,
						end: 0
					};
					const i = (0, s.ensureNotNull)(this.timeScale().visibleBarsStrictRange()),
						o = (0, s.ensureNotNull)(this.timeScale().points().firstIndex()),
						r = (0, s.ensureNotNull)(this.timeScale().points().lastIndex());
					if (!(i.lastBar() > o && i.firstBar() < r)) return {
						start: 0,
						end: 0
					};
					let n;
					n = i.lastBar() < r ? this.timeScale().indexToTimePoint(i.lastBar()) : T;
					const a = {
						start: this.timeScale().indexToTimePoint(Math.max(i.firstBar(), o)),
						end: n
					};
					return {
						start: null !== (e = a.start) && void 0 !== e ? e : 1 / 0,
						end: null !== (t = a.end) && void 0 !== t ? t : -1 / 0
					}
				}
				getVisibleRangePlates() {
					const e = [],
						t = this.getVisibleTickMarksRange(),
						i = this.getIntervalInTicks();
					return Object.keys(this._marks).forEach((s => {
						var o, r;
						const n = this._marks[s],
							a = n.tickmark;
						a >= (null !== (o = t.start) && void 0 !== o ? o : 1 / 0) && a <= (null !== (r = t.end) && void 0 !== r ? r : -1 / 0) + i && e.push(n)
					})), e
				}
				getPublishedPlates() {
					const e = {};
					return window.is_authenticated ? (this.getVisibleRangePlates().forEach((t => {
						t.is_public && (this._pinnedTooltips[t.id] || t.user__id === window.user.id) && (e[t.id] = t)
					})), e) : e
				}
				filterDisplayedPlates(e) {
					const t = e.reduce(((e, t) => {
						const i = this._getIndex(t.tickmark);
						return null !== i && (e[i] = e[i] || [], e[i].push(t)), e
					}), {});
					return Object.keys(t).reduce(((e, i) => {
						let s = t[i];
						return s = s.sort(((e, t) => t.views_count - e.views_count)), s = s.slice(0, 10), e.concat(s)
					}), [])
				}
				getViewData() {
					return {
						barWidth: this.barWidth(),
						plates: this.getPlatesViewData(),
						tooltip: this._tooltip
					}
				}
				barWidth() {
					return this.timeScale().barSpacing()
				}
				getPlatesViewData() {
					var e, t, i;
					const o = this._model.mainSeries();
					if (o.data().isEmpty()) return [];
					const r = (0, _.isPriceSourceStyle)(o.style()) ? o.barFunction() : null,
						n = this.filterDisplayedPlates(this.getVisibleRangePlates()),
						a = {},
						l = null !== (e = this._model.lastHittestData()) && void 0 !== e ? e : this._model.lastSelectedHittestData(),
						c = [];
					for (const e of n) {
						const i = (0, s.ensureNotNull)(this._getIndex(e.tickmark)),
							o = this._getBar(i);
						if (null === o) continue;
						const n = this._layout(e.direction),
							h = this._theme(e.direction);
						let d = null;
						null !== l && this._model.hoveredSource() === this && (d = null !== (t = l.activeItem) && void 0 !== t ? t : null);
						const _ = null !== d && d.id === e.id,
							m = this.timeScale().indexToCoordinate(i),
							p = this._offset(n, o, r),
							g = (0, s.ensureNotNull)(this.priceScale()).isInverted();
						let S = 0;
						i in a || (a[i] = {
							up: 0,
							down: 0
						}), S = a[i][n]++, c.push((0, u.merge)({
							id: e.id,
							x: m,
							y: p,
							yInverted: g,
							order: S,
							direction: n,
							theme: h,
							hovered: _,
							pinned: !0 === this._pinnedTooltips[e.id],
							user__id: e.user__id,
							label: e.label,
							labelFontColor: e.labelFontColor || "#444",
							minSize: e.minSize || 5
						}, this._plateViewData(e)))
					}
					const h = c.filter((e => !0 === e.hovered));
					for (let e = 0; e < n.length; e++) n[e].user__id === (null === (i = h[0]) || void 0 === i ? void 0 : i.user__id) && (n[e].highlightByAuthor = !0);
					return c.sort(((e, t) => e.hovered && !t.hovered ? 1 : 0)), c
				}
				paneViews() {
					return this._properties.childs().visible.value() ? [new m(this, (e => new y(e.getViewData(), this)))] : []
				}
				priceAxisViews() {
					return null
				}
				updateAllViews() {}
				pointsCount() {
					return 0
				}
				roundRange(e) {
					return {
						start: Math.round(e.start),
						end: Math.round(e.end)
					}
				}
				refreshData() {
					null !== this._lastRange && this.getData(this._lastRange)
				}
				getData(e) {
					(0, u.isNumber)(e.start) && (0, u.isNumber)(e.end) ? (this._lastRange = e, e.end = T, this._pushGetDataStack(Object.assign({}, e))) : w.logError("Wrong range")
				}
				clearMarks() {
					this._abortAllRequests(), this._marks = {}, this._loadedRange = null
				}
				isUserDeletable() {
					return !1
				}
				_plateViewData(e) {
					return {}
				}
				_layout(e) {
					switch (e) {
						default:
						case 0:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
							return "up";
						case 1:
							return "down"
					}
				}
				_theme(e) {
					switch (e) {
						default:
						case 0:
							return "neutral";
						case 1:
						case 5:
							return "green";
						case 2:
						case 6:
							return "red";
						case 3:
							return "yellow";
						case 4:
							return "blue"
					}
				}
				_offset(e, t, i) {
					let o;
					switch (e) {
						default:
						case "up":
							o = null === i ? t[2] : i(t);
							break;
						case "down":
							o = null === i ? t[3] : i(t)
					}
					return (0, s.ensureNotNull)(this.priceScale()).priceToCoordinate(o, (0, s.ensureNotNull)((0, s.ensureNotNull)(this.ownerSource()).firstValue()))
				}
				_getIndex(e) {
					return this.timeScale().timePointToIndex(e)
				}
				_getBar(e) {
					return this._model.mainSeries().data().valueAt(e)
				}
				_rangeDifference(e) {
					return e = Object.assign({
						start: 1 / 0,
						end: -1 / 0
					}, e), this._loadedRange && (e.start < this._loadedRange.start ? e.end = this._loadedRange.start : e.end > this._loadedRange.end && (e.start = this._loadedRange.end)), e
				}
				_rangeUnion(e, t) {
					return e = Object.assign({
						start: 1 / 0,
						end: -1 / 0
					}, e), t && (e.start = Math.min(t.start, e.start), e.end = Math.max(t.end, e.end)), e
				}
				_pushGetDataStack(e) {
					(0, u.isNumber)(e.start) && (0, u.isNumber)(e.end) ? (this._getDataTimeout && clearTimeout(this._getDataTimeout), this._collectedRange = this._rangeUnion(e, this._collectedRange), this._getDataTimeout = setTimeout((() => {
						this._getData(this._collectedRange), this._getDataTimeout = this._collectedRange = null
					}), 300)) : w.logError("Wrong tickmark range")
				}
				_abortAllRequests() {
					this._requests.forEach((e => {
						e.cancel()
					})), this._requests = [], this._getDataTimeout && clearTimeout(this._getDataTimeout), this._getDataTimeout = this._collectedRange = null
				}
			}
		},
		919250: (e, t, i) => {
			"use strict";
			i.d(t, {
				TooltipRenderer: () => o
			});
			var s = i(588537);
			class o {
				constructor(e, t) {
					this._tooltips = {}, this._hoveredId = null, this._tooltipFactory = e, this.source = t
				}
				showPlate(e, t) {
					const i = this._findOrCreateTooltip(e);
					null !== i && (i.drawPlate(e, t), i.plateData = e)
				}
				draw(e, t) {
					this._hoveredId = null;
					for (const t of e) t.hovered && (this._hoveredId = t.id);
					for (const i of e) this.showPlate(i, t)
				}
				endDraw() {
					var e, t;
					for (const i in this._tooltips)
						if (this._tooltips.hasOwnProperty(i)) {
							const o = (0, s.ensureDefined)(this._tooltips[i]);
							o.toggleVisibility(), this._hoveredId && (null === (e = o.plateData) || void 0 === e ? void 0 : e.id) !== this._hoveredId && !(null === (t = o.plateData) || void 0 === t ? void 0 : t.pinned) && (o.remove(), delete this._tooltips[i])
						}
				}
				removeAll() {
					for (const e in this._tooltips)
						if (this._tooltips.hasOwnProperty(e)) {
							(0, s.ensureDefined)(this._tooltips[e]).remove()
						} this._tooltips = {}
				}
				removeTooltip(e) {
					delete this._tooltips[e]
				}
				_createTooltip() {
					return new r(this, this._tooltipFactory())
				}
				_findOrCreateTooltip(e) {
					let t = this._tooltips[e.id];
					return void 0 === t && (e.hovered || e.pinned) && (t = this._createTooltip(), this._tooltips[e.id] = t), t || null
				}
			}
			class r {
				constructor(e, t) {
					this._visible = !1, this._renderer = e, this._tooltip = t
				}
				drawPlate(e, t) {
					this._visible = !0, this._tooltip.setSource(this._renderer.source), this._tooltip.showPlate(e, t), e.hovered || e.pinned || this._tooltip.hide((() => this._renderer.removeTooltip(e.id)))
				}
				remove() {
					this._tooltip.removeLayout()
				}
				toggleVisibility() {
					this._tooltip.toggleLayout(this._visible), this._visible = !1
				}
			}
		},
		194946: (e, t, i) => {
			"use strict";
			i.d(t, {
				blobImageFilter: () => a,
				imageIsOversized: () => c,
				generateLink: () => d,
				checkImageSize: () => u,
				uploadImage: () => _
			});
			var s = i(86674),
				o = i(824112),
				r = i(575932),
				n = i(911905);

			function a(e) {
				return "image/png" === e.type || "image/jpeg" === e.type
			}
			const l = new o.Size(2e3, 2e3);

			function c(e) {
				return e.width > l.w || e.height > l.h
			}
			const h = (0, n.getLogger)("Chart.Uploader");
			async function d(e) {
				const t = new FormData,
					i = "name" in e ? e.name : "image.png";
				t.append("content_type", e.type), t.append("filename", i), t.append("size", "" + e.size);
				try {
					const e = await (0, s.fetch)("/charts/uploads/generate-link/", {
						method: "POST",
						body: t
					});
					if (!e.ok) throw new Error(`Error generating upload link: ${e.status}`);
					return e.json()
				} catch (t) {
					throw h.logError(`Error generating upload link: ${t}. blob.type: ${e.type} blob.size: ${e.size} filename: ${i}`), t
				}
			}
			async function u(e) {
				return new Promise(((t, i) => {
					const s = new FileReader;
					s.onload = e => {
						var s;
						const o = new Image;
						o.src = null === (s = e.target) || void 0 === s ? void 0 : s.result, o.onload = () => {
							t(!c(o))
						}, o.onerror = i
					}, s.onerror = i, s.readAsDataURL(e)
				}))
			}
			async function _(e) {
				if (!await u(e)) throw new Error((0, r.t)("The image being pasted is way too large"));
				try {
					const t = await d(e),
						i = t.data.fields,
						o = new FormData;
					for (const e of Object.keys(i)) o.append(e, i[e]);
					o.append("file", e);
					const r = await (0, s.fetch)(t.data.url, {
						method: "POST",
						body: o
					});
					if (r.ok) return t.data.url + t.filepath;
					throw new Error(`Upload response is not ok: ${r.status}`)
				} catch (e) {
					throw new Error(`Error uploading image: ${e.message}`)
				}
			}
		},
		699882: (e, t, i) => {
			"use strict";
			i.d(t, {
				LogicalRange: () => o
			});
			var s = i(588537);
			class o {
				constructor(e, t) {
					(0, s.assert)(e <= t, "The left value should be greater than or equal to the right value"), this._left = e, this._right = t
				}
				left() {
					return this._left
				}
				right() {
					return this._right
				}
				length() {
					return this._right - this._left + 1
				}
				contains(e, t) {
					return e < this._left - .5 ? !0 === t && 1 : e > this._right + .5 ? !0 === t && 2 : !0 !== t || 0
				}
				before(e) {
					return e < this._left - .5
				}
				after(e) {
					return e > this._right + .5
				}
				equals(e) {
					return this._left === e.left() && this._right === e.right()
				}
				static compare(e, t) {
					return null === e || null === t ? e === t : e.equals(t)
				}
			}
		},
		298438: (e, t, i) => {
			"use strict";
			i.d(t, {
				magnetEnabled: () => p,
				magnetMode: () => g,
				setIsMagnetEnabled: () => S,
				setMagnetMode: () => v
			});
			var s = i(346090),
				o = i(262325),
				r = i.n(o),
				n = i(359266),
				a = i(308170),
				l = i(540968),
				c = i(125082);
			const h = new(r())(!1),
				d = new(r())(n.MagnetMode.WeakMagnet),
				u = (0, c.modifierPressed)(),
				_ = (0, c.shiftPressed)();

			function m() {
				const e = u.value();
				if (_.value() && (a.isToolEditingNow.value() || a.isToolCreatingNow.value())) return void h.setValue(!1);
				const t = a.tool.value(),
					i = a.isStudyEditingNow.value() || a.isPointSelectedNow.value(),
					s = e && ((0, l.isLineToolName)(t) || a.isToolEditingNow.value() || (0, a.toolIsMeasure)(t) || i),
					o = (0, a.properties)().childs().magnet.value();
				d.setValue(!o && s ? n.MagnetMode.StrongMagnet : (0, a.properties)().childs().magnetMode.value()), h.setValue(s ? !o : o)
			}

			function p() {
				return h
			}

			function g() {
				return d
			}

			function S(e) {
				(0, s.saveDefaultProperties)(!0), (0, a.properties)().childs().magnet.setValue(e), (0, s.saveDefaultProperties)(!1)
			}

			function v(e) {
				(0, s.saveDefaultProperties)(!0), (0, a.properties)().childs().magnetMode.setValue(e), (0, a.properties)().childs().magnet.setValue(!0), (0, s.saveDefaultProperties)(!1)
			}(0, a.runOnDrawingStateReady)((() => {
				(0, a.properties)().childs().magnet.subscribe(null, m), (0, a.properties)().childs().magnetMode.subscribe(null, m), u.subscribe(m), _.subscribe(m), a.tool.subscribe(m), a.isToolEditingNow.subscribe(m), m()
			}))
		},
		175239: (e, t, i) => {
			"use strict";
			i.d(t, {
				MainSeriesScaleRatioProperty: () => r
			});
			var s = i(97639),
				o = i.n(s);
			class r {
				constructor(e) {
					this._changed = new(o()), this._model = e
				}
				getStepChangeValue() {
					return .1
				}
				getMinValue() {
					return 1e-7
				}
				getMaxValue() {
					return 99999999
				}
				value() {
					return this._model.mainSeriesScaleRatio()
				}
				setValue(e, t) {
					(e !== this.value() || t) && (this._model.setMainSeriesScaleRatio(e), this._onChanged())
				}
				state() {
					return null
				}
				clone() {
					return new r(this._model)
				}
				listeners() {
					return this._changed
				}
				subscribe(e, t) {
					this._changed.subscribe(e, t)
				}
				unsubscribe(e, t) {
					this._changed.unsubscribe(e, t)
				}
				unsubscribeAll(e) {
					this._changed.unsubscribeAll(e)
				}
				storeStateIfUndefined() {
					return !0
				}
				_onChanged() {
					this._changed.fire(this)
				}
			}
		},
		819589: (e, t, i) => {
			"use strict";
			i.d(t, {
				RectangleRenderer: () => d
			});
			var s = i(588537),
				o = i(86441),
				r = i(934026),
				n = i(204652),
				a = i(218718),
				l = i(721386),
				c = i(345185),
				h = i(164149);
			class d {
				constructor(e, t, i) {
					this._data = null, this._hitTestResult = e || new a.HitTestResult(a.HitTestResult.MOVEPOINT), this._backHitTestResult = t || new a.HitTestResult(a.HitTestResult.MOVEPOINT_BACKGROUND), this._forceOverrideTransparency = Boolean(i)
				}
				setData(e) {
					this._data = e
				}
				hitTest(e, t) {
					if (null === this._data || this._data.points.length < 2 || this._data.nohittest) return null;
					const [i, s] = this._getPointsInPhysicalSpace(t), r = new o.Point(s.x, i.y), a = new o.Point(i.x, s.y), l = new o.Point(e.x * t.pixelRatio, e.y * t.pixelRatio), c = this._extendAndHitTestLineSegment(l, i, r, t);
					if (null !== c) return c;
					const h = this._extendAndHitTestLineSegment(l, a, s, t);
					if (null !== h) return h;
					let d = (0, n.distanceToSegment)(r, s, l);
					return d.distance <= 3 ? this._hitTestResult : (d = (0, n.distanceToSegment)(i, a, l), d.distance <= 3 ? this._hitTestResult : this._data.fillBackground ? this._hitTestBackground(l, i, s, t) : null)
				}
				getColor() {
					const e = (0, s.ensure)(this._data);
					return void 0 === e.transparency ? e.backcolor : (0, l.generateColor)(e.backcolor, e.transparency, this._forceOverrideTransparency)
				}
				draw(e, t) {
					if (null === this._data || this._data.points.length < 2 || this._data.linewidth <= 0 && !this._data.fillBackground) return;
					e.save();
					const [i, s] = this._getPointsInPhysicalSpace(t), o = this._data.linewidth ? Math.max(1, Math.floor(this._data.linewidth * t.pixelRatio)) : 0, r = this._data.fillBackground ? this.getColor() : void 0, n = Math.max(1, Math.floor(t.pixelRatio));
					(0, h.fillRectWithBorder)(e, i.x, i.y, s.x, s.y, r, this._data.color, o, c.LINESTYLE_SOLID, this._data.extendLeft, this._data.extendRight, "center", t.physicalWidth, this._data.includeRightEdge && 1 === n ? 1 : 0), e.restore()
				}
				_getPointsInPhysicalSpace(e, t = 0) {
					const i = (0, s.ensureNotNull)(this._data),
						[r, n] = i.points,
						a = e.pixelRatio,
						l = Math.min(r.x, n.x),
						c = Math.max(r.x, n.x),
						h = Math.min(r.y, n.y),
						d = Math.max(r.y, n.y),
						u = Math.round(l * a) + t,
						_ = Math.round(c * a) + t,
						m = Math.round(h * a) + t,
						p = Math.round(d * a) + t;
					return [new o.Point(u, m), new o.Point(_, p)]
				}
				_extendAndHitTestLineSegment(e, t, i, s) {
					const o = this._extendAndClipLineSegment(t, i, s);
					if (null !== o) {
						if ((0, n.distanceToSegment)(o[0], o[1], e).distance <= 3) return this._hitTestResult
					}
					return null
				}
				_extendAndClipLineSegment(e, t, i) {
					const r = (0, s.ensureNotNull)(this._data);
					if ((0, o.equalPoints)(e, t) && !r.extendLeft && !r.extendRight) return null;
					const n = i.physicalWidth,
						a = Math.min(e.x, t.x),
						l = Math.max(e.x, t.x),
						c = r.extendLeft ? 0 : Math.max(a, 0),
						h = r.extendRight ? n : Math.min(l, n);
					return c > h || h <= 0 || c >= n ? null : [new o.Point(c, e.y), new o.Point(h, t.y)]
				}
				_hitTestBackground(e, t, i, s) {
					const n = this._extendAndClipLineSegment(t, i, s);
					return null !== n && (0, r.pointInBox)(e, (0, o.box)(n[0], n[1])) ? this._backHitTestResult : null
				}
			}
		},
		3452: (e, t, i) => {
			"use strict";
			i.d(t, {
				PrePostMarket: () => S,
				defaultPrePostMarketPreferences: () => g
			});
			var s = i(679520),
				o = i(345185),
				r = i(613648),
				n = i(506656),
				a = i(267850);
			class l extends a.PriceLineAxisView {
				constructor(e, t) {
					super(), this._model = e, this._source = t
				}
				_value() {
					const e = this._model.mainSeries(),
						t = e.priceScale(),
						i = e.firstValue();
					if (null === i) return {
						noData: !0
					};
					const s = this._source.price(),
						o = this._source.currentSession();
					if (null === s || "pre_market" !== o && "post_market" !== o) return {
						noData: !0
					};
					const r = t.priceToCoordinate(s, i);
					return {
						noData: !1,
						floatCoordinate: r,
						coordinate: r,
						color: "",
						formattedPricePercentage: "",
						formattedPriceAbsolute: "",
						formattedPriceIndexedTo100: "",
						text: "",
						index: 0
					}
				}
				_priceLineColor(e) {
					const t = this._source.properties().childs();
					return "pre_market" === this._source.currentSession() ? t.preMarketColor.value() : t.postMarketColor.value()
				}
				_lineWidth() {
					return this._source.properties().childs().lineWidth.value()
				}
				_lineStyle() {
					return this._source.properties().childs().lineStyle.value()
				}
				_isVisible() {
					if (!this._source.canBeVisibleOnSymbolAndInterval() || !this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value()) return !1;
					const e = this._source.price(),
						t = this._source.currentSession();
					return null !== e && ("pre_market" === t || "post_market" === t)
				}
			}
			var c = i(575932),
				h = i(498424);
			class d extends h.PriceAxisView {
				constructor(e, t) {
					super(), this._model = e, this._source = t
				}
				_updateRendererData(e, t, i) {
					if (e.visible = !1, t.visible = !1,
						!this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value()) return;
					const s = this._model.mainSeries(),
						o = s.priceScale(),
						r = s.firstValue();
					if (null === r) return;
					if (!this._source.canBeVisibleOnSymbolAndInterval()) return;
					const n = this._source.price(),
						a = this._source.currentSession();
					if (null == n || "pre_market" !== a && "post_market" !== a) return;
					e.visible = !0, t.visible = !0, e.text = o.formatPriceAbsolute(n), t.text = "pre_market" === a ? (0, c.t)("Pre") : (0, c.t)("Post"), i.coordinate = o.priceToCoordinate(n, r);
					const l = this._source.properties().childs();
					i.background = "pre_market" === a ? l.preMarketColor.value() : l.postMarketColor.value()
				}
			}
			var u = i(350985),
				_ = i(218718);
			class m extends u.HorizontalLinePaneView {
				constructor(e, t, i) {
					super(), this._model = e, this._source = t;
					const s = {
						doubleClickHandler: i,
						doubleTapHandler: i
					};
					this._lineRenderer.setHitTest(new _.HitTestResult(_.HitTestResult.REGULAR, s))
				}
				_updateImpl() {
					const e = this._lineRendererData;
					e.visible = !1;
					const t = this._model.mainSeries(),
						i = this._source.properties().childs();
					if (!i.visible.value() || !t.isVisible()) return;
					const s = t.priceScale(),
						o = t.firstValue();
					if (null === o) return;
					if (!this._source.canBeVisibleOnSymbolAndInterval()) return;
					const r = this._source.price(),
						n = this._source.currentSession();
					null === r || "pre_market" !== n && "post_market" !== n || (e.visible = !0, e.y = s.priceToCoordinate(r, o), e.linestyle = i.lineStyle.value(), e.linewidth = i.lineWidth.value(), e.color = "pre_market" === n ? i.preMarketColor.value() : i.postMarketColor.value())
				}
			}
			var p = i(194459);
			const g = {
				visible: !0,
				lineStyle: o.LINESTYLE_DOTTED,
				lineWidth: 1,
				preMarketColor: "#fb8c00",
				postMarketColor: s.colorsPalette["color-tv-blue-500"]
			};
			class S extends n.CustomSourceBase {
				constructor(e, t, i) {
					super(e, t), this._extraHoursPrice = null, this._currentSession = "holiday", this._quotesProvider = t.mainSeries().quotesProvider(), this._prePostMarketLinePaneView = new m(t, this, i), this._prePostPriceAxisView = new d(t, this), this._prePostLabelPaneView = new r.PanePriceAxisView(this._prePostPriceAxisView, t.mainSeries(), t), this._prePostPriceLineAxisView = new l(t, this), this._quotesProvider.quotesUpdate().subscribe(this, this._updateQuotes), this._updateQuotes()
				}
				destroy() {
					this._quotesProvider.quotesUpdate().unsubscribeAll(this)
				}
				paneViews(e) {
					return this._isMainSourcePane(e) ? [this._prePostMarketLinePaneView] : []
				}
				labelPaneViews(e) {
					return this._isMainSourcePane(e) ? [this._prePostLabelPaneView] : []
				}
				priceAxisViews(e, t) {
					return this._isMainSourcePane(e) ? e.findTargetPriceAxisViews(this, t, [this._prePostPriceAxisView], [this._prePostPriceLineAxisView]) : []
				}
				priceScale() {
					return this._model.mainSeries().priceScale()
				}
				updateAllViews(e) {
					this._prePostMarketLinePaneView.update(e), this._prePostPriceAxisView.update(e), this._prePostPriceLineAxisView.update(e), this._prePostLabelPaneView.update(e)
				}
				price() {
					return this._extraHoursPrice
				}
				currentSession() {
					return this._currentSession
				}
				canBeVisibleOnSymbolAndInterval() {
					return this._model.mainSeries().isPrePostMarketPricesAvailableProperty().value()
				}
				properties() {
					return this._model.mainSeries().properties().childs().prePostMarket
				}
				_updateQuotes() {
					const e = this._quotesProvider.quotes();
					null === e ? this._extraHoursPrice = null : (this._extraHoursPrice = e.rtc, void 0 !== e.current_session && (this._currentSession = e.current_session));
					const t = this._model.mainSeries().properties().childs().prePostMarket.childs().visible.value(),
						i = this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value();
					this.canBeVisibleOnSymbolAndInterval() && (t || i) && (this.updateAllViews((0, p.dataSourceChangeEvent)(this.id())), this._model.updateSource(this))
				}
				_isMainSourcePane(e) {
					return this._model.paneForSource(this._model.mainSeries()) === e
				}
			}
		},
		480910: (e, t, i) => {
			"use strict";
			i.d(t, {
				PriceScaleBase: () => k
			});
			var s = i(588537),
				o = i(270617),
				r = i(97639),
				n = i.n(r),
				a = i(377884),
				l = i(559270),
				c = i(943615),
				h = i(404703),
				d = i(902899),
				u = i(983019),
				_ = i(232567),
				m = i.n(_),
				p = i(140662),
				g = i(992179),
				S = i(749473),
				v = i(705318),
				f = i(534953),
				b = i(466915);
			class y {
				constructor(e, t) {
					if (this._base = e, this._integralDividers = t, (0, b.isBaseDecimal)(this._base)) this._fractionalDividers = [2, 2.5, 2];
					else {
						this._fractionalDividers = [];
						for (let e = this._base; 1 !== e;) {
							if (e % 2 == 0) this._fractionalDividers.push(2), e /= 2;
							else {
								if (e % 5 != 0) throw new Error("unexpected base");
								this._fractionalDividers.push(2), this._fractionalDividers.push(2.5), e /= 5
							}
							if (this._fractionalDividers.length > 100) throw new Error("something wrong with base")
						}
					}
				}
				tickSpan(e, t, i) {
					const s = 0 === this._base ? 0 : 1 / this._base,
						o = 1e-14;
					let r = Math.pow(10, Math.max(0, Math.ceil((0, b.log10)(e - t)))),
						n = 0,
						a = this._integralDividers[0];
					for (;;) {
						const e = (0, b.greaterOrEqual)(r, s, o) && r > s + o,
							t = (0, b.greaterOrEqual)(r, i * a, o),
							l = (0, b.greaterOrEqual)(r, 1, o);
						if (!(e && t && l)) break;
						r /= a, a = this._integralDividers[++n % this._integralDividers.length]
					}
					if (r <= s + o && (r = s), r = Math.max(1, r), this._fractionalDividers.length > 0 && (0, b.equal)(r, 1, o))
						for (n = 0, a = this._fractionalDividers[0];
							(0, b.greaterOrEqual)(r, i * a, o) && r > s + o;) r /= a, a = this._fractionalDividers[++n % this._fractionalDividers.length];
					return r
				}
			}
			class C {
				constructor(e, t, i, s) {
					this._marks = null, this._priceScale = e, this._base = t, this._coordinateToLogicalFunc = i, this._logicalToCoordinateFunc = s
				}
				base() {
					return this._base
				}
				setBase(e) {
					if (e < 0) throw new Error("base < 0");
					this._base = e
				}
				tickSpan(e, t, i = 0) {
					if (e < t) throw new Error("high < low");
					const s = this._priceScale.height(),
						o = (e - t) * this._tickMarkHeight() / s,
						r = new y(this._base, [2, 2.5, 2]),
						n = new y(this._base, [2, 2, 2.5]),
						a = new y(this._base, [2.5, 2, 2]);
					let l = 0;
					const c = r.tickSpan(e, t, o);
					c > i && (l = c);
					const h = n.tickSpan(e, t, o);
					h > i && (l = Math.min(l, h));
					const d = a.tickSpan(e, t, o);
					return d > i && (l = Math.min(l, d)), l > 0 ? l : e - t
				}
				rebuildTickMarks() {
					this._marks = null
				}
				marks() {
					return null === this._marks && (this._marks = this._rebuildTickMarksImpl()), this._marks
				}
				_fontHeight() {
					return this._priceScale.fontSize()
				}
				_tickMarkHeight() {
					return Math.ceil(2.5 * this._fontHeight())
				}
				_rebuildTickMarksImpl() {
					const e = this._priceScale,
						t = [],
						i = e.mainSource();
					if (e.isEmpty() || null === i) return t;
					let s = i.firstValue();
					null === s && (s = 0);
					const o = e.height(),
						r = this._coordinateToLogicalFunc(o - 1, s),
						n = this._coordinateToLogicalFunc(0, s),
						a = Math.max(r, n),
						l = Math.min(r, n);
					if (a === l) return t;
					let c = this.tickSpan(a, l),
						h = a % c;
					h += h < 0 ? c : 0;
					const d = a >= l ? 1 : -1;
					let u = null;
					const _ = e.formatter();
					let m = NaN;
					for (let i = a - h; i > l; i -= c) {
						i === m && (c = this.tickSpan(a, l, c)), m = i;
						const o = this._logicalToCoordinateFunc(i, s);
						null !== u && Math.abs(o - u) < this._tickMarkHeight() || (t.push({
							coord: o,
							label: _.format(i)
						}), u = o, e.isLog() && (c = this.tickSpan(i * d, l)))
					}
					return t
				}
			}
			var w = i(540968),
				T = i(308170),
				P = i(965513),
				M = i(689765);
			const x = new P.PercentageFormatter,
				I = new M.PriceFormatter(100, 1),
				A = {
					autoScale: !0,
					autoScaleDisabled: !1,
					lockScale: !1,
					percentage: !1,
					percentageDisabled: !1,
					log: !1,
					logDisabled: !1,
					alignLabels: !0,
					isInverted: !1,
					indexedTo100: !1
				};
			class k {
				constructor(e) {
					this._marksCache = null, this._onMarksChanged = new(n()), this.m_dataSources = [], this._sourcesForAutoscale = null, this._hasSeries = !1, this._studiesCount = 0, this._drawingCount = 0, this._seriesLikeSources = [], this._seriesLikeSourcesSet = new Set, this._priceDataSources = [], this._mainSource = null, this._lastSourceRemoved = new(n()), this._scaleSeriesOnly = !1, this._invalidatedForRange = {
						isValid: !0,
						visibleBars: null
					}, this.m_priceRange = null, this._logFormula = (0, c.logFormulaForPriceRange)(null), this.m_height = 0, this._margins = {
						top: 0,
						bottom: 0
					}, this._correctedMarginsCache = null, this._topPixelMargin = 0, this._bottomPixelMargin = 0, this._internalHeightCache = null, this._internalHeightChanged = new(n()), this._priceRangeSnapshot = null, this._scrollStartPoint = null, this._currencyCache = null, this._unitCache = null, this._measureUnitIdCache = null, this._recalculatePriceRangeOnce = !1, this._cachedOrderedSoruces = null, this._scaleStartPoint = null, this._twoPointsScaleStartPosition = null, this._maxPriceRange = null, this._minPriceRange = null, this._priceRangeChanged = new(n()), this._sourcesToUpdateViews = null, this._markBuilder = new C(this, 100, this._coordinateToLogical.bind(this), this._logicalToCoordinate.bind(this)), this._formatter = null, this._id = "", e = Object.assign({}, A, e), this._properties = new(m())(e)
				}
				id() {
					return this._id
				}
				setId(e) {
					this._id = e
				}
				isLog() {
					return this._properties.childs().log.value()
				}
				isPercentage() {
					return this._properties.childs().percentage.value()
				}
				isInverted() {
					return this._properties.childs().isInverted.value()
				}
				isIndexedTo100() {
					return this._properties.childs().indexedTo100.value()
				}
				isAutoScale() {
					return this._properties.childs().autoScale.value() && !this.isLockScale()
				}
				isLockScale() {
					return this._properties.childs().lockScale.value()
				}
				isRegular() {
					return !this.isPercentage() && !this.isLog() && !this.isIndexedTo100()
				}
				properties() {
					return this._properties
				}
				height() {
					return this.m_height
				}
				setHeight(e) {
					this.m_height !== e && (this.m_height = e, this._invalidateInternalHeightCache(), this._marksCache = null)
				}
				internalHeight() {
					if (this._internalHeightCache) return this._internalHeightCache;
					const e = this.height() - this.topPixelMargin() - this.bottomPixelMargin();
					return this._internalHeightCache = e, e
				}
				priceRange() {
					return this._makeSureItIsValid(), this.m_priceRange
				}
				setPriceRange(e, t, i) {
					if (!(e instanceof l.PriceRange)) throw new TypeError("incorrect price range");
					const s = this.m_priceRange;
					if (!t && l.PriceRange.compare(s, e)) return;
					const o = null !== this._maxPriceRange && this._maxPriceRange.containsStrictly(e),
						r = null !== this._minPriceRange && e.containsStrictly(this._minPriceRange);
					this.isLockScale() && !t && (o || r) || (this._marksCache = null, this.m_priceRange = e, i || this._priceRangeChanged.fire(s, e))
				}
				setMinPriceRange(e) {
					this._minPriceRange = e
				}
				setMaxPriceRange(e) {
					this._maxPriceRange = e
				}
				recalculatePriceRangeOnce() {
					this._recalculatePriceRangeOnce = !0
				}
				priceRangeShouldBeRecalculatedOnce() {
					if (!this._recalculatePriceRangeOnce || this.isLockScale()) return !1;
					const e = this.mainSource();
					return null !== e && e.priceRangeReady()
				}
				priceRangeChanged() {
					return this._priceRangeChanged
				}
				canDetachSource(e) {
					return this.m_dataSources.some((t => t !== e && !(0, p.isESDOrRollDatesStudy)(t) && (0, d.isPriceDataSource)(t) && !((0, p.isStudy)(t) && t.isLinkedToSeries())))
				}
				updateAllViews(e) {
					const t = this._getSourcesToUpdateViews();
					for (const i of t) i.updateAllViews(e)
				}
				logFormula() {
					return this._logFormula
				}
				state() {
					var e;
					const t = this._properties.childs();
					return {
						id: this._id,
						m_priceRange: (null === (e = this.priceRange()) || void 0 === e ? void 0 : e.serialize()) || null,
						m_isAutoScale: this.isAutoScale(),
						m_isPercentage: t.percentage.value(),
						m_isIndexedTo100: t.indexedTo100.value(),
						m_isLog: t.log.value(),
						m_isLockScale: this.isLockScale(),
						m_isInverted: this.isInverted(),
						m_height: this.m_height,
						m_topMargin: this._margins.top,
						m_bottomMargin: this._margins.bottom,
						alignLabels: t.alignLabels.value(),
						logFormula: (0, o.clone)(this._logFormula)
					}
				}
				restoreState(e) {
					let t = e.m_priceRange;
					if (void 0 === t) throw new TypeError("invalid state");
					if (void 0 === e.m_isAutoScale) throw new TypeError("invalid state");
					void 0 !== e.id && (this._id = e.id);
					const i = {
						autoScale: e.m_isAutoScale
					};
					void 0 !== e.m_isPercentage && (i.percentage = e.m_isPercentage), void 0 !== e.m_isIndexedTo100 && (i.indexedTo100 = e.m_isIndexedTo100), void 0 !== e.m_isLog && (i.log = e.m_isLog), void 0 !== e.m_isLockScale && (i.lockScale = e.m_isLockScale), void 0 !== e.m_isInverted && this._properties.childs().isInverted.setValue(e.m_isInverted), void 0 !== e.m_height && this.setHeight(Math.max(0, e.m_height)), this.setMode(i), t ? (t instanceof l.PriceRange || (t = new l.PriceRange(t)), this.setPriceRange(t, !0)) : this.m_priceRange = null, e.logFormula && (this._logFormula = e.logFormula), void 0 !== e.m_topMargin && (this._margins.top = e.m_topMargin), void 0 !== e.m_bottomMargin && (this._margins.bottom = e.m_bottomMargin), void 0 !== e.alignLabels && this._properties.childs().alignLabels.setValue(e.alignLabels), this._mainSource = null, this._scaleSeriesOnly = !1
				}
				priceToLogical(e) {
					return this.isLog() && e ? (0, c.toLog)(e, this._logFormula) : e
				}
				logicalToPrice(e) {
					return this.isLog() ? (0, c.fromLog)(e, this._logFormula) : e
				}
				priceToCoordinate(e, t) {
					const i = this._priceToPercentOrIndexedTo100IfNeeded(e, t);
					return this._logicalToCoordinate(i)
				}
				coordinateToPrice(e, t) {
					let i = this._coordinateToLogical(e);
					return this.isPercentage() ? i = (0, c.fromPercent)(i, t) : this.isIndexedTo100() && (i = (0, c.fromIndexedTo100)(i, t)), i
				}
				mainSource() {
					if (null !== this._mainSource) return this._mainSource;
					let e;
					for (const t of this.m_dataSources) {
						if (t instanceof h.Series) {
							e = t;
							break
						}!e && (0, d.isPriceDataSource)(t) && (e = t)
					}
					return this._mainSource = e || null, this._correctedMarginsCache = null, this._mainSource
				}
				pricesArrayToCoordinates(e, t, i) {
					this._makeSureItIsValid();
					const o = this.bottomPixelMargin(),
						r = (0, s.ensureNotNull)(this.priceRange()),
						n = r.minValue(),
						a = r.maxValue(),
						l = this.internalHeight() - 1,
						h = this.isInverted(),
						d = l / (a - n);
					void 0 === i && (i = e.length);
					const u = this.isPercentage(),
						_ = this.isIndexedTo100(),
						m = this.isLog(),
						p = this.m_height;
					let g, S;
					for (let s = 0; s < i; s++) g = e[s], Number.isFinite(g) && (u ? g = (0, c.toPercent)(g, t) : _ ? g = (0, c.toIndexedTo100)(g, t) : m && (g = (0, c.toLog)(g, this._logFormula)), S = o + d * (g - n), e[s] = h ? S : p - 1 - S)
				}
				pointsArrayToCoordinates(e, t, i) {
					var o, r;
					this._makeSureItIsValid();
					const n = (0, s.ensureNotNull)(this.priceRange()),
						a = this.bottomPixelMargin(),
						l = n.minValue(),
						h = n.maxValue(),
						d = this.internalHeight() - 1,
						u = this.isInverted(),
						_ = d / (h - l),
						m = e,
						p = null !== (o = null == i ? void 0 : i.startItemIndex) && void 0 !== o ? o : 0,
						g = null !== (r = null == i ? void 0 : i.endItemIndex) && void 0 !== r ? r : m.length;
					if (this.isPercentage())
						for (let e = p; e < g; e++) m[e].y = (0, c.toPercent)(m[e].y, t);
					if (this.isIndexedTo100())
						for (let e = p; e < g; e++) m[e].y = (0, c.toIndexedTo100)(m[e].y, t);
					if (this.isLog())
						for (let e = p; e < g; e++) m[e].y = this.priceToLogical(m[e].y);
					for (let e = p; e < g; e++) {
						const t = m[e].y;
						if (isNaN(t) || null == t) continue;
						const i = a + _ * (t - l),
							s = u ? i : this.m_height - 1 - i;
						m[e].y = s
					}
				}
				barPricesToCoordinates(e, t) {
					this._makeSureItIsValid();
					const i = (0, s.ensureNotNull)(this.priceRange()),
						o = e,
						r = this.bottomPixelMargin(),
						n = i.minValue(),
						a = i.maxValue(),
						l = this.internalHeight() - 1;
					let h = null;
					if (this.isPercentage() ? h = c.toPercent : this.isIndexedTo100() ? h = c.toIndexedTo100 : this.isLog() && (h = (e, t) => e ? (0, c.toLog)(e, this._logFormula) : e), 0 === o.length) return;
					const d = "open" in o[0],
						u = "close" in o[0];
					if (null !== h)
						for (let e = 0; e < o.length; e++) {
							if (!o[e]) continue;
							const i = o[e];
							d && (i.open = h(i.open, t)), i.high = h(i.high, t), i.low = h(i.low, t), u && (i.close = h(i.close, t)), void 0 !== i.additionalPrice && (i.additionalPrice = h(i.additionalPrice, t))
						}
					const _ = l / (a - n),
						m = this.isInverted();
					for (let e = 0; e < o.length; e++) {
						const t = o[e];
						if (!t) continue;
						if (d) {
							const e = r + _ * (t.open - n),
								i = m ? e : this.m_height - 1 - e;
							t.open = i
						}
						const i = r + _ * (t.high - n),
							s = m ? i : this.m_height - 1 - i;
						t.high = s;
						const a = r + _ * (t.low - n),
							l = m ? a : this.m_height - 1 - a;
						if (t.low = l, u) {
							const e = r + _ * (t.close - n),
								i = m ? e : this.m_height - 1 - e;
							t.close = i
						}
						if (void 0 !== t.additionalPrice) {
							const e = r + _ * (t.additionalPrice - n);
							t.additionalPrice = m ? e : this.m_height - 1 - e
						}
					}
				}
				formatter() {
					return null === this._formatter && this.updateFormatter(), (0, s.ensureNotNull)(this._formatter)
				}
				updateFormatter() {
					this._marksCache = null;
					const e = this.mainSource();
					let t = 100;
					e && (t = e.base()), this._formatter = null, this.isPercentage() ? (this._formatter = x, t = 100) : this.isIndexedTo100() ? (this._formatter = new M.PriceFormatter(100, 1), t = 100) : this._formatter = e ? e.formatter() : I, this._markBuilder = new C(this, t, this._coordinateToLogical.bind(this), this._logicalToCoordinate.bind(this)), this._markBuilder.rebuildTickMarks()
				}
				formatPrice(e, t, i) {
					return this.isPercentage() ? this.formatPricePercentage(e, t, i) : this.isIndexedTo100() ? this.formatPriceIndexedTo100(e, t) : this.formatter().format(e)
				}
				formatPriceAbsolute(e) {
					return this._mainSourceFormatter().format(e)
				}
				formatPricePercentage(e, t, i) {
					return e = (0, c.toPercent)(e, t), x.format(e, i)
				}
				formatPriceIndexedTo100(e, t) {
					const i = (0, c.toIndexedTo100)(e, t);
					return this.formatter().format(i)
				}
				getFormattedValues(e, t, i) {
					const s = this.formatPriceAbsolute(e),
						o = this.formatPricePercentage(e, t, i),
						r = this.formatPriceIndexedTo100(e, t);
					return {
						formattedPriceAbsolute: s,
						formattedPricePercentage: o,
						formattedPriceIndexedTo100: r,
						text: (0, c.getCurrentModePriceText)(this, {
							formattedPriceAbsolute: s,
							formattedPricePercentage: o,
							formattedPriceIndexedTo100: r
						})
					}
				}
				dataSources() {
					return this.m_dataSources
				}
				seriesLikeSources() {
					return this._seriesLikeSources
				}
				addDataSource(e, t) {
					if (t || -1 === this.m_dataSources.indexOf(e)) {
						if ((0, d.isPriceDataSource)(e) && (this._priceDataSources.push(e), e.currencyChanged().subscribe(this, (() => this._currencyCache = null)), e.unitChanged().subscribe(this, (() => this._unitCache = null)), (0, g.isSymbolSource)(e) && (this._seriesLikeSources.push(e), this._seriesLikeSourcesSet.add(e), e.symbolResolved().subscribe(this, (() => {
								this._currencyCache = null, this._unitCache = null, this._measureUnitIdCache = null
							})), e instanceof h.Series))) {
							const t = e.properties();
							this._hasSeries || (t.childs().lockScale && (this.setMode({
								lockScale: t.childs().lockScale.value()
							}), t.removeProperty("lockScale")), t.childs().pnfStyle.child("lockScale") && t.childs().pnfStyle.removeProperty("lockScale")), this._hasSeries = !0
						}
						e.properties().visible.listeners().subscribe(this, this._dropScaleCache), (0, p.isStudy)(e) && (e.onIsActualIntervalChange().subscribe(this, this._dropScaleCache), e.onHibernationStateChange().subscribe(this, this._dropScaleCache), 0 === this._studiesCount && (0, T.hideAllIndicators)().subscribe(this, this._dropScaleCache), this._studiesCount++), (0, w.isLineTool)(e) && (0 === this._drawingCount && (0, T.hideAllDrawings)().subscribe(this, this._dropScaleCache), this._drawingCount++), this.m_dataSources.push(e), this._mainSource = null, this._correctedMarginsCache = null, this._sourcesToUpdateViews = null, this._dropScaleCache(), this.updateFormatter(), this._initScaleProperties(), this.invalidateSourcesCache()
					}
				}
				removeDataSource(e) {
					const t = this.m_dataSources.indexOf(e);
					if ((0, s.assert)(-1 !== t, "Source is not attached to scale"), e.properties().visible.listeners().unsubscribe(this, this._dropScaleCache), this.m_dataSources.splice(t, 1), (0, d.isPriceDataSource)(e)) {
						const t = this._priceDataSources.indexOf(e);
						if ((0, s.assert)(-1 !== t, "Source is not found"), this._priceDataSources.splice(t, 1), (0, g.isSymbolSource)(e)) {
							const t = this._seriesLikeSources.indexOf(e);
							(0, s.assert)(-1 !== t, "Source is not found"), this._seriesLikeSources.splice(t, 1), this._seriesLikeSourcesSet.delete(e), e.symbolResolved().unsubscribeAll(this), e instanceof h.Series && (this._hasSeries = !1)
						}
						e.currencyChanged().unsubscribeAll(this), e.unitChanged().unsubscribeAll(this)
					}
					this.mainSource() || this.setMode({
						autoScale: !0
					}), (0, p.isStudy)(e) && (e.onIsActualIntervalChange().unsubscribe(this, this._dropScaleCache), e.onHibernationStateChange().unsubscribe(this, this._dropScaleCache), this._studiesCount--, 0 === this._studiesCount && (0,
						T.hideAllIndicators)().unsubscribe(this, this._dropScaleCache)), (0, w.isLineTool)(e) && (this._drawingCount--, 0 === this._drawingCount && (0, T.hideAllDrawings)().unsubscribe(this, this._dropScaleCache)), this._mainSource = null, this._correctedMarginsCache = null, this._sourcesForAutoscale = null, this._sourcesToUpdateViews = null, this.updateFormatter(), this.invalidateSourcesCache(), 0 === this.m_dataSources.length && this._lastSourceRemoved.fire(), this._currencyCache = null, this._unitCache = null, this._measureUnitIdCache = null
				}
				currency(e) {
					if (null !== this._currencyCache && e.size() === this._currencyCache.availableCurrenciesCount) return this._currencyCache.value;
					let t;
					const i = new Set,
						o = new Set,
						r = new Set,
						n = new Map;
					let a, l = 0 === this._seriesLikeSources.length,
						c = !0,
						h = 0,
						d = 0;
					for (const d of this._seriesLikeSources) {
						if (!d.isVisible()) continue;
						const u = d.symbolInfo();
						if (null === u) {
							t = null;
							break
						}
						const _ = (0, S.symbolOriginalCurrency)(u);
						if (null === _) {
							t = null;
							break
						}
						n.set(_, (0, s.ensureNotNull)((0, S.symbolOriginalCurrency)(u, !0)));
						const m = d.currency();
						if (null === m) {
							t = null;
							break
						}
						n.set(m, (0, s.ensureNotNull)((0, S.symbolCurrency)(u, !0)));
						const p = (0, S.symbolBaseCurrency)(u);
						null !== p && o.add(p), c = c && _ === m, r.add(m), i.add(_), void 0 === a ? a = m : null !== a && a !== m && (a = null), l || e.convertible(m) && (0, S.symbolCurrencyConvertible)(u) || (l = !0), h += 1
					}
					if (null !== t)
						for (const i of this._priceDataSources) {
							if (this._seriesLikeSourcesSet.has(i)) continue;
							const o = i;
							if (!o.isCurrencySource() || !o.isVisible()) continue;
							const c = o.currency();
							if (null === c) {
								t = null;
								break
							}
							r.add(c), d += 1;
							const h = (0, s.ensureNotNull)(o.symbolSource()),
								u = o.currencySourceSymbolInfo();
							if (null === u) {
								t = null;
								break
							}
							if (l || e.convertible(c) && (0, S.symbolCurrencyConvertible)(u) || (l = !0), n.set(c, (0, s.ensureNotNull)((0, S.symbolCurrency)(u, !0))), this._seriesLikeSourcesSet.has(h) || (l = !0), void 0 === a) a = c;
							else if (null !== a && a !== c) {
								a = null;
								break
							}
						}
					return void 0 === t && (t = 0 === h && 0 === d ? null : {
						readOnly: l,
						selectedCurrency: a || null,
						currencies: r,
						originalCurrencies: i,
						baseCurrencies: o,
						symbolSourceCount: h,
						allCurrenciesAreOriginal: c,
						displayedValues: n
					}), this._currencyCache = {
						value: t,
						availableCurrenciesCount: e.size()
					}, t
				}
				unit(e) {
					if (null !== this._unitCache && e.size() === this._unitCache.availableUnitsCount) return this._unitCache.value;
					let t;
					const i = new Set,
						o = new Set,
						r = new Map,
						n = new Map;
					let l, c = 0 === this._seriesLikeSources.length ? new Set : e.allGroups(),
						h = !0,
						d = 0,
						u = 0;
					for (const s of this._seriesLikeSources) {
						if (!s.isVisible()) continue;
						const u = s.symbolInfo();
						if (null === u) {
							t = null;
							break
						}
						const _ = (0, S.symbolOriginalUnit)(u, s.model().unitConversionEnabled());
						if (null === _) {
							t = null;
							break
						}
						r.set(_, e.name(_)), n.set(_, e.description(_));
						const m = s.unit();
						if (null === m) {
							t = null;
							break
						}
						if (r.set(m, e.name(m)), n.set(m, e.description(m)), h = h && _ === m, o.add(m), i.add(_), void 0 === l ? l = m : null !== l && l !== m && (l = null), c.size > 0) {
							const t = (0, v.unitConvertibleGroups)(u, m, e);
							c = (0, a.intersect)(c, new Set(t))
						}
						d += 1
					}
					if (null !== t)
						for (const i of this._priceDataSources) {
							if (this._seriesLikeSourcesSet.has(i)) continue;
							const h = i;
							if (!h.isUnitSource() || !h.isVisible()) continue;
							const d = h.unit();
							if (null === d) {
								t = null;
								break
							}
							o.add(d), u += 1;
							const _ = (0,
									s.ensureNotNull)(h.symbolSource()),
								m = _.symbolInfo();
							if (null === m) {
								t = null;
								break
							}
							if (c.size > 0) {
								const t = (0, v.unitConvertibleGroups)(m, d, e);
								c = (0, a.intersect)(c, new Set(t))
							}
							if (r.set(d, e.name(d)), n.set(d, e.description(d)), this._seriesLikeSourcesSet.has(_) || (c = new Set), void 0 === l) l = d;
							else if (null !== l && l !== d) {
								l = null;
								break
							}
						}
					if (void 0 === t)
						if (0 === d && 0 === u) t = null;
						else {
							t = {
								availableGroups: c,
								selectedUnit: l || null,
								units: o,
								originalUnits: i,
								symbolSourceCount: d,
								allUnitsAreOriginal: h,
								names: r,
								descriptions: n
							}
						} return this._unitCache = {
						value: t,
						availableUnitsCount: e.size()
					}, t
				}
				measureUnitId(e) {
					if (null !== this._measureUnitIdCache && e.size() === this._measureUnitIdCache.availableUnitsCount) return this._measureUnitIdCache.value;
					let t, i;
					const s = new Map,
						o = new Map,
						r = new Set;
					let n = 0;
					for (const a of this._seriesLikeSources) {
						if (!a.isVisible()) continue;
						const l = a.measureUnitId();
						if (null === l) {
							t = null;
							break
						}
						r.add(l), s.set(l, e.name(l)), o.set(l, e.description(l)), void 0 === i ? i = l : null !== i && i !== l && (i = null), n += 1
					}
					return void 0 === t && (t = 0 === n ? null : {
						selectedMeasureUnitId: i || null,
						measureUnitIds: r,
						names: s,
						descriptions: o,
						symbolSourceCount: n
					}), this._measureUnitIdCache = {
						value: t,
						availableUnitsCount: e.size()
					}, t
				}
				setMargins(e) {
					if (!(0, o.isNumber)(e.top) || !(0, o.isNumber)(e.bottom)) throw new TypeError("invalid margin");
					if (e.top < 0 || e.top > 30 || e.bottom < 0 || e.bottom > 30) throw new RangeError("invalid margin");
					this._margins.top === e.top && this._margins.bottom === e.bottom || (this._margins = e, this._correctedMarginsCache = null, this._invalidateInternalHeightCache(), this._marksCache = null)
				}
				topMargin() {
					return this._correctedMargins().top
				}
				bottomMargin() {
					return this._correctedMargins().bottom
				}
				invalidateMargins() {
					this._correctedMarginsCache = null
				}
				topPixelMargin() {
					return this.isInverted() ? this.bottomMargin() * this.height() + this._bottomPixelMargin : this.topMargin() * this.height() + this._topPixelMargin
				}
				bottomPixelMargin() {
					return this.isInverted() ? this.topMargin() * this.height() + this._topPixelMargin : this.bottomMargin() * this.height() + this._bottomPixelMargin
				}
				marks() {
					return this._makeSureItIsValid(), null === this._marksCache && (this._markBuilder.rebuildTickMarks(), this._marksCache = this._markBuilder.marks(), this._onMarksChanged.fire()), this._marksCache
				}
				onMarksChanged() {
					return this._onMarksChanged
				}
				priceRangeInPrice() {
					if (this.isEmpty()) return null;
					const e = this.mainSource();
					if (null === e) return null;
					const t = (0, s.ensureNotNull)(e.firstValue()),
						i = this.height();
					return {
						from: this.coordinateToPrice(i - 1, t),
						to: this.coordinateToPrice(0, t)
					}
				}
				setPriceRangeInPrice(e) {
					if (this.isPercentage() || this.isIndexedTo100()) return;
					const t = this.isInverted(),
						i = t ? this.bottomMargin() : this.topMargin(),
						s = t ? this.topMargin() : this.bottomMargin(),
						o = this.isLog();
					let r = o ? (0, c.toLog)(e.from, this._logFormula) : e.from,
						n = o ? (0, c.toLog)(e.to, this._logFormula) : e.to;
					const a = n - r;
					r += s * a, n -= i * a, this.setMode({
						autoScale: !1
					}), this.setPriceRange(new l.PriceRange(r, n)), this._marksCache = null, this._onMarksChanged.fire()
				}
				hasMainSeries() {
					return this._hasSeries
				}
				getStudies() {
					return this.dataSources().filter(p.isStudy)
				}
				lastSourceRemoved() {
					return this._lastSourceRemoved
				}
				sourcesForAutoscale() {
					return this._mainSource && this._scaleSeriesOnly !== this._scalesProperties.childs().scaleSeriesOnly.value() && (this._sourcesForAutoscale = null), this._sourcesForAutoscale || (this._sourcesForAutoscale = this._recalculateSourcesForAutoscale()), this._sourcesForAutoscale
				}
				recalculatePriceRange(e) {
					this._invalidatedForRange = {
						visibleBars: e,
						isValid: !1
					}
				}
				internalHeightChanged() {
					return this._internalHeightChanged
				}
				orderedSources() {
					if (this._cachedOrderedSoruces) return this._cachedOrderedSoruces;
					let e = this.m_dataSources.slice();
					return e = e.filter((e => !((0, p.isESDOrRollDatesStudy)(e) || e instanceof u.ChartEventsSource))), e = (0, f.sortSources)(e), this._cachedOrderedSoruces = e, this._cachedOrderedSoruces
				}
				invalidateSourcesCache() {
					this._cachedOrderedSoruces = null, this._sourcesToUpdateViews = null
				}
				startScale(e) {
					var t, i;
					this.isEmpty() || this.isPercentage() || this.isIndexedTo100() || null !== this._scaleStartPoint || null !== this._priceRangeSnapshot || (this._scaleStartPoint = this.m_height - e, this._priceRangeSnapshot = null !== (i = null === (t = this.priceRange()) || void 0 === t ? void 0 : t.clone()) && void 0 !== i ? i : null)
				}
				scaleTo(e) {
					if (this.isPercentage() || this.isIndexedTo100() || null === this._scaleStartPoint) return;
					this.setMode({
						autoScale: !1
					}), (e = this.m_height - e) < 0 && (e = 0);
					let t = (this._scaleStartPoint + .2 * (this.m_height - 1)) / (e + .2 * (this.m_height - 1));
					const i = (0, s.ensureNotNull)(this._priceRangeSnapshot).clone();
					t = Math.max(t, .1), i.scaleAroundCenter(t), this.setPriceRange(i)
				}
				endScale() {
					this.isPercentage() || this.isIndexedTo100() || null !== this._scaleStartPoint && (this._scaleStartPoint = null, this._priceRangeSnapshot = null)
				}
				startTwoPointsScale(e, t) {
					if (this.isEmpty() || this.isPercentage() || this.isIndexedTo100() || null !== this._twoPointsScaleStartPosition) return;
					const i = Math.min(e, t),
						s = Math.max(e, t);
					this._twoPointsScaleStartPosition = {
						topLogical: this._coordinateToLogical(i),
						bottomLogical: this._coordinateToLogical(s)
					}
				}
				twoPointsScale(e, t) {
					if (this.isPercentage() || this.isIndexedTo100() || null === this._twoPointsScaleStartPosition) return;
					this.setMode({
						autoScale: !1
					});
					const i = Math.min(e, t),
						s = Math.max(e, t),
						{
							topLogical: o,
							bottomLogical: r
						} = this._twoPointsScaleStartPosition,
						n = this.bottomPixelMargin(),
						a = this.internalHeight() - 1,
						c = (this._invertedCoordinate(i) - n) / a,
						h = (r - o) / ((this._invertedCoordinate(s) - n) / a - c),
						d = o - h * c,
						u = d + h;
					this.setPriceRange(new l.PriceRange(this.priceToLogical(d), this.priceToLogical(u)))
				}
				endTwoPointsScale() {
					this._twoPointsScaleStartPosition = null
				}
				startScroll(e) {
					var t, i;
					this.isAutoScale() || null === this._scrollStartPoint && null === this._priceRangeSnapshot && (this.isEmpty() || (this._scrollStartPoint = e, this._priceRangeSnapshot = null !== (i = null === (t = this.priceRange()) || void 0 === t ? void 0 : t.clone()) && void 0 !== i ? i : null))
				}
				scrollTo(e) {
					if (this.isAutoScale()) return;
					if (null === this._scrollStartPoint || null === this._priceRangeSnapshot) return;
					const t = this.priceRange();
					if (null === t) return;
					let i = e - this._scrollStartPoint;
					this.isInverted() && (i *= -1);
					const s = i * (t.length() / (this.internalHeight() - 1)),
						o = this._priceRangeSnapshot.clone();
					o.shift(s), this.setPriceRange(o, !0), this._marksCache = null
				}
				endScroll() {
					this.isAutoScale() || null !== this._scrollStartPoint && (this._scrollStartPoint = null, this._priceRangeSnapshot = null)
				}
				_recalculateSourcesForAutoscale() {
					this._mainSource && (this._scaleSeriesOnly = this._scalesProperties.childs().scaleSeriesOnly.value());
					const e = this._scaleSeriesOnly && this._hasSeries;
					return this.m_dataSources.filter((t => !!(t.properties().visible.value() || t instanceof h.Series) && (e ? t instanceof h.Series : (0, p.isStudy)(t) ? !t.isSourceHidden() && t.isIncludedInAutoScale() : t.isIncludedInAutoScale())))
				}
				_updateAutoScaleDisabledProperty(e) {
					const t = this._properties.childs(),
						i = t.indexedTo100.value() || t.percentage.value() || t.lockScale.value();
					e ? t.autoScaleDisabled.setValueSilently(i) : t.autoScaleDisabled.setValue(i)
				}
				_setAutoScaleValueWithDependentProperties(e) {
					const t = this._properties.childs();
					t.autoScale.setValueSilently(e), e && (t.percentage.setValueSilently(!1), t.indexedTo100.setValueSilently(!1), t.lockScale.setValueSilently(!1), t.logDisabled.setValueSilently(!1)), this._updateAutoScaleDisabledProperty(!0)
				}
				_setLockScaleValueWithDependentProperties(e) {
					const t = this._properties.childs();
					t.lockScale.setValueSilently(e), e && (t.autoScale.setValueSilently(!1), t.percentage.setValueSilently(!1), t.indexedTo100.setValueSilently(!1), t.log.setValueSilently(!1)), t.percentageDisabled.setValueSilently(e), t.logDisabled.setValueSilently(e), this._updateAutoScaleDisabledProperty(!0)
				}
				_setPercentageValueWithDependentProperties(e) {
					const t = this._properties.childs();
					t.percentage.setValueSilently(e), e && (t.autoScale.setValueSilently(!0), t.log.setValueSilently(!1), t.lockScale.setValueSilently(!1), t.indexedTo100.setValueSilently(!1)), this._updateAutoScaleDisabledProperty(!0)
				}
				_setIndexedTo100ValueWithDependentProperties(e) {
					const t = this._properties.childs();
					t.indexedTo100.setValueSilently(e), e && (t.autoScale.setValueSilently(!0), t.log.setValueSilently(!1), t.lockScale.setValueSilently(!1), t.percentage.setValueSilently(!1)), this._updateAutoScaleDisabledProperty(!0)
				}
				_setLogValueWithDependentProperties(e) {
					const t = this._properties.childs();
					t.log.setValueSilently(e), e && (t.lockScale.setValueSilently(!1), t.percentage.setValueSilently(!1), t.indexedTo100.setValueSilently(!1)), this._updateAutoScaleDisabledProperty(!0)
				}
				_recalculatePriceRangeImpl() {
					const e = this._invalidatedForRange.visibleBars;
					if (null === e) return;
					let t = null;
					const i = this.sourcesForAutoscale(),
						s = this.isPercentage(),
						o = this.isIndexedTo100();
					let r = 0,
						n = 0;
					for (const a of i) {
						if (!a.properties().visible.value()) continue;
						const i = a.firstValue();
						if (null === i) continue;
						const l = e.firstBar(),
							h = e.lastBar(),
							d = a.autoScaleInfo(l, h);
						let u = d.range;
						u && (s ? u = (0, c.toPercentRange)(u, i) : o && (u = (0, c.toIndexedTo100Range)(u, i)), t = null === t ? u : t.merge(u)), void 0 !== d.topPixelMargin && (r = Math.max(r, d.topPixelMargin)), void 0 !== d.bottomPixelMargin && (n = Math.max(n, d.bottomPixelMargin))
					}
					if ((Math.abs(r - this._topPixelMargin) > 0 || Math.abs(n - this._bottomPixelMargin) > 0) && (this._bottomPixelMargin = n, this._topPixelMargin = r, this._marksCache = null, this._invalidateInternalHeightCache()), t) {
						if (t.minValue() === t.maxValue() && (t = new l.PriceRange(t.minValue() - .5, t.maxValue() + .5)), this.isLog()) {
							const e = this._convertPriceRangeFromLog(t),
								i = (0, c.logFormulaForPriceRange)(e);
							if (!(0, c.logFormulasAreSame)(i, this._logFormula)) {
								const s = this._priceRangeSnapshot ? this._convertPriceRangeFromLog(this._priceRangeSnapshot) : null;
								this._logFormula = i, t = this._convertPriceRangeToLog(e), s && (this._priceRangeSnapshot = this._convertPriceRangeToLog(s))
							}
						}
						this.setPriceRange(t)
					} else this.m_priceRange || (this.setPriceRange(new l.PriceRange(-.5, .5)), this._logFormula = (0, c.logFormulaForPriceRange)(null));
					this._invalidatedForRange.isValid = !0;
					const a = this.mainSource();
					null !== a && this._recalculatePriceRangeOnce && (this._recalculatePriceRangeOnce = !a.priceRangeReady())
				}
				_makeSureItIsValid() {
					this._invalidatedForRange.isValid || (this._invalidatedForRange.isValid = !0, this._recalculatePriceRangeImpl())
				}
				_invalidateInternalHeightCache() {
					this._internalHeightCache = null, this._internalHeightChanged.fire()
				}
				_coordinateToLogical(e) {
					if (this._makeSureItIsValid(), this.isEmpty()) return 0;
					const t = this._invertedCoordinate(e),
						i = (0, s.ensureNotNull)(this.priceRange()),
						o = i.minValue() + (i.maxValue() - i.minValue()) * ((t - this.bottomPixelMargin()) / (this.internalHeight() - 1));
					return this.logicalToPrice(o)
				}
				_logicalToCoordinate(e) {
					if (this._makeSureItIsValid(), this.isEmpty()) return 0;
					e = this.priceToLogical(e);
					const t = (0, s.ensureNotNull)(this.priceRange()),
						i = this.bottomPixelMargin() + (this.internalHeight() - 1) * (e - t.minValue()) / (t.maxValue() - t.minValue());
					return this._invertedCoordinate(i)
				}
				_dropScaleCache() {
					this._sourcesForAutoscale = null, this._currencyCache = null, this._unitCache = null, this._measureUnitIdCache = null
				}
				_invertedCoordinate(e) {
					return this.isInverted() ? e : this.height() - 1 - e
				}
				_initScaleProperties() {
					const e = this.isLockScale(),
						t = this.properties().childs();
					e && (t.percentage.setValue(!1), t.indexedTo100.setValue(!1), t.log.setValue(!1), t.autoScale.setValue(!1)), t.percentageDisabled.setValue(e), t.logDisabled.setValue(e), this._updateAutoScaleDisabledProperty(!1), t.percentage.value() && (t.log.setValue(!1), t.indexedTo100.setValue(!1)), t.indexedTo100.value() && (t.log.setValue(!1), t.percentage.setValue(!1))
				}
				_correctedMargins() {
					if (null === this._correctedMarginsCache) {
						const e = this.mainSource();
						this._correctedMarginsCache = null !== e ? e.correctScaleMargins(this._margins) : this._margins
					}
					return this._correctedMarginsCache
				}
				_getSourcesToUpdateViews() {
					return this._sourcesToUpdateViews || (this._sourcesToUpdateViews = this.m_dataSources.filter((e => !(0, w.isLineTool)(e) || e.isActualSymbol() && e.isActualCurrency()))), this._sourcesToUpdateViews
				}
				_mainSourceFormatter() {
					const e = this.mainSource();
					return (null == e ? void 0 : e.formatter()) || I
				}
				_priceToPercentOrIndexedTo100IfNeeded(e, t) {
					return this.isPercentage() ? (0, c.toPercent)(e, t) : this.isIndexedTo100() ? (0, c.toIndexedTo100)(e, t) : e
				}
			}
		},
		812380: (e, t, i) => {
			"use strict";
			var s = i(97639),
				o = i(480910).PriceScaleBase,
				r = i(559270).PriceRange,
				n = i(95935).randomHash,
				a = i(943615),
				l = a.fromLog,
				c = a.toLog;
			class h extends o {
				constructor(e, t) {
					super(t), this._scalesProperties = e;
					var i = this;
					this._modeChanged = new s,
						this._properties.isInverted.listeners().subscribe(this, h.prototype._onIsInvertedChanged), this._properties.listeners().subscribe(null, (function() {
							if (i.mainSource() && i.mainSource().model()) {
								var e = i.mainSource().model().paneForSource(i.mainSource());
								i.mainSource().model().updatePane(e)
							}
						})), this._scalesProperties.listeners().subscribe(this, (function() {
							this._marksCache = null
						})), this.setId(n())
				}
				_convertPriceRangeFromLog(e) {
					if (null === e) return null;
					var t = l(e.minValue(), this._logFormula),
						i = l(e.maxValue(), this._logFormula);
					return new r(t, i)
				}
				_convertPriceRangeToLog(e) {
					if (null === e) return null;
					var t = c(e.minValue(), this._logFormula),
						i = c(e.maxValue(), this._logFormula);
					return new r(t, i)
				}
				_canConvertPriceRangeFromLog(e) {
					if (null === e) return !1;
					var t = l(e.minValue(), this._logFormula),
						i = l(e.maxValue(), this._logFormula);
					return isFinite(t) && isFinite(i)
				}
				mode() {
					return {
						autoScale: this._properties.autoScale.value(),
						lockScale: this._properties.lockScale.value(),
						percentage: this._properties.percentage.value(),
						indexedTo100: this._properties.indexedTo100.value(),
						log: this._properties.log.value()
					}
				}
				setMode(e) {
					var t = {},
						i = this.mode(),
						s = this._properties.state(),
						o = null;
					void 0 !== e.autoScale && e.autoScale !== s.autoScale && (t.autoScale = e.autoScale, this._setAutoScaleValueWithDependentProperties(e.autoScale)), void 0 !== e.lockScale && e.lockScale !== s.lockScale && (t.lockScale = e.lockScale, this._setLockScaleValueWithDependentProperties(e.lockScale)), void 0 !== e.percentage && e.percentage !== s.percentage && (t.percentage = e.percentage, this._setPercentageValueWithDependentProperties(e.percentage), this._invalidatedForRange.isValid = !1), void 0 !== e.indexedTo100 && e.indexedTo100 !== s.indexedTo100 && (t.indexedTo100 = e.indexedTo100, this._setIndexedTo100ValueWithDependentProperties(e.indexedTo100), this._invalidatedForRange.isValid = !1), void 0 !== e.log && e.log !== s.log && (t.log = e.log, this._setLogValueWithDependentProperties(e.log)), s.log && !this._properties.log.value() && (this._canConvertPriceRangeFromLog(this.m_priceRange) ? null !== (o = this._convertPriceRangeFromLog(this.m_priceRange)) && this.setPriceRange(o) : this.properties().autoScale.setValue(!0)), !s.log && this._properties.log.value() && null !== (o = this._convertPriceRangeToLog(this.m_priceRange)) && this.setPriceRange(o), s.autoScale !== this._properties.autoScale.value() && this._properties.autoScale.listeners().fire(this._properties.autoScale), s.autoScaleDisabled !== this._properties.autoScaleDisabled.value() && this._properties.autoScaleDisabled.listeners().fire(this._properties.autoScaleDisabled), s.lockScale !== this._properties.lockScale.value() && this._properties.lockScale.listeners().fire(this._properties.lockScale), s.percentage !== this._properties.percentage.value() && (this._properties.percentage.listeners().fire(this._properties.percentage), this.updateFormatter()), s.indexedTo100 !== this._properties.indexedTo100.value() && (this._properties.indexedTo100.listeners().fire(this._properties.indexedTo100), this.updateFormatter()),
						s.percentageDisabled !== this._properties.percentageDisabled.value() && this._properties.percentageDisabled.listeners().fire(this._properties.percentageDisabled), s.log !== this._properties.log.value() && this._properties.log.listeners().fire(this._properties.log), s.logDisabled !== this._properties.logDisabled.value() && this._properties.logDisabled.listeners().fire(this._properties.logDisabled), void 0 === t.log && void 0 === t.percentage && void 0 === t.lockScale && void 0 === t.autoScale && void 0 === t.indexedTo100 || this._modeChanged.fire(i, this.mode())
				}
				modeChanged() {
					return this._modeChanged
				}
				fontSize() {
					return this._scalesProperties.fontSize.value()
				}
				isEmpty() {
					return this._makeSureItIsValid(), 0 === this.m_height || !this.m_priceRange || this.m_priceRange.isEmpty()
				}
				_onIsInvertedChanged() {
					this._marksCache = null, this._markBuilder.rebuildTickMarks()
				}
			}
			t.PriceScale = h
		},
		286649: (e, t, i) => {
			"use strict";
			var s;
			i.d(t, {
					PublishedChartsFilter: () => s
				}),
				function(e) {
					e.None = "all", e.Following = "following", e.Private = "private"
				}(s || (s = {}))
		},
		648684: (e, t, i) => {
			"use strict";
			i.d(t, {
				PublishedChartsTimeline: () => y
			});
			var s = i(62802),
				o = i.n(s),
				r = i(483306),
				n = i(501867),
				a = i(286649),
				l = i(911905),
				c = i(345848),
				h = i(638456),
				d = i(977809),
				u = i(588537),
				_ = i(443275);
			const m = ["green", "red", "neutral", "yellow", "blue"];
			class p extends _.BarMarksTooltip {
				constructor() {
					super(...arguments), this._source = null, this._layoutAvatar = null, this._layoutText = null, this._layoutUsername = null, this._layoutPin = null, this._pictureFetched = !1, this._plateData = null
				}
				_createLayout() {
					const e = document.createElement("div");
					e.classList.add("published-charts-tooltip"), this._layout = e;
					const t = document.createElement("div");
					t.classList.add("avatar"), t.appendChild(document.createElement("img")), e.appendChild(t), this._layoutAvatar = t;
					const i = document.createElement("div");
					i.classList.add("text"), e.appendChild(i), this._layoutText = i;
					const s = document.createElement("div");
					s.classList.add("username"), s.appendChild(document.createTextNode("by ")), s.appendChild(document.createElement("b")), e.appendChild(s), this._layoutUsername = s;
					const o = document.createElement("div");
					o.classList.add("pin"), e.appendChild(o), this._layoutPin = o, this._pictureFetched = !1, o.addEventListener("click", (() => {
						const e = (0, u.ensureNotNull)(this._plateData);
						e.pinned = !e.pinned, (0, u.ensureNotNull)(this._source).pinTooltip(e.id, e.pinned), o.classList.toggle("pinned", e.pinned)
					})), i.addEventListener("click", (() => {
						const e = (0, u.ensureNotNull)(this._plateData);
						(0, u.ensureNotNull)(this._source).showIdea(e.id, e.pinned)
					}))
				}
				_updatePlate(e) {
					this._plateData = e, (0, u.ensureNotNull)(this._layout).classList.remove(...m), (0, u.ensureNotNull)(this._layout).classList.add(e.themeName), (0, u.ensureNotNull)(this._layoutText).innerText = e.title, (0, u.ensureNotNull)((0, u.ensureNotNull)(this._layoutUsername).querySelector("b")).innerText = e.username, (0, u.ensureNotNull)(this._layoutPin).classList.toggle("pinned", e.pinned), this._pictureFetched || (this._pictureFetched = !0, fetch(`/api/v1/user/profile/${e.username}/?avatars_fallback=true&by=username`).then((e => e.json())).then((t => {
						const i = (0, u.ensureNotNull)(this._layoutAvatar),
							s = (0,
								u.ensureNotNull)(i.querySelector("img"));
						s.alt = e.username, void 0 !== t.avatars && (s.src = t.avatars.mid)
					})))
				}
			}
			var g = i(86674),
				S = i(223124),
				v = i(919250),
				f = i(346090);
			const b = (0, l.getLogger)("Chart.PublishedChartsTimeLine");
			class y extends r.BarsMarksContainer {
				constructor(e, t) {
					let i = o().getValue("PublishedChartsTimeline.filter", a.PublishedChartsFilter.None);
					window.is_authenticated || (i = a.PublishedChartsFilter.None);
					super(e, new f.DefaultProperty("publishedchartstimeline", {
						filter: i
					})), this.toolname = "PublishedChartsTimeline", this._currentRange = null, this._properties.childs().visible.subscribe(this, (() => {
						this._getData(this._currentRange)
					})), this.properties().childs().filter.subscribe(this, (e => {
						o().setValue("PublishedChartsTimeline.filter", e.value()), this.clearMarks(), this._getData(this._currentRange)
					})), this._containsData = e.isSnapshot(), this._containsData && this._properties.childs().visible.setValue(!0), this.setUserEditEnabled(!1), this._onIdeaClickedHandler = t
				}
				paneViews() {
					return this._model.isInReplay() ? [] : super.paneViews()
				}
				showIdea(e, t) {
					var i;
					const s = this._marks[e];
					if (s) {
						if ((0, c.trackEvent)("GUI", "View published idea"), t && (0, c.trackEvent)("GUI", "Ideas navigation arrow"), (0, h.onWidget)() || this._containsData) {
							let e = s.published_chart_url || "/v/" + s.image_url + "/";
							return e = this._getBaseUrl() + e, void window.open(e)
						}
						null === (i = this._onIdeaClickedHandler) || void 0 === i || i.call(this, {
							chartId: s.image_url,
							chartName: s.name,
							publishedUrl: s.published_chart_url,
							shortSymbol: s.short_name
						})
					} else b.logDebug("PublishedChartsTimeline.showIdea: unexpected published chart id")
				}
				onClicked(e) {
					null !== e && this.showIdea(e.activeItem.id, !1)
				}
				state(e) {
					const t = {
						type: "BarsMarksContainer",
						id: this.id(),
						zorder: this.zorder(),
						pinnedTooltips: this._pinnedTooltips
					};
					return e && this._properties.childs().visible.value() && (t.marks = this.getPublishedPlates()), t
				}
				restoreData(e, t) {
					null != e.pinnedTooltips && (this._pinnedTooltips = e.pinnedTooltips), t && void 0 !== e.marks && (this._marks = e.marks)
				}
				updateDotData(e, t) {
					return {
						...t,
						mine: e.mine,
						public: e.public,
						direction: e.direction
					}
				}
				updatePlateData(e, t) {
					return {
						...t,
						title: e.title,
						user_id: e.user_id,
						username: e.username,
						barWidth: this.barWidth()
					}
				}
				destroy() {
					this._onIdeaClickedHandler = null, this._boundOnMessage && (n.off("ideas", this._boundOnMessage), n.off("ideas.post", this._boundOnMessage), this._boundOnMessage = null), super.destroy()
				}
				_initialize() {
					n && (this._boundOnMessage = this._onMessage.bind(this), n.on("ideas", this._boundOnMessage), n.on("ideas.post", this._boundOnMessage))
				}
				_plateViewData(e) {
					return {
						title: e.title,
						user_id: e.user__id,
						username: e.username,
						suggested: e.is_hot,
						mine: e.user__id === window.user.id,
						public: e.is_public
					}
				}
				_getData(e, t) {
					const i = this._model.mainSeries().properties().childs(),
						s = this._model.mainSeries().symbolInfo();
					if (this._currentRange = e, !s || !this._properties.childs().visible.value() && !t) return Promise.resolve([]);
					let o = s.base_name.length > 1 ? s.base_name : [s.pro_name];
					const r = this.roundRange(this._rangeDifference(e));
					o = (0, d.uniq)(o), o = o.sort();
					const n = new FormData;
					n.append("interval", i.interval.value()), n.append("legs", JSON.stringify(o)),
						n.append("startTickmark", r.start.toString()), n.append("endTickmark", r.end.toString()), n.append("filter", this.properties().childs().filter.value());
					const a = (0, S.makeCancelable)(new Promise(((e, t) => {
						(0, g.fetch)("/charttimeline/", {
							method: "POST",
							body: n,
							headers: new Headers({
								acccept: "application/json",
								"X-Requested-With": "XMLHttpRequest"
							})
						}).then((i => {
							i.ok ? i.json().then(e) : t()
						})).catch(t)
					})));
					return a.promise.then((t => {
						t.forEach((e => {
							this._marks[e.id] = e
						})), this._loadedRange = this._rangeUnion(e, this._loadedRange);
						const i = this._requests.indexOf(a);
						~i && this._requests.splice(i, 1), this.onNeedRepaint.fire()
					})), this._requests.push(a), a.promise
				}
				_createTooltipRenderer() {
					return new v.TooltipRenderer((() => new p), this)
				}
				_onMessage(e, t, i, s) {
					if (this._containsData) return;
					const o = this._model.mainSeries(),
						r = o.symbolInfo(),
						n = r && r.base_name;
					if (!n) return;
					const a = o.properties().childs();
					e.interval === a.interval.value() && ~n.indexOf(e.pro_symbol) && (this._marks[e.id] = e, this.onNeedRepaint.fire())
				}
				_getBaseUrl() {
					if ((0, h.onWidget)() && window.locale_domains) {
						const e = window.locale || "en",
							t = window.locale_domains[e] ? window.locale_domains[e] : window.locale_domains.en;
						return t ? document.location.protocol + "//" + t : ""
					}
					return ""
				}
			}
		},
		509966: (e, t, i) => {
			"use strict";
			i.d(t, {
				rangesAreEqual: () => r
			});
			var s = i(285055),
				o = i(273044);

			function r(e, t) {
				return !!o.Interval.isEqual(e.res, t.res) && (0, s.areEqualTimeFrames)(e.val, t.val)
			}
		},
		748863: (e, t, i) => {
			"use strict";
			i.d(t, {
				createPriceScaleSelectionStrategy: () => l,
				allPriceScaleSelectionStrategyInfo: () => c
			});
			var s = i(588537),
				o = i(575932),
				r = i(140662);
			class n {
				constructor(e) {
					this._priceScalesLimit = 8, this._metaInfo = e
				}
				metaInfo() {
					return this._metaInfo
				}
				findSuitableScale(e, t, i, s) {
					if (void 0 !== s) return this._tryToGetDesiredPriceScale(e, t, s, i);
					if ((0, r.isStudy)(t)) {
						const s = t.metaInfo();
						if ("Volume" === s.shortId && e.containsMainSeries()) return e.createPriceScaleAtPosition("overlay");
						const o = t.desiredPriceScalePosition();
						if (null !== o) return this._tryToGetDesiredPriceScale(e, t, o, i);
						if (void 0 !== i && ((0, r.isStudy)(i) || e.isMainPane()) && s.is_price_study) return this._getPriceScaleTheSameAsForSource(i, e)
					}
					let o = !1;
					if ((0, r.isStudy)(t)) {
						const i = t.metaInfo().groupingKey;
						if (void 0 !== i) {
							const t = e.model().findNonOverlayStudyWithGroupingKey(i, e);
							if (null !== t) return this._getPriceScaleTheSameAsForSource(t.study, t.pane)
						}
						o = Boolean(t.metaInfo().is_price_study)
					} else t === e.model().mainSeries() && (o = !0);
					if (o) {
						const t = this._findFirstScaleForPriceStudy(e);
						if (null !== t) return t
					}
					return this.createNewPriceScaleIfPossible(e)
				}
				canCreateNewPriceScale(e) {
					return e.leftPriceScales().length + e.rightPriceScales().length < this._priceScalesLimit
				}
				_getPriceScaleTheSameAsForSource(e, t) {
					return t.isOverlay(e) ? t.createPriceScaleAtPosition("overlay") : (0, s.ensureNotNull)(e.priceScale())
				}
				_priceScaleIsPrice(e, t) {
					const i = e.mainSource();
					return !!i && (i === t.mainSeries() || !!(0, r.isStudy)(i) && Boolean(i.metaInfo().is_price_study))
				}
				_findFirstScaleForPriceStudy(e) {
					const t = e.model();
					for (let i = 0; i < this._priceScalesLimit; i++) {
						if (e.rightPriceScales().length > i && this._priceScaleIsPrice(e.rightPriceScales()[i], t)) return e.rightPriceScales()[i];
						if (e.leftPriceScales().length > i && this._priceScaleIsPrice(e.leftPriceScales()[i], t)) return e.leftPriceScales()[i]
					}
					return null
				}
				_targetPriceScaleIndex(e, t) {
					if (e.mainSource() === t.mainSeries()) return 0
				}
				_tryToGetDesiredPriceScale(e, t, i, o) {
					switch (i) {
						case "left":
							return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("left") : e.createPriceScaleAtPosition("overlay");
						case "right":
							return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("right") : e.createPriceScaleAtPosition("overlay");
						case "as-series":
							return void 0 !== o ? (0, s.ensureNotNull)(o.priceScale()) : e.isMainPane() ? (0, s.ensureNotNull)((0, s.ensureNotNull)(e.mainDataSource()).priceScale()) : this.createNewPriceScaleIfPossible(e);
						case "overlay":
							return e.createPriceScaleAtPosition("overlay")
					}
				}
			}
			const a = [{
				name: "left",
				title: (0, o.t)("Stack on the left"),
				ctor: class extends n {
					constructor(e) {
						super(e)
					}
					apply(e) {
						const t = e.model();
						e.rightPriceScales().slice(0).forEach((i => e.movePriceScale(i, "left", this._targetPriceScaleIndex(i, t))))
					}
					createNewPriceScaleIfPossible(e) {
						return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("left") : e.createPriceScaleAtPosition("overlay")
					}
				}
			}, {
				name: "right",
				title: (0, o.t)("Stack on the right"),
				ctor: class extends n {
					constructor(e) {
						super(e)
					}
					apply(e) {
						const t = e.model();
						e.leftPriceScales().slice(0).forEach((i => e.movePriceScale(i, "right", this._targetPriceScaleIndex(i, t))))
					}
					createNewPriceScaleIfPossible(e) {
						return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("right") : e.createPriceScaleAtPosition("overlay")
					}
				}
			}, {
				name: "auto",
				title: (0, o.t)("Auto"),
				ctor: class extends n {
					constructor(e) {
						super(e)
					}
					apply(e) {
						if (e.containsMainSeries()) {
							const t = (0, s.ensureNotNull)((0, s.ensureNotNull)(e.mainDataSource()).priceScale());
							e.movePriceScale(t, "right", 0)
						}
						const t = e.model();
						for (; e.leftPriceScales().length > e.rightPriceScales().length;) {
							const i = e.leftPriceScales()[e.leftPriceScales().length - 1];
							e.movePriceScale(i, "right", this._targetPriceScaleIndex(i, t))
						}
						for (; e.rightPriceScales().length - e.leftPriceScales().length > 1;) {
							const i = e.rightPriceScales()[e.rightPriceScales().length - 1];
							e.movePriceScale(i, "left", this._targetPriceScaleIndex(i, t))
						}
					}
					createNewPriceScaleIfPossible(e) {
						if (!this.canCreateNewPriceScale(e)) return e.createPriceScaleAtPosition("overlay");
						const t = e.leftPriceScales().length < e.rightPriceScales().length ? "left" : "right";
						return e.createPriceScaleAtPosition(t)
					}
				}
			}];

			function l(e) {
				const t = (0, s.ensureDefined)(a.find((t => t.name === e)));
				return new t.ctor(t)
			}

			function c() {
				return a
			}
		},
		769393: (e, t, i) => {
			"use strict";
			var s;
			i.d(t, {
					InsertionErrorCode: () => s
				}),
				function(e) {
					e.StudyCannotBeChild = "cannot_be_child", e.StubWasRemoved = "stub_was_removed", e.CannotGetMetainfo = "cannot_get_metainfo", e.Cancelled = "cancelled", e.Unknown = "unknown"
				}(s || (s = {}))
		},
		938391: (e, t, i) => {
			"use strict";
			i.d(t, {
				StudyColorRotatorFactory: () => h
			});
			var s = i(679520),
				o = i(724377),
				r = i(721386),
				n = i(140662);
			const a = ["color-sky-blue-400", "color-banana-yellow-700", "color-deep-blue-500", "color-grapes-purple-a700", "color-iguana-green-500", "color-minty-green-a700", "color-ripe-red-a200", "color-berry-pink-200", "color-tv-blue-a100", "color-tan-orange-a200", "color-sky-blue-a400", "color-deep-blue-a100", "color-grapes-purple-400", "color-iguana-green-a700", "color-minty-green-200", "color-ripe-red-200", "color-berry-pink-a200", "color-ripe-red-500", "color-grapes-purple-500", "color-deep-blue-400", "color-tv-blue-a200", "color-sky-blue-500", "color-iguana-green-400", "color-minty-green-400", "color-banana-yellow-600", "color-tan-orange-500", "color-berry-pink-400", "color-ripe-red-300", "color-grapes-purple-300", "color-deep-blue-300", "color-tv-blue-300", "color-sky-blue-300", "color-iguana-green-300", "color-minty-green-300", "color-banana-yellow-400", "color-tan-orange-300", "color-berry-pink-300", "color-tan-orange-a700"];
			class l {
				constructor(e) {
					this._offset = 0, this._offset = e
				}
				getColor(e) {
					if (0 === this._offset) return e;
					const t = a[(this._offset - 1) % a.length],
						i = s.colorsPalette[t],
						n = (0, r.isHexColor)(e) ? 1 : (0, o.parseRgba)(e)[3];
					return (0, r.generateColor)(i, (0, r.alphaToTransparency)(n))
				}
			}
			class c {
				constructor(e, t) {
					this._offset = e, this._modelStartOffset = t
				}
				getColor(e) {
					if ((0, r.isHexColor)(e)) {
						const t = (0, o.parseRgb)(e);
						return (0, o.rgbToHexString)((0, o.shiftRgb)(t, this._offset, this._modelStartOffset))
					} {
						const t = (0, o.parseRgba)(e);
						return (0, o.rgbaToString)((0, o.shiftRgba)(t, this._offset, this._modelStartOffset))
					}
				}
			}
			class h {
				constructor(e) {
					this._chartModel = e
				}
				getColorRotator(e) {
					const t = (0, n.studyColorRotationMode)(e);
					if (null === t) return null;
					const i = this._calcDefaultColorsOffset(e);
					switch (t) {
						case "loop":
							return new l(i);
						case "shift": {
							const e = this._chartModel.getStudyShiftColorStartOffset();
							return new c(i, e)
						}
					}
				}
				_calcDefaultColorsOffset(e) {
					let t = 0;
					const i = (0, n.useSameColorRotationComparator)(e);
					return this._chartModel.dataSources().filter(n.isStudy).forEach((s => {
						i(e, s.metaInfo()) && t++
					})), t
				}
			}
		},
		131341: (e, t, i) => {
			"use strict";
			i.d(t, {
				StudyInserter: () => n
			});
			var s = i(970028),
				o = i(769393);
			const r = (0, i(911905).getLogger)("Chart.Studies.StudyInserter");
			class n {
				constructor(e, t, i) {
					this._parentSource = void 0, this._propsState = void 0, this._preferredPriceScale = void 0, this._allowChangeCurrency = !1, this._allowChangeUnit = !1, this._paneSize = void 0, this._forceOverlay = !1, this._studyMetaInfoRepository = t, this._inserterImpl = i, this._studyDescriptor = e
				}
				setParentSource(e) {
					this._parentSource = e || void 0
				}
				setPaneSize(e) {
					this._paneSize = e
				}
				setPreferredPriceScale(e) {
					this._preferredPriceScale = e
				}
				setAllowChangeCurrency(e) {
					this._allowChangeCurrency = e
				}
				setAllowChangeUnit(e) {
					this._allowChangeUnit = e
				}
				setForceOverlay(e) {
					this._forceOverlay = e
				}
				setPropertiesState(e) {
					this._propsState = e
				}
				setTargetPriceScaleMode(e) {
					this._targetPriceScaleMode = e
				}
				async insert(e, t) {
					const i = void 0 !== (s = this._inserterImpl).createStub && void 0 !== s.removeStub ? this._inserterImpl.createStub() : null;
					var s;
					let n, a = !0;
					try {
						n = await this._studyMetaInfoRepository.findById(this._studyDescriptor)
					} catch (e) {
						return r.logWarn(`Cannot get study ${JSON.stringify(this._studyDescriptor)}`),
							Promise.reject(o.InsertionErrorCode.CannotGetMetainfo)
					} finally {
						null !== i && (a = this._inserterImpl.removeStub(i))
					}
					if (!a) return Promise.reject(o.InsertionErrorCode.StubWasRemoved);
					if (void 0 !== t && t.cancelled) return Promise.reject(o.InsertionErrorCode.Cancelled);
					if (!this._canApplyStudyToParent(n)) return Promise.reject(o.InsertionErrorCode.StudyCannotBeChild);
					const l = {
						...n.defaults.inputs
					};
					let c = {};
					if (void 0 !== e) {
						const t = await e(l, n.inputs, n);
						c = t.inputs, void 0 === this._parentSource && t.parentSource && (this._parentSource = t.parentSource)
					}
					if (void 0 !== t && t.cancelled) return Promise.reject(o.InsertionErrorCode.Cancelled);
					const h = this._insertStudy(n, c);
					return null === h ? Promise.reject(o.InsertionErrorCode.Unknown) : h
				}
				_insertStudy(e, t) {
					return this._inserterImpl.createStudy(e, t, null, this._propsState, this._forceOverlay, this._parentSource, this._preferredPriceScale, this._allowChangeCurrency, this._allowChangeUnit, this._paneSize, this._targetPriceScaleMode)
				}
				_canApplyStudyToParent(e) {
					return void 0 === this._parentSource || s.StudyMetaInfo.canBeChild(e)
				}
			}
		},
		929744: (e, t, i) => {
			"use strict";
			i.d(t, {
				isStudyLineToolStub: () => n,
				StudyLineToolStub: () => a
			});
			var s = i(262325),
				o = i.n(s),
				r = i(147627);

			function n(e) {
				return e instanceof a
			}
			class a extends r.StudyStub {
				constructor(e, t, i) {
					var s;
					super(e, {
						...t,
						ownFirstValue: null
					}, i), this._linkKey = new(o())(null !== (s = t.linkKey) && void 0 !== s ? s : null)
				}
				linkKey() {
					return this._linkKey
				}
			}
		},
		190472: (e, t, i) => {
			"use strict";
			i.d(t, {
				StudyMetaInfoRepository: () => u
			});
			var s = i(575932),
				o = i(588537),
				r = i(970028),
				n = i(481211),
				a = i(813652),
				l = i(366156),
				c = i(610498),
				h = i.n(c);
			const d = (0, i(911905).getLogger)("Chart.Studies.StudyMetaInfoRepository", {
				color: "#606"
			});
			class u {
				constructor(e) {
					this._nextRequestNumber = 1, this._rawStudiesMetaInfo = [], this._isReady = !1, this._metaInfoQueryQueue = [], this._javaMetaInfoQueryQueue = [], this._javaStudiesMetaInfo = [], this._pineMetaInfoCache = [], this._studiesMigrations = [], this._gateway = e
				}
				requestMetaInfo() {
					this._requestStarted();
					const e = this._makeNextRequestId();
					return d.logNormal(`Requesting metainfo #${e}`), new Promise((t => {
						d.logNormal(`Requesting studies metadata #${e}`), this._gateway.requestMetadata(e, (i => {
							d.logNormal(`Requesting studies metadata #${e} finished`);
							const s = i.params[1].metainfo.slice(); {
								const e = i.params[1].migrations.slice();
								this._processSiteMetaInfo(s, e)
							}
							this._requestFinished(), t()
						}))
					}))
				}
				findById(e) {
					if (!this._isReady) return this._enqueueMetaInfoQuery(e);
					const t = this._findStudyMetaInfo(e);
					return null !== t ? Promise.resolve(t) : "pine" === e.type ? this._compilePine(e) : Promise.reject(`unexpected study id=${e.studyId} with type=${e.type}`)
				}
				findByIdSync(e) {
					return this._findStudyMetaInfo(e)
				}
				isReady() {
					return this._isReady
				}
				findAllJavaStudies() {
					return this._isReady ? Promise.resolve(this._javaStudiesMetaInfo) : this._enqueueJavaMetaInfoQuery()
				}
				getInternalMetaInfoArray() {
					return this._javaStudiesMetaInfo
				}
				getMigrations() {
					return this._studiesMigrations
				}
				addPineMetaInfo(e) {
					return m(this._pineMetaInfoCache, e)
				}
				_processMigrations(e) {
					this._studiesMigrations = [];
					for (let t = 0; e && t < e.length; t++) this._studiesMigrations.push(e[t])
				}
				_processSiteMetaInfo(e, t) {
					for (const t of e) h()._verifyInputsMaxValue(t), _(t);
					this._rawStudiesMetaInfo = e, this._processMigrations(t);
					for (const e of this._rawStudiesMetaInfo) m(this._javaStudiesMetaInfo, e);
					r.StudyMetaInfo.overrideDefaults(this._javaStudiesMetaInfo)
				}
				_processLibraryMetaInfo(e) {}
				_requestStarted() {
					this._isReady = !1, this._javaStudiesMetaInfo = [], this._pineMetaInfoCache = [], this._studiesMigrations = [], this._rawStudiesMetaInfo = []
				}
				_requestFinished() {
					this._isReady = !0, this._processPendingMetaInfoQueries(), this._processPendingFullMetaInfoQueries()
				}
				_enqueueMetaInfoQuery(e) {
					return new Promise((t => {
						this._metaInfoQueryQueue.push({
							studyDescriptor: e,
							resolver: t
						})
					}))
				}
				_enqueueJavaMetaInfoQuery() {
					return new Promise((e => {
						this._javaMetaInfoQueryQueue.push({
							resolver: e
						})
					}))
				}
				_processPendingMetaInfoQueries() {
					for (; this._metaInfoQueryQueue.length;) {
						const e = this._metaInfoQueryQueue.shift();
						this.findById(e.studyDescriptor).then(e.resolver)
					}
				}
				_processPendingFullMetaInfoQueries() {
					for (; this._javaMetaInfoQueryQueue.length;) {
						this._javaMetaInfoQueryQueue.shift().resolver(this._javaStudiesMetaInfo)
					}
				}
				_findStudyMetaInfo(e) {
					return "java" === e.type ? this._javaStudiesMetaInfo.find((t => t.id === e.studyId)) || null : this._pineMetaInfoCache.find((t => t.scriptIdPart === e.pineId && (void 0 === e.pineVersion || (0, o.ensureDefined)(t.pine).version === e.pineVersion))) || null
				}
				_makeNextRequestId() {
					return "metadata_" + this._nextRequestNumber++
				}
				_compilePine(e) {
					d.logNormal(`Compiling ${e.pineId} script`);
					const t = Promise.resolve((0, l.translateScriptAsync2)(e.pineId, e.pineVersion || "last")).then((t => (d.logNormal(`Compiling ${e.pineId} is successful`), this.addPineMetaInfo((0, o.ensureDefined)(t)))));
					return t.catch((() => {
						d.logNormal(`Compiling ${e.pineId} is failed`)
					})), t
				}
			}

			function _(e) {
				e.description_localized = (0, s.t)(e.description, {
					context: "study"
				})
			}

			function m(e, t) {
				const i = new r.StudyMetaInfo(t);
				(0, n.migrateMetaInfoAndPropState)(i);
				let s = !0;
				const o = e.findIndex((e => e.id === i.id));
				if (-1 === o) e.push(i);
				else {
					const t = e[o],
						r = void 0 !== t.pine ? a.Version.parse(t.pine.version) : null,
						n = void 0 !== i.pine ? a.Version.parse(i.pine.version) : null;
					null === n || null === r || n.isGreaterOrEqual(r) ? (t.removeDefaults(), e[o] = i) : s = !1
				}
				return s && i.createDefaults(), i
			}
		},
		126844: (e, t, i) => {
			"use strict";
			var s = i(97639);

			function o() {
				this._marksByIndex = new Map, this._marksBySpan = [], this.changed = new s, this.minIndex = void 0, this.maxIndex = void 0
			}
			o.prototype.reset = function() {
				this._resetImpl(), this.changed.fire()
			}, o.prototype._resetImpl = function() {
				this._marksByIndex = new Map, this._marksBySpan = [], this.minIndex = void 0, this.maxIndex = void 0, this._cache = void 0
			}, o.prototype.merge = function(e) {
				if (0 !== e.length) {
					var t = e[0].index,
						i = e[e.length - 1].index;
					t <= this.minIndex && i >= this.maxIndex && this._resetImpl();
					for (var s = this._marksBySpan, o = new Set, r = 0; r < e.length; r++) {
						var n = (c = e[r]).index,
							a = c.span,
							l = this._marksByIndex.get(c.index);
						if (l) {
							if (l.index === c.index && l.span === c.span) {
								l.time = c.time;
								continue
							}
							this._removeTickmark(l)
						}
					}
					for (r = 0; r < e.length; r++) {
						var c;
						n = (c = e[r]).index, a = c.span;
						if (!this._marksByIndex.has(c.index)) {
							this._marksByIndex.set(n, c);
							var h = s[a];
							void 0 === h && (h = [], s[a] = h);
							var d = 0 === h.length || h[h.length - 1].index < c.index;
							s[a].push(c), d || o.add(a)
						}
					}
					this.minIndex = void 0 === this.minIndex ? t : Math.min(this.minIndex, t), this.maxIndex = void 0 === this.maxIndex ? i : Math.max(this.maxIndex, i);
					for (a = s.length; a--;) s[a] && (s[a].length || delete s[a], o.has(a) && s[a].sort(this._sortByIndexAsc));
					this._cache = void 0, this.changed.fire()
				}
			}, o.prototype._removeTickmark = function(e) {
				var t = e.index;
				if (this._marksByIndex.get(t) === e) {
					this._marksByIndex.delete(t), t <= this.minIndex && this.minIndex++, t >= this.maxIndex && this.maxIndex--, this.maxIndex < this.minIndex && (this.minIndex = void 0, this.maxIndex = void 0);
					var i = this._marksBySpan[e.span],
						s = i.indexOf(e); - 1 !== s && i.splice(s, 1)
				}
			}, o.prototype._sortByIndexAsc = function(e, t) {
				return e.index - t.index
			}, o.prototype.removeTail = function(e) {
				var t = new Map;
				this.maxIndex = 0, this._marksByIndex.forEach(function(i, s) {
					i.time < e && (t.set(s, i), this.maxIndex = Math.max(this.maxIndex, s))
				}.bind(this)), this._marksByIndex = t
			}, o.prototype.addTail = function(e) {
				for (var t = 0; t < e.length; t++) e[t].index = this.maxIndex + t + 1;
				this.merge(e)
			}, o.prototype.indexToTime = function(e) {
				var t = this._marksByIndex.get(e);
				return t ? new Date(1e3 * t.time) : null
			}, o.prototype.density = function() {
				var e = this.maxIndex - this.minIndex;
				if (0 !== e) return 1e3 * (this._marksByIndex.get(this.maxIndex).time - this._marksByIndex.get(this.minIndex).time) / e
			}, o.prototype.estimateLeft = function(e) {
				var t = this.density();
				if (t) return (1e3 * this._marksByIndex.get(this.minIndex).time - e) / t
			}, o.prototype.nearestIndex = function(e) {
				for (var t = this.minIndex, i = this.maxIndex; i - t > 2;) {
					if (1e3 * this._marksByIndex.get(t).time === e) return t;
					if (1e3 * this._marksByIndex.get(i).time === e) return i;
					var s = Math.round((t + i) / 2);
					1e3 * this._marksByIndex.get(s).time > e ? i = s : t = s
				}
				return t
			}, o.prototype.build = function(e, t) {
				var i = Math.ceil(t / e);
				if (this._maxbar === i && this._cache) return this._cache;
				this._maxbar = i;
				for (var s = [], o = this._marksBySpan.length; o--;)
					if (this._marksBySpan[o]) {
						var r = s;
						s = [];
						for (var n = r.length, a = 0, l = this._marksBySpan[o], c = l.length, h = 1 / 0, d = -1 / 0, u = 0; u < c; u++) {
							for (var _ = l[u], m = _.index; a < n;) {
								var p = r[a],
									g = p.index;
								if (!(g < m)) {
									h = g;
									break
								}
								a++, s.push(p), d = g, h = 1 / 0
							}
							h - m >= i && m - d >= i && (s.push(_), d = m)
						}
						for (; a < n; a++) s.push(r[a])
					} return this._cache = s, this._cache
			}, o.prototype.state = function() {
				for (var e = [], t = this._marksBySpan.length; t--;) this._marksBySpan[t] && (e = e.concat(this._marksBySpan[t]));
				return {
					marks: e = e.map((function(e) {
						return [e.span, e.time, e.index]
					})),
					version: 2
				}
			}, o.prototype.restoreState = function(e) {
				if (this._marksByIndex = new Map, this._marksBySpan = [], this.maxIndex = void 0, this.minIndex = void 0, e && e.marks && e.marks.length)
					if (2 === e.version) {
						var t = e.marks.map((function(e) {
							return {
								span: e[0],
								time: e[1],
								index: e[2]
							}
						}));
						this.merge(t)
					} else this.merge(e.marks)
			}, e.exports.Tickmarks = o
		},
		984610: (e, t, i) => {
			"use strict";
			i.d(t, {
				trackDrawingCreated: () => a,
				trackDrawingPasted: () => l,
				trackDrawingCloned: () => c,
				trackChartStyleChanged: () => h
			});
			var s = i(776734),
				o = i(588537),
				r = i(195048);

			function n(e, t) {
				(0, s.getTracker)().then((i => {
					if (null !== i) {
						const s = (0, o.ensureNotNull)(e.model().mainSeries().symbolInfo()),
							r = s.pro_name || s.name;
						i.trackDrawingsAnalytics(r, e.name(), t)
					}
				}))
			}

			function a(e) {
				n(e, "create")
			}

			function l(e) {
				n(e, "paste")
			}

			function c(e) {
				n(e, "clone")
			}

			function h(e) {
				(0, s.getTracker)().then((t => {
					if (null !== t) {
						const i = r.STYLE_SHORT_NAMES[e];
						t.trackChartStyle(i)
					}
				}))
			}
		},
		613763: (e, t, i) => {
			"use strict";
			i.d(t, {
				ApplyLineToolTemplateUndoCommand: () => o
			});
			var s = i(72833);
			class o extends s.UndoCommand {
				constructor(e, t, i) {
					super(i), this._source = e, this._newState = t, this._oldState = e.properties().state()
				}
				redo() {
					this._source.applyTemplate(this._newState)
				}
				undo() {
					this._source.applyTemplate(this._oldState)
				}
			}
		},
		148976: (e, t, i) => {
			"use strict";
			i.d(t, {
				ExcludeLineToolsFromGroupUndoCommand: () => l
			});
			var s = i(588537),
				o = (i(897116), i(575932)),
				r = i(277036),
				n = i(72833);
			const a = new r.TranslatedString("exclude line tools from group {group}", (0, o.t)("exclude line tools from group {group}"));
			class l extends n.UndoCommand {
				constructor(e, t, i) {
					super(a.format({
						group: t.name()
					})), this._model = e, this._groupId = t.id, this._groupName = t.name(), this._lineToolsIds = i.map((e => e.id()))
				}
				redo() {
					const e = (0, s.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId)),
						t = this._lineToolsIds.map((e => this._model.dataSourceForId(e)));
					e.excludeLineTools(t), 0 === e.lineTools().length && this._model.lineToolsGroupModel().removeGroup(e)
				}
				undo() {
					const e = this._lineToolsIds.map((e => this._model.dataSourceForId(e))),
						t = this._model.lineToolsGroupModel().groupForId(this._groupId);
					null !== t ? t.addLineTools(e) : this._model.lineToolsGroupModel().createGroup(e, this._groupName, this._groupId)
				}
			}
		},
		36047: (e, t, i) => {
			"use strict";
			i.d(t, {
				mergeAllScalesAction: () => c
			});
			var s = i(575932),
				o = i(277036),
				r = i(911905);
			const n = new o.TranslatedString("move all scales to left", (0, s.t)("move all scales to left")),
				a = new o.TranslatedString("move all scales to right", (0, s.t)("move all scales to right")),
				l = (0, r.getLogger)("Chart.MergeAllScales");

			function c(e, t) {
				e.beginUndoMacro("left" === t ? n : a), e.model().panes().forEach((i => {
					const s = "left" === t ? i.rightPriceScales() : i.leftPriceScales(),
						o = ("left" === t ? i.leftPriceScales() : i.rightPriceScales()).concat(s),
						r = "overlay" === i.priceScalePosition(i.defaultPriceScale()) ? o[0] : i.defaultPriceScale();
					e.movePriceScale(i, r, t, 0), o.forEach((t => {
						if (t === r) return;
						let s = t.mainSource();
						for (; null !== s;) {
							e.moveToScale(s, i, r, null, !0);
							const o = t.mainSource();
							if (o === s) {
								l.logError("Loop detected while trying to merge scales");
								break
							}
							s = o
						}
					}))
				})), e.endUndoMacro(), e.model().fullUpdate()
			}
		},
		284330: (e, t, i) => {
			"use strict";
			i.d(t, {
				MergeUpUndoCommand: () => n,
				MergeDownUndoCommand: () => a,
				MergeToTargetPane: () => l
			});
			var s = i(588537),
				o = i(242133);
			class r extends o.MoveSourceUndoCommand {
				constructor(e, t, i, s) {
					super(e, t, i), this._restorePane = !1, this._keepZOrder = null != s && s
				}
				redo() {
					const e = this._chartModel.panes().length,
						t = this._chartModel.panes()[this._targetPaneIndex()],
						i = (0, s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId)),
						o = (0, s.ensureNotNull)(this._chartModel.paneForSource(i)),
						r = this._chartModel.children(i, !0);
					o.bulkActionMacro((() => {
						r.forEach((e => this._chartModel.detachSource(e))), this._restorePane = this._chartModel.detachSource(i)
					}));
					const n = "overlay" === this._initialPriceScalePosition ? this._initialPriceScalePosition : void 0,
						a = t.findSuitableScale(i, void 0, n),
						l = 0 === a.dataSources().length;
					if (t.bulkActionMacro((() => {
							t.addDataSource(i, a, this._keepZOrder), r.forEach((e => t.addDataSource(e, a, this._keepZOrder)))
						})), i === this._chartModel.mainSeries()) {
						const e = t.priceScalePosition(a);
						t.movePriceScale(a, e, 0)
					}
					if (l) {
						(0, s.ensureNotNull)(i.priceScale()).restoreState(this._newPriceScaleState(t.isOverlay(i)))
					}
					this._chartModel.fullUpdate(), e !== this._chartModel.panes().length && this._chartModel.setShouldBeSavedEvenIfHidden(!0)
				}
				undo() {
					let e;
					e = this._restorePane ? this._chartModel.createPane(this._initialPaneIndex) : this._chartModel.panes()[this._initialPaneIndex];
					const t = (0, s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId)),
						i = (0, s.ensureNotNull)(this._chartModel.paneForSource(t)),
						o = this._chartModel.children(t, !0);
					i.bulkActionMacro((() => {
						o.forEach((e => this._chartModel.detachSource(e))), this._chartModel.detachSource(t)
					}));
					let r = e.getPriceScaleById(this._initialPriceScaleId);
					null === r && (r = e.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex)), e.bulkActionMacro((() => {
						e.addDataSource(t, r, !0), o.forEach((t => e.addDataSource(t, r, !1)))
					})), (0, s.ensureNotNull)(t.priceScale()).restoreState(this._originalPriceScaleState()), this._chartModel.fullUpdate()
				}
			}
			class n extends r {
				constructor(e, t, i) {
					super(e, t, i)
				}
				_targetPaneIndex() {
					return this._initialPaneIndex - 1
				}
			}
			class a extends r {
				constructor(e, t, i) {
					super(e, t, i)
				}
				_targetPaneIndex() {
					return this._initialPaneIndex + 1
				}
			}
			class l extends r {
				constructor(e, t, i, s, o) {
					super(e, t, s, o), this._targetPane = i
				}
				_targetPaneIndex() {
					return this._targetPane
				}
			}
		},
		242133: (e, t, i) => {
			"use strict";
			i.d(t, {
				MoveSourceUndoCommand: () => r
			});
			var s = i(588537),
				o = i(72833);
			class r extends o.UndoCommand {
				constructor(e, t, i) {
					super(i), this._chartModel = e, this._sourceId = t.id();
					const o = (0, s.ensureNotNull)(t.priceScale());
					this._initialPriceScaleId = o.id(), this._initialPriceScaleState = (0, s.ensureNotNull)(t.priceScale()).state();
					const r = (0, s.ensureNotNull)(e.paneForSource(t));
					this._initialPriceScalePosition = r.priceScalePosition(o), this._initialPriceScaleIndex = r.priceScaleIndex(o, this._initialPriceScalePosition), this._initialPaneIndex = e.panes().indexOf(r)
				}
				_newPriceScaleState(e) {
					const t = {
						...this._initialPriceScaleState
					};
					return delete t.m_isLockScale, delete t.id, delete t.m_topMargin, delete t.m_bottomMargin, t
				}
				_originalPriceScaleState() {
					return this._initialPriceScaleState
				}
			}
		},
		38300: (e, t, i) => {
			"use strict";
			i.d(t, {
				MoveToNewPriceScaleUndoCommand: () => n,
				MoveToExistingPriceScaleUndoCommand: () => a
			});
			var s = i(588537),
				o = i(242133);
			class r extends o.MoveSourceUndoCommand {
				constructor(e, t, i, s) {
					super(e, t, s), this._sourcePaneRemoved = !1, this._targetPaneIndex = e.panes().indexOf(i)
				}
				redo() {
					const e = this._chartModel.panes()[this._initialPaneIndex],
						t = this._chartModel.panes()[this._targetPaneIndex],
						i = e !== t,
						o = this._targetPriceScale(t),
						r = (0, s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId)),
						n = this._chartModel.children(r, !0);
					for (const e of n) i ? (this._chartModel.detachSource(e),
						t.addDataSource(e, o, !1)) : t.move(e, o);
					i ? (this._sourcePaneRemoved = this._chartModel.detachSource(r), t.addDataSource(r, o, !1)) : t.move(r, o);
					const a = t.priceScalePosition(o);
					t.movePriceScale(o, a, this._targetPriceScaleIndex(r)), this._chartModel.fullUpdate()
				}
				undo() {
					this._sourcePaneRemoved && this._chartModel.createPane(this._initialPaneIndex);
					const e = this._chartModel.panes()[this._initialPaneIndex],
						t = e !== this._chartModel.panes()[this._targetPaneIndex],
						i = (0, s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
					let o = e.getPriceScaleById(this._initialPriceScaleId);
					null === o && (o = e.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex));
					const r = this._chartModel.children(i, !0);
					for (const i of r) t ? (this._chartModel.detachSource(i), e.addDataSource(i, o, !1)) : e.move(i, o);
					t ? (this._chartModel.detachSource(i), e.addDataSource(i, o, !1)) : e.move(i, o), (0, s.ensureNotNull)(i.priceScale()).restoreState(this._originalPriceScaleState()), this._chartModel.fullUpdate()
				}
			}
			class n extends r {
				constructor(e, t, i, s, o) {
					super(e, t, i, o), this._targetPriceScalePosition = s
				}
				_targetPriceScale(e) {
					const t = e.createPriceScaleAtPosition(this._targetPriceScalePosition);
					return t.restoreState(this._newPriceScaleState("overlay" === this._targetPriceScalePosition)), t
				}
				_targetPriceScaleIndex(e) {
					return e === this._chartModel.mainSeries() ? 0 : void 0
				}
			}
			class a extends r {
				constructor(e, t, i, s, o) {
					super(e, t, i, o), this._targetPriceScaleId = s.id()
				}
				_targetPriceScale(e) {
					return (0, s.ensureNotNull)(e.getPriceScaleById(this._targetPriceScaleId))
				}
				_targetPriceScaleIndex(e) {}
			}
		},
		433904: (e, t, i) => {
			"use strict";
			i.d(t, {
				PriceScaleChangeUndoCommand: () => h
			});
			var s = i(588537),
				o = i(575932),
				r = i(277036),
				n = i(911905),
				a = i(72833);
			const l = (0, n.getLogger)("Chart.ChartUndoModel"),
				c = new r.TranslatedString("scale price", (0, o.t)("scale price"));
			class h extends a.UndoCommand {
				constructor(e, t, i, s, o) {
					super(c, !1), this._newPriceScaleState = null, this._model = e, this._paneIndex = e.panes().indexOf(t), this._priceScaleId = i.id(), this._state = s, this._timestamp = o ? performance.now() : null
				}
				undo() {
					if (null !== this._newPriceScaleState) return void l.logDebug("PriceScaleChangeUndoCommand.undo: Command is already undone");
					const [e, t] = this._paneAndScale();
					this._newPriceScaleState = t.state(), this._model.restorePriceScaleState(e, t, this._state)
				}
				redo() {
					if (null === this._newPriceScaleState) return void l.logDebug("PriceScaleChangeUndoCommand.redo: Command is not undone");
					const [e, t] = this._paneAndScale();
					this._model.restorePriceScaleState(e, t, this._newPriceScaleState), this._newPriceScaleState = null
				}
				canMerge(e) {
					return e instanceof h && null !== this._timestamp && null !== e._timestamp && null === this._newPriceScaleState && e._model === this._model && e._paneIndex === this._paneIndex && e._priceScaleId === this._priceScaleId && Math.abs(e._timestamp - this._timestamp) < 1e3
				}
				merge(e) {
					this._timestamp = e._timestamp
				}
				_paneAndScale() {
					const e = this._model.panes()[this._paneIndex],
						t = (0, s.ensureNotNull)(e.getPriceScaleById(this._priceScaleId));
					return [e, t]
				}
			}
		},
		43159: (e, t, i) => {
			"use strict";
			i.d(t, {
				RemoveLineDataSourcesUndoCommand: () => n
			});
			var s = i(588537),
				o = i(72833),
				r = i(148976);
			class n extends o.UndoCommand {
				constructor({
					title: e,
					chartModel: t,
					lineDataSourceIds: i
				}) {
					super(e), this._excludeLineToolsFromGroupUndoCommands = [], this._undoState = [], this._chartModel = t, this._lineDataSourceIds = i
				}
				redo() {
					const e = this._lineDataSourceIds.map((e => (0, s.ensureNotNull)(this._chartModel.dataSourceForId(e))));
					this._groupLineToolsByGroups(e).forEach(((e, t) => {
						const i = new r.ExcludeLineToolsFromGroupUndoCommand(this._chartModel, t, e);
						i.redo(), this._excludeLineToolsFromGroupUndoCommands.push(i)
					})), e.forEach((e => {
						this._undoState.push({
							state: e.state(!1),
							paneIndex: this._chartModel.panes().indexOf((0, s.ensureNotNull)(this._chartModel.paneForSource(e))),
							sharingMode: e.sharingMode().value()
						}), this._chartModel.removeSource(e)
					}))
				}
				undo() {
					var e;
					for (let t = this._undoState.shift(); t; t = this._undoState.shift()) null === (e = this._chartModel.restoreSource(!1, t.paneIndex, null, t.state, null)) || void 0 === e || e.share(t.sharingMode);
					this._excludeLineToolsFromGroupUndoCommands.forEach((e => e.undo()))
				}
				_groupLineToolsByGroups(e) {
					const t = this._chartModel.lineToolsGroupModel();
					return e.reduce(((e, i) => {
						const s = t.groupForLineTool(i);
						if (null !== s) {
							const t = e.get(s) || [];
							t.push(i), e.set(s, t)
						}
						return e
					}), new Map)
				}
			}
		},
		69318: (e, t, i) => {
			"use strict";
			i.d(t, {
				RemoveSourcesCommand: () => p
			});
			var s = i(588537),
				o = i(575932),
				r = i(277036),
				n = i(247001),
				a = i(72833),
				l = i(540968),
				c = i(911905),
				h = i(648488),
				d = i(140662),
				u = i(43159);
			const _ = (0, c.getLogger)("Chart.RemoveSourcesCommand"),
				m = new r.TranslatedString("remove line data sources", (0, o.t)("remove line data sources"));
			class p extends a.UndoCommand {
				constructor(e, t, i) {
					super(i), this._removeLineDataSourcesUndoCommand = null, this._initialPriceScaleMode = null;
					const [o, r] = (0, h.closeSourcesSet)(e, t).reduce(((e, t) => ((0, l.isLineTool)(t) ? e[1].push(t.id()) : e[0].push(t.id()), e)), [
						[],
						[]
					]);
					this._chartModel = e, this._sourceIds = o, this._lineDataSourceIds = r, this._sourceStates = [], this._paneIndexes = [], this._priceScalePositionIds = [], this._paneStates = [], this._restorePanes = [];
					const n = t[0];
					1 === t.length && (0, d.isStudy)(n) && (this._initialPriceScaleMode = (0, s.ensureNotNull)(n.priceScale()).mode())
				}
				removedIds() {
					return [...this._sourceIds, ...this._lineDataSourceIds]
				}
				redo() {
					const e = this._chartModel.panes().length,
						t = this._sourceIds.map((e => (0, s.ensureNotNull)(this._chartModel.dataSourceForId(e))));
					this._sourceStates = t.map((e => (0, s.ensureNotNull)(e.state(!1))));
					const i = t.map((e => (0, s.ensureNotNull)(this._chartModel.paneForSource(e))));
					this._paneIndexes = i.map((e => this._chartModel.panes().indexOf(e))), this._lineDataSourceIds.length > 0 && (this._removeLineDataSourcesUndoCommand = new u.RemoveLineDataSourcesUndoCommand({
						title: m,
						chartModel: this._chartModel,
						lineDataSourceIds: this._lineDataSourceIds
					}), this._removeLineDataSourcesUndoCommand.redo()), this._priceScalePositionIds = t.map(((e, t) => {
						const s = e.priceScale();
						if (null === s) return null;
						const o = i[t].priceScalePosition(s);
						return {
							id: s.id(),
							position: o,
							priceScaleIndex: i[t].priceScaleIndex(s, o)
						}
					}));
					const o = new Set;
					t.forEach(((e, t) => {
						o.add(this._paneIndexes[t])
					})), this._paneStates = t.map(((e, t) => {
						const s = this._paneIndexes[t];
						return o.has(s) ? i[t].state(!1, !0) : null
					})), this._restorePanes = t.map((e => this._chartModel.removeSource(e))), t.forEach((e => {
						(0, d.isStudy)(e) && (0, n.trackStudies)(e, "remove")
					})), e !== this._chartModel.panes().length && this._chartModel.setShouldBeSavedEvenIfHidden(!0)
				}
				undo() {
					const e = [];
					for (let t = this._sourceStates.length - 1; t >= 0; t--) {
						const i = this._chartModel.restoreSource(this._restorePanes[t], this._paneIndexes[t], this._paneStates[t], this._sourceStates[t], this._priceScalePositionIds[t]);
						i && e.push(i)
					}
					e.some(((t, i) => t.id() !== this._sourceIds[e.length - i - 1])) && _.logError("Source was restored improperly - source ids does not match"), null !== this._initialPriceScaleMode && (0, s.ensureNotNull)(e[0].priceScale()).setMode(this._initialPriceScaleMode), this._removeLineDataSourcesUndoCommand && this._removeLineDataSourcesUndoCommand.undo()
				}
			}
		},
		852545: (e, t, i) => {
			"use strict";
			i.d(t, {
				RestoreDefaultsPreferencesUndoCommand: () => m
			});
			var s = i(588537),
				o = i(575932),
				r = i(277036),
				n = i(72833),
				a = i(507942),
				l = i(940448),
				c = i(932255),
				h = i(374097),
				d = i(110933),
				u = i(733133);
			const _ = new r.TranslatedString("apply all chart properties", (0, o.t)("apply all chart properties"));
			class m extends n.UndoCommand {
				constructor(e) {
					super(_), this._trading = null, this._oldShowSellBuyButtons = null, this._oldNoConfirmEnabled = null, this._oldShowOnlyRejectionNotifications = null, this._oldShowPricesWithZeroVolume = null, this._oldShowPricesWithSpread = null, this._oldOrderExecutedSoundEnabled = null, this._prevWatermarkPreferences = null, this._model = e, this._trading = (0, d.tradingService)(), null !== this._trading && (this._oldShowSellBuyButtons = this._trading.showSellBuyButtons.value(), this._oldNoConfirmEnabled = this._trading.noConfirmEnabled.value(), this._oldShowOnlyRejectionNotifications = this._trading.showOnlyRejectionNotifications.value(), this._oldShowPricesWithZeroVolume = this._trading.showPricesWith().zeroVolume.value(), this._oldShowPricesWithSpread = this._trading.showPricesWith().spread.value(), this._oldOrderExecutedSoundEnabled = this._trading.orderExecutedSoundParams.enabled.value()), this._defaultsPreferences = (0, a.defaultsPreferencesByWhiteList)(this._model, this._model.mainSeries()), this._oldPreferences = e.preferences(), this._prevDateFormat = l.dateFormatProperty.value(), this._prevTimeHoursFormat = c.timeHoursFormatProperty.value(), this._prevAddPlusButton = u.addPlusButtonProperty.value(), this._prevShowOpenMarkerStatus = h.showMarketOpenStatusProperty.value();
					const t = this._model.watermarkSource();
					null !== t && (this._prevWatermarkPreferences = t.properties().state())
				}
				redo() {
					null !== this._trading && (this._trading.showSellBuyButtons.setValue(!0), this._trading.noConfirmEnabled.setValue(!1), this._trading.showOnlyRejectionNotifications.setValue(!1), this._trading.showPricesWith().zeroVolume.setValue(!0), this._trading.showPricesWith().spread.setValue(!0), this._trading.orderExecutedSoundParams.enabled.setValue(!1)), this._model.applyPreferences(this._defaultsPreferences), this._model.mainSeries().onChartStyleChanged(), this._model.updateScales(), (0, l.restoreDateFormatSettingsValue)(), (0, c.restoreTimeHoursFormatSettingsValue)(), (0,
						u.restoreAddPlusButtonSettingsValue)(), (0, h.restoreShowMarketOpenStatusProperty)();
					const e = this._model.watermarkSource();
					null !== e && e.restorePropertiesDefaults()
				}
				undo() {
					null !== this._trading && (this._trading.showSellBuyButtons.setValue((0, s.ensureNotNull)(this._oldShowSellBuyButtons)), this._trading.noConfirmEnabled.setValue((0, s.ensureNotNull)(this._oldNoConfirmEnabled)), this._trading.showOnlyRejectionNotifications.setValue((0, s.ensureNotNull)(this._oldShowOnlyRejectionNotifications)), this._trading.showPricesWith().zeroVolume.setValue((0, s.ensureNotNull)(this._oldShowPricesWithZeroVolume)), this._trading.showPricesWith().spread.setValue((0, s.ensureNotNull)(this._oldShowPricesWithSpread)), this._trading.orderExecutedSoundParams.enabled.setValue((0, s.ensureNotNull)(this._oldOrderExecutedSoundEnabled))), this._model.applyPreferences(this._oldPreferences), this._model.mainSeries().onChartStyleChanged(), this._model.updateScales(), l.dateFormatProperty.setValue(this._prevDateFormat), c.timeHoursFormatProperty.setValue(this._prevTimeHoursFormat), h.showMarketOpenStatusProperty.setValue(this._prevShowOpenMarkerStatus), u.addPlusButtonProperty.setValue(this._prevAddPlusButton);
					const e = this._model.watermarkSource();
					null !== e && null !== this._prevWatermarkPreferences && e.properties().mergeAndFire(this._prevWatermarkPreferences)
				}
			}
		},
		999998: (e, t, i) => {
			"use strict";
			i.d(t, {
				SetPriceScaleCurrencyUndoCommand: () => n
			});
			var s = i(588537),
				o = i(72833),
				r = i(749473);
			class n extends o.UndoCommand {
				constructor(e, t, i, o) {
					super(o), this._newSourcesCurrencies = new Map, this._oldSourcesCurrencies = new Map, this._showFade = !1, this._chartWidget = i;
					const n = i.model().mainSeries();
					for (const i of e.seriesLikeSources()) {
						if (!i.isVisible()) continue;
						const e = t || (0, r.symbolOriginalCurrency)((0, s.ensureNotNull)(i.symbolInfo()));
						this._newSourcesCurrencies.set(i.id(), e), this._oldSourcesCurrencies.set(i.id(), i.currency()), this._showFade = this._showFade || i === n && i.currency() !== e
					}
				}
				redo() {
					this._applyCurrencies(this._newSourcesCurrencies)
				}
				undo() {
					this._applyCurrencies(this._oldSourcesCurrencies)
				}
				_applyCurrencies(e) {
					this._showFade && this._chartWidget.screen.show();
					const t = this._chartWidget.model().model();
					e.forEach(((e, i) => {
						(0, s.ensureNotNull)(t.dataSourceForId(i)).setCurrency(e)
					})), this._chartWidget.model().selectionMacro((e => {
						e.clearSelection()
					}))
				}
			}
		},
		587314: (e, t, i) => {
			"use strict";
			i.d(t, {
				SetPriceScaleModeCommand: () => n
			});
			var s = i(346090),
				o = i(72833),
				r = i(194459);
			class n extends o.UndoCommand {
				constructor(e, t, i, s) {
					super(i), this._newMode = e, this._priceScaleId = t.id(), this._model = s, this._oldMode = t.mode()
				}
				redo() {
					this._applyMode(this._newMode)
				}
				undo() {
					this._applyMode(this._oldMode)
				}
				_applyMode(e) {
					const t = this._findPriceScaleById();
					null !== t && ((0, s.saveDefaultProperties)(!0), t.setMode(e), (0, s.saveDefaultProperties)(!1), this._model && (this._model.recalculateAllPanes((0, r.viewportChangeEvent)()), this._model.lightUpdate()))
				}
				_findPriceScaleById() {
					const e = this._model.panes();
					for (let t = 0; t < e.length; t++) {
						const i = e[t].getPriceScaleById(this._priceScaleId);
						if (null !== i) return i
					}
					return null
				}
			}
		},
		426297: (e, t, i) => {
			"use strict";
			i.d(t, {
				SetPriceScaleSelectionStrategyCommand: () => a
			});
			var s = i(588537),
				o = i(72833),
				r = i(748863);
			class n {
				constructor(e) {
					this._leftScales = e.leftPriceScales().map((e => e.id())), this._rightScales = e.rightPriceScales().map((e => e.id()))
				}
				restorePane(e) {
					this._leftScales.reverse().map((t => (0, s.ensureNotNull)(e.getPriceScaleById(t)))).forEach((t => e.movePriceScale(t, "left"))), this._rightScales.reverse().map((t => (0, s.ensureNotNull)(e.getPriceScaleById(t)))).forEach((t => e.movePriceScale(t, "right")))
				}
			}
			class a extends o.UndoCommand {
				constructor(e, t, i) {
					super(i), this._chartModel = e, this._targetStrategy = (0, r.createPriceScaleSelectionStrategy)(t), this._initialState = e.panes().map((e => new n(e)))
				}
				redo() {
					this._chartModel.panes().forEach((e => e.setPriceScaleSelectionStrategy(this._targetStrategy))), this._chartModel.fullUpdate()
				}
				undo() {
					const e = this._chartModel.panes();
					for (let t = 0; t < e.length; t++) this._initialState[t].restorePane(e[t]);
					this._chartModel.fullUpdate()
				}
			}
		},
		160377: (e, t, i) => {
			"use strict";
			i.d(t, {
				SetPriceScaleUnitUndoCommand: () => n
			});
			var s = i(588537),
				o = i(72833),
				r = i(749473);
			class n extends o.UndoCommand {
				constructor(e, t, i, o) {
					super(o), this._newSourcesUnits = new Map, this._oldSourcesUnits = new Map, this._showFade = !1, this._chartWidget = i;
					const n = i.model().mainSeries();
					for (const i of e.seriesLikeSources()) {
						if (!i.isVisible()) continue;
						const e = t || (0, r.symbolOriginalUnit)((0, s.ensureNotNull)(i.symbolInfo()), this._chartWidget.model().model().unitConversionEnabled());
						this._newSourcesUnits.set(i.id(), e), this._oldSourcesUnits.set(i.id(), i.unit()), this._showFade = this._showFade || i === n && i.unit() !== e
					}
				}
				redo() {
					this._applyUnits(this._newSourcesUnits)
				}
				undo() {
					this._applyUnits(this._oldSourcesUnits)
				}
				_applyUnits(e) {
					this._showFade && this._chartWidget.screen.show();
					const t = this._chartWidget.model().model();
					e.forEach(((e, i) => {
						(0, s.ensureNotNull)(t.dataSourceForId(i)).setUnit(e)
					})), this._chartWidget.model().selectionMacro((e => {
						e.clearSelection()
					}))
				}
			}
		},
		467659: (e, t, i) => {
			"use strict";
			i.d(t, {
				SetScaleRatioPropertiesCommand: () => n
			});
			var s = i(72833),
				o = i(346090),
				r = i(194459);
			class n extends s.UndoCommand {
				constructor(e, t, i, s) {
					super(i), this._property = e, this._newValue = t, this._model = s, this._priceScale = this._model.mainSeries().priceScale(), this._oldValue = this._property.value(), this._oldMode = this._priceScale.mode()
				}
				redo() {
					this._oldValue = this._property.value(), this._oldMode = this._priceScale.mode(), (0, o.saveDefaultProperties)(!0), this._priceScale.setMode({
						autoScale: !1,
						percentage: !1,
						log: !1
					}), this._property.setValue(this._newValue), (0, o.saveDefaultProperties)(!1), this._model.recalculateAllPanes((0, r.viewportChangeEvent)()), this._model.lightUpdate()
				}
				undo() {
					(0, o.saveDefaultProperties)(!0), this._property.setValue(this._oldValue), this._priceScale.setMode(this._oldMode), (0, o.saveDefaultProperties)(!1), this._model.recalculateAllPanes((0, r.viewportChangeEvent)()), this._model.lightUpdate()
				}
			}
		},
		648488: (e, t, i) => {
			"use strict";

			function s(e, t) {
				let i = [];
				const o = e.children(t, !1);
				for (let t = 0; t < o.length; t++) i = i.concat(s(e, o[t]));
				return i.push(t), i
			}

			function o(e, t) {
				const i = new Set,
					o = t => {
						e.children(t, !1).forEach((e => {
							i.has(e) || (i.add(e), o(e))
						}))
					};
				return t.forEach(o), t.filter((e => !i.has(e))).map((t => s(e, t))).reduce(((e, t) => e.concat(t)), [])
			}
			i.d(t, {
				closeSourcesSet: () => o
			})
		},
		657624: (e, t, i) => {
			"use strict";
			i.d(t, {
				SwapChartsUndoCommand: () => a
			});
			var s = i(575932),
				o = i(277036),
				r = i(72833);
			const n = new o.TranslatedString("swap charts in the Layout", (0, s.t)("swap charts in the Layout"));
			class a extends r.UndoCommand {
				constructor(e, t, i) {
					super(n), this._swapper = e, this._from = t, this._to = i
				}
				redo() {
					this._swapper(this._from, this._to)
				}
				undo() {
					this._swapper(this._from, this._to)
				}
			}
		},
		558e3: (e, t, i) => {
			"use strict";
			i.d(t, {
				TimeScaleChangeUndoCommand: () => n
			});
			var s = i(911905),
				o = i(72833);
			const r = (0, s.getLogger)("Chart.ChartUndoModel");
			class n extends o.UndoCommand {
				constructor(e, t, i) {
					super(i, !1), this._newRightOffsetAndBarSpacing = null, this.setCustomFlag("doesnt_affect_save", !0), this._model = e, this._rightOffsetAndBarSpacing = t
				}
				undo() {
					if (null !== this._newRightOffsetAndBarSpacing) return void r.logDebug("TimeScaleChangeUndoCommand.undo: Command is already undone");
					const e = this._model.timeScale();
					this._newRightOffsetAndBarSpacing = {
						barSpacing: e.barSpacing(),
						rightOffset: e.rightOffset()
					}, e.setBarSpacing(this._rightOffsetAndBarSpacing.barSpacing), e.setRightOffset(this._rightOffsetAndBarSpacing.rightOffset), this._model.lightUpdate()
				}
				redo() {
					if (null === this._newRightOffsetAndBarSpacing) return void r.logDebug("TimeScaleChangeUndoCommand.redo: Command is not undone");
					const e = this._model.timeScale();
					e.setBarSpacing(this._newRightOffsetAndBarSpacing.barSpacing), e.setRightOffset(this._newRightOffsetAndBarSpacing.rightOffset), this._model.lightUpdate(), this._newRightOffsetAndBarSpacing = null
				}
			}
		},
		72833: (e, t, i) => {
			"use strict";
			i.d(t, {
				UndoCommand: () => o
			});
			var s = i(277036);
			class o {
				constructor(e, t = !0) {
					this._customFlags = {}, this._text = e || new s.TranslatedString("", ""), this._executeOnPush = t
				}
				text() {
					return this._text
				}
				executeOnPush() {
					return this._executeOnPush
				}
				customFlag(e) {
					return this._customFlags[e]
				}
				setCustomFlag(e, t) {
					this._customFlags[e] = t
				}
				canMerge(e) {
					return !1
				}
				merge(e) {
					throw new Error("Should be re-implemented in child classes")
				}
			}
		},
		440081: (e, t, i) => {
			"use strict";
			i.d(t, {
				createUndoHistory: () => u
			});
			var s = i(588537),
				o = i(878667),
				r = i(761233),
				n = i(72833);
			class a extends n.UndoCommand {
				constructor(e, t, i) {
					super(i), this._wv = e, this._newValue = t, this._oldValue = e.value()
				}
				redo() {
					this._wv.setValue(this._newValue)
				}
				undo() {
					this._wv.setValue(this._oldValue)
				}
			}
			var l = i(911905),
				c = i(97639),
				h = i.n(c);
			const d = (0, l.getLogger)("Common.UndoHistory");

			function u() {
				const e = [],
					t = new o.UndoStack,
					i = new o.UndoStack,
					n = new(h());

				function l(s) {
					if (e.length > 0) e[e.length - 1].addCommand(s);
					else {
						i.clear();
						const e = t.head(),
							o = e && e.text().originalText();
						e && e.canMerge(s) ? e.merge(s) : t.push(s);
						const r = s.text().originalText();
						"" !== r && r !== o && d.logNormal("DO: " + r)
					}
					s.executeOnPush() && s.redo(), e.length || n.fire(c())
				}

				function c() {
					const e = t.head(),
						s = i.head();
					return {
						enableUndo: !t.isEmpty(),
						undoText: void 0 === e ? void 0 : e.text().translatedText(),
						enableRedo: !i.isEmpty(),
						redoText: void 0 === s ? void 0 : s.text().translatedText()
					}
				}
				return {
					beginUndoMacro: function(t) {
						const i = new r.UndoMacroCommand(t);
						return e.push(i), i
					},
					clearStack: function() {
						t.clear(), i.clear(), n.fire(c())
					},
					createUndoCheckpoint: function() {
						return {
							lastActualCommand: t.isEmpty() ? null : t.head()
						}
					},
					endUndoMacro: function() {
						const t = (0, s.ensureDefined)(e.pop());
						t.isEmpty() || l(t)
					},
					pushUndoCommand: l,
					redo: function() {
						if (i.isEmpty()) return !1;
						const e = i.pop();
						return !!e && (e.redo(), t.push(e), d.logNormal("REDO: " + e.text().originalText()), n.fire(c()), !0)
					},
					redoStack: function() {
						return i
					},
					setWatchedValue: function(e, t, i, s) {
						if (e.value() !== t) {
							const o = new a(e, t, i);
							o.setCustomFlag("doesnt_affect_save", !!s), l(o), o.redo()
						}
					},
					undo: function() {
						if (t.isEmpty()) return !1;
						const e = t.pop();
						return !!e && (e.undo(), i.push(e), d.logNormal("UNDO: " + e.text().originalText()), n.fire(c()), !0)
					},
					undoStack: function() {
						return t
					},
					undoToCheckpoint: function(e) {
						for (; !t.isEmpty() && e.lastActualCommand !== t.head();) t.pop().undo();
						i.clear(), n.fire(c())
					},
					state: c,
					onChange: function() {
						return n
					}
				}
			}
		},
		761233: (e, t, i) => {
			"use strict";
			i.d(t, {
				UndoMacroCommand: () => o
			});
			var s = i(72833);
			class o extends s.UndoCommand {
				constructor(e) {
					super(e, !1), this._subcommands = []
				}
				addCommand(e) {
					this._subcommands.push(e)
				}
				isEmpty() {
					return 0 === this._subcommands.length
				}
				redo() {
					for (let e = 0; e < this._subcommands.length; e++) this._subcommands[e].redo()
				}
				undo() {
					for (let e = this._subcommands.length - 1; e >= 0; e--) this._subcommands[e].undo()
				}
				commands() {
					return this._subcommands
				}
			}
		},
		878667: (e, t, i) => {
			"use strict";
			i.d(t, {
				UndoStack: () => a
			});
			var s = i(72833),
				o = i(97639),
				r = i.n(o);
			const n = (0, i(911905).getLogger)("Common.UndoStack");
			class a {
				constructor() {
					this._commands = [], this._onChange = new(r())
				}
				onChange() {
					return this._onChange
				}
				isEmpty() {
					return 0 === this._commands.length
				}
				clear() {
					this.isEmpty() || (this._commands.length = 0, this._onChange.fire())
				}
				push(e) {
					if (!(e instanceof s.UndoCommand)) throw new TypeError("argument must be an instance of UndoCommand");
					this._commands.push(e), this._onChange.fire(e)
				}
				pop() {
					if (this.isEmpty()) return void n.logDebug("pop: undo stack is empty");
					const e = this._commands.pop();
					return this._onChange.fire(e), e
				}
				head() {
					if (!this.isEmpty()) return this._commands[this._commands.length - 1]
				}
			}
		},
		167977: (e, t, i) => {
			"use strict";
			i.d(t, {
				UnmergeDownUndoCommand: () => n,
				UnmergeUpUndoCommand: () => a,
				UnmergeToNewBottomPane: () => l
			});
			var s = i(588537),
				o = i(242133);
			class r extends o.MoveSourceUndoCommand {
				constructor(e, t, i) {
					super(e, t, i)
				}
				redo() {
					const e = (0, s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId)),
						t = (0, s.ensureNotNull)(this._chartModel.paneForSource(e)),
						i = this._chartModel.children(e, !0);
					t.bulkActionMacro((() => {
						i.forEach((e => this._chartModel.detachSource(e))), this._chartModel.detachSource(e)
					}));
					const o = this._chartModel.createPane(this.targetPaneIndex()),
						r = o.findSuitableScale(e);
					o.bulkActionMacro((() => {
						o.addDataSource(e, r, !1), i.forEach((e => o.addDataSource(e, r, !1)))
					})), (0, s.ensureNotNull)(e.priceScale()).restoreState(this._newPriceScaleState(o.isOverlay(e))), this._chartModel.fullUpdate(), this._chartModel.setShouldBeSavedEvenIfHidden(!0)
				}
				undo() {
					const e = (0, s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId)),
						t = (0,
							s.ensureNotNull)(this._chartModel.paneForSource(e)),
						i = this._chartModel.children(e, !0);
					t.bulkActionMacro((() => {
						i.forEach((e => this._chartModel.detachSource(e)));
						const t = this._chartModel.detachSource(e);
						(0, s.assert)(t, "Undo of detaching must remove pane")
					}));
					const o = this._chartModel.panes()[this._initialPaneIndex];
					let r = o.getPriceScaleById(this._initialPriceScaleId);
					null === r && (r = o.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex)), o.bulkActionMacro((() => {
						o.addDataSource(e, r, !0), i.forEach((e => o.addDataSource(e, r, !1)))
					})), (0, s.ensureNotNull)(e.priceScale()).restoreState(this._originalPriceScaleState()), this._chartModel.fullUpdate()
				}
			}
			class n extends r {
				constructor(e, t, i) {
					super(e, t, i)
				}
				targetPaneIndex() {
					return this._initialPaneIndex + 1
				}
			}
			class a extends r {
				constructor(e, t, i) {
					super(e, t, i)
				}
				targetPaneIndex() {
					return this._initialPaneIndex
				}
			}
			class l extends r {
				constructor(e, t, i) {
					super(e, t, i)
				}
				targetPaneIndex() {
					return this._chartModel.panes().length
				}
			}
		},
		705318: (e, t, i) => {
			"use strict";
			i.d(t, {
				unitConvertibleGroups: () => r,
				sourceNewUnitOnPinningToPriceScale: () => n
			});
			var s = i(992179),
				o = i(749473);

			function r(e, t, i) {
				const s = (0, o.symbolUnitConvertibleGroupsIfExist)(e, !0);
				if (null !== s) return s;
				const r = i.unitGroupById(t);
				return null === r ? [] : [r]
			}

			function n(e, t, i, o) {
				let n = null;
				if (i.unitConversionEnabled() && (0, s.isSymbolSource)(e)) {
					const s = i.availableUnits(),
						a = t.unit(s),
						l = e.unit(),
						c = null === l ? [] : r(e.symbolInfo(), l, s);
					null !== a && null !== a.selectedUnit && !a.allUnitsAreOriginal && a.selectedUnit !== l && (o && null === l || null !== l && s.convertible(l, c)) && (n = a.selectedUnit)
				}
				return n
			}
		},
		891585: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				watermarkProperty: () => d,
				restoreWatermarkPropertyDefaults: () => u
			});
			var s = i(724377),
				o = i(62802),
				r = i(232567),
				n = i.n(r);
			const a = "symbolWatermark",
				l = {
					visibility: !1,
					color: "rgba(80, 83, 94, 0.25)"
				};

			function c() {
				const e = o.getJSON(a);
				let t = Object.assign({}, l, e);
				if (void 0 === e) {
					if (void 0 !== o.getJSON("chartproperties")) {
						const e = o.getJSON("chartproperties").symbolWatermarkProperties;
						if (void 0 !== e) {
							const i = (0, s.tryParseRgba)(e.color);
							t = Object.assign(t, e), null !== i && (0 !== i[3] ? t.visibility = !0 : (i[3] = .25, t.color = (0, s.rgbaToString)(i)))
						}
					}
					delete t.transparency
				}
				return t
			}
			let h = null;

			function d() {
				return null === h && (h = new(n())(c()), o.onSync.subscribe(null, (() => {
					null !== h && h.mergeAndFire(c())
				})), h.listeners().subscribe(null, (() => {
					null !== h && o.setJSON(a, h.state())
				}))), h
			}

			function u() {
				null !== h && h.mergeAndFire(l)
			}
		},
		836966: (e, t, i) => {
			"use strict";
			var s = i(773547).translatedIntervalString,
				o = i(913324).getTranslatedSymbolDescription,
				r = i(588427).CHART_FONT_FAMILY,
				n = i(891585),
				a = n.watermarkProperty,
				l = n.restoreWatermarkPropertyDefaults,
				c = i(824112).drawScaled,
				h = i(385518).applyDefaultsOverrides,
				d = i(385518).applyPropertiesOverrides;
			const u = "symbolWatermarkProperties";
			t.Watermark = function(e, t) {
				var i = {},
					n = a();

				function _(e, t) {
					var s = e.font;
					return i.hasOwnProperty(s) || (i[s] = {}), i[s].hasOwnProperty(t) || (i[s][t] = e.measureText(t).width), i[s][t]
				}
				h(n, void 0, !1, u), n.listeners().subscribe(this, (function() {
					e.updateSource(this)
				})), this.destroy = function() {
					n.listeners().unsubscribeAll(this)
				}, this.properties = function() {
					return n
				}, this.restorePropertiesDefaults = function() {
					l()
				}, this.applyOverrides = function(e) {
					d(n, void 0, !1, e, u)
				};
				var m = {
					renderer: function(e, i) {
						return {
							draw: function(a, l) {
								c(a, l.pixelRatio, (function() {
									var l = t.symbolInfo();
									a.fillStyle = n.color.value();
									var c, h = l.name;
									/QUANDL/.test(l.exchange) && ((c = h.split(/\//)).length && (h = c[c.length - 1]));
									for (var d = {
											description: l.description,
											short_description: l.short_description,
											pro_name: l.pro_name,
											short_name: l.name,
											local_description: l.local_description,
											language: l.language
										}, u = [{
											text: h ? h + ", " + s(t.interval()) : "",
											font: "96px " + r,
											lineHeight: 117,
											vertOffset: 0
										}, {
											text: o(d) || "",
											font: "48px " + r,
											lineHeight: 58,
											vertOffset: 5
										}], m = 0, p = 0; p < u.length; p++) {
										if ((v = u[p]).text) {
											a.font = v.font;
											var g = _(a, v.text);
											v.zoom = g > i ? i / g : 1, m += v.lineHeight * v.zoom
										}
									}
									var S = Math.max((e - m) / 2, 0);
									for (p = 0; p < u.length; p++) {
										var v;
										(v = u[p]).text && (a.save(), a.translate(i / 2, S), a.textBaseline = "top", a.textAlign = "center", a.font = v.font, a.scale(v.zoom, v.zoom), a.fillText(v.text, 0, v.vertOffset), a.restore(), S += v.lineHeight * v.zoom)
									}
								}))
							}
						}
					},
					update: function() {}
				};
				this.paneViews = function() {
					return t.symbolInfo() && n.visibility.value() ? [m] : []
				}
			}
		},
		676024: (e, t, i) => {
			"use strict";
			i.d(t, {
				reorderDataSourcesStateZOrder: () => f,
				newLineToolZOrder: () => C,
				newStudyZOrder: () => w,
				moveAfterSource: () => L,
				moveBeforeSource: () => E
			});
			var s = i(540968),
				o = i(140662),
				r = i(404703),
				n = i(986607),
				a = i(377884);

			function l(e) {
				return (0, s.isLineTool)(e) && !e.isSpeciallyZOrderedSource()
			}

			function c(e) {
				return (0, o.isStudy)(e) && !e.isSpeciallyZOrderedSource()
			}

			function h(e, t) {
				return e.zorder - t.zorder
			}

			function d(e, t) {
				(0, n.isMainSeriesState)(e) ? e.zorder = 0: e.zorder = t
			}

			function u(e, t) {
				e.setZorder(t)
			}

			function _(e) {
				return e.zorder()
			}

			function m(e) {
				return Math.round(1e3 * e) / 1e3
			}

			function p(e, t) {
				const i = Math.max(e, t),
					s = Math.min(e, t);
				return Math.max(0, Math.ceil(i) - Math.floor(s) - 1)
			}

			function g(e, t, i) {
				let s = 0;
				const o = function(e, t) {
					const i = 1e3;
					return Math.abs(t * i - e * i) / i
				}(t, e);
				var r;
				return o > i ? (e = Math.trunc(e), s = Math.floor(o / (i + 1))) : (r = o / (i + 1), s = Math.floor(1e3 * r) / 1e3), {
					startZOrder: e,
					zOrderStep: s
				}
			}

			function S(e, t, i, s) {
				let o = e.length,
					r = t;
				for (let t = e.length - 1; t >= -1; t--)
					if (-1 === t || s(e[t])) {
						const s = t;
						let n = P(r);
						if (o - 1 === s) s >= 0 && i(e[s], n);
						else {
							const t = p(o, s);
							let a = 0;
							for (; 0 === a;) {
								const e = g(r, n, t);
								r = e.startZOrder, a = e.zOrderStep, 0 === a && (n -= 1e4, 0 === n && (n -= 1e4))
							}
							let l = o - 1;
							for (; l > s;) {
								const t = m(r - a);
								i(e[l], t), r = t, l--
							}
							s >= 0 && i(e[s], n)
						}
						r = n, o = s
					}
			}

			function v(e, t, i, s) {
				let o = -1,
					r = t;
				for (let t = 0; t <= e.length; t++)
					if (t === e.length || s(e[t])) {
						const s = t;
						let n = T(r);
						if (o + 1 === s) s <= e.length - 1 && i(e[s], n);
						else {
							const t = p(o, s);
							let a = 0;
							for (; 0 === a;) {
								const e = g(r, n, t);
								r = e.startZOrder, a = e.zOrderStep, 0 === a && (n += 1e4, 0 === n && (n += 1e4))
							}
							let l = o + 1;
							for (; l <= s - 1;) {
								const t = m(r + a);
								i(e[l], t), r = t, l++
							}
							s <= e.length - 1 && i(e[s], n)
						}
						r = n, o = s
					}
			}

			function f(e) {
				! function(e, t, i, s, o, r) {
					let n = null;
					const a = [];
					for (const o of e) t(o) ? (a.push(o), n = o) : (i(o) || s(o)) && a.push(o);
					a.sort(r), null !== n && o(n, 0);
					const l = null === n ? -1 : a.indexOf(n); - 1 !== l ? (S(a.slice(0, l), 0, o, i), v(a.slice(l + 1), 0, o, i)) : v(a, 0, o, i)
				}(e, n.isMainSeriesState, n.isStudyState, n.isLineToolState, d, h)
			}

			function b(e, t) {
				const i = Math.floor(e / 1e4);
				let s = t.get(i);
				return void 0 === s && (s = [], t.set(i, s)), s
			}

			function y(e, t, i, s, o, r) {
				let n = -1 / 0,
					a = 1 / 0,
					l = -1 / 0,
					c = 0;
				const h = new Map;
				for (let s = 0; s < e.length; ++s) {
					const r = e[s],
						d = o(r);
					t(r) ? (n = Math.max(n, d), b(d, h).push(r)) : i(r) && (d < 0 && (a = Math.min(a, d), l = Math.max(l, d)), c = Math.max(c, d))
				}
				if (r) {
					const e = Math.max(c, n),
						t = g(e, T(e), 1);
					return m(t.startZOrder + t.zOrderStep)
				}
				if (n === -1 / 0) {
					const e = a === 1 / 0 ? 0 : a,
						t = g(P(e), e, 1);
					return m(t.startZOrder + t.zOrderStep)
				}
				const d = g(n, T(n), 1);
				if (0 !== d.zOrderStep) return m(d.startZOrder + d.zOrderStep);
				const u = b(n, h).sort(((e, t) => o(e) - o(t)));
				let _ = P(o(u[0]));
				const p = T(_),
					S = g(_, p, u.length + 1).zOrderStep;
				return 0 !== S ? (u.forEach((e => {
					const t = m(_ + S);
					s(e, t), _ = t
				})), m(_ + S)) : m(p + 5e3)
			}

			function C(e, t) {
				return y(e, l, c, u, _, t)
			}

			function w(e) {
				let t = -1e4;
				for (const i of e) c(i) && (t = Math.min(t, i.zorder() - 1e4));
				return 0 === t ? -1e4 : t
			}

			function T(e) {
				const t = 1e4 * Math.ceil(e / 1e4);
				return t === e ? t + 1e4 : t
			}

			function P(e) {
				const t = 1e4 * Math.floor(e / 1e4);
				return t === e ? t - 1e4 : t
			}

			function M(e, t, i, s, o, r, n) {
				const l = t.length,
					{
						newItems: c,
						movedItemsStartIndex: h
					} = i > 0 ? (0, a.moveAfter)(e, t, i - 1) : (0, a.moveBefore)(e, t, 0);
				let d = !1;
				for (let t = h; t < h + l; t++)
					if (c[t] !== e[t]) {
						d = !0;
						break
					} if (!d) return;
				if (s(t[0])) return void(i < e.length && n(e[i]) < 0 ? v(c.slice(h + 1), 0, r, o) : S(c.slice(0, h), 0, r, o));
				t.some((e => o(e))) ? function(e, t, i, s, o, r) {
					let n, a, l = -1,
						c = -1;
					0 === i ? (c = x(e, i + t, s), a = r(e[c])) : i + t === e.length ? (l = I(e, i - 1, s), n = r(e[l])) : (l = I(e, i - 1, s), n = r(e[l]), c = x(e, i + t, s), a = r(e[c]));
					if ((void 0 === n || n < 0) && void 0 !== a && a <= 0) S(e.slice(0, c), a, o, s);
					else if ((void 0 === a || a > 0) && void 0 !== n && n >= 0) v(e.slice(l + 1), n, o, s);
					else {
						i + t < e.length - i ? S(e.slice(0, i + t), 0, o, s) : v(e.slice(i), 0, o, s)
					}
				}(c, l, h, o, r, n) : function(e, t, i, s, o, r, n) {
					let a, l;
					0 === i ? l = n(e[i + t]) : i + t === e.length ? a = n(e[i - 1]) : (a = n(e[i - 1]), l = n(e[i + t]));
					let c = 0,
						h = 0,
						d = 0,
						u = 0,
						_ = 0;
					if ((void 0 === a || a < 0) && void 0 !== l && l <= 0) {
						c = l;
						const e = g(c, void 0 !== a ? a : P(l), t);
						c = e.startZOrder, _ = e.zOrderStep, d = i + t - 1, u = d - t, h = -1
					} else if ((void 0 === l || l > 0) && void 0 !== a && a >= 0) {
						c = a;
						const e = g(c, void 0 !== l ? l : T(a), t);
						c = e.startZOrder, _ = e.zOrderStep, d = i, u = d + t, h = 1
					}
					if (0 !== _)
						for (; d !== u;) {
							const t = m(c + h * _);
							r(e[d], t), c = t, d += h
						} else {
							const t = e.findIndex((e => o(e))); - 1 !== t ? (S(e.slice(0, t), 0, r, s), v(e.slice(t + 1), 0, r, s)) : v(e, 0, r, s)
						}
				}(c, l, h, o, s, r, n)
			}

			function x(e, t, i) {
				for (; t < e.length && i(e[t]);) t++;
				return Math.min(t, e.length - 1)
			}

			function I(e, t, i) {
				for (; t >= 0 && i(e[t]);) t--;
				return Math.max(0, t)
			}

			function A(e, t, i, s, o, r, n) {
				const a = e.indexOf(i) + 1;
				M(e, t, a, s, o, r, n)
			}

			function k(e, t, i, s, o, r, n) {
				const a = e.indexOf(i);
				M(e, t, a, s, o, r, n)
			}

			function L(e, t, i) {
				A(e, t, i, r.isSeries, c, u, _)
			}

			function E(e, t, i) {
				k(e, t, i, r.isSeries, c, u, _)
			}
		},
		805048: (e, t, i) => {
			"use strict";
			i.d(t, {
				ActionCreators: () => m
			});
			var s = i(575932),
				o = i(588746),
				r = i(920358),
				n = i(97985),
				a = i(478398),
				l = i(789795),
				c = i(439970),
				h = i(951983),
				d = i(201457),
				u = i(535149),
				_ = i(133736);
			const m = {
				stopAlerts: (e, t, i) => new o.TVAction({
					label: t,
					icon: (null == i ? void 0 : i.showIcon) ? c : void 0,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((t => t.stopAlerts({
						confirmation: null == i ? void 0 : i.confirmation,
						ids: e.map((e => e.id))
					})))
				}),
				restartAlerts: (e, t, i) => new o.TVAction({
					label: t,
					icon: (null == i ? void 0 : i.showIcon) ? l : void 0,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((t => t.restartAlerts({
						confirmation: null == i ? void 0 : i.confirmation,
						ids: e.map((e => e.id))
					})))
				}),
				cloneAlerts: e => new o.TVAction({
					label: (0, s.t)("Clone"),
					icon: d,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((t => t.cloneAlerts({
						ids: e.map((e => e.id))
					})))
				}),
				deleteAlerts: (e, t, i) => new o.TVAction({
					label: t,
					icon: (null == i ? void 0 : i.showIcon) ? u : void 0,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((t => t.deleteAlerts({
						confirmation: null == i ? void 0 : i.confirmation,
						ids: e.map((e => e.id))
					})))
				}),
				stopAlert: (e, t) => new o.TVAction({
					label: (0, s.t)("Stop", {
						context: "alert"
					}),
					icon: c,
					onExecute: () => (null == t || t(), (0, r.getPriceAlertsDispatcher)().then((t => t.stopAlert(e))))
				}),
				restartAlert: (e, t) => new o.TVAction({
					label: (0, s.t)("Restart"),
					icon: l,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((i => i.restartAlert(e, {
						actionSource: t
					})))
				}),
				editAlert: (e, t, i, a) => new o.TVAction({
					label: i ? (0, n.appendEllipsis)((0, s.t)("Edit alert")) : (0, n.appendEllipsis)((0, s.t)("Edit")),
					icon: h,
					onExecute: () => (null == a || a(), (0, r.getPriceAlertsDispatcher)().then((i => i.openEditDialog(e, {
						actionSource: t
					}))))
				}),
				cloneAlert: (e, t, i) => new o.TVAction({
					label: (0, s.t)("Clone"),
					icon: d,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((s => s.cloneAlert(e, {
						actionSource: t,
						eventLabel: i
					})))
				}),
				deleteAlert: (e, t) => new o.TVAction({
					label: (0, s.t)("Remove"),
					icon: u,
					onExecute: () => {
						null == t || t(), (0, r.getPriceAlertsDispatcher)().then((t => t.deleteAlert(e, {
							showConfirm: !0
						})))
					}
				}),
				restartAllAlerts: (e, t) => new o.TVAction({
					label: (0, a.bulkRestartLabel)(Boolean(e || t)),
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((i => i.restartAllAlerts({
						showConfirm: !0,
						symbol: e,
						resolution: t,
						active: !1
					})))
				}),
				stopAllAlerts: (e, t) => new o.TVAction({
					label: (0, a.bulkStopLabel)(Boolean(e || t)),
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((i => i.stopAllAlerts({
						showConfirm: !0,
						symbol: e,
						resolution: t
					})))
				}),
				deleteAllInactiveAlerts: () => new o.TVAction({
					label: (0, a.bulkRemoveInactiveLabel)(),
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((e => e.deleteAllAlerts({
						active: !1,
						showConfirm: !0,
						symbol: null,
						resolution: null
					})))
				}),
				deleteAllAlerts: (e, t, i) => new o.TVAction({
					label: (0, a.bulkRemoveLabel)(Boolean(e || t || i)),
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((s => s.deleteAllAlerts({
						showConfirm: !0,
						symbol: e,
						resolution: t,
						active: !!i || null
					})))
				}),
				deleteAllEvents: () => new o.TVAction({
					label: (0, s.t)("Clear Log"),
					icon: _,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((e => e.deleteEvents()))
				}),
				deleteEvents: e => new o.TVAction({
					label: (0, s.t)("Remove"),
					icon: u,
					onExecute: () => (0, r.getPriceAlertsDispatcher)().then((t => t.deleteEvents({
						ids: e.map((e => e.id))
					})))
				})
			}
		},
		89615: (e, t, i) => {
			"use strict";

			function s(e = 0) {
				return e < 1e3 ? e : e / 1e3
			}

			function o(e, t) {
				if (e.length > t) {
					const i = /[\W]+$/g,
						s = e.substring(0, t),
						o = s.replace(i, "");
					return `${o.length?o:s.substring(0,t-1)}`
				}
				return e
			}
			i.d(t, {
				ensureDurationInSeconds: () => s,
				cutString: () => o
			})
		},
		987433: (e, t, i) => {
			"use strict";
			i.d(t, {
				confirmDatasourceRemoving: () => r
			});
			var s = i(575932),
				o = i(779923);

			function r() {
				return new Promise((e => (0, o.showConfirm)({
					text: (0, s.t)("This drawing is used in alert. If you remove the drawing, the alert will be also removed. Do you want to remove the drawing anyway?"),
					onConfirm: ({
						dialogClose: t
					}) => {
						e(!0), t()
					},
					onClose: () => e(!1)
				})))
			}
		},
		478398: (e, t, i) => {
			"use strict";
			i.d(t, {
				bulkStopLabel: () => r,
				bulkRestartLabel: () => n,
				bulkRemoveLabel: () => a,
				bulkRemoveInactiveLabel: () => l,
				bulkStopConfirmation: () => c,
				bulkRestartConfirmation: () => h,
				bulkRemoveConfirmation: () => d,
				bulkRemoveInactiveConfirmation: () => u,
				selectedRemoveConfirmation: () => _
			});
			var s = i(575932),
				o = i(89615);
			const r = e => e ? (0, s.t)("Stop as per filter") : (0, s.t)("Stop all"),
				n = e => e ? (0, s.t)("Restart as per filter") : (0, s.t)("Restart all inactive"),
				a = e => e ? (0, s.t)("Remove as per filter") : (0, s.t)("Remove all"),
				l = () => (0, s.t)("Remove all inactive"),
				c = e => e ? {
					title: (0, s.t)("Stop filtered alerts"),
					text: (0, s.t)("Need a quick break from filtered alerts?")
				} : {
					title: (0, s.t)("Stop all alerts"),
					text: (0, s.t)("Need a quick break from your alerts?")
				},
				h = e => e ? {
					title: (0, s.t)("Restart filtered alerts"),
					text: (0, s.t)("Ready to bring filtered alerts back to life?")
				} : {
					title: (0, s.t)("Restart all inactive alerts"),
					text: (0, s.t)("Ready to bring your alerts back to life?")
				},
				d = e => e ? {
					title: (0, s.t)("Delete filtered alerts"),
					text: (0, s.t)("Do you really want to delete filtered alerts?")
				} : {
					title: (0, s.t)("Delete all alerts"),
					text: (0, s.t)("Ready to delete your alerts and start over?")
				},
				u = () => ({
					title: (0, s.t)("Delete inactive alerts"),
					text: (0, s.t)("Delete all your inactive alerts so you can create new ones?")
				}),
				_ = e => {
					if (1 !== e.length) return {
						title: (0, s.t)("Delete selected alerts"),
						text: (0, s.t)("Do you really want to delete selected alerts?")
					};
					const t = e[0],
						i = t.get("name") || t.get("description") || t.title();
					return {
						title: (0, s.t)("Delete alert"),
						text: (0, s.t)("Do you really want to delete your alert '{alert}'?").format({
							alert: (0, o.cutString)(i, 100)
						})
					}
				}
		},
		68446: (e, t, i) => {
			"use strict";

			function s(e, t, i = "promise rejected by time-out") {
				return new Promise(((s, o) => {
					const r = setTimeout((() => o(i)), t);
					e.then((e => {
						clearTimeout(r), s(e)
					})), e.catch((e => {
						clearTimeout(r), o(e)
					}))
				}))
			}
			i.d(t, {
				makeTimeLimited: () => s
			})
		},
		779592: (e, t, i) => {
			"use strict";

			function s() {
				return Promise.all([i.e(90519), i.e(90926), i.e(48181), i.e(8834), i.e(35354), i.e(30063), i.e(91670), i.e(82073), i.e(75514), i.e(92697), i.e(32077)]).then(i.bind(i, 341286))
			}
			i.d(t, {
				loadChangeIntervalDialog: () => s
			})
		},
		544998: (e, t, i) => {
			"use strict";
			i.d(t, {
				showChangeIntervalDialogAsync: () => r
			});
			var s = i(779592);
			let o = null;

			function r(e) {
				const t = o = (0, s.loadChangeIntervalDialog)().then((i => {
					t === o && i.showChangeIntervalDialog(e)
				}));
				return t
			}
		},
		578101: (e, t, i) => {
			"use strict";

			function s(e) {
				return Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(30063), i.e(91670), i.e(63280), i.e(80580), i.e(68074), i.e(52498), i.e(9935), i.e(50522), i.e(77542), i.e(92617), i.e(97430), i.e(45410), i.e(82290), i.e(59697), i.e(88314), i.e(75514), i.e(97974), i.e(92697), i.e(68985), i.e(18611), i.e(38277), i.e(91859)]).then(i.bind(i, 450656)).then((t => t.showGoToDateDialog(e)))
			}
			i.d(t, {
				showGoToDateDialog: () => s
			})
		},
		291246: (e, t, i) => {
			"use strict";
			async function s(e) {
				(await Promise.all([i.e(90519), i.e(90926), i.e(8834), i.e(30063), i.e(99740), i.e(77301), i.e(75966), i.e(34778), i.e(75514), i.e(92697), i.e(84268), i.e(26066)]).then(i.bind(i, 622518))).renderGoToTradingViewReferralDialog(e)
			}
			i.d(t, {
				showGoToTradingViewReferralDialog: () => s
			})
		},
		427840: (e, t, i) => {
			"use strict";
			i.d(t, {
				showDeleteStudyTreeConfirm: () => r
			});
			var s = i(575932),
				o = i(779923);

			function r(e) {
				(0, o.showConfirm)({
					title: (0, s.t)("Confirm Remove Study Tree"),
					text: (0, s.t)("Do you really want to delete study and all of it's children?"),
					onConfirm: ({
						dialogClose: t
					}) => {
						e(), t()
					}
				})
			}
		},
		891075: (e, t, i) => {
			"use strict";

			function s(e, t) {
				Promise.all([i.e(90519), i.e(90926), i.e(8834), i.e(30063), i.e(73836), i.e(90929), i.e(75514), i.e(92697), i.e(9374)]).then(i.bind(i, 311461)).then((i => {
					i.showSymbolInfoDialog(null != e ? e : null, t)
				}))
			}
			i.d(t, {
				showSymbolInfoDialog: () => s
			})
		},
		87772: (e, t, i) => {
			"use strict";
			i.d(t, {
				Worker: () => s
			});
			class s extends Worker {
				constructor(e, t) {
					super(function(e) {
						const t = new URL(e);
						if (t.origin === location.origin) return t;
						const s = new Blob(["self.WEBPACK_PUBLIC_PATH=", JSON.stringify(new URL(i.p, location.href).href), ";\n", "importScripts(", JSON.stringify(t.href), ");"], {
							type: "application/javascript"
						});
						return URL.createObjectURL(s)
					}(e), t)
				}
			}
		},
		357547: (e, t, i) => {
			"use strict";
			i.d(t, {
				workerBasedTimers: () => r
			});
			var s = i(761068),
				o = i(87772);
			const r = new class {
				constructor() {
					this._timerWorker = null, this._timerIdCounter = 1, this._timersMap = new Map, this._rejectsToCall = new Set, this._processMessage = e => {
						const t = this._timersMap.get(e.data.turnaround);
						switch (e.data.type) {
							case "timerCreated":
								t && (t.scheduledForRemoving ? ("interval" === t.type ? this._getTimerWorker().postMessage({
									type: "clearInterval",
									id: e.data.id
								}) : this._getTimerWorker().postMessage({
									type: "clearTimeout",
									id: e.data.id
								}), this._deleteTimerFromMap(e.data.turnaround)) : t.workerTimerId = e.data.id);
								break;
							case "timerFired":
								t && (t.callback(), "timeout" === t.type && this._deleteTimerFromMap(e.data.turnaround))
						}
					}
				}
				destroy() {
					var e;
					this._rejectsToCall.forEach((e => e((0, s.createAbortError)()))), null === (e = this._timerWorker) || void 0 === e || e.terminate(), this._timerWorker = null, this._timersMap.clear()
				}
				setTimeout(e, t) {
					return this._setTimeoutImpl(e, t, "timeout")
				}
				clearTimeout(e) {
					const t = this._timersMap.get(e);
					t && (t.workerTimerId ? (this._getTimerWorker().postMessage({
						type: "clearTimeout",
						id: t.workerTimerId
					}), this._deleteTimerFromMap(e)) : t.scheduledForRemoving = !0)
				}
				setInterval(e, t) {
					const i = this._nextTimerId();
					return this._timersMap.set(i, {
						callback: e,
						type: "interval"
					}), this._getTimerWorker().postMessage({
						type: "setInterval",
						delay: t,
						turnaround: i
					}), i
				}
				clearInterval(e) {
					const t = this._timersMap.get(e);
					t && (t.workerTimerId ? (this._getTimerWorker().postMessage({
						type: "clearInterval",
						id: t.workerTimerId
					}), this._deleteTimerFromMap(e)) : t.scheduledForRemoving = !0)
				}
				async createTimeout(e, t) {
					let i;
					return new Promise(((o, r) => {
						var n;
						i = r, this._rejectsToCall.add(i);
						const a = this.setTimeout(o, e);
						null === (n = null == t ? void 0 : t.signal) || void 0 === n || n.addEventListener("abort", (() => {
							this.clearTimeout(a), r((0, s.createAbortError)())
						}))
					})).finally((() => {
						this._rejectsToCall.delete(i)
					}))
				}
				async *createInterval(e, t) {
					let i = () => {},
						o = e => {};
					const r = this.setInterval((() => {
						i()
					}), e);
					t.signal.addEventListener("abort", (() => {
						this.clearInterval(r), o((0, s.createAbortError)())
					}));
					try {
						for (;;) await new Promise(((e, t) => {
							i = e, this._rejectsToCall.delete(o), o = t, this._rejectsToCall.add(o)
						})), yield
					} catch (e) {
						if (!(0, s.isAbortError)(e)) throw e
					}
				}
				_getTimerWorker() {
					return null === this._timerWorker && (this._timerWorker = new o.Worker(new URL(i.p + i.u(77050), i.b), {
						name: "Timer worker"
					}), this._timerWorker.onmessage = this._processMessage), this._timerWorker
				}
				_setTimeoutImpl(e, t, i) {
					const s = this._nextTimerId();
					return this._timersMap.set(s, {
						callback: e,
						type: i
					}), this._getTimerWorker().postMessage({
						type: "setTimeout",
						delay: t,
						turnaround: s
					}), s
				}
				_deleteTimerFromMap(e) {
					if (this._timersMap.delete(e), 0 === this._timersMap.size) {
						const e = this._setTimeoutImpl((() => {
							var t;
							1 === this._timersMap.size && this._timersMap.has(e) && (this._timersMap.delete(e), null === (t = this._timerWorker) || void 0 === t || t.terminate(), this._timerWorker = null)
						}), 6e4, "terminal_timer")
					}
				}
				_nextTimerId() {
					return this._timerIdCounter++
				}
			}
		},
		388482: (e, t, i) => {
			"use strict";
			i.d(t, {
				getChartStorage: () => r
			});
			var s = i(594520);
			let o = null;

			function r() {
				return null === o && (o = new s.ChartStorageHttp), o
			}
		},
		594520: (e, t, i) => {
			"use strict";
			i.d(t, {
				parseLineToolsAndGroupsDTO: () => c,
				ChartStorageHttp: () => d
			});
			var s = i(86674),
				o = i(895370),
				r = i(175203),
				n = i(45696),
				a = i(198303);

			function l() {
				const e = document.querySelector('link[rel~="chart-storage"]'),
					t = new URL((null == e ? void 0 : e.href) || "/charts-storage/", location.href);
				return t.pathname.endsWith("/") || (t.pathname += "/"), t
			}

			function c(e, t) {
				const i = {
					sources: new Map,
					groups: new Map
				};
				for (const t in e.sources || {}) {
					const s = e.sources[t];
					i.sources.set(t, s)
				}
				for (const t in e.drawing_groups || {}) {
					const s = e.drawing_groups[t];
					i.groups.set(t, s)
				}
				return null !== t && (i.serverRequestId = t), i.clientId = e.clientId, i
			}

			function h(e) {
				const {
					charts: t = {},
					countSourcesTotal: i = 0,
					limitBytesTotal: s = 0,
					sizeBytesTotal: o = 0
				} = e, r = new Map;
				for (const e in t) {
					const i = t[e].symbols,
						s = new Map;
					for (const e in i || {}) {
						const t = i[e];
						s.set(e, {
							countSources: t.countSources,
							sizeBytes: t.sizeBytes,
							ids: t.ids
						})
					}
					r.set(e, s)
				}
				return {
					charts: r,
					countSourcesTotal: i,
					limitBytesTotal: s,
					sizeBytesTotal: o
				}
			}
			class d {
				constructor() {
					this._lastSaveRequest = Promise.resolve(), this._requestsCounter = 0
				}
				async saveLineToolsAndGroups(e, t, i, c) {
					if ("" === e || void 0 === e) return Promise.reject("Unnamed chart cannot be saved");
					const h = `${e}.${t}.${this._requestsCounter++}`,
						d = `ChartStorage.Save.TotallyProcessing.${h}`,
						u = (0, o.perfMeasureOperation)(d, (() => this._lastSaveRequest.then((async () => {
							const d = `ChartStorage.Save.GettingToken.${h}`,
								u = await (0, o.perfMeasureOperation)(d, (() => (0, n.getStorageTarget)(e, t, c))),
								_ = new URL(u.path, l());
							u.chartId && _.searchParams.append("chart_id", u.chartId), _.searchParams.append("jwt", u.token);
							const m = function(e) {
									const t = {
										sources: {}
									};
									return e.sources.forEach(((e, i) => {
										t.sources[i] = e
									})), t.drawing_groups = {}, e.groups.forEach(((e, i) => {
										t.drawing_groups[i] = e
									})), t.clientId = e.clientId, JSON.stringify(t)
								}(i),
								p = `ChartStorage.Save.GettingResponse.${h}`;
							return (0, o.perfMeasureOperation)(p, (() => (0, s.fetch)(_.toString(), {
								method: "PUT",
								headers: {
									"Content-Type": "application/json",
									"X-BUILD-TIME": window.BUILD_TIME
								},
								credentials: "include",
								body: m
							}).then((e => {
								if (!e.ok) {
									const t = 429 === e.status;
									throw new a.SavingLineToolsError(t, `Response status is not success: ${e.status}`)
								}
								const t = e.json();
								return r.telemetry.sendLineToolsStorageReport("line_tools_save_success"), t
							})).then((s => ({
								content: s,
								savedDto: i,
								layoutId: e,
								chartId: t,
								sharingMode: c
							})))))
						}))));
					return this._lastSaveRequest = u.catch((e => {
						r.telemetry.sendLineToolsStorageReport("line_tools_save_error")
					})), u
				}
				async loadLineToolsAndGroups(e, t, i) {
					if ("" === e || void 0 === e) return {
						sources: new Map,
						groups: new Map
					};
					const a = `${e}.${t}.${i.requestType}.${this._requestsCounter++}`,
						h = `ChartStorage.Load.GettingToken.${a}`,
						d = await (0, o.perfMeasureOperation)(h, (() => (0, n.getStorageTarget)(e, t, i.sharingMode))),
						u = new URL(d.path, l());
					switch (d.chartId && u.searchParams.append("chart_id", d.chartId), u.searchParams.append("jwt", d.token), i.requestType) {
						case "mainSeriesLineTools":
							u.searchParams.append("symbol", i.symbol), 0 === i.sharingMode && u.searchParams.append("includeOwnerSource", i.seriesSourceId), u.searchParams.append("brokerName", i.brokerName);
							break;
						case "studiesLineTools":
							u.searchParams.append("excludeOwnerSource", i.seriesSourceId);
							break;
						case "lineToolsWithoutSymbol":
							u.searchParams.append("symbol", ""), 0 === i.sharingMode && u.searchParams.append("includeOwnerSource", i.seriesSourceId)
					}
					const _ = `ChartStorage.Load.GettingResponse.${a}`;
					return (0, o.perfMeasureOperation)(_, (() => (0, s.fetch)(u.toString(), {
						method: "GET",
						credentials: "include"
					}).then((e => {
						if (!e.ok) throw new Error("Response status is not success");
						const t = e.headers.get("X-Request-Id");
						return e.json().then((e => {
							if (null === e) throw new Error("Body is null");
							if (!e.success) throw new Error("Response is not success");
							const i = c(e.payload || {}, t);
							return r.telemetry.sendLineToolsStorageReport("line_tools_load_success"), i
						}))
					})))).catch((e => {
						throw r.telemetry.sendLineToolsStorageReport("line_tools_load_error"), e
					}))
				}
				async removeLineTools(e, t, i, a) {
					if ("" === e || void 0 === e) return !1;
					const c = `${e}.${t}.${this._requestsCounter++}`,
						h = `ChartStorage.Remove.GettingToken.${c}`,
						d = await (0, o.perfMeasureOperation)(h, (() => (0, n.getStorageTarget)(e, t, i))),
						u = new URL(d.path, l());
					d.chartId && u.searchParams.append("chart_id", d.chartId), u.searchParams.append("jwt", d.token), u.searchParams.append("symbol", a);
					const _ = `ChartStorage.Remove.GettingResponse.${c}`;
					return (0, o.perfMeasureOperation)(_, (() => (0, s.fetch)(u.toString(), {
						method: "DELETE",
						credentials: "include"
					}).then((e => {
						if (!e.ok) throw new Error("Response status is not success");
						return e.json().then((e => {
							if (null === e) throw new Error("Body is null");
							if (!e.success) throw new Error("Response is not success");
							return r.telemetry.sendLineToolsStorageReport("line_tools_remove_by_symbol_success"), !0
						}))
					})))).catch((e => {
						throw r.telemetry.sendLineToolsStorageReport("line_tools_remove_by_symbol_error"), e
					}))
				}
				async getLayoutDrawingsSizeInfo(e, t) {
					if ("" === e || void 0 === e) return {
						charts: new Map,
						countSourcesTotal: 0,
						limitBytesTotal: 0,
						sizeBytesTotal: 0
					};
					const i = `${e}.${t}.${this._requestsCounter++}`,
						s = `ChartStorage.GetSizes.GettingToken.${i}`,
						a = await (0, o.perfMeasureOperation)(s, (() => (0, n.getStorageTarget)(e, t, 0))),
						c = new URL(`layout/${e}/sizes`, l());
					return c.searchParams.append("jwt", a.token), this._fetchData(`ChartStorage.GetSizes.GettingResponse.${i}`, c, {
						method: "GET",
						credentials: "include"
					}).then((e => (r.telemetry.sendLineToolsStorageReport("line_tools_size_info_success"), h(e || {})))).catch((e => {
						throw r.telemetry.sendLineToolsStorageReport("line_tools_size_info_error"), e
					}))
				}
				async getUserGlobalDrawingsSizeInfo(e) {
					if ("" === e || void 0 === e) return {
						charts: new Map,
						countSourcesTotal: 0,
						limitBytesTotal: 0,
						sizeBytesTotal: 0
					};
					const t = this._requestsCounter++,
						i = await (0, o.perfMeasureOperation)(`ChartStorage.GetGlobalSizes.GettingToken.${t}`, (() => (0, n.getStorageTarget)(e, "", 2))),
						s = new URL("user/sizes", l());
					return s.searchParams.append("jwt", i.token), this._fetchData(`ChartStorage.GetGlobalSizes.GettingResponse.${t}`, s, {
						credentials: "include"
					}).then((e => (r.telemetry.sendLineToolsStorageReport("global_line_tools_size_info_success"), h(e || {})))).catch((e => {
						throw r.telemetry.sendLineToolsStorageReport("global_line_tools_size_info_error"), e
					}))
				}
				async _fetchData(e, t, i) {
					const r = await (0, o.perfMeasureOperation)(e, (() => (0, s.fetch)(t.toString(), i)));
					if (!r.ok) throw new Error("Response status is not success");
					const n = await r.json();
					if (null === n) throw new Error("Body is null");
					if (!n.success) throw new Error("Response is not success");
					return n.payload
				}
			}
		},
		45696: (e, t, i) => {
			"use strict";
			i.d(t, {
				sharedChartId: () => r,
				globallySharedChartId: () => n,
				getStorageTarget: () => a
			});
			var s = i(175203),
				o = i(761068);
			const r = "_shared",
				n = "UserSync";
			async function a(e, t, i, n) {
				try {
					const a = new URL("/chart-token/", location.href);
					a.searchParams.append("image_url", e);
					const l = window.user.id || -1;
					a.searchParams.append("user_id", "" + l);
					const c = await fetch(a.toString(), {
						signal: n
					});
					if (!c.ok) throw new Error(`Http response is not ok: ${c.status}}`);
					const h = await c.json();
					if (s.telemetry.sendLineToolsStorageReport("line_tools_token_request_success"), null == n ? void 0 : n.aborted) throw (0, o.createAbortError)();
					let d = t;
					return 2 === i ? d = void 0 : 1 === i && (d = r), {
						token: h.token,
						chartId: d,
						path: 2 === i ? "user/sources" : `layout/${e}/sources`
					}
				} catch (e) {
					throw (0, o.isAbortError)(e) || s.telemetry.sendLineToolsStorageReport("line_tools_token_request_error"), e
				}
			}
		},
		198303: (e, t, i) => {
			"use strict";
			i.d(t, {
				SavingLineToolsError: () => s
			});
			class s extends Error {
				constructor(e, t) {
					super(t), this.shouldBeCooled = e
				}
			}
		},
		196726: (e, t, i) => {
			"use strict";
			i.d(t, {
				preventDefault: () => o,
				wrapHandlerWithPreventEvent: () => r,
				preventScrollByWheelClick: () => n
			});
			var s = i(638456);

			function o(e) {
				e.cancelable && e.preventDefault()
			}

			function r(e) {
				return t => {
					o(t), e()
				}
			}

			function n(e) {
				s.isChrome && e.addEventListener("mousedown", (e => {
					if (1 === e.button) return e.preventDefault(), !1
				}))
			}
		},
		359663: (e, t, i) => {
			"use strict";
			i.d(t, {
				FeatureToggleWatchedValue: () => n
			});
			var s = i(125226),
				o = i(262325),
				r = i.n(o);
			class n extends(r()) {
				constructor(e, t) {
					super(function(e, t) {
						return (0, s.isFeatureEnabled)(e)
					}(e)), (0, s.onFeaturesStateChanged)().subscribe(this, (t => {
						e === t && this.setValue((0, s.isFeatureEnabled)(e))
					}))
				}
				destroy() {
					(0, s.onFeaturesStateChanged)().unsubscribeAll(this)
				}
			}
		},
		895370: (e, t, i) => {
			"use strict";
			i.d(t, {
				addPerfMark: () => c,
				perfMeasureOperation: () => h
			});
			var s = i(95935);

			function o() {}
			const r = console.timeStamp ? console.timeStamp.bind(console) : o,
				n = window.performance && performance.mark ? performance.mark.bind(performance) : o,
				a = window.performance && performance.measure ? performance.measure.bind(performance) : o,
				l = window.performance && performance.clearMarks ? performance.clearMarks.bind(performance) : o;

			function c(e) {
				r(e), n(e)
			}
			async function h(e, t) {
				const i = `measure-${e}-${(0,s.randomHash)()}`;
				n(i);
				try {
					return await t()
				} finally {
					a(e, i), l(i)
				}
			}
		},
		963568: (e, t, i) => {
			"use strict";
			i.d(t, {
				retries: () => r,
				retriesWithDelays: () => n
			});
			var s = i(761068);
			async function o(e, t, i) {
				let s;
				for (let o = 0; o < t; ++o) try {
					return await e(s)
				} catch (e) {
					s = e, await i(o)
				}
				throw s
			}
			async function r(e, t) {
				return o(e, t, (() => Promise.resolve()))
			}
			async function n(e, t) {
				return o(e, t.length + 1, (e => e < t.length ? (0, s.delay)(null, t[e]) : Promise.resolve()))
			}
		},
		180389: (e, t, i) => {
			"use strict";
			i.d(t, {
				showThemeAction: () => a,
				showThemeSwitcher: () => n
			});
			var s = i(638456);

			function o(e) {
				const t = e.match(/^(\d+).(\d+).(\d+)/);
				if (!t) return null;
				const [, i, s, o] = t;
				return [parseInt(i), parseInt(s), parseInt(o)]
			}

			function r(e) {
				const t = (0, s.desktopAppVersion)();
				return !!t && function(e, t) {
					const i = o(e),
						s = o(t);
					if (!i || !s) return !1;
					const [r, n, a] = i, [l, c, h] = s;
					return r !== l ? r < l : n !== c ? n < c : a !== h && a < h
				}(t, e)
			}

			function n() {
				return !(0, s.isDesktopApp)() || r("1.0.10")
			}

			function a() {
				return (0, s.isDesktopApp)() && !r("1.0.11")
			}
		},
		247001: (e, t, i) => {
			"use strict";
			i.d(t, {
				trackStudies: () => r
			});
			var s = i(776734),
				o = i(970028);

			function r(e, t) {
				const i = e.metaInfo(),
					r = !e.isPine() || e.isStandardPine() ? i.description : i.scriptIdPart,
					n = i.productId,
					a = o.StudyMetaInfo.isScriptStrategy(i),
					l = window.user && window.user.pro_plan || "";
				(0, s.getTracker)().then((e => {
					e && e.trackStudiesAnalytics(r, n, t, a, l)
				}))
			}
		},
		484400: (e, t, i) => {
			"use strict";
			i.d(t, {
				DEFAULT_THEME: () => s
			});
			const s = "light"
		},
		709353: (e, t, i) => {
			"use strict";
			i.d(t, {
				themes: () => l
			});
			var s = i(919346),
				o = i(575932);
			const r = JSON.parse('{"color-bg-primary":"color-cold-gray-850","color-bg-primary-hover":"color-cold-gray-800","color-bg-secondary":"color-cold-gray-900","color-bg-highlight":"color-cold-gray-900","color-bg-scroll-buttons":"color-cold-gray-800","color-legacy-bg-scroll-buttons":"color-cold-gray-550","color-legacy-bg-widget":"color-cold-gray-900","color-text-primary":"color-cold-gray-200","color-text-secondary":"color-cold-gray-500","color-text-tertiary":"color-cold-gray-400","color-text-disabled":"color-cold-gray-650","color-accent-content":"color-white","color-divider":"color-cold-gray-700","color-divider-hover":"color-cold-gray-800","color-divider-secondary":"color-cold-gray-800","color-box-shadow":"color-cold-gray-900","color-active-hover-text":"color-cold-gray-300","color-alert-text":"color-cold-gray-200","color-border":"color-cold-gray-750","color-border-chat-fields":"color-cold-gray-750","color-border-hover":"color-cold-gray-650","color-border-table":"color-cold-gray-800","color-brand":"color-tv-blue-500","color-brand-hover":"color-tv-blue-600","color-brand-active":"color-tv-blue-700","color-button-hover-bg":"color-cold-gray-850","color-chart-page-bg":"color-cold-gray-800","color-common-tooltip-bg":"color-cold-gray-750","color-danger":"color-ripe-red-600","color-danger-hover":"color-ripe-red-500","color-danger-active":"color-ripe-red-400","color-depthrenderer-fill-style":"color-cold-gray-150","color-depthrenderer-stroke-style":"color-cold-gray-650","color-disabled-border-and-color":"color-cold-gray-800","color-disabled-input":"color-cold-gray-750","color-empty-container-message":"color-cold-gray-500","color-highlight-new":"color-tv-blue-a800","color-icons":"color-cold-gray-500","color-input-bg":"color-cold-gray-800","color-input-textarea-readonly":"color-cold-gray-650","color-input-placeholder-text":"color-cold-gray-700","color-input-publish-bg":"color-cold-gray-900","color-item-active-blue":"color-tv-blue-a900","color-item-hover-active-bg":"color-cold-gray-800","color-item-hover-bg":"color-cold-gray-800","color-item-hover-blue":"color-tv-blue-a800","color-item-selected-blue":"color-tv-blue-a800","color-item-active-text":"color-cold-gray-200","color-item-active-bg":"color-tv-blue-500","color-link":"color-tv-blue-500","color-link-hover":"color-tv-blue-600","color-link-active":"color-tv-blue-700","color-list-item":"color-cold-gray-500","color-list-nth-child-bg":"color-cold-gray-850","color-news-highlight":"color-cold-gray-800","color-pane-bg":"color-cold-gray-900","color-pane-secondary-bg":"color-cold-gray-850","color-placeholder":"color-cold-gray-650","color-popup-menu-item-hover-bg":"color-cold-gray-800","color-popup-menu-separator":"color-cold-gray-700","color-row-hover-active-bg":"color-cold-gray-800","color-sb-scrollbar-body-bg":"color-cold-gray-650","color-screener-description":"color-cold-gray-200","color-section-separator-border":"color-cold-gray-750","color-search-button-hover":"color-cold-gray-700","color-separator-table-chat":"color-cold-gray-750","color-success":"color-minty-green-700","color-success-hover":"color-minty-green-600","color-success-active":"color-minty-green-500","color-tag-active-bg":"color-cold-gray-750","color-tag-hover-bg":"color-cold-gray-800","color-text-regular":"color-cold-gray-200","color-toolbar-button-text":"color-cold-gray-300","color-toolbar-button-text-hover":"color-cold-gray-300","color-toolbar-button-text-active":"color-tv-blue-500","color-toolbar-button-text-active-hover":"color-tv-blue-600","color-toolbar-button-background-hover":"color-cold-gray-800","color-toolbar-button-background-secondary-hover":"color-cold-gray-750","color-toolbar-toggle-button-background-active":"color-tv-blue-500","color-toolbar-toggle-button-background-active-hover":"color-tv-blue-600","color-toolbar-toggle-button-icon":"color-cold-gray-650","color-toolbar-interactive-element-text-normal":"color-cold-gray-300","color-toolbar-interactive-element-text-hover":"color-cold-gray-250","color-toolbar-opened-element-bg":"color-cold-gray-800","color-tooltip-bg":"color-cold-gray-750","color-tv-button-checked":"color-cold-gray-500","color-tv-dialog-caption":"color-cold-gray-50","color-tv-dropdown-item-hover-bg":"color-cold-gray-800","color-underlined-text":"color-cold-gray-300","color-widget-pages-bg":"color-cold-gray-900","color-warning":"color-tan-orange-700","color-forex-icon":"color-white","color-list-item-active-bg":"color-tv-blue-500","color-list-item-hover-bg":"color-cold-gray-800","color-list-item-text":"color-cold-gray-200","color-price-axis-label-back":"color-cold-gray-800","color-price-axis-label-text":"color-cold-gray-500","color-price-axis-gear":"color-cold-gray-500","color-price-axis-gear-hover":"color-cold-gray-400","color-price-axis-highlight":"color-cold-gray-800","color-bid":"color-tv-blue-500","color-scroll-bg":"color-cold-gray-750","color-scroll-border":"color-cold-gray-850","color-widget-border":"color-cold-gray-800","color-scroll-buttons-arrow":"color-white","color-control-intent-default":"color-cold-gray-650","color-control-intent-success":"color-minty-green-600","color-control-intent-primary":"color-tv-blue-500","color-control-intent-warning":"color-tan-orange-500","color-control-intent-danger":"color-ripe-red-700","color-growing":"color-minty-green-500","color-falling":"color-ripe-red-500","color-goto-label-background":"color-cold-gray-650","color-pre-market":"color-tan-orange-600","color-pre-market-bg":"color-tan-orange-400","color-post-market":"color-tv-blue-500","color-post-market-bg":"color-tv-blue-400","color-market-open":"color-minty-green-500","color-market-open-bg":"color-minty-green-400","color-market-closed":"color-cold-gray-400","color-market-holiday":"color-cold-gray-400","color-invalid-symbol":"color-ripe-red-400","color-invalid-symbol-hover":"color-ripe-red-500","color-replay-mode":"color-tv-blue-500","color-replay-mode-icon":"color-tv-blue-50","color-replay-mode-hover":"color-tv-blue-600","color-notaccurate-mode":"color-berry-pink-700","color-notaccurate-mode-bg":"color-berry-pink-400","color-delay-mode":"color-tan-orange-700","color-delay-mode-bg":"color-tan-orange-400","color-eod-mode":"color-grapes-purple-700","color-eod-mode-bg":"color-grapes-purple-400","color-data-problem":"color-ripe-red-600","color-data-problem-bg":"color-ripe-red-400","color-data-problem-hover":"color-ripe-red-500","color-list-item-bg-highlighted":"color-tv-blue-a900","color-list-item-bg-selected":"color-tv-blue-a800","color-list-item-bg-highlighted-hover":"color-tv-blue-a800","color-list-item-bg-selected-hover":"color-tv-blue-a700","color-screener-header-bg":"color-cold-gray-850","color-screener-header-bg-hover":"color-cold-gray-800","color-overlay":"color-cold-gray-950","color-boost-button-text":"color-tv-blue-300","color-card-border":"color-cold-gray-700","color-card-border-hover":"color-cold-gray-600","color-background-special-primary":"color-black","color-stroke-special-primary":"color-cold-gray-800","color-selection-bg":"color-tv-blue-a700"}'),
				n = JSON.parse('{"color-toolbar-button-text-active":"color-seeking-alpha-brand"}');
			var a = i(679520);
			const l = {
				[s.StdTheme.Light]: {
					name: s.StdTheme.Light,
					label: () => (0, o.t)("Light", {
						context: "colorThemeName"
					}),
					order: 2,
					getThemedColor: e => (0, a.getHexColorByName)(e)
				},
				[s.StdTheme.Dark]: {
					name: s.StdTheme.Dark,
					label: () => (0, o.t)("Dark", {
						context: "colorThemeName"
					}),
					order: 1,
					getThemedColor: e => {
						const t = r[e] || e;
						return (0, a.getHexColorByName)(t)
					}
				}
			};
			l.sa = {
				isPrivate: !0,
				noChartTheme: !0,
				name: "sa",
				getThemedColor: e => {
					const t = n[e] || e;
					return (0, a.getHexColorByName)(t)
				}
			}
		},
		902981: (e, t, i) => {
			"use strict";
			i.d(t, {
				getThemeFromUserSettings: () => r,
				saveThemeInUserSettings: () => n
			});
			var s = i(62802);

			function o(e) {
				const t = function() {
						const e = location.hostname.split(".").filter(Boolean);
						return e.every(isFinite) ? location.host : e.slice(-2).join(".")
					}(),
					i = void 0 === e ? -1 : 3e8;
				document.cookie = `theme=${e};path=/;domain=${t};max-age=${i}`
			}

			function r() {
				return /(?:^|;)\s*theme=(dark|light)(?:;|$)|$/.exec(document.cookie)[1] || (0, s.getValue)("current_theme.name") || null
			}

			function n(e) {
				o(e), (0, s.setValue)("current_theme.name", e, {
					forceFlush: !0
				})
			}
		},
		440135: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				DEFAULT_THEME: () => u.DEFAULT_THEME,
				extractThemeFromModel: () => D,
				getCurrentTheme: () => p,
				getStdTheme: () => P,
				getStdThemeNames: () => w,
				getStdThemedValue: () => M,
				getTheme: () => y,
				getThemeNames: () => C,
				getThemedColor: () => g,
				isPublicTheme: () => m,
				isStdTheme: () => E,
				isStdThemeName: () => T,
				isStdThemedDefaultValue: () => x,
				isThemeExist: () => k,
				loadTheme: () => S,
				removeTheme: () => A,
				restoreTheme: () => v,
				saveTheme: () => I,
				savedThemeName: () => f,
				syncTheme: () => b,
				themes: () => _.themes,
				translateStdThemeName: () => L
			});
			var s = i(724377),
				o = i(385518),
				r = i(902981),
				n = i(86674);
			const a = (0, i(911905).getLogger)("Themes.Provider");
			let l = null;

			function c(e) {
				return (0, n.fetch)("/theme/?themeName=" + encodeURIComponent(e), {
					credentials: "include",
					method: "GET"
				}).then((e => e.json())).then((e => {
					const t = {};
					return e.content && (t.content = JSON.parse(e.content)), t
				}))
			}
			var h = i(919346),
				d = i(909740),
				u = i(484400),
				_ = i(709353);

			function m(e) {
				return !e.isPrivate
			}

			function p() {
				return _.themes[d.watchedTheme.value()] || _.themes[u.DEFAULT_THEME]
			}

			function g(e) {
				return p().getThemedColor(e)
			}
			async function S(e, t) {
				const {
					themeName: i,
					standardTheme: s,
					syncState: r = !0,
					noUndo: n = !1,
					applyOverrides: a = !1
				} = t, l = await (s ? Promise.resolve(P(i)) : y(i)), c = !s;
				if (void 0 !== l.content) {
					const t = !s;
					a && (void 0 !== (h = l.content).chartProperties && (0, o.applyDefaultsOverrides)(h.chartProperties), void 0 !== h.mainSourceProperties && (0, o.applyDefaultsOverrides)(h.mainSourceProperties, void 0, !0, "mainSeriesProperties")), await e.applyTheme({
						theme: l.content,
						onlyActiveChart: t,
						restoreNonThemeDefaults: c,
						themeName: i,
						standardTheme: s,
						syncState: r,
						noUndo: n
					})
				}
				var h;
				return l
			}

			function v() {
				(0, d.setTheme)((0, r.getThemeFromUserSettings)() || u.DEFAULT_THEME)
			}

			function f() {
				return (0, r.getThemeFromUserSettings)()
			}

			function b() {
				(0, r.saveThemeInUserSettings)(p().name)
			}

			function y(e) {
				return c(e)
			}

			function C() {
				return l || (0, n.fetch)("/themes/", {
					credentials: "include",
					method: "GET"
				}).then((e => (l = e.json(), l)))
			}

			function w() {
				return h.getStdThemeNames()
			}

			function T(e) {
				return w().includes(e)
			}

			function P(e) {
				return h.getStdChartTheme(e) || {
					content: void 0
				}
			}

			function M(e, t) {
				const i = t || p().name,
					s = h.getStdChartTheme(i),
					o = 0 !== e.length && e.split(".");
				return s && s.content && o ? o.reduce(((e, t) => e[t]), s.content) : null
			}

			function x(e, t, i) {
				const o = M(e, i);
				return null !== o && (0, s.areEqualRgba)((0, s.parseRgba)(o), (0, s.parseRgba)(String(t)))
			}

			function I(e, t) {
				return function(e, t) {
					const i = new FormData;
					return i.append("content", JSON.stringify(t)), i.append("name", e), l = null, (0, n.fetch)("/save-theme/", {
						credentials: "include",
						method: "POST",
						body: i
					}).then((e => e.json()), (e => a.logError(e)))
				}(e, t)
			}

			function A(e) {
				return function(e) {
					const t = new FormData;
					return t.append("name", e), l = null, (0, n.fetch)("/remove-theme/", {
						credentials: "include",
						method: "POST",
						body: t
					}).then((e => e.json()), (e => a.logError(e)))
				}(e)
			}

			function k(e) {
				return function(e) {
					return c(e).then((e => Boolean(e.content)))
				}(e)
			}

			function L(e) {
				return h.translateThemeName(e)
			}

			function E(e) {
				return h.isStdTheme(e)
			}

			function D(e) {
				return {
					content: {
						chartProperties: {
							paneProperties: e.model().properties().childs().paneProperties.state(),
							scalesProperties: e.model().properties().childs().scalesProperties.state()
						},
						sessions: e.model().sessions().properties().state(),
						mainSourceProperties: e.model().mainSeries().properties().state(),
						version: e.model().version()
					}
				}
			}
		},
		875049: (e, t, i) => {
			"use strict";
			i.d(t, {
				default: () => r
			});
			var s = i(345848);
			const o = {
					filterNamesMap: {
						script_type: "Indicators and Strategies",
						"script_type-indicators": "Indicators",
						"script_type-strategies": "Strategies",
						stream: "All Markets",
						"stream-stocks": "Stocks",
						"stream-indices": "Indices",
						"stream-commodities": "Commodities",
						"stream-currencies": "Currencies",
						"stream-bitcoin": "Bitcoin",
						"interval-all": "All Intervals",
						"interval-m": "Short Term",
						"interval-h": "Medium Term",
						"interval-dwm": "Long Term",
						"sort-unmoderated": "Unmoderated",
						"sort-trending": "Trending",
						"sort-discussed": "Most Discussed",
						"sort-viewed": "Most Viewed",
						"sort-agreed": "Most Agreed",
						"sort-suggested": "Suggested",
						"sort-recent": "All Ideas",
						"time-day": "Today",
						"time-week": "This Week",
						"time-month": "This Month",
						"time-all": "All Time",
						"by-everyone": "Everyone",
						"by-following": "Following",
						"by-me": "My Ideas"
					},
					goProFeaturesMap: {
						customIntervals: "Add Custom Interval",
						intradaySpread: "Inraday Spread",
						kagiRenko: "Japanese Intraday Chart",
						alerts: {
							prefix: "New Alerts Limit",
							widget: "Widget",
							chart: "Chart Header"
						},
						multipleCharts: "Multiple Charts Layout",
						savedChartsLimit: "Save Chart Limit",
						studyLimit: "Studies Limit",
						multipleWatchLists: {
							prefix: "Watchlists",
							new: "Create New List",
							rename: "Rename List",
							saveAs: "Save List As"
						},
						importWatchlist: "Watchlists Import Watchlist",
						exportWatchlist: "Watchlists Export Watchlist",
						BATSExchangePopup: "BATS Exchange Popup",
						DataQualityPopup: "Data Quality Popup",
						FreeDelayPopup: "Free Delay Popup",
						proRTProduct: "Volume Profile",
						studyOnStudy: "Unlimited Study on Study"
					},
					trackFeature: {
						savedChartsLimit: !0,
						BATSExchangePopup: !0,
						FreeDelayPopup: !0,
						DataQualityPopup: !0,
						intradaySpread: !0,
						studyOnStudy: !0
					},
					trackGoPro: function(e, t, i) {
						i && !t && (t = i, i = null);
						var r = o.goProFeaturesMap[t];
						if (r) {
							if (i) {
								if ("string" == typeof r) return;
								r = "{0} {1}".format(r.prefix, r[i])
							}(0, s.trackEvent)(e, r)
						}
					}
				},
				r = o
		},
		405117: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				trackGoProFeature: () => o
			});
			var s = i(875049);

			function o(e, t) {
				s.default.trackGoPro("Gopro Features", e, t)
			}
		},
		72368: (e, t, i) => {
			"use strict";
			i.d(t, {
				isMobile: () => n,
				isPlatformMobile: () => a,
				canShowNewSymbolSearch: () => l
			});
			var s = i(314802),
				o = i(611688),
				r = i(638456);

			function n() {
				const e = window.matchMedia("(min-width: 602px) and (min-height: 445px)").matches;
				return r.CheckMobile.any() && !e
			}

			function a() {
				return !(0, s.isOnMobileAppPage)("any") && n()
			}

			function l() {
				return !o.enabled("widget") && !(0, s.isOnMobileAppPage)("any")
			}
		},
		560420: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				activateKeyPressHandler: () => u,
				showDialog: () => _
			});
			var s = i(637936),
				o = i(589468),
				r = i(611688),
				n = i(544998),
				a = i(779592),
				l = i(187545),
				c = i(345848);
			let h = null;

			function d(e) {
				if (!(0, o.globalKeypressMatches)(e)) return !1;
				e.preventDefault();
				const t = String.fromCharCode(e.charCode);
				return r.enabled("show_interval_dialog_on_key_press") && function(e) {
					return /[1-9]/.test(e)
				}(t) ? (0, n.showChangeIntervalDialogAsync)({
					initVal: t
				}) : r.enabled("symbol_search_hot_key") && (_({
					defaultValue: t,
					selectSearchOnInit: !1,
					source: "keyboard"
				}), (0, c.trackEvent)("GUI", "SS", "hotkey")), !0
			}

			function u() {
				(0, a.loadChangeIntervalDialog)(), s.pushBackListener("symbolEdit", d)
			}

			function _(e) {
				const t = h = (0, l.loadNewSymbolSearch)().then((i => {
					t === h && i.showDefaultSearchDialog(e)
				}));
				return t
			}
		},
		711496: (e, t, i) => {
			"use strict";
			i.d(t, {
				hasMoreFinancialsButton: () => a
			});
			const s = new Set(["stock", "dr", "right", "warrant", "structured", "bond"]),
				o = new Set(["mutual", "unit", "trust", "reit", "etn", "closedend"]),
				r = new Set(["convertible", "corporate"]),
				n = new Set(["cfd"]);

			function a(e, t) {
				return "fund" === e && (null == t ? void 0 : t.length) ? t.filter((e => o.has(e))).length > 0 : "bond" === e && (null == t ? void 0 : t.length) ? t.filter((e => r.has(e))).length > 0 : "stock" === e && (null == t ? void 0 : t.length) ? 0 === t.filter((e => n.has(e))).length : Boolean(e && s.has(e))
			}
		},
		2606: (e, t, i) => {
			"use strict";
			i.d(t, {
				isDetailsReady: () => o
			});
			var s = i(262325);
			const o = new(i.n(s)())(!1)
		},
		301062: (e, t, i) => {
			"use strict";
			i.d(t, {
				createSymbolNote: () => c,
				showSymbolNotes: () => l,
				showSymbolNotesGroups: () => h
			});
			var s = i(2606),
				o = i(421219);
			async function r(e) {
				Promise.all([i.e(10146), i.e(90519), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(3086), i.e(30063), i.e(72066), i.e(15107), i.e(63280), i.e(21834), i.e(80580), i.e(68074), i.e(52498), i.e(82739), i.e(94430), i.e(63146), i.e(55706), i.e(44415), i.e(29462), i.e(36325), i.e(60600), i.e(87893), i.e(75514), i.e(24377), i.e(93921), i.e(79049), i.e(48512), i.e(6889), i.e(50996)]).then(i.bind(i, 768175)).then((t => {
					t.renderNotesDialog(e)
				}))
			}
			let n = null;

			function a(e, t) {
				if (n && s.isDetailsReady.unsubscribe(n), n = () => {
						var i, s, o;
						(null === (o = null === (s = null === (i = null === window || void 0 === window ? void 0 : window.widgetbar) || void 0 === i ? void 0 : i.layout) || void 0 === s ? void 0 : s.getWidgetByType("detail")) || void 0 === o ? void 0 : o.widgetObject).navigate(e, t)
					}, s.isDetailsReady.value()) return n(), void(n = null);
				s.isDetailsReady.subscribe(n, {
					once: !0
				})
			}

			function l(e = null, t) {
				const i = (0, o.pathToGroup)(null != e ? e : "");
				t ? r(i) : a(i)
			}

			function c(e = null, t) {
				const i = (0,
					o.pathToGroup)(null != e ? e : "") + "?new=" + performance.now();
				t && r(i), a(i)
			}

			function h() {
				a(o.NOTES_PATH_PATTERN)
			}
		},
		421219: (e, t, i) => {
			"use strict";
			i.d(t, {
				NOTES_PATH_PATTERN: () => s,
				GROUP_PATH_PATTERN: () => o,
				UNATTENDED_PATH_PATTERN: () => r,
				pathToGroup: () => n
			});
			const s = "/notes/",
				o = "/notes/groups/:symbol/",
				r = "/notes/unattended/";

			function n(e) {
				return e ? o.replace(":symbol", encodeURIComponent(e)) : r
			}
		},
		834698: (e, t, i) => {
			"use strict";
			i.d(t, {
				CompareDialogRenderer: () => o
			});
			var s = i(410685);
			class o extends s.DialogRenderer {
				constructor(e) {
					super(), this._dialog = null, this._subscribe = e => {
						this._setVisibility(e)
					}, this._chartWidgetCollection = e
				}
				show() {
					this._load().then((e => {
						var t, i;
						null === (t = this._dialog) || void 0 === t || t.hide(), null === (i = this._dialog) || void 0 === i || i.visible().unsubscribe(this._subscribe), this._dialog = e, e.visible().subscribe(this._subscribe), e.show()
					}))
				}
				hide() {
					var e;
					null === (e = this._dialog) || void 0 === e || e.hide()
				}
				_load() {
					return Promise.all([i.e(57271).then(i.bind(i, 910261)), Promise.all([i.e(10146), i.e(90519), i.e(90926), i.e(37135), i.e(8834), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(78941), i.e(21834), i.e(95468), i.e(80580), i.e(68074), i.e(52498), i.e(82739), i.e(44155), i.e(63146), i.e(5799), i.e(52019), i.e(24384), i.e(55706), i.e(35015), i.e(2036), i.e(61153), i.e(50991), i.e(4171), i.e(40731), i.e(93683), i.e(54072), i.e(95619), i.e(19347), i.e(75514), i.e(93921), i.e(69397), i.e(22407), i.e(46e3), i.e(95106), i.e(30731)]).then(i.bind(i, 160654))]).then((([e, t]) => {
						const i = new e.CompareModel(this._chartWidgetCollection);
						return t.getCompareDialogRenderer(i)
					}))
				}
			}
		},
		103669: (e, t, i) => {
			"use strict";
			i.d(t, {
				DetailsDialogController: () => r
			});
			var s = i(410685);
			let o;
			class r extends s.DialogRenderer {
				constructor() {
					super(...arguments), this._dialog = null, this._promise = null, this._subscribe = e => {
						this._setVisibility(e)
					}
				}
				show(e) {
					const t = this._promise = Promise.all([i.e(90519), i.e(8348), i.e(90926), i.e(37135), i.e(8834), i.e(3086), i.e(30063), i.e(72066), i.e(21834), i.e(95468), i.e(80580), i.e(68074), i.e(52498), i.e(12580), i.e(63146), i.e(28111), i.e(55706), i.e(31784), i.e(82640), i.e(93586), i.e(39081), i.e(28143), i.e(40820), i.e(8504), i.e(87128), i.e(75514), i.e(24377), i.e(93921), i.e(11857), i.e(79049), i.e(97998), i.e(64248), i.e(93987), i.e(7498), i.e(34216), i.e(44008), i.e(66854), i.e(26720)]).then(i.bind(i, 282555)).then((i => {
						this._promise === t && (this._dialog && (this._dialog.hide(), this._dialog.visible().unsubscribe(this._subscribe)), this._dialog = new i.DetailsDialogRenderer, this._dialog.visible().subscribe(this._subscribe), this._dialog.show(e))
					}))
				}
				hide() {
					var e, t;
					null === (e = this._dialog) || void 0 === e || e.hide(), null === (t = this._dialog) || void 0 === t || t.visible().unsubscribe(this._subscribe)
				}
				static getInstance() {
					return o || (o = new r), o
				}
			}
		},
		715518: (e, t, i) => {
			"use strict";
			i.d(t, {
				showDetailsDialog: () => o
			});
			var s = i(103669);

			function o(e) {
				s.DetailsDialogController.getInstance().show(e)
			}
		},
		597101: (e, t, i) => {
			"use strict";
			i.d(t, {
				hideStateChange: () => o
			});
			var s = i(97639);
			const o = new(i.n(s)())
		},
		951713: (e, t, i) => {
			"use strict";
			i.d(t, {
				getHideOptions: () => h,
				toggleHideMode: () => d,
				getHideModeStateValue: () => u,
				getSavedHideMode: () => _
			});
			var s = i(588537),
				o = i(575932),
				r = i(62802),
				n = i(110933),
				a = i(308170),
				l = i(597101);
			let c = null;

			function h() {
				if (null !== c) return c;
				const e = (0, n.tradingService)();
				return c = new Map([
					["drawings", {
						label: (0, o.t)("Hide drawings"),
						dataName: "hide-drawing-tools",
						tooltip: {
							active: (0, o.t)("Show all drawings"),
							inactive: (0, o.t)("Hide all drawings")
						},
						getBoxedValue: () => (0, a.hideAllDrawings)(),
						trackLabel: "hide drawings"
					}],
					["indicators", {
						label: (0, o.t)("Hide indicators"),
						dataName: "hide-indicators",
						tooltip: {
							active: (0, o.t)("Show all indicators"),
							inactive: (0, o.t)("Hide all indicators")
						},
						getBoxedValue: () => (0, a.hideAllIndicators)(),
						trackLabel: "hide indicators"
					}],
					["positions", {
						label: (0, o.t)("Hide positions & orders"),
						dataName: "hide-positions-and-orders",
						tooltip: {
							active: (0, o.t)("Show all positions & orders"),
							inactive: (0, o.t)("Hide all positions & orders")
						},
						getBoxedValue: () => (0, s.ensureNotNull)(e).showTradedSources,
						inverted: !0,
						trackLabel: "hide positions"
					}],
					["all", {
						label: (0, o.t)("Hide all"),
						dataName: "hide-all",
						tooltip: {
							active: e ? (0, o.t)("Show all drawings, indicators, positions & orders") : (0, o.t)("Show all drawings and indicators"),
							inactive: e ? (0, o.t)("Hide all drawings, indicators, positions & orders") : (0, o.t)("Hide all drawings and indicators")
						},
						trackLabel: "hide all"
					}]
				]), e || c.delete("positions"), c
			}

			function d(e) {
				e ? r.setValue("ChartToolsHideMode", e) : e = _();
				const t = m();
				let i = !t;
				return "all" === e ? (p(((e, t, s) => {
					e.setValue(s ? !i : i)
				})), l.hideStateChange.fire({
					hideMode: e,
					isActive: i
				}), i) : (p(((s, o, r) => {
					if (o === e) {
						const e = t ? !r : !s.value();
						s.setValue(e), i = r ? !e : e
					} else s.setValue(Boolean(r))
				})), l.hideStateChange.fire({
					hideMode: e,
					isActive: i
				}), i)
			}

			function u(e) {
				if ("all" === e) return m();
				const t = (0, s.ensureDefined)(h().get(e)),
					i = (0, s.ensureDefined)(t.getBoxedValue)().value();
				return t.inverted ? !i : i
			}

			function _() {
				const e = r.getValue("ChartToolsHideMode", "drawings");
				return h().has(e) ? e : "drawings"
			}

			function m() {
				let e = !0;
				return p(((t, i, s) => {
					const o = t.value();
					e = e && (s ? !o : o)
				})), e
			}

			function p(e) {
				h().forEach(((t, i) => {
					var s;
					const o = null === (s = t.getBoxedValue) || void 0 === s ? void 0 : s.call(t);
					o && e(o, i, t.inverted)
				}))
			}
		},
		333126: (e, t, i) => {
			"use strict";
			i.d(t, {
				ObjectTreeDialogController: () => r
			});
			var s = i(410685);
			let o;
			class r extends s.DialogRenderer {
				constructor() {
					super(), this._dialog = null, this._subscribe = e => {
						this._setVisibility(e)
					}
				}
				show() {
					this._load().then((e => e.show()))
				}
				hide() {
					var e;
					null === (e = this._dialog) || void 0 === e || e.hide()
				}
				static getInstance() {
					return o || (o = new r), o
				}
				_load() {
					return Promise.all([i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(30063), i.e(91670), i.e(21834), i.e(77301), i.e(95468), i.e(80580), i.e(68074), i.e(52498), i.e(82739), i.e(12580), i.e(28111), i.e(1689), i.e(74733), i.e(82520), i.e(11812), i.e(81532), i.e(1419), i.e(21765), i.e(53669), i.e(13404), i.e(13389), i.e(75514), i.e(69397), i.e(29594), i.e(79049), i.e(95904), i.e(70549), i.e(72785), i.e(28248), i.e(25031), i.e(34862)]).then(i.bind(i, 110614)).then((e => {
						var t, i;
						return null === (t = this._dialog) || void 0 === t || t.hide(), null === (i = this._dialog) || void 0 === i || i.visible().unsubscribe(this._subscribe),
							this._dialog = new e.ObjectTreeDialogRenderer, this._dialog.visible().subscribe(this._subscribe), this._dialog
					}))
				}
			}
		},
		382384: (e, t, i) => {
			"use strict";
			i.d(t, {
				showConfirmInputsDialog: () => c
			});
			var s = i(575932),
				o = i(588537),
				r = i(270617),
				n = i(624635),
				a = i(232567),
				l = i.n(a);
			async function c(e, t, a, c, h = "default") {
				let d, u = null;
				const _ = e.model().model(),
					m = (0, r.clone)((0, o.ensureDefined)(t.defaults.inputs)),
					p = new(l())({
						inputs: m
					}),
					g = function(e, t) {
						return "symbol" === t ? e.inputs.filter((t => t.id === e.symbolInputId())) : e.inputs.filter((e => e.confirm))
					}(t, h),
					S = () => {
						d && _.removeCustomSource(d)
					},
					v = () => {
						S(), c()
					},
					f = e => {
						a({
							inputs: e,
							parentSource: u
						}), S()
					},
					b = g.filter(n.isTimeOrPriceNotHiddenInput);
				if (b.length > 0) try {
					const s = await Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(78941), i.e(91670), i.e(53221), i.e(63280), i.e(21834), i.e(95468), i.e(80580), i.e(67161), i.e(68074), i.e(52498), i.e(34640), i.e(9935), i.e(82739), i.e(94430), i.e(44155), i.e(63146), i.e(5799), i.e(32151), i.e(52019), i.e(24384), i.e(55706), i.e(35015), i.e(2036), i.e(29499), i.e(61153), i.e(77542), i.e(50991), i.e(4171), i.e(40731), i.e(92617), i.e(92716), i.e(93683), i.e(69727), i.e(97430), i.e(74499), i.e(60990), i.e(83230), i.e(43671), i.e(24327), i.e(24768), i.e(75514), i.e(93921), i.e(69397), i.e(88067), i.e(68985), i.e(46e3), i.e(95106), i.e(21114), i.e(81868), i.e(81880), i.e(53030)]).then(i.bind(i, 415680)),
						o = await s.selectInputValuesOnChart(e, b, p, t.shortDescription, t.inputs);
					d = o.customSourceId, u = o.destPane ? o.destPane.mainDataSource() : null
				} catch (e) {
					return void v()
				}
				b.length !== g.length ? Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(78941), i.e(91670), i.e(53221), i.e(63280), i.e(21834), i.e(95468), i.e(80580), i.e(67161), i.e(68074), i.e(52498), i.e(34640), i.e(9935), i.e(82739), i.e(94430), i.e(44155), i.e(63146), i.e(5799), i.e(32151), i.e(52019), i.e(24384), i.e(55706), i.e(35015), i.e(2036), i.e(29499), i.e(61153), i.e(77542), i.e(50991), i.e(4171), i.e(40731), i.e(92617), i.e(92716), i.e(93683), i.e(69727), i.e(97430), i.e(74499), i.e(60990), i.e(83230), i.e(43671), i.e(24327), i.e(24768), i.e(75514), i.e(93921), i.e(69397), i.e(88067), i.e(68985), i.e(46e3), i.e(95106), i.e(21114), i.e(81868), i.e(81880), i.e(53030)]).then(i.bind(i, 49294)).then((t => {
					const i = new t.ConfirmInputsDialogRenderer(function(e) {
						if ("symbol" === e) return (0, s.t)("Add Symbol");
						return (0, s.t)("Confirm Inputs")
					}(h), g, p, h, e.model(), f, v);
					return i.show(), i
				})) : f(p.state().inputs || {})
			}
		},
		161590: (e, t, i) => {
			"use strict";
			i.d(t, {
				GeneralChartPropertiesRenderer: () => o
			});
			var s = i(410685);
			class o extends s.DialogRenderer {
				constructor(e) {
					super(), this._dialog = null, this._subscribe = e => {
						this._setVisibility(e)
					}, this._chartWidgetCollection = e
				}
				show() {
					const e = this._chartWidgetCollection,
						t = e.activeChartWidget.value();
					return t.generalPropertiesDefinitions().then((s => Promise.all([i.e(10146), i.e(90519), i.e(8348), i.e(90926), i.e(48181), i.e(37135), i.e(8834), i.e(35354), i.e(5979), i.e(3086), i.e(30063), i.e(72066), i.e(78941), i.e(91670), i.e(53221), i.e(63280), i.e(21834), i.e(95468), i.e(80580), i.e(67161), i.e(68074), i.e(52498), i.e(34640), i.e(9935), i.e(82739), i.e(29331), i.e(94430), i.e(44155), i.e(63146), i.e(5799), i.e(32151), i.e(52019), i.e(24384), i.e(55706), i.e(35015), i.e(2036), i.e(29499), i.e(61153), i.e(74733), i.e(77542), i.e(50991), i.e(4171), i.e(40731), i.e(92617), i.e(92716), i.e(93683), i.e(69727), i.e(97430), i.e(74499), i.e(60990), i.e(83230), i.e(38489), i.e(43671), i.e(24327), i.e(44072), i.e(59171), i.e(14558), i.e(20501), i.e(99738), i.e(20201), i.e(68896), i.e(24935), i.e(75514), i.e(93921), i.e(69397), i.e(35189), i.e(88067), i.e(68985), i.e(46e3), i.e(95106), i.e(21114), i.e(81868), i.e(81880), i.e(7835), i.e(41831), i.e(37078)]).then(i.bind(i, 824306)).then((i => {
						var o, r;
						const n = new i.GeneralChartPropertiesDialogRenderer({
							chartWidgetCollection: e,
							propertyPages: s,
							activePageId: this._activePageId,
							model: t.model()
						});
						return null === (o = this._dialog) || void 0 === o || o.hide(), null === (r = this._dialog) || void 0 === r || r.visible().unsubscribe(this._subscribe), this._dialog = n, n.visible().subscribe(this._subscribe), n.show(), this._activePageId = void 0, n
					}))))
				}
				hide() {
					var e;
					null === (e = this._dialog) || void 0 === e || e.hide()
				}
				isVisible() {
					return this.visible().value()
				}
				focusOnText() {}
				setActivePage(e) {
					this._activePageId = e
				}
			}
		},
		826939: (e, t, i) => {
			"use strict";
			i.d(t, {
				WATCHLIST_WIDGET_ID: () => s
			});
			const s = "watchlist-widget"
		},
		104436: (e, t, i) => {
			"use strict";
			var s;
			i.d(t, {
					ToolboxType: () => s
				}),
				function(e) {
					e[e.Delete = 0] = "Delete"
				}(s || (s = {}))
		},
		324020: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M15 5H6.5C5.67 5 5 5.67 5 6.5v15c0 .83.67 1.5 1.5 1.5h15c.83 0 1.5-.67 1.5-1.5V16h1v5.5a2.5 2.5 0 0 1-2.5 2.5h-15A2.5 2.5 0 0 1 4 21.5v-15A2.5 2.5 0 0 1 6.5 4H15v1Zm7.41-.3a2 2 0 0 0-2.82 0l-.94.95-7.5 7.5-1 1-.15.14V19h4.7l.15-.15 1-1 7.5-7.5.94-.94a2 2 0 0 0 0-2.82L22.41 4.7Zm-2.12.71a1 1 0 0 1 1.42 0l1.88 1.88a1 1 0 0 1 0 1.42l-.59.58-1.65-1.64L19.71 6l.58-.59Zm.36 2.94L22.29 10l-6.79 6.8-1.65-1.65-1.64-1.65L19 6.7l1.65 1.65Zm-7.5 7.5 1.64 1.65-.5.5H11v-3.3l.5-.5 1.65 1.65Z"/></svg>'
		},
		845437: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd"><path stroke="currentColor" d="M13 22.5H5.5a2 2 0 0 1-2-2v-14a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2V14"/><path stroke="currentColor" stroke-linecap="square" d="M18.5 15.5v8m-4-4h8"/><path fill="currentColor" d="M7 8h11v1H7zm0 4h11v1H7zm0 4h5v1H7z"/></g></svg>'
		},
		527409: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><path fill="currentcolor" d="m13.5 5a1 1 0 0 0 0 19 1 1 0 0 0 0-19m0 1a1 1 0 0 1 0 17 1 1 0 0 1 0-17zm2.31-.6A9.5 9.5 0 0 0 9 14.5a9.5 9.5 0 0 0 6.81 9.1l.99-.78A8.5 8.5 0 0 1 10 14.5a8.5 8.5 0 0 1 6.8-8.32"/></svg>'
		},
		855824: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 7 5" width="7" height="5" fill="none"><path stroke="currentColor" stroke-width="1.2" d="M1 1.5l2.5 2 2.5-2"/></svg>'
		},
		428026: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M17.5 7H17v6h-3v-3H9v6H5v6h17V7h-4.5zm.5 14h3V8h-3v13zm-1 0v-7h-3v7h3zm-4-7.5V21h-3V11h3v2.5zM9 21v-4H6v4h3z"/></svg>'
		},
		437924: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" transform="translate(4 5)"><circle stroke="currentColor" cx="9.5" cy="9.5" r="9"/><path stroke="currentColor" d="M7 14.5h2.5v-5H7"/><path stroke="currentColor" stroke-linecap="square" d="M9.5 14.5h2"/><path fill="currentColor" d="M9.5 7a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/></g></svg>'
		},
		902872: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(6 3)"><rect width="15" height="12" rx="2" x=".5" y="8.5"/><path stroke-linecap="round" stroke-width="2" d="M8 15v2"/><path d="M11.5 4a3.5 3.5 0 0 0-7 0v4.5"/></g></svg>'
		},
		832164: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 15" width="15" height="15" fill="none"><path d="M3.00004 7.50008C3.00004 6.25729 3.50318 5.13298 4.31807 4.31809L3.61097 3.61098C2.6162 4.60574 2.00004 5.98143 2.00004 7.50008H3.00004ZM4.31807 4.31809C5.13296 3.50321 6.25727 3.00008 7.50004 3.00008V2.00008C5.98141 2.00008 4.60572 2.61623 3.61097 3.61098L4.31807 4.31809ZM4.31808 3.61098L2.55033 1.84323L1.84322 2.55033L3.61097 4.31809L4.31808 3.61098ZM7.50004 3.00008C8.74283 3.00008 9.86715 3.50321 10.682 4.31811L11.3891 3.611C10.3944 2.61624 9.01869 2.00008 7.50004 2.00008V3.00008ZM10.682 4.31811C11.4969 5.13299 12 6.2573 12 7.50008H13C13 5.98144 12.3839 4.60576 11.3891 3.611L10.682 4.31811ZM11.3891 4.31811L13.1569 2.55033L12.4498 1.84322L10.682 3.611L11.3891 4.31811ZM12 7.50008C12 8.74285 11.4969 9.86716 10.682 10.682L11.3891 11.3892C12.3839 10.3944 13 9.01872 13 7.50008H12ZM10.682 10.682C9.86715 11.4969 8.74283 12.0001 7.50004 12.0001V13.0001C9.01869 13.0001 10.3944 12.3839 11.3891 11.3892L10.682 10.682ZM10.682 11.3892L12.4498 13.1569L13.1569 12.4498L11.3891 10.682L10.682 11.3892ZM7.50004 12.0001C6.25727 12.0001 5.13296 11.497 4.31807 10.6821L3.61097 11.3892C4.60572 12.3839 5.98141 13.0001 7.50004 13.0001V12.0001ZM4.31807 10.6821C3.50318 9.86718 3.00004 8.74286 3.00004 7.50008H2.00004C2.00004 9.01873 2.6162 10.3944 3.61097 11.3892L4.31807 10.6821ZM2.55033 13.1569L4.31808 11.3892L3.61097 10.6821L1.84322 12.4498L2.55033 13.1569ZM8.00004 2.50007L8 -8.77353e-06L7 8.77353e-06L7.00004 2.50009L8.00004 2.50007ZM12.5001 8.00008L15 8L15 7L12.5 7.00008L12.5001 8.00008ZM2.50006 7.00008L1.564e-05 7L-1.564e-05 8L2.50003 8.00008L2.50006 7.00008ZM7.00004 12.5001L7 15L8 15L8.00004 12.5001L7.00004 12.5001Z"/></svg>'
		},
		139267: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor"><path d="M6.5 15A8.5 8.5 0 1 0 15 6.5H8.5"/><path d="M12 10L8.5 6.5 12 3"/></g></svg>'
		},
		416911: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(3 6)"><path d="M.964 8C3 4 6.679.5 11 .5 15.32.5 19 4 21.036 8 19 12 15.32 15.5 11 15.5 6.679 15.5 3 12 .964 8z"/><circle cx="11" cy="8" r="3.5"/></g></svg>'
		},
		321035: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><rect width="10" height="4" fill="currentColor" rx="2" x="4" y="7"/></svg>'
		},
		816030: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><circle fill="currentColor" cx="9" cy="9" r="5"/></svg>'
		},
		720983: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18" fill="none"><circle fill="currentColor" cx="9" cy="9" r="4"/></svg>'
		},
		434074: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M9.3 9l.9-4.53a1.23 1.23 0 1 0-2.4 0L8.7 9l-.9 4.53a1.23 1.23 0 1 0 2.4 0L9.3 9z"/><path fill="currentColor" d="M9.15 9.26l4.38-1.48a1.23 1.23 0 1 0-1.21-2.09L8.85 8.74l-4.38 1.48a1.23 1.23 0 1 0 1.21 2.09l3.47-3.05z"/><path fill="currentColor" d="M9.15 8.74L5.68 5.69a1.23 1.23 0 1 0-1.2 2.09l4.37 1.48 3.47 3.05a1.23 1.23 0 1 0 1.2-2.09L9.16 8.74z"/></svg>'
		},
		20123: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M13.29 4.8h-.09a4.2 4.2 0 1 0 .09 8.4 6 6 0 1 1 0-8.4z"/></svg>'
		},
		572074: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M12.58 12.1A3.86 3.86 0 0 0 9 6.75a3.87 3.87 0 0 0-3.58 5.33 7.74 7.74 0 0 1 7.16 0zM3.64 9.93l-2.3-.62.37-1.38 2.3.62-.37 1.38zM6.1 6.07L5.07 3.92l1.3-.6 1 2.15-1.29.6zM10.62 5.47l1-2.16 1.3.6-1.01 2.16-1.3-.6zM13.99 8.55l2.3-.62.36 1.38-2.3.62L14 8.55z"/></svg>'
		},
		381554: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor"><path stroke-linecap="square" d="M21.5 14.5a8 8 0 1 0-8 8m6-6v8m-4-4h8"/><path d="M10 14.5h3.5V9m-3.277-1.76a3 3 0 1 0-3.993 3.979m14.565-.012a3 3 0 1 0-4.019-3.966"/></g></svg>'
		},
		706862: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor"><path stroke-linecap="square" d="M11.5 21.5v-7m3 7v-5m3 5v-3m-9 3v-5"/><path d="M5.5 22v-3"/><path stroke-linecap="square" d="M5.5 13.5l4.297-4.297a2.406 2.406 0 0 1 3.406 0l2.594 2.594c.94.94 2.463.943 3.406 0L23.5 7.5M22.5 12.5v6m-3-3h6"/></g></svg>'
		},
		108218: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(3 4)"><circle cx="10.5" cy="10.5" r="8"/><path d="M7 10.5h3.5V5M7.223 3.24A3 3 0 1 0 3.23 7.218m14.565-.011a3 3 0 1 0-4.019-3.966"/></g></svg>'
		},
		854190: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><path fill="none" fill-rule="evenodd" stroke="currentColor" stroke-linecap="square" d="M6.145 11.968L14 5.5l7.855 6.468a.3.3 0 0 1-.191.532H6.336a.3.3 0 0 1-.19-.532zm0 4.064L14 22.5l7.855-6.468a.3.3 0 0 0-.191-.532H6.336a.3.3 0 0 0-.19.532z"/></svg>'
		},
		225191: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" transform="translate(4 5)"><path fill="currentColor" d="M3 1h1v13.5H3z"/><circle stroke="currentColor" cx="3.5" cy="16.5" r="2"/><path fill="currentColor" d="M5.5 16H18v1H5.5z"/><path stroke="currentColor" d="M0 4L3.5.5 7 4m8 9l3.5 3.5L15 20"/></g></svg>'
		},
		951983: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(4 4)"><path d="M.5 10.992c0 .287.226.508.505.508H2.65c.19.93.55 1.82 1.09 2.63L2.577 15.3a.5.5 0 0 0-.007.71l1.42 1.42a.5.5 0 0 0 .71-.007l1.17-1.163c.81.54 1.71.9 2.63 1.09v1.645c0 .284.227.505.508.505h1.984c.28 0 .508-.221.508-.505V17.35a7.46 7.46 0 0 0 2.63-1.09l1.17 1.163a.5.5 0 0 0 .71.007l1.42-1.42a.5.5 0 0 0-.007-.71l-1.163-1.17c.54-.81.9-1.7 1.09-2.63h1.645a.502.502 0 0 0 .505-.508V9.008a.503.503 0 0 0-.505-.508H17.35c-.19-.93-.55-1.82-1.09-2.63l1.163-1.17a.5.5 0 0 0 .007-.71l-1.42-1.42a.5.5 0 0 0-.71.007L14.13 3.74a7.46 7.46 0 0 0-2.63-1.09V1.005A.504.504 0 0 0 10.992.5H9.008a.504.504 0 0 0-.508.505V2.65c-.92.19-1.82.55-2.63 1.09L4.7 2.577a.5.5 0 0 0-.71-.007L2.57 3.99a.5.5 0 0 0 .007.71L3.74 5.87c-.54.81-.9 1.7-1.09 2.63H1.005a.503.503 0 0 0-.505.508v1.984z"/><circle cx="10" cy="10" r="2.5"/></g></svg>'
		},
		593379: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="currentColor" fill-rule="nonzero"><path d="M4 15h8.5v-1h-8.5zM16.5 15h8.5v-1h-8.5z"/><path d="M14.5 16c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>'
		},
		535149: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" fill-rule="evenodd" d="M11.5 6a.5.5 0 0 0-.5.5V8h6V6.5a.5.5 0 0 0-.5-.5h-5zM18 8V6.5c0-.83-.67-1.5-1.5-1.5h-5c-.83 0-1.5.67-1.5 1.5V8H5.5a.5.5 0 0 0 0 1H7v12.5A2.5 2.5 0 0 0 9.5 24h9a2.5 2.5 0 0 0 2.5-2.5V9h1.5a.5.5 0 0 0 0-1H18zm2 1H8v12.5c0 .83.67 1.5 1.5 1.5h9c.83 0 1.5-.67 1.5-1.5V9zm-8.5 3c.28 0 .5.22.5.5v7a.5.5 0 0 1-1 0v-7c0-.28.22-.5.5-.5zm5.5.5a.5.5 0 0 0-1 0v7a.5.5 0 0 0 1 0v-7z"/></svg>'
		},
		484959: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><path fill="currentColor" d="M18.15 7.02A9.05 9.05 0 0014 6c-3.45 0-6.08 2-7.8 3.92a18.18 18.18 0 00-2.64 3.84v.02h-.01L4 14l-.45-.21-.1.21.1.21L4 14l-.45.21.01.03a5.85 5.85 0 00.16.32c.11.2.28.51.5.87a18.18 18.18 0 002.4 3.12l.71-.71A17.18 17.18 0 014.56 14a10.05 10.05 0 01.52-.91c.41-.69 1.04-1.6 1.85-2.5C8.58 8.75 10.95 7 14 7a8 8 0 013.4.77l.75-.75zm-3.11 3.12a4 4 0 00-4.9 4.9l.86-.87V14a3 3 0 013.17-3l.87-.86zm1.96 3.7l.86-.88a4 4 0 01-4.9 4.9l.87-.86A3 3 0 0017 13.83zm-6.4 6.4A8 8 0 0014 21c3.05 0 5.42-1.76 7.07-3.58A17.18 17.18 0 0023.44 14a9.47 9.47 0 00-.52-.91 17.18 17.18 0 00-2.25-2.93l.7-.7a18.18 18.18 0 013.06 4.3l.02.02L24 14l.45.21-.01.03a7.03 7.03 0 01-.16.32c-.11.2-.28.51-.5.87-.44.72-1.1 1.69-1.97 2.65C20.08 20.01 17.45 22 14 22c-1.55 0-2.94-.4-4.15-1.02l.75-.75zM24 14l.45-.21.1.21-.1.21L24 14zM22.2 6.5L6.5 22.2l-.7-.7L21.5 5.8l.7.7z"/></svg>'
		},
		397874: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(6 4)"><rect width="15" height="12" rx="2" x=".5" y="7.5"/><path stroke-linecap="round" stroke-width="2" d="M8 14v2"/><path d="M11.5 7.5V4a3.5 3.5 0 0 0-7 0v3.5"/></g></svg>'
		},
		677067: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M13.39 3.84a1 1 0 0 1 1.22 0l8.19 6.37a1 1 0 0 1 0 1.58l-8.19 6.37a1 1 0 0 1-1.22 0L5.2 11.79a1 1 0 0 1 0-1.58l8.19-6.37zm.61.8L5.81 11 14 17.37 22.19 11 14 4.63zM5.3 13.6l8.7 6.76 8.7-6.76.6.78-8.69 6.77a1 1 0 0 1-1.22 0l-8.7-6.77.62-.78zm8.09 10.55l-8.7-6.77.62-.78L14 23.37l8.7-6.76.6.78-8.69 6.77a1 1 0 0 1-1.22 0z"/></svg>'
		},
		776351: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 28" width="36" height="28"><path fill="currentColor" d="M14 22H7V11H0V4h14v18zM28 22h-8l7.5-18h8L28 22z"/><circle fill="currentColor" cx="20" cy="8" r="4"/></svg>'
		},
		439970: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" fill-rule="evenodd" d="M13.5 24a9.5 9.5 0 1 0 0-19 9.5 9.5 0 0 0 0 19zm0 1a10.5 10.5 0 1 0 0-21 10.5 10.5 0 0 0 0 21zM11 10h1v9h-1v-9zm5 0h-1v9h1v-9z"/></svg>'
		},
		789795: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" fill-rule="evenodd" d="M23 14.5a9.5 9.5 0 1 1-19 0 9.5 9.5 0 0 1 19 0zm1 0a10.5 10.5 0 1 1-21 0 10.5 10.5 0 0 1 21 0zM11.3 9.6l-.8-.6v11l.8-.6 6-4.5.53-.4-.53-.4-6-4.5zm4.87 4.9L11.5 18v-7l4.67 3.5z"/></svg>'
		},
		133736: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M5.5 16.5c1 3 7 7 11 7 2-4 2-8.5 2-8.5s-1-3.5-2-4-4.5.5-4.5.5-3 3.5-6.5 5z"/><path stroke="currentColor" d="M15.5 11l3-6s.5-1 1.5-.5.5 1.5.5 1.5l-3 6M12 11.5l6.5 3.5M7.5 19c2-.5 4-2.5 4-2.5m0 5.5c2-1 3-3.5 3-3.5"/></svg>'
		},
		786559: e => {
			e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><rect width="18" height="18" fill="#EC407A" rx="9" opacity=".15"/><path fill="#C2185B" d="M13.4 5.9c-.41 1.62-1.16 2.43-2.25 2.43-.52 0-1.25-.15-2.2-.45-.93-.3-1.58-.45-1.96-.45-.55 0-.98.3-1.27.9H4.66c.1-.67.36-1.24.76-1.71.4-.48.86-.72 1.4-.72.56 0 1.31.16 2.27.46.95.3 1.62.45 2.01.45.64 0 1.06-.3 1.27-.9h1.03zm0 3.87c-.41 1.62-1.16 2.43-2.25 2.43-.52 0-1.25-.15-2.2-.45-.93-.3-1.58-.46-1.96-.46-.55 0-.98.3-1.27.9H4.66c.1-.67.36-1.24.76-1.7.4-.48.86-.72 1.4-.72.56 0 1.31.15 2.27.46.95.3 1.62.44 2.01.44.64 0 1.06-.3 1.27-.9h1.03z"/></svg>'
		}
	}
]);