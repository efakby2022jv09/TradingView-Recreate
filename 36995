(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
	[36995], {
		846778: (e, t, i) => {
			"use strict";
			i.d(t, {
				showPasteLineToolHint: () => c
			});
			var r = i(575932),
				n = i(62802),
				s = i(638456),
				o = i(470316),
				l = i(611688);
			const a = (0, r.t)("Next time you can use {shortcut} for quick paste");

			function c(e, t) {
				l.enabled("popup_hints") && !s.CheckMobile.any() && Promise.all([i.e(8834), i.e(91579), i.e(75514), i.e(26166)]).then(i.bind(i, 410837)).then((i => {
					const r = new i.ChartEventHintRenderer(e),
						s = a.format({
							shortcut: (0, o.humanReadableHash)(o.Modifiers.Mod + 86)
						});
					let l = null;
					r.show(s, (() => {
						null !== l && (clearTimeout(l), l = null, n.setValue(t, !0, {
							forceFlush: !0
						}))
					})), l = setTimeout((() => {
						l = null, r.hide()
					}), 5e3)
				}))
			}
		},
		490901: (e, t, i) => {
			"use strict";
			i.d(t, {
				solutionIds: () => r
			});
			const r = JSON.parse('{"EXTENDED_HOURS":43000502023,"PRE_MARKET":43000502023,"POST_MARKET":43000502023,"SPREAD_CHARTS":43000502298,"ALERTS":43000520149,"ALERT_ON_STRATEGY":43000481368,"ALERT_WEBHOOK":43000529348,"ALERT_DESCRIPTION_PLACEHOLDER":43000531021,"VOLUME_PROFILE":43000502040,"VOLUME_PROFILE_INDICATOR":43000557450,"RENKO":43000502284,"KAGI":43000502272,"LINE_BREAK":43000502273,"PNF":43000502276,"FINANCIAL_DATA":43000543506,"BROKER_RATING":43000542490,"CRYPTO_MARKET_CAP":43000540941,"CRYPTO_PAYMENT":43000485536,"ALERT_ON_SPREAD":43000478406,"ALERT_ON_CUSTOM_SCRIPT":43000478415,"ALERT_FUNCTION":43000597494,"SMS_VERIFICATION":43000553429,"MAGNET_MODE":43000537270,"PINE_CANNOT_DETERMINE":43000587849,"PRIVACY_SETTINGS":43000548335,"PUBLICATION_TYPE":43000609497,"SCRIPT_ACCESS":43000482573,"MEMORY_LIMITS_EXCEEDED":43000590233,"FREE_USER_FAQS":43000590947,"STRATEGY_UNREALISTIC_RESULTS":43000481029,"STRATEGY_FUTURE_DATA":43000614705,"STREAM_RULES":43000591348,"HOW_TO_USE_PAPER":43000516466,"HOW_TO_USE_CQG":43000516372,"HOW_TO_USE_OANDA":43000516375,"HOW_TO_USE_FOREXCOM":43000516374,"FAVORITE_IDEA":43000555216,"YOUTUBE_ERROR":43000612153,"AUTHORS_INSTRUCTIONS_PUBCLICATION":43000549951,"AUTHORS_INSTRUCTIONS_EDIT":43000614618,"SCRIPT_INSTRUCTIONS":43000482573,"BAR_REPLAY_UNAVAILABILITY":43000475470,"WHAT_IS_CBOE_BZX_EXCHANGE":43000473924,"GOPRO_UPGRADE_DESCRIPTION":43000473324,"GOPRO_DOWNGRADE_DESCRIPTION":43000485437,"BROKERAGE_REVIEWS":43000591351,"CHANGE_SUBSCRIPTION":43000635806,"PINE_LIBRARY_INFO":43000638371,"HOW_TO_CREATE_A_STREAM":43000560174,"HOW_DO_I_UPDATE_DESKTOP_APP":43000647779,"TECHNICAL_RATINGS":43000614331,"BACKTESTING_WIDGET":43000561856,"DEEP_BACKTESTING_WIDGET":43000670566,"DEEP_BACKTESTING":43000666199,"DEEP_BACKTESTING_AVAILABLE_DATA":43000668210,"BETA_BROKERS":43000673434,"VIDEO_UPLOAD_FAILED":43000666607,"VIDEO_DEVICE_ACCESS":43000677209,"PUBLIC_INVITE_ONLY_SCRIPTS":43000614617}')
		},
		277036: (e, t, i) => {
			"use strict";
			i.d(t, {
				TranslatedString: () => r
			});
			class r {
				constructor(e, t) {
					this._originalText = e, this._translatedText = t
				}
				originalText() {
					return this._originalText
				}
				translatedText() {
					return this._translatedText
				}
				format(e) {
					const t = {},
						i = {};
					for (const n of Object.keys(e)) {
						const s = e[n];
						s instanceof r ? (t[n] = s.originalText(), i[n] = s.translatedText()) : (t[n] = s.toString(), i[n] = s.toString())
					}
					const n = this._originalText.format(t),
						s = this._translatedText.format(i);
					return new r(n, s)
				}
			}
		},
		363585: (e, t, i) => {
			"use strict";
			var r;
			i.d(t, {
					ACTION_ID: () => r
				}),
				function(e) {
					e.TVActionId = "TVActionId", e.ChartApplyIndicatorsToAllCharts = "Chart.ApplyIndicatorsToAllCharts", e.ChartChangeTimeZone = "Chart.ChangeTimeZone", e.ChartDialogsShowChangeInterval = "Chart.Dialogs.ShowChangeInterval", e.ChartDialogsShowChangeSymbol = "Chart.Dialogs.ShowChangeSymbol", e.ChartDialogsShowCompareOrAddSymbol = "Chart.Dialogs.ShowCompareOrAddSymbol", e.ChartDialogsShowGeneralSettings = "Chart.Dialogs.ShowGeneralSettings", e.ChartDialogsShowGeneralSettingsSymbolTab = "Chart.Dialogs.ShowGeneralSettings.SymbolTab", e.ChartDialogsShowGoToDate = "Chart.Dialogs.ShowGoToDate", e.ChartDialogsShowInsertIndicators = "Chart.Dialogs.ShowInsertIndicators", e.ChartDialogsShowSymbolInfo = "Chart.Dialogs.ShowSymbolInfo", e.ChartDrawingToolbarToggleVisibility = "Chart.DrawingToolbar.ToggleVisibility", e.ChartLinesToggleBidAskLinesVisibility = "Chart.Lines.ToggleBidAskLinesVisibility", e.ChartLinesToggleHighLowLinesVisibility = "Chart.Lines.ToggleHighLowLinesVisibility", e.ChartLinesToggleAverageLineVisibility = "Chart.Lines.ToggleAverageLineVisibility", e.ChartLinesToggleSeriesPrevCloseLineVisibility = "Chart.Lines.ToggleSeriesPrevCloseLineVisibility", e.ChartLinesToggleSeriesPriceLineVisibility = "Chart.Lines.ToggleSeriesPriceLineVisibility", e.ChartLineToolPitchforkChangeTypeToInside = "Chart.LineTool.Pitchfork.ChangeTypeToInside", e.ChartLineToolPitchforkChangeTypeToModifiedSchiff = "Chart.LineTool.Pitchfork.ChangeTypeToModifiedSchiff", e.ChartLineToolPitchforkChangeTypeToOriginal = "Chart.LineTool.Pitchfork.ChangeTypeToOriginal", e.ChartLineToolPitchforkChangeTypeToSchiff = "Chart.LineTool.Pitchfork.ChangeTypeToSchiff", e.ChartMarksToggleVisibility = "Chart.Marks.ToggleVisibility", e.ChartMoveChartInLayout = "Chart.MoveChartInLayout", e.ChartMoveChartInLayoutBack = "Chart.MoveChartInLayout.Back", e.ChartMoveChartInLayoutForward = "Chart.MoveChartInLayout.Forward", e.ChartObjectTreeShow = "Chart.ObjectTree.Show", e.ChartPriceScaleLabelsToggleBidAskLabelsVisibility = "Chart.PriceScale.Labels.ToggleBidAskLabelsVisibility", e.ChartPriceScaleLabelsToggleHighLowPriceLabelsVisibility = "Chart.PriceScale.Labels.ToggleHighLowPriceLabelsVisibility", e.ChartPriceScaleLabelsToggleAveragePriceLabelVisibility = "Chart.PriceScale.Labels.ToggleAveragePriceLabelVisibility", e.ChartPriceScaleLabelsToggleIndicatorsNameLabelsVisibility = "Chart.PriceScale.Labels.ToggleIndicatorsNameLabelsVisibility", e.ChartPriceScaleLabelsToggleIndicatorsValueLabelsVisibility = "Chart.PriceScale.Labels.ToggleIndicatorsValueLabelsVisibility", e.ChartPriceScaleLabelsToggleSeriesLastValueVisibility = "Chart.PriceScale.Labels.ToggleSeriesLastValueVisibility", e.ChartPriceScaleLabelsToggleSymbolNameLabelsVisibility = "Chart.PriceScale.Labels.ToggleSymbolNameLabelsVisibility", e.ChartPriceScaleLabelsToggleSymbolPrevCloseValueVisibility = "Chart.PriceScale.Labels.ToggleSymbolPrevCloseValueVisibility", e.ChartPriceScaleMergeAllScalesToLeft = "Chart.PriceScale.MergeAllScalesToLeft",
						e.ChartPriceScaleMergeAllScalesToRight = "Chart.PriceScale.MergeAllScalesToRight", e.ChartPriceScaleMoveToLeft = "Chart.PriceScale.MoveToLeft", e.ChartPriceScaleMoveToRight = "Chart.PriceScale.MoveToRight", e.ChartPriceScaleToggleAddOrderPlusButtonVisibility = "Chart.PriceScale.ToggleAddOrderPlusButtonVisibility", e.ChartPriceScaleToggleAutoScaleSeriesOnly = "Chart.PriceScale.ToggleAutoScaleSeriesOnly", e.ChartPriceScaleToggleCountdownToBarCloseVisibility = "Chart.PriceScale.ToggleCountdownToBarCloseVisibility", e.ChartRedo = "Chart.Redo", e.ChartRemoveAllIndicators = "Chart.RemoveAllIndicators", e.ChartRemoveAllIndicatorsAndLineTools = "Chart.RemoveAllIndicatorsAndLineTools", e.ChartRemoveAllLineTools = "Chart.RemoveAllLineTools", e.ChartScalesReset = "Chart.Scales.Reset", e.ChartScalesToggleLockPriceToBarRatio = "Chart.Scales.ToggleLockPriceToBarRatio", e.ChartSelectedObjectHide = "Chart.SelectedObject.Hide", e.ChartSelectedObjectRemove = "Chart.SelectedObject.Remove", e.ChartSelectedObjectShowSettingsDialog = "Chart.SelectedObject.ShowSettingsDialog", e.ChartSelectedObjectToggleLocked = "Chart.SelectedObject.ToggleLocked", e.ChartSeriesPriceScaleToggleAutoScale = "Chart.Series.PriceScale.ToggleAutoScale", e.ChartSeriesPriceScaleToggleIndexedTo100 = "Chart.Series.PriceScale.ToggleIndexedTo100", e.ChartSeriesPriceScaleToggleInvertPriceScale = "Chart.Series.PriceScale.ToggleInvertPriceScale", e.ChartSeriesPriceScaleToggleLogarithmic = "Chart.Series.PriceScale.ToggleLogarithmic", e.ChartSeriesPriceScaleTogglePercentage = "Chart.Series.PriceScale.TogglePercentage", e.ChartSeriesPriceScaleToggleRegular = "Chart.Series.PriceScale.ToggleRegular", e.ChartSessionBreaksToggleVisibility = "Chart.SessionBreaks.ToggleVisibility", e.ChartTimeScaleReset = "Chart.TimeScale.Reset", e.ChartUndo = "Chart.Undo"
				}(r || (r = {}))
		},
		829770: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				Action: () => a,
				ActionAsync: () => c,
				Separator: () => u,
				Loader: () => h
			});
			var r = i(588537),
				n = i(97639),
				s = i.n(n),
				o = i(470316),
				l = i(95935);
			class a {
				constructor(e, t = l.guid()) {
					this.type = "action", this._destroyed = !1, this._binding = null, (0, r.assert)(void 0 !== e.actionId, "actionId must be defined"), this.id = t, this._onUpdate = new(s()), this._options = e, this.update(e)
				}
				execute() {
					this._options.checkable && this.update({
						checked: !this._options.checked
					}), this._options.onExecute && this._options.onExecute(this)
				}
				getLabel() {
					return this._options.label || ""
				}
				getSubItems() {
					return this._options.subItems || []
				}
				isDisabled() {
					return !0 === this._options.disabled
				}
				isActive() {
					return !0 === this._options.active
				}
				isCheckable() {
					return !0 === this._options.checkable
				}
				isChecked() {
					return !0 === this._options.checked
				}
				isLoading() {
					return !0 === this._options.loading
				}
				getSize() {
					var e;
					return null !== (e = this._options.size) && void 0 !== e ? e : "normal"
				}
				getPayload() {
					return this._options.payload
				}
				update(e) {
					this._destroyed || (this._unbindShortcut(), e.hotkeyHash && (this._options.shortcutHint = (0, o.humanReadableHash)(e.hotkeyHash)), this._options = Object.assign(this._options, e), this._bindShortcut(), this._onUpdate.fire(this))
				}
				onUpdate() {
					return this._onUpdate
				}
				getState() {
					return {
						actionId: this._options.actionId,
						label: this.getLabel(),
						disabled: this.isDisabled(),
						active: this.isActive(),
						subItems: this.getSubItems(),
						checkable: this.isCheckable(),
						checked: this.isChecked(),
						loading: this.isLoading(),
						size: this.getSize(),
						doNotCloseOnClick: this._options.doNotCloseOnClick || !1,
						shortcutHint: this._options.shortcutHint,
						hint: this._options.hint,
						icon: this._options.icon,
						iconChecked: this._options.iconChecked,
						toolbox: this._options.toolbox,
						showToolboxOnHover: this._options.showToolboxOnHover || !1,
						statName: this._options.statName,
						name: this._options.name,
						invisibleHotkey: this._options.invisibleHotkey,
						noInteractive: this._options.noInteractive
					}
				}
				getBinding() {
					return this._binding
				}
				setBinding(e) {
					this._binding = e
				}
				destroy() {
					var e, t;
					this._destroyed = !0, this._onUpdate.destroy(), null !== this._binding && this._binding.destroy(), this._unbindShortcut(), null === (t = (e = this._options).onDestroy) || void 0 === t || t.call(e)
				}
				options() {
					return this._options
				}
				_bindShortcut() {
					if (!this._options.hotkeyGroup || !this._options.hotkeyHash) return;
					const e = "string" == typeof this._options.label ? this._options.label : this._options.name;
					this._hotkeyAction = this._options.hotkeyGroup.add({
						hotkey: this._options.hotkeyHash,
						desc: e,
						handler: () => this.execute(),
						isDisabled: () => this.isDisabled()
					})
				}
				_unbindShortcut() {
					this._hotkeyAction && (this._hotkeyAction.destroy(), delete this._hotkeyAction)
				}
			}
			class c extends a {
				constructor(e, t, i) {
					super({
						actionId: e
					}, i), this._loader = t, this._loaded = !1
				}
				loadOptions() {
					return this._loadingPromise || (this._loadingPromise = this._loader().then((e => {
						this._loaded = !0, this.update(e)
					}))), this._loadingPromise
				}
				getState() {
					return this.loadOptions(), super.getState()
				}
				isLoading() {
					return !this.isLoaded()
				}
				isLoaded() {
					return this._loaded
				}
			}
			class u {
				constructor(e) {
					this.type = "separator", this.id = l.guid(), this._hint = e
				}
				getHint() {
					return this._hint
				}
			}
			class h extends a {
				constructor(e) {
					super({
						actionId: e
					})
				}
				isLoading() {
					return !0
				}
				getSize() {
					return "big"
				}
			}
		},
		824112: (e, t, i) => {
			"use strict";
			i.d(t, {
				Size: () => o,
				getCanvasDevicePixelRatio: () => l,
				getBindingPixelRatio: () => a,
				getContext2D: () => c,
				getPrescaledContext2D: () => u,
				getPretransformedContext2D: () => h,
				fillRect: () => d,
				clearRect: () => p,
				drawScaled: () => _,
				createDisconnectedCanvas: () => P,
				createDisconnectedBoundCanvas: () => f,
				createBoundCanvas: () => v,
				calcTextHorizontalShift: () => m,
				disableSelection: () => C,
				addExclusionArea: () => y
			});
			var r = i(640435),
				n = i(588537),
				s = i(143498);
			class o {
				constructor(e, t) {
					this.w = e, this.h = t
				}
				equals(e) {
					return this.w === e.w && this.h === e.h
				}
			}

			function l(e) {
				var t, i;
				return Math.max(1, (null === (i = null === (t = e.ownerDocument) || void 0 === t ? void 0 : t.defaultView) || void 0 === i ? void 0 : i.devicePixelRatio) || 1)
			}

			function a(e) {
				return l(e.canvasElement)
			}

			function c(e) {
				const t = (0, n.ensureNotNull)(e.getContext("2d"));
				return t.setTransform(1, 0, 0, 1, 0, 0), t
			}

			function u(e) {
				const t = (0, n.ensureNotNull)(e.getContext("2d")),
					i = l(e);
				return t.setTransform(i, 0, 0, i, 0, 0), t
			}

			function h(e, t) {
				const i = (0, n.ensureNotNull)(e.canvasElement.getContext("2d")),
					r = a(e);
				return i.setTransform(r, 0, 0, r, 0, 0), t || i.translate(.5, .5), i
			}

			function d(e, t, i, r, n, s) {
				e.save(), e.translate(-.5, -.5), e.fillStyle = s, e.fillRect(t, i, r, n), e.restore()
			}

			function p(e, t, i, r, n, s) {
				e.save(),
					e.translate(-.5, -.5), e.globalCompositeOperation = "copy", e.fillStyle = s, e.fillRect(t, i, r, n), e.restore()
			}

			function _(e, t, i) {
				e.save(), e.scale(t, t), i(), e.restore()
			}

			function P(e, t, i) {
				const r = g(e);
				return void 0 === i && (i = l(r)), r.width = t.w * i, r.height = t.h * i, r
			}

			function f(e, t) {
				const i = g(e),
					n = (0, r.bindCanvasElementBitmapSizeTo)(i, {
						type: "device-pixel-content-box",
						transform: (e, t) => ({
							width: Math.max(e.width, t.width),
							height: Math.max(e.height, t.height)
						})
					});
				return n.resizeCanvasElement({
					width: t.w,
					height: t.h
				}), n
			}

			function g(e) {
				const t = e.createElement("canvas");
				return C(t), t
			}

			function v(e, t) {
				const i = g((0, n.ensureNotNull)(e.ownerDocument));
				e.appendChild(i);
				const s = (0, r.bindCanvasElementBitmapSizeTo)(i, {
					type: "device-pixel-content-box",
					transform: (e, t) => ({
						width: Math.max(e.width, t.width),
						height: Math.max(e.height, t.height)
					})
				});
				return s.resizeCanvasElement({
					width: t.w,
					height: t.h
				}), s
			}

			function m(e, t) {
				return "center" === e.textAlign ? 0 : (0, s.isRtl)() ? "start" === e.textAlign || "right" === e.textAlign ? t : 0 : "start" === e.textAlign || "left" === e.textAlign ? 0 : t
			}

			function C(e) {
				e.style.userSelect = "none", e.style.webkitUserSelect = "none", e.style.msUserSelect = "none", e.style.MozUserSelect = "none", e.style.webkitTapHighlightColor = "transparent"
			}

			function y(e, t, i) {
				e.beginPath(), e.rect(0, 0, t.physicalWidth, t.physicalHeight);
				for (let r = 0; r < i.length; r++) {
					let {
						x: n,
						y: s
					} = i[r];
					n *= t.pixelRatio, s *= t.pixelRatio, 0 !== r ? e.lineTo(n, s) : e.moveTo(n, s)
				}
				e.closePath(), e.clip("evenodd")
			}
		},
		588427: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				setChartFontFamily: () => o,
				CHART_FONT_FAMILY: () => l,
				CHART_MONOSPACE_FONT_FAMILY: () => a
			});
			var r = i(314802);
			const n = "'Trebuchet MS', Roboto, Ubuntu, sans-serif",
				s = `-apple-system, BlinkMacSystemFont, ${n}`;

			function o(e) {
				l = e
			}
			let l = ((0, r.isOnMobileAppPage)("old"), n);
			const a = "monospace"; {
				const e = ["U+2E80-2FD5", "U+3040-309F", "U+1B100-1B12F", "U+1AFF0-1AFFF", "U+1B000-1B0FF", "U+1B130-1B16F", "U+3190-319F", "U+30A0-30FF", "U+31F0-31FF", "U+3400-4DBF", "U+4E00-9FFF", "U+0E00-0E7F"],
					t = l;
				(async () => {
					if (!/iPhone OS 15_\d+?/.test(navigator.userAgent)) return s; {
						if (["kr", "zh_CN", "zh_TW"].includes(window.locale)) return l;
						const t = new FontFace("ChartIosFont", "local(Helvetica), local(Arial)", {
							unicodeRange: e.join(", ")
						});
						try {
							return document.fonts.add(await t.load()), `ChartIosFont, ${s}`
						} catch (e) {
							return l
						}
					}
				})().then((e => {
					t === l && o(e)
				}))
			}
		},
		676553: (e, t, i) => {
			"use strict";
			i.d(t, {
				showCustomUrlEventDialog: () => l
			});
			var r = i(575932),
				n = i(779923);
			const s = (0, r.t)("Ok"),
				o = (0, r.t)("Cancel");
			async function l(e) {
				const {
					onConfirm: t,
					onClose: i,
					title: r,
					placeholderText: l
				} = e;
				return (0, n.showRename)({
					title: r,
					text: "",
					placeholder: l,
					mainButtonText: s,
					cancelButtonText: o,
					onRename: ({
						newValue: e,
						dialogClose: i
					}) => {
						t(e), i()
					},
					onClose: i
				})
			}
		},
		63208: (e, t, i) => {
			"use strict";
			i.d(t, {
				CHART_WIDGET_COLLECTION_SERVICE: () => n,
				chartWidgetCollectionService: () => s,
				CollectionViewMode: () => o
			});
			var r = i(564894);
			const n = {
				id: "ChartWidgetCollectionService"
			};

			function s() {
				return (0, r.hasService)(n) ? (0, r.service)(n) : null
			}
			var o;
			! function(e) {
				e.Multichart = "multichart", e.ForceFullscreen = "force-fullscreen"
			}(o || (o = {}))
		},
		388230: (e, t, i) => {
			"use strict";
			i.d(t, {
				InvalidationLevel: () => r,
				InvalidationMask: () => l,
				defaultInvalidationLevel: () => o
			});
			var r, n = i(588537);
			class s {
				constructor(e = o) {
					this._paneInvalidationLevel = o, this._leftPriceScalesInvalidationMap = new Map, this._rightPriceScalesInvalidationMap = new Map, this._legendWidgetInvalidated = !1, this._invalidationLevel = e
				}
				fullInvalidation() {
					return this._invalidationLevel
				}
				invalidateAll(e) {
					this._invalidationLevel = Math.max(this._invalidationLevel, e)
				}
				invalidatePane(e) {
					this._paneInvalidationLevel = Math.max(this._invalidationLevel, e)
				}
				invalidateLegendWidgetLayout() {
					this._legendWidgetInvalidated = !0
				}
				invalidatePriceScale(e, t, i) {
					const r = "left" === e ? this._leftPriceScalesInvalidationMap : this._rightPriceScalesInvalidationMap,
						n = r.get(t) || o;
					r.set(t, Math.max(n, i))
				}
				invalidationLevelForPane() {
					return Math.max(this._paneInvalidationLevel, this._invalidationLevel)
				}
				legendWidgetLayoutInvalidated() {
					return this._legendWidgetInvalidated || this._invalidationLevel === r.Full
				}
				getterForPriceScaleInvalidationLevelBySide(e) {
					const t = "left" === e ? this._leftPriceScalesInvalidationMap : this._rightPriceScalesInvalidationMap;
					return e => Math.max(t.get(e) || o, this._invalidationLevel)
				}
				priceScaleSideMaxLevel(e) {
					const t = "left" === e ? this._leftPriceScalesInvalidationMap : this._rightPriceScalesInvalidationMap;
					let i = this._invalidationLevel;
					return t.size > 0 && t.forEach((e => {
						e > i && (i = e)
					})), i
				}
				merge(e) {
					this._invalidationLevel = Math.max(this._invalidationLevel, e._invalidationLevel), this._paneInvalidationLevel = Math.max(this._paneInvalidationLevel, e._paneInvalidationLevel), e._leftPriceScalesInvalidationMap.forEach(((e, t) => {
						const i = this._leftPriceScalesInvalidationMap.get(t) || o;
						this._leftPriceScalesInvalidationMap.set(t, Math.max(i, e))
					})), e._rightPriceScalesInvalidationMap.forEach(((e, t) => {
						const i = this._rightPriceScalesInvalidationMap.get(t) || o;
						this._rightPriceScalesInvalidationMap.set(t, Math.max(i, e))
					})), this._legendWidgetInvalidated = this._legendWidgetInvalidated || e._legendWidgetInvalidated
				}
			}! function(e) {
				e[e.None = 0] = "None", e[e.Cursor = 1] = "Cursor", e[e.Light = 2] = "Light", e[e.Full = 3] = "Full"
			}(r || (r = {}));
			const o = r.None;
			class l {
				constructor(e = o) {
					this._panesOrderChanged = !1, this._keepVisibleTimeRangeOnResize = !1, this._timeAxisInvalidationLevel = o, this._invalidatedPanes = new Map, this._additionalActions = [], this._invalidationLevel = e
				}
				invalidateAll(e) {
					this._invalidationLevel !== e && (this._invalidationLevel = Math.max(this._invalidationLevel, e), this._invalidatedPanes.forEach((e => {
						e.invalidateAll(this._invalidationLevel)
					})))
				}
				invalidateAllPane(e, t) {
					this._invalidatedPanes.has(e) || this._invalidatedPanes.set(e, new s(this._invalidationLevel)), (0, n.ensureDefined)(this._invalidatedPanes.get(e)).invalidateAll(t)
				}
				invalidatePriceScale(e, t, i, r) {
					this._invalidatedPanes.has(e) || this._invalidatedPanes.set(e, new s(this._invalidationLevel)), (0, n.ensureDefined)(this._invalidatedPanes.get(e)).invalidatePriceScale(t, i, r)
				}
				invalidateTimeScale(e) {
					this._timeAxisInvalidationLevel = Math.max(this._timeAxisInvalidationLevel, e)
				}
				invalidatePanesOrder() {
					this._panesOrderChanged = !0
				}
				lockVisibleTimeRangeOnResize() {
					this._keepVisibleTimeRangeOnResize = !0
				}
				fullInvalidation() {
					return this._invalidationLevel
				}
				maxPaneInvalidation() {
					const e = [];
					return this._invalidatedPanes.forEach((t => {
						e.push(t.fullInvalidation())
					})), Math.max(...e, this._invalidationLevel)
				}
				invalidateForPane(e) {
					return this._invalidatedPanes.get(e) || new s(this._invalidationLevel)
				}
				invalidateForTimeScale() {
					return Math.max(this._timeAxisInvalidationLevel, this._invalidationLevel)
				}
				validationActions() {
					return this._additionalActions
				}
				addValidationAction(e) {
					this._additionalActions.push(e)
				}
				merge(e) {
					this._invalidationLevel = Math.max(this._invalidationLevel, e._invalidationLevel), this._panesOrderChanged = this._panesOrderChanged || e._panesOrderChanged, this._keepVisibleTimeRangeOnResize = this._keepVisibleTimeRangeOnResize || e._keepVisibleTimeRangeOnResize, this._invalidatedPanes.forEach((e => {
						e.invalidateAll(this._invalidationLevel)
					})), e._invalidatedPanes.forEach(((e, t) => {
						this._invalidatedPanes.has(t) || this._invalidatedPanes.set(t, new s(this._invalidationLevel)), (0, n.ensureDefined)(this._invalidatedPanes.get(t)).merge(e)
					})), this._timeAxisInvalidationLevel = Math.max(this._timeAxisInvalidationLevel, e._timeAxisInvalidationLevel);
					for (let t = 0; t < e._additionalActions.length; t++) this._additionalActions.push(e._additionalActions[t])
				}
				panesOrderInvalidated() {
					return this._panesOrderChanged
				}
				isVisibleTimeRangeLockedOnResize() {
					return this._keepVisibleTimeRangeOnResize
				}
				static cursor() {
					return new l(r.Cursor)
				}
				static light() {
					return new l(r.Light)
				}
				static full() {
					return new l(r.Full)
				}
				static panesOrder() {
					const e = l.full();
					return e.invalidatePanesOrder(), e
				}
				static invalidateLegendWidgetLayout(e) {
					var t;
					const i = new l;
					return i._invalidatedPanes.set(e, new s), null === (t = i._invalidatedPanes.get(e)) || void 0 === t || t.invalidateLegendWidgetLayout(), i
				}
				static validateAction(e) {
					const t = new l;
					return t._additionalActions.push(e), t
				}
			}
		},
		420808: (e, t, i) => {
			"use strict";
			i.d(t, {
				lastMouseOrTouchEventInfo: () => n,
				setLastMouseOrTouchEventInfo: () => s
			});
			let r = (0, i(638456).supportTouch)() ? {
				isTouch: !0,
				stylus: !1
			} : {
				isTouch: !1
			};

			function n() {
				return r
			}

			function s(e) {
				r = e.isTouch ? {
					isTouch: !0,
					stylus: e.stylus
				} : {
					isTouch: !1
				}
			}
		},
		180560: (e, t, i) => {
			"use strict";
			var r, n, s, o, l, a, c, u, h, d, p, _, P, f, g;
			i.r(t), i.d(t, {
					CONNECTSTATUSES: () => r,
					ORDERTYPE: () => n,
					SIDE: () => s,
					ORDERSTATUS: () => o,
					ORDERSTATUSFILTER: () => l,
					TradingEntityType: () => a,
					PARENTTYPE: () => c,
					BracketType: () => u,
					TICKETFOCUS: () => h,
					NOTIFICATION: () => d,
					OrderOrPositionMessageType: () => p,
					AccountType: () => _,
					DisconnectType: () => P,
					PipValueType: () => f,
					RestrictionType: () => g
				}),
				function(e) {
					e[e.CONNECTED = 1] = "CONNECTED", e[e.CONNECTING = 2] = "CONNECTING", e[e.DISCONNECTED = 3] = "DISCONNECTED", e[e.ERROR = 4] = "ERROR"
				}(r || (r = {})),
				function(e) {
					e[e.LIMIT = 1] = "LIMIT", e[e.MARKET = 2] = "MARKET", e[e.STOP = 3] = "STOP", e[e.STOPLIMIT = 4] = "STOPLIMIT"
				}(n || (n = {})),
				function(e) {
					e[e.BUY = 1] = "BUY", e[e.SELL = -1] = "SELL"
				}(s || (s = {})),
				function(e) {
					e[e.CANCELED = 1] = "CANCELED", e[e.FILLED = 2] = "FILLED", e[e.INACTIVE = 3] = "INACTIVE", e[e.PLACING = 4] = "PLACING", e[e.REJECTED = 5] = "REJECTED", e[e.WORKING = 6] = "WORKING"
				}(o || (o = {})),
				function(e) {
					e[e.ALL = 0] = "ALL", e[e.CANCELED = 1] = "CANCELED", e[e.FILLED = 2] = "FILLED", e[e.INACTIVE = 3] = "INACTIVE", e[e.REJECTED = 5] = "REJECTED",
						e[e.WORKING = 6] = "WORKING"
				}(l || (l = {})),
				function(e) {
					e[e.Order = 1] = "Order", e[e.Position = 2] = "Position"
				}(a || (a = {})),
				function(e) {
					e[e.ORDER = 1] = "ORDER", e[e.POSITION = 2] = "POSITION"
				}(c || (c = {})),
				function(e) {
					e[e.StopLoss = 0] = "StopLoss", e[e.TakeProfit = 1] = "TakeProfit", e[e.TrailingStop = 2] = "TrailingStop"
				}(u || (u = {})),
				function(e) {
					e[e.LIMITPRICE = 1] = "LIMITPRICE", e[e.STOPPRICE = 2] = "STOPPRICE", e[e.TAKEPROFIT = 3] = "TAKEPROFIT", e[e.STOPLOSS = 4] = "STOPLOSS"
				}(h || (h = {})),
				function(e) {
					e[e.ERROR = 0] = "ERROR", e[e.SUCCESS = 1] = "SUCCESS"
				}(d || (d = {})),
				function(e) {
					e.Information = "information", e.Warning = "warning", e.Error = "error"
				}(p || (p = {})),
				function(e) {
					e.Demo = "demo", e.Live = "live"
				}(_ || (_ = {})),
				function(e) {
					e[e.LogOut = 0] = "LogOut", e[e.FailedRestoring = 1] = "FailedRestoring", e[e.Offline = 2] = "Offline", e[e.APIError = 3] = "APIError", e[e.TwoFactorRequired = 4] = "TwoFactorRequired", e[e.CancelAuthorization = 5] = "CancelAuthorization", e[e.TimeOutForAuthorization = 6] = "TimeOutForAuthorization", e[e.OauthError = 7] = "OauthError", e[e.BrokenConnection = 8] = "BrokenConnection"
				}(P || (P = {})),
				function(e) {
					e[e.None = 0] = "None", e[e.Pips = 1] = "Pips", e[e.Ticks = 2] = "Ticks"
				}(f || (f = {})),
				function(e) {
					e.Halted = "HALTED", e.NotShortable = "NOT-SHORTABLE", e.HardToBorrow = "HARD-TO-BORROW"
				}(g || (g = {}))
		},
		20006: (e, t, i) => {
			"use strict";
			i.d(t, {
				alignToStep: () => s
			});
			var r = i(960521),
				n = i.n(r);

			function s(e, t) {
				return n()(e).div(t).round(0, n().roundHalfUp).mul(t).toNumber()
			}
		},
		556616: (e, t, i) => {
			"use strict";
			var r = i(208214).makeFont,
				n = i(208214).parseFont,
				s = (0, i(911905).getLogger)("Model.ChartTradingUtils"),
				o = {
					_fontHeightCache: {},
					_parsedColorCache: {},
					_parseColor: function(e) {
						if (this._parsedColorCache[e]) return this._parsedColorCache[e];
						var t = document.createElement("div");
						t.style.color = e;
						var i = t.style.color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i) || t.style.color.match(/^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d*\.?\d+)\s*\)$/i),
							r = {
								r: i[1],
								g: i[2],
								b: i[3],
								a: i[4] || "1"
							};
						return this._parsedColorCache[e] = r, r
					},
					getColorFromProperties: function(e, t) {
						var i = 1 - t.value() / 100,
							r = this._parseColor(e.value());
						return "rgba(" + r.r + "," + r.g + "," + r.b + "," + i + ")"
					},
					setColorToProperties: function(e, t, i) {
						var r = this._parseColor(e);
						t.setValue("rgb(" + r.r + "," + r.g + "," + r.b + ")");
						var n = 100 * (1 - r.a);
						i.setValue(Math.max(0, Math.min(n, 100)))
					},
					getFontFromProperties: function(e, t, i, n) {
						return r(t.value(), e.value(), n.value() ? "italic" : "", i.value() ? "bold" : "")
					},
					setFontToProperties: function(e, t, i, r, o) {
						var l = n(e);
						null !== l ? (l.family.length > 0 && t.setValue(l.family), i.setValue(l.size), r.setValue(l.bold), o.setValue(l.italic)) : s.logError("Invalid font: " + e)
					},
					fontHeight: function(e) {
						if (!this._fontHeightCache[e]) {
							var t = document.createElement("span");
							t.appendChild(document.createTextNode("height")), document.body.appendChild(t), t.style.cssText = "font: " + e + "; white-space: nowrap; display: inline;";
							var i = t.offsetHeight;
							document.body.removeChild(t), this._fontHeightCache[e] = Math.ceil(i)
						}
						return this._fontHeightCache[e]
					},
					drawPolyHoverOrPress: function(e, t, i, r) {
						r ? (e.save(), e.fillStyle = "rgba(0, 0, 0, 0.15)", CanvasEx.drawPoly(e, t, !0), e.restore()) : i && (e.save(), e.fillStyle = "rgba(0, 0, 0, 0.1)",
							CanvasEx.drawPoly(e, t, !0), e.restore())
					},
					repaint: function(e) {
						e.lightUpdate()
					},
					roundToMinTick: function(e, t) {
						var i = 1 / e.mainSource().base();
						return i * Math.round(t / i)
					}
				};
			e.exports = o
		},
		62949: (e, t, i) => {
			"use strict";
			i.d(t, {
				DataSource: () => c
			});
			var r = i(611688),
				n = i(262325),
				s = i.n(n),
				o = i(95935),
				l = i(97639),
				a = i.n(l);
			class c {
				constructor(e) {
					this.hasAlert = new(s())(!1), this._zorder = 0, this.m_priceScale = null, this._ownerSource = null, this._userEditEnabled = !0, this._onPriceScaleChanged = new(a()), this._isSelectionEnabled = !0, this._instanceId = (0, o.randomHashN)(6), this._ownerSourceChanged = new(a()), this._zOrderChanged = new(a()), this._id = null != e ? e : (0, o.randomHashN)(6)
				}
				id() {
					return this._id
				}
				instanceId() {
					return this._instanceId
				}
				preferNoScale() {
					return !1
				}
				setId(e) {
					this._id = e
				}
				zorder() {
					return this._zorder
				}
				setZorder(e) {
					"number" == typeof e && this._zorder !== e && (this._zorder = e, this._zOrderChanged.fire(e))
				}
				isSpeciallyZOrderedSource() {
					return !1
				}
				title() {
					throw new Error("Implement this fun in a subclass")
				}
				name() {
					throw new Error("Implement this fun in a subclass")
				}
				priceScale() {
					return this.m_priceScale
				}
				setPriceScale(e) {
					this.m_priceScale = e, this._onPriceScaleChanged.fire()
				}
				ownerSource() {
					return this._ownerSource
				}
				setOwnerSource(e) {
					this._ownerSource = e, this._ownerSourceChanged.fire()
				}
				ownerSourceChanged() {
					return this._ownerSourceChanged
				}
				zOrderChanged() {
					return this._zOrderChanged
				}
				isSavedInChart(e) {
					return !0
				}
				isSavedInStudyTemplates() {
					return !0
				}
				isRemovedByStudyTemplates() {
					return !0
				}
				hasContextMenu() {
					return !0
				}
				showInObjectTree() {
					return !0
				}
				setUserEditEnabled(e) {
					this._userEditEnabled = e
				}
				userEditEnabled() {
					return this._userEditEnabled
				}
				canBeHidden() {
					return this.userEditEnabled()
				}
				isUserDeletable() {
					return this.userEditEnabled()
				}
				properties() {
					throw new Error("Implement this fun in a subclass")
				}
				isVisible() {
					return this.properties().visible.value()
				}
				dataWindowView() {
					return null
				}
				priceAxisViews(e, t) {
					return null
				}
				timeAxisViews() {
					return null
				}
				updateAllViews(e) {}
				paneViews(e) {
					return null
				}
				labelPaneViews() {
					return null
				}
				isFailed() {
					return !1
				}
				isLoading() {
					return !1
				}
				isPhantom() {
					return !1
				}
				isChildStudy() {
					return !1
				}
				hasChildren() {
					return !1
				}
				canHaveChildren() {
					return !1
				}
				onClickOutside() {}
				getSourceIcon() {
					return null
				}
				state(e) {
					throw new Error("Implement this fun in a subclass")
				}
				onPriceScaleChanged() {
					return this._onPriceScaleChanged
				}
				doesMovingAffectsUndo() {
					return !0
				}
				isMultiPaneAvailable() {
					return !1
				}
				isMultiPaneEnabled() {
					return !1
				}
				copiable() {
					return !1
				}
				cloneable() {
					return !1
				}
				movable() {
					return !1
				}
				isIncludedInAutoScale() {
					return !1
				}
				isHoveredEnabled() {
					return this.isSelectionEnabled()
				}
				isSelectionEnabled() {
					return this._isSelectionEnabled
				}
				setSelectionEnabled(e) {
					this._isSelectionEnabled = e
				}
				firstValue() {
					return null
				}
				priceRange(e, t) {
					return null
				}
				autoScaleInfo(e, t) {
					return {
						range: this.priceRange(e, t)
					}
				}
				stateForAlert() {
					return null
				}
				canHasAlert() {
					return !1
				}
				alertCreationAvailable() {
					return this.hasStateForAlert()
				}
				hasStateForAlert() {
					return r.enabled("alerts")
				}
				idForAlert() {
					return this._id
				}
			}
		},
		346090: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				createDefaultsState: () => d,
				saveDefaultProperties: () => _,
				DefaultProperty: () => P
			});
			var r = i(822914),
				n = i(754061),
				s = i(702040),
				o = i(385518),
				l = i(232567),
				a = i.n(l),
				c = i(97639),
				u = i.n(c);

			function h(e, t) {
				const i = (0, r.default)(e);
				return t.forEach((e => (0, s.default)(i, e.split(".")))), i
			}

			function d(e, t, i, s) {
				const l = e ? o.defaults : o.factoryDefaults,
					a = t.startsWith("study_") ? (0, r.default)(l("study")) : {};
				let c = (0, r.default)(l(t, s));
				return t.startsWith("study_") && c.inputs && delete c.inputs.symbol, "linetoolicon" === t && e && (c.icon = (0, o.defaults)(t).icon), c = h(c, i), (0, n.default)(a, c), a
			}
			let p = !1;

			function _(e) {
				p = e
			}
			class P extends(a()) {
				constructor(e, t, i, r) {
					super(function(e, t, i, r) {
						let s;
						return void 0 === r && (r = !0), i ? s = t : (s = d(r, e, [], null), t && (0, n.default)(s, t)), s
					}(e, t, i, r)), this._exclusions = [], this._restoreFactoryDefaultsEvent = new(u()), this._defaultName = e, this._useUserPreferences = null == r || r, this.listeners().subscribe(this, P.prototype.onPropertyChanged), this._restoreFactoryDefaultsEvent = new(u())
				}
				preferences() {
					return this.state(this._exclusions)
				}
				mergePreferences(e) {
					this.mergeAndFire(h(e, this._exclusions))
				}
				addExclusion(e) {
					this._exclusions.indexOf(e) < 0 && this._exclusions.push(e)
				}
				removeExclusion(e) {
					const t = this._exclusions.indexOf(e); - 1 !== t && this._exclusions.splice(t, 1)
				}
				restoreFactoryDefaults() {
					const e = d(!1, this._defaultName, this._exclusions, null);
					this.mergeAndFire(e), this._defaultName.startsWith("study_") && !this._defaultName.startsWith("study_VbPFixed") || (0, o.saveDefaults)(this._defaultName, void 0), this._restoreFactoryDefaultsEvent.fire()
				}
				onRestoreFactoryDefaults() {
					return this._restoreFactoryDefaultsEvent
				}
				onPropertyChanged() {
					!p || this._defaultName.startsWith("study_") && !this._defaultName.startsWith("study_VbPFixed") || this.saveDefaults()
				}
				saveDefaults() {
					this._useUserPreferences && (0, o.saveDefaults)(this._defaultName, this.preferences())
				}
				clone(e) {
					const t = new P(this._defaultName, this.state(), null == e ? void 0 : e.replaceByState, this._useUserPreferences);
					for (let e = 0; e < this._exclusions.length; ++e) t.addExclusion(this._exclusions[e]);
					return t
				}
			}
		},
		308170: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				toolIsCursor: () => p,
				toolIsMeasure: () => _,
				resetToCursor: () => P,
				lockTimeAxisTime: () => T,
				tool: () => S,
				iconTool: () => w,
				cursorTool: () => b,
				isToolCreatingNow: () => x,
				isToolEditingNow: () => L,
				isToolMovingNow: () => A,
				isDirectionalMovementActive: () => D,
				createdLineTool: () => V,
				continuedLineTool: () => I,
				cancelledLineTool: () => M,
				beenSetLineToolLastPoint: () => R,
				startedMovingLineTool: () => B,
				movedLineTool: () => E,
				finishedMovingLineTool: () => k,
				startedChangingLineTool: () => N,
				changedLineTool: () => F,
				finishedChangingLineTool: () => O,
				removedLineTool: () => U,
				finishedLineTool: () => z,
				changedLineStyle: () => W,
				copiedLineTool: () => H,
				restoredLineTool: () => q,
				restoredLineToolState: () => j,
				isPointSelectedNow: () => G,
				isStudyEditingNow: () => K,
				createLineTool: () => $,
				continueLineTool: () => X,
				cancelLineTool: () => Z,
				setLineToolLastPoint: () => J,
				startMovingLineTool: () => ee,
				moveLineTool: () => te,
				finishMovingLineTool: () => ie,
				startChangingLineTool: () => re,
				changeLineTool: () => ne,
				finishChangingLineTool: () => se,
				removeLineTool: () => oe,
				finishLineTool: () => le,
				changeLineStyle: () => ae,
				copyLineTool: () => ce,
				restoreLineTool: () => ue,
				restoreLineToolState: () => he,
				init: () => _e,
				runOnDrawingStateReady: () => Pe,
				properties: () => fe,
				hideAllDrawings: () => ge,
				hideAllIndicators: () => ve,
				lockDrawings: () => me,
				hideMarksOnBars: () => Ce,
				drawOnAllCharts: () => ye,
				drawOnAllChartsMode: () => Te,
				lockTimeAxis: () => Se
			});
			var r = i(588537),
				n = i(860949),
				s = i(346090),
				o = i(385518),
				l = i(262325),
				a = i.n(l),
				c = i(97639),
				u = i.n(c),
				h = i(62802),
				d = i(251954);

			function p(e) {
				return "cursor" === e || "arrow" === e || "dot" === e
			}

			function _(e) {
				return "measure" === e
			}

			function P(e = !1) {
				if (!e && f) {
					if (f.childs().stayInDrawingMode.value()) return
				}
				S.setValue(b.value())
			}
			let f = null,
				g = null,
				v = null,
				m = null,
				C = null,
				y = null;
			const T = new(a()),
				S = new(a()),
				w = new(a()),
				b = new(a()),
				x = new(a())(!1),
				L = new(a())(!1),
				A = new(a())(!1),
				D = new(a())(!1),
				V = new(u()),
				I = new(u()),
				M = new(u()),
				R = new(u()),
				B = new(u()),
				E = new(u()),
				k = new(u()),
				N = new(u()),
				F = new(u()),
				O = new(u()),
				U = new(u()),
				z = new(u()),
				W = new(u()),
				H = new(u()),
				q = new(u()),
				j = new(u()),
				G = new(a())(!1),
				K = new(a())(!1);

			function Q(e, t) {
				const i = t || {
					value: !1
				};
				return t => {
					i.value || (i.value = !0, e.fire(t), i.value = !1)
				}
			}
			const Y = {
					value: !1
				},
				$ = Q(V, Y),
				X = Q(I, Y),
				Z = Q(M, Y),
				J = Q(R, Y),
				ee = Q(B),
				te = Q(E),
				ie = Q(k),
				re = Q(N),
				ne = Q(F),
				se = Q(O),
				oe = Q(U),
				le = Q(z),
				ae = Q(W, Y),
				ce = Q(H, Y),
				ue = Q(q),
				he = Q(j);
			let de = !1,
				pe = [];

			function _e() {
				de || (S.setValue(h.getValue("chart.cursorPreference", "cursor")), S.subscribe((e => p(e) && b.setValue(e)), {
					callWithLast: !0
				}), b.subscribe((e => {
					e && h.setValue("chart.cursorPreference", e)
				})), f = new s.DefaultProperty("drawings"), g = (0, n.createPrimitiveProperty)(), v = (0, n.createPrimitiveProperty)(), m = (0, n.createPrimitiveProperty)(), C = (0, n.createPrimitiveProperty)(), y = (0, n.createPrimitiveProperty)(), g.setValue(!1), v.setValue(!1), m.setValue(!1), C.setValue(!1), y.setValue(!1), S.subscribe((() => {
					(0, d.emit)("onSelectedLineToolChanged")
				})), w.subscribe((() => {
					(0, o.saveDefaults)("linetoolicon", {
						...(0, o.defaults)("linetoolicon"),
						icon: w.value()
					})
				})), de = !0, pe.forEach((e => e())), pe = [])
			}

			function Pe(e) {
				de ? e() : pe.push(e)
			}

			function fe() {
				return (0, r.ensureNotNull)(f)
			}

			function ge() {
				return (0, r.ensureNotNull)(g)
			}

			function ve() {
				return (0, r.ensureNotNull)(v)
			}

			function me() {
				return (0, r.ensureNotNull)(m)
			}

			function Ce() {
				return (0, r.ensureNotNull)(C)
			}

			function ye() {
				return fe().childs().drawOnAllCharts
			}

			function Te() {
				return fe().childs().drawOnAllChartsMode
			}

			function Se() {
				return (0, r.ensureNotNull)(y)
			}
		},
		396484: (e, t, i) => {
			"use strict";
			i.d(t, {
				LimitedPrecisionNumericFormatter: () => n
			});
			var r = i(270617);
			class n {
				constructor(e = 1) {
					this._precision = e
				}
				format(e) {
					(0, r.isNumber)(e) || (e = parseFloat(e));
					const t = e.toFixed(this._precision),
						i = Math.pow(10, -this._precision);
					return Math.max(parseFloat(t), i) + ""
				}
				parse(e) {
					const t = parseFloat(e);
					return isNaN(t) ? {
						res: !1
					} : {
						res: !0,
						value: t,
						suggest: this.format(t)
					}
				}
			}
		},
		218718: (e, t, i) => {
			"use strict";

			function r(e, t, i) {
				if (e.isTouch) {
					if (void 0 !== i) return i(e), !0
				} else if (void 0 !== t) return t(e), !0;
				return !1
			}

			function n(e, t, i, r) {
				return void 0 !== t.executeDefaultAction && (e.isTouch ? Boolean(t.executeDefaultAction[r]) : Boolean(t.executeDefaultAction[i]))
			}
			var s;
			i.d(t, {
					tryCallHandler: () => r,
					shouldDefaultActionBeExecuted: () => n,
					AreaName: () => s,
					HitTestResult: () => o
				}),
				function(e) {
					e.Style = "Style", e.Text = "Text", e.SourceItemMove = "SourceItemMove"
				}(s || (s = {}));
			class o {
				constructor(e, t, i) {
					this._result = e, this._data = t || null, this._eraseMarker = i
				}
				result() {
					return this._result
				}
				data() {
					return this._data
				}
				hasPressedMoveHandler(e) {
					return null !== this._data && function(e, t, i) {
						if (e.isTouch) {
							if (void 0 !== i) return !0
						} else if (void 0 !== t) return !0;
						return !1
					}(e, this._data.pressedMouseMoveHandler, this._data.touchMoveHandler)
				}
				tryCallMouseDownOrTouchStartHandler(e) {
					return null !== this._data && r(e, this._data.mouseDownHandler, this._data.touchStartHandler)
				}
				tryCallMouseUpOrTouchEndHandler(e) {
					return null !== this._data && r(e, this._data.mouseUpHandler, this._data.touchEndHandler)
				}
				tryCallMouseEnterHandler(e) {
					return null !== this._data && r(e, this._data.mouseEnterHandler)
				}
				tryCallMouseLeaveHandler(e) {
					return null !== this._data && r(e, this._data.mouseLeaveHandler)
				}
				tryCallMouseMoveHandler(e) {
					return null !== this._data && r(e, this._data.mouseMoveHandler)
				}
				tryCallClickOrTapHandler(e) {
					return null !== this._data && r(e, this._data.clickHandler, this._data.tapHandler)
				}
				tryCallDblClickOrDblTapHandler(e) {
					return null !== this._data && r(e, this._data.doubleClickHandler, this._data.doubleTapHandler)
				}
				tryCallContextMenuHandler(e) {
					return null !== this._data && r(e, this._data.contextMenuHandler, this._data.touchContextMenuHandler)
				}
				eraseMarker() {
					return this._eraseMarker
				}
			}
			o.MOVEPOINT_BACKGROUND = 1, o.REGULAR = 2, o.MOVEPOINT = 3, o.CHANGEPOINT = 4, o.CUSTOM = 5
		},
		194543: (e, t, i) => {
			"use strict";
			i.d(t, {
				intervalsVisibilitiesDefaults: () => r
			});
			const r = {
				ticks: !0,
				seconds: !0,
				secondsFrom: 1,
				secondsTo: 59,
				minutes: !0,
				minutesFrom: 1,
				minutesTo: 59,
				hours: !0,
				hoursFrom: 1,
				hoursTo: 24,
				days: !0,
				daysFrom: 1,
				daysTo: 366,
				weeks: !0,
				weeksFrom: 1,
				weeksTo: 52,
				months: !0,
				monthsFrom: 1,
				monthsTo: 12,
				ranges: !0
			}
		},
		52500: (e, t, i) => {
			"use strict";
			i.d(t, {
				IntervalsVisibilitiesProperty: () => o
			});
			var r = i(232567),
				n = i.n(r),
				s = i(669415);
			class o extends(n()) {
				state(e) {
					var t;
					return null !== (t = (0, s.nonDefaultIntervalsVisibilities)(super.state(e))) && void 0 !== t ? t : void 0
				}
				storeStateIfUndefined() {
					return !1
				}
			}
		},
		669415: (e, t, i) => {
			"use strict";
			i.d(t, {
				makeIntervalsVisibilitiesVisibleAtInterval: () => l,
				isActualInterval: () => c,
				nonDefaultIntervalsVisibilities: () => u,
				mergeIntervalVisibilitiesDefaults: () => h
			});
			var r = i(588537),
				n = i(273044),
				s = i(194543),
				o = i(270617);

			function l(e, t) {
				let i = t.multiplier();
				if (t.isTicks() && (e.ticks = !0), t.isSeconds() && (i < 60 ? (e.seconds = !0, e.secondsFrom = Math.min(e.secondsFrom, i), e.secondsTo = Math.max(e.secondsTo, i)) : (i /= 60, t = new n.Interval(n.ResolutionKind.Minutes, i))), t.isMinutes())
					if (i < 60) e.minutes = !0, e.minutesFrom = Math.min(e.minutesFrom, i), e.minutesTo = Math.max(e.minutesTo, i);
					else {
						const t = Math.floor(i / 60);
						e.hours = !0, e.hoursFrom = Math.min(e.hoursFrom, t), e.hoursTo = Math.max(e.hoursTo, t)
					} t.isDays() && (e.days = !0, e.daysFrom = Math.min(e.daysFrom, i), e.daysTo = Math.max(e.daysTo, i)), t.isWeeks() && (e.weeks = !0, e.weeksFrom = Math.min(e.weeksFrom, i), e.weeksTo = Math.max(e.weeksTo, i)), t.isMonths() && (e.months = !0, e.monthsFrom = Math.min(e.monthsFrom, i), e.monthsTo = Math.max(e.monthsTo, i)), t.isRange() && (e.ranges = !0)
			}

			function a(e, t, i, r) {
				return e && r >= t && r <= i
			}

			function c(e, t) {
				const i = t.childs();
				switch (e.kind()) {
					case n.ResolutionKind.Ticks:
						return i.ticks.value();
					case n.ResolutionKind.Seconds:
						if (e.multiplier() < 60) return a(i.seconds.value(), i.secondsFrom.value(), i.secondsTo.value(), e.multiplier()); {
							const t = Math.floor(e.multiplier() / 60);
							return a(i.minutes.value(), i.minutesFrom.value(), i.minutesTo.value(), t)
						}
						case n.ResolutionKind.Minutes:
							if (e.multiplier() < 60) return a(i.minutes.value(), i.minutesFrom.value(), i.minutesTo.value(), e.multiplier()); {
								const t = Math.floor(e.multiplier() / 60);
								return a(i.hours.value(), i.hoursFrom.value(), i.hoursTo.value(), t)
							}
							case n.ResolutionKind.Days:
								return a(i.days.value(), i.daysFrom.value(), i.daysTo.value(), e.multiplier());
							case n.ResolutionKind.Weeks:
								return a(i.weeks.value(), i.weeksFrom.value(), i.weeksTo.value(), e.multiplier());
							case n.ResolutionKind.Months:
								return a(i.months.value(), i.monthsFrom.value(), i.monthsTo.value(), e.multiplier());
							case n.ResolutionKind.Range:
								return i.ranges.value()
				}
				return (0, r.assert)(!1, `Unsupported resolution: ${e.value()}`), !1
			}

			function u(e) {
				const t = Object.keys(e).filter((t => s.intervalsVisibilitiesDefaults[t] !== e[t]));
				return 0 === t.length ? null : t.reduce(((t, i) => (t[i] = e[i], t)), {})
			}

			function h(e) {
				return (0, o.merge)((0, o.clone)(s.intervalsVisibilitiesDefaults), null != e ? e : {})
			}
		},
		755827: (e, t, i) => {
			"use strict";
			i.d(t, {
				LevelsProperty: () => p
			});
			var r = i(270617),
				n = i(346090),
				s = i(385518);
			const o = {
				prefixes: [""],
				range: [0, 0],
				names: ["coeff", "color", "visible", "linestyle", "linewidth"],
				typecheck: {
					pack: () => Object(),
					unpack: () => []
				}
			};

			function l(e, t, i, r) {
				return r.push(i[t]), r
			}

			function a(e, t, i, r) {
				return r[t] = i[e], r
			}

			function c() {
				return []
			}

			function u() {
				return {}
			}

			function h(e, t, i) {
				return i.prefixes.forEach((n => {
					const s = n + "level";
					for (let n = i.range[0]; n <= i.range[1]; n++)
						if (e[s + n] && (0, r.isSameType)(e[s + n], t.typecheck())) {
							let r = t.tpl();
							i.names.forEach(((i, o) => {
								r = t.fill("" + o, i, e[s + n], r)
							})), e[s + n] = r
						}
				})), e
			}

			function d(e, t, i) {
				return i(e, {
					tpl: u,
					fill: a,
					typecheck: t.typecheck.unpack
				}, t)
			}
			class p extends n.DefaultProperty {
				constructor(e, t, i, r, n) {
					n = null != n ? n : h;
					const s = {
						...o,
						...null != r ? r : {}
					};
					super(e, t ? d(t, s, n) : t, i), this._map = s, this._levelsIterator = n
				}
				state(e, t) {
					const i = super.state(e);
					return t ? i : (r = i, n = this._map, (0, this._levelsIterator)(r, {
						tpl: c,
						fill: l,
						typecheck: n.typecheck.pack
					}, n));
					var r, n
				}
				saveDefaults() {
					this._useUserPreferences && (0, s.saveDefaults)(this._defaultName, this.state(this._exclusions, !0))
				}
				clone() {
					const e = this.state(),
						t = new p(this._defaultName, e);
					for (let e = 0; e < this._exclusions.length; ++e) t.addExclusion(this._exclusions[e]);
					return t
				}
				merge(e, t) {
					return super.merge(d(e, this._map, this._levelsIterator), t)
				}
			}
		},
		821595: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineTool5PointsPattern: () => l
			});
			var r = i(588537),
				n = i(346090),
				s = i(724145),
				o = i(424146);
			class l extends s.LineDataSource {
				constructor(e, t, i, r) {
					super(e, t || l.createProperties(), i, r), this._loadPaneViews(e)
				}
				pointsCount() {
					return 5
				}
				name() {
					return "XABCD Pattern"
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetool5pointspattern", e);
					return l._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 949902)).then((e => e.PatternWithBackgroundDefinitionViewModel))
				}
				_loadPaneViews(e) {
					Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 705760)).then((t => {
						this._setPaneViews([new t.Pattern5pointsPaneView(this, e)])
					}))
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e), e.addChild("linesColors", new o.LineToolColorsProperty([(0, r.ensureDefined)(e.child("color"))])), e.addChild("textsColors", new o.LineToolColorsProperty([(0, r.ensureDefined)(e.child("textcolor"))]))
				}
			}
		},
		496807: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolABCD: () => l
			});
			var r = i(588537),
				n = i(346090),
				s = i(724145),
				o = i(424146);
			class l extends s.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || l.createProperties();
					super(e, s, r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 672626)).then((t => {
						this._setPaneViews([new t.ABCDPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 4
				}
				name() {
					return "ABCD Pattern"
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolabcd", e);
					return l._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 587412)).then((e => e.PatternWithoutBackgroundDefinitionsViewModel))
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e), e.addChild("linesColors", new o.LineToolColorsProperty([(0, r.ensureDefined)(e.child("color"))])), e.addChild("textsColors", new o.LineToolColorsProperty([(0, r.ensureDefined)(e.child("textcolor"))]))
				}
			}
		},
		389886: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolArc: () => u
			});
			var r = i(588537),
				n = i(204652),
				s = i(86441),
				o = i(625422),
				l = i(346090),
				a = i(724145),
				c = i(424146);
			class u extends a.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || u.createProperties();
					super(e, s, r, n), this.version = 2, this._dist = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 209147)).then((({
						ArcPaneView: t
					}) => {
						const i = [new t(this, e)];
						this._setPaneViews(i)
					}))
				}
				startChanging(e, t) {
					if (super.startChanging(e, t), 0 === e || 1 === e) {
						const e = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
							t = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
							i = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[2]));
						this._dist = (0, n.distanceToLine)(e, t, i).distance;
						const o = t.subtract(e),
							l = new s.Point(-o.y, o.x),
							a = e.add(t).scaled(.5);
						i.subtract(a).dotProduct(l) < 0 && (this._dist = -this._dist)
					}
				}
				endChanging(e, t) {
					return this._dist = null, super.endChanging(e, t)
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Arc"
				}
				hasEditableCoordinates() {
					return !1
				}
				setPoint(e, t) {
					const i = {
							...t
						},
						l = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						a = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1]));
					switch (e) {
						case 0: {
							const e = (0, r.ensureNotNull)(this._dist),
								t = (0, r.ensureNotNull)(this.pointToScreenPoint(i)),
								n = a.subtract(t),
								o = t.add(a).scaled(.5);
							let l = new s.Point(-n.y, n.x);
							l = l.normalized();
							const c = o.add(l.scaled(e));
							this._points[0] = i, this._points[2] = (0, r.ensureNotNull)(this.screenPointToPoint(c));
							break
						}
						case 1: {
							const e = (0, r.ensureNotNull)(this._dist),
								t = (0, r.ensureNotNull)(this.pointToScreenPoint(i)),
								n = t.subtract(l),
								o = l.add(t).scaled(.5),
								a = new s.Point(-n.y, n.x).normalized(),
								c = o.add(a.scaled(e));
							this._points[1] = i, this._points[2] = (0,
								r.ensureNotNull)(this.screenPointToPoint(c));
							break
						}
						case 2: {
							let e = (0, r.ensureNotNull)(this.pointToScreenPoint(i));
							const t = (0, n.distanceToLine)(l, a, e).distance,
								c = a.subtract(l),
								u = l.add(a).scaled(.5),
								h = new s.Point(-c.y, c.x).normalized(),
								d = u.add(h.scaled(t)),
								p = u.add(h.scaled(-t)),
								_ = c.length(),
								P = c.x / _,
								f = c.y / _;
							let g = Math.acos(P);
							f < 0 && (g = -g);
							let v = (0, o.translationMatrix)(-u.x, -u.y);
							e = (0, o.transformPoint)(v, e);
							let m = (0, o.transformPoint)(v, d);
							v = (0, o.rotationMatrix)(-g), e = (0, o.transformPoint)(v, e), m = (0, o.transformPoint)(v, m), v = (0, o.scalingMatrix)(1, _ / (2 * t)), e = (0, o.transformPoint)(v, e), m = (0, o.transformPoint)(v, m);
							const C = e.y * m.y >= 0 ? new s.Point(d.x, d.y) : new s.Point(p.x, p.y);
							this._points[2] = (0, r.ensureNotNull)(this.screenPointToPoint(C));
							break
						}
					}
					this.normalizePoints()
				}
				migrateVersion(e, t, i) {
					if (1 === e && 2 === this._points.length) {
						const e = (2 * this._points[0].price + 3 * this._points[1].price) / 5;
						this._points.push({
							price: e,
							index: this._points[1].index
						})
					}
					if (1 === e && 2 === this._timePoint.length) {
						const e = {
							price: (2 * this._timePoint[0].price + 3 * this._timePoint[1].price) / 5,
							offset: this._timePoint[1].offset,
							time_t: this._timePoint[1].time_t
						};
						this._timePoint.push(e)
					}
				}
				static createProperties(e) {
					const t = new l.DefaultProperty("linetoolarc", e);
					return u._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 880717))).GeneralFiguresDefinitionsViewModelBase
				}
				static _configureProperties(e) {
					a.LineDataSource._configureProperties(e), e.addChild("linesColors", new c.LineToolColorsProperty([e.childs().color]))
				}
			}
		},
		650581: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolArrowMark: () => a,
				LineToolArrowMarkLeft: () => c,
				LineToolArrowMarkUp: () => u,
				LineToolArrowMarkRight: () => h,
				LineToolArrowMarkDown: () => d
			});
			var r = i(346090),
				n = i(724145),
				s = i(232567),
				o = i.n(s),
				l = i(424146);
			class a extends n.LineDataSource {
				constructor(e, t, r, n, s) {
					const o = t || a.createProperties(null, r);
					super(e, o, n, s), this._textPaneView = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 35303)).then((({
						ArrowMarkPaneView: t
					}) => {
						const i = [new t(this, e)];
						this._setPaneViews(i)
					}))
				}
				paneViews(e) {
					const t = super.paneViews();
					return null !== t && this._textPaneView && t.push(this._textPaneView), t
				}
				pointsCount() {
					return 1
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				static createProperties(e, t) {
					const i = new r.DefaultProperty(t, e);
					return a._configureProperties(i), i
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 988010)).then((e => e.ArrowMarkDefinitionsViewModel))
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e), e.addChild("linesColors", new l.LineToolColorsProperty([e.childs().arrowColor])), e.addChild("textsColors", new l.LineToolColorsProperty([e.childs().color])), e.hasChild("text") || e.addChild("text", new(o())("")), e.addExclusion("text")
				}
			}
			a.version = 2;
			class c extends a {
				constructor(e, t, i, r) {
					super(e, t, "linetoolarrowmarkleft", i, r)
				}
				direction() {
					return "left"
				}
				name() {
					return "Arrow Mark Left"
				}
				textAlignParams() {
					return {
						horzAlign: "left",
						vertAlign: "middle",
						offsetX: 22,
						offsetY: 3
					}
				}
				static createProperties(e) {
					return a.createProperties(e, "linetoolarrowmarkleft")
				}
			}
			class u extends a {
				constructor(e, t, i, r) {
					super(e, t, "linetoolarrowmarkup", i, r)
				}
				direction() {
					return "up"
				}
				name() {
					return "Arrow Mark Up"
				}
				textAlignParams() {
					return {
						horzAlign: "center",
						vertAlign: "top",
						offsetX: 0,
						offsetY: 20
					}
				}
				static createProperties(e) {
					return a.createProperties(e, "linetoolarrowmarkup")
				}
			}
			class h extends a {
				constructor(e, t, i, r) {
					super(e, t, "linetoolarrowmarkright", i, r)
				}
				direction() {
					return "right"
				}
				name() {
					return "Arrow Mark Right"
				}
				textAlignParams() {
					return {
						horzAlign: "right",
						vertAlign: "middle",
						offsetX: 22,
						offsetY: 3,
						forceTextAlign: !0
					}
				}
				static createProperties(e) {
					return a.createProperties(e, "linetoolarrowmarkright")
				}
			}
			class d extends a {
				constructor(e, t, i, r) {
					super(e, t, "linetoolarrowmarkdown", i, r)
				}
				direction() {
					return "down"
				}
				name() {
					return "Arrow Mark Down"
				}
				textAlignParams() {
					return {
						horzAlign: "center",
						vertAlign: "bottom",
						offsetX: 0,
						offsetY: 20
					}
				}
				static createProperties(e) {
					return a.createProperties(e, "linetoolarrowmarkdown")
				}
			}
		},
		665851: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolArrowMarker: () => l
			});
			var r = i(724145),
				n = i(346090),
				s = i(232567),
				o = i.n(s);
			class l extends r.LineDataSource {
				constructor(e, t, r, n) {
					super(e, null != t ? t : l.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 215575)).then((({
						ArrowMarkerPaneView: e
					}) => {
						this._setPaneViews([new e(this, this.model())])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Trend Line"
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolarrowmarker", e);
					return l._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 233871)).then((e => e.ArrowMarkerDefinitionsViewModel))
				}
				static _configureProperties(e) {
					r.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(o())("")), e.addExclusion("text")
				}
			}
		},
		60046: (e, t, i) => {
			"use strict";
			var r = i(439195).LineToolTrendLine,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				name() {
					return "Arrow"
				}
				static createProperties(e) {
					var t = new n("linetoolarrow", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolArrow = s
		},
		97807: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolBalloon: () => u
			});
			var r = i(575932),
				n = i(346090),
				s = i(724145),
				o = i(232567),
				l = i.n(o),
				a = i(424146);
			const c = (0, r.t)("Comment");
			class u extends s.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || u.createProperties();
					super(e, s, r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 761627)).then((t => {
						this._setPaneViews([new t.BalloonPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Balloon"
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				shouldBeRemovedOnDeselect() {
					return "" === this._properties.childs().text.value().trim()
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolballoon", e);
					return u._configureProperties(t), t
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 200597)).then((e => e.BalloonDefinitionsViewModel))
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(l())(c)), e.addExclusion("text"), e.addChild("linesColors", new a.LineToolColorsProperty([e.childs().borderColor])), e.addChild("textsColors", new a.LineToolColorsProperty([e.childs().color]))
				}
			}
		},
		183819: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolBarsPattern: () => m
			});
			var r = i(588537),
				n = i(575932),
				s = i(277036),
				o = i(270617),
				l = i(829770),
				a = i(346090),
				c = i(752280),
				u = i(724145),
				h = i(813580),
				d = i(194459);
			const p = new s.TranslatedString("mirror bars pattern", (0, n.t)("mirror bars pattern")),
				_ = new s.TranslatedString("flip bars pattern", (0, n.t)("flip bars pattern")),
				P = (0, n.t)("Mirrored"),
				f = (0, n.t)("Flipped"),
				g = {
					0: 2,
					1: 4,
					2: 1,
					3: 1,
					4: 2,
					5: 3,
					6: -1
				},
				v = {
					0: 3,
					1: 4,
					2: 4,
					3: 1,
					4: 2,
					5: 3,
					6: -1
				};
			class m extends u.LineDataSource {
				constructor(e, t = m.createProperties(), r, n) {
					super(e, t, r, n), this._pattern = [], this._scale = 1, this._pointsCoordinatePricesDiff = null;
					const s = t.childs().mode.value();
					(0, o.isString)(s) && t.childs().mode.setValue(parseInt(s)), t.childs().mirrored.listeners().subscribe(this, this._mirror), t.childs().flipped.listeners().subscribe(this, this._flip), t.childs().mode.subscribe(this, this._updateLastPoint), this.version = 2, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 544902)).then((t => {
						this._setPaneViews([new t.BarsPatternPaneView(this, e)])
					}))
				}
				pattern() {
					return this._pattern
				}
				isSynchronizable() {
					return !1
				}
				additionalActions(e) {
					return [new l.Action({
						actionId: "Chart.LineTool.BarsPattern.ToggleMirrored",
						checked: this.properties().childs().mirrored.value(),
						checkable: !0,
						label: P,
						onExecute: () => {
							e.setProperty(this.properties().childs().mirrored, !this.properties().childs().mirrored.value(), p), this.updateAllViews((0, d.dataSourceChangeEvent)(this.id())), this._model.updateSource(this)
						}
					}), new l.Action({
						actionId: "Chart.LineTool.BarsPattern.ToggleFlipped",
						checked: this.properties().childs().flipped.value(),
						checkable: !0,
						label: f,
						onExecute: () => {
							e.setProperty(this.properties().childs().flipped, !this.properties().childs().flipped.value(), _), this.updateAllViews((0, d.dataSourceChangeEvent)(this.id())), this._model.updateSource(this)
						}
					})]
				}
				pointsCount() {
					return 2
				}
				state(e) {
					return {
						...super.state(e),
						pattern: this._pattern,
						scale: this._scale,
						diff: this._pointsCoordinatePricesDiff
					}
				}
				restoreData(e) {
					const {
						pattern: t = this._pattern,
						scale: i = this._scale,
						diff: r = this._pointsCoordinatePricesDiff
					} = e;
					this._pattern = t, this._scale = i, this._pointsCoordinatePricesDiff = r
				}
				name() {
					return "Bars Pattern"
				}
				hasEditableCoordinates() {
					return !1
				}
				cloneData(e) {
					this._pattern = (0, o.clone)(e._pattern), this._scale = e._scale, this._pointsCoordinatePricesDiff = e._pointsCoordinatePricesDiff
				}
				firstPatternPrice() {
					const {
						mode: e,
						flipped: t
					} = this.properties().childs(), i = this._pattern[0];
					return e.value() === h.LineToolBarsPatternMode.LineHL2 ? (i[2] + i[3]) / 2 : t.value() ? i[v[e.value()]] : i[g[e.value()]]
				}
				lastPatternPrice() {
					const {
						mode: e,
						flipped: t
					} = this.properties().childs(), i = this._pattern[this._pattern.length - 1];
					return e.value() === h.LineToolBarsPatternMode.LineHL2 ? (i[2] + i[3]) / 2 : t.value() ? i[g[e.value()]] : i[v[e.value()]]
				}
				addPoint(e, t, i) {
					const n = super.addPoint(e, t, !0);
					if (n) {
						const e = this._model.mainSeries(),
							[{
								index: t
							}, {
								index: i
							}] = this.points(),
							n = (0, r.ensureDefined)(e.nearestIndex(Math.min(t, i), c.PlotRowSearchMode.NearestRight)),
							s = (0, r.ensureDefined)(e.nearestIndex(Math.max(t, i), c.PlotRowSearchMode.NearestLeft));
						this._pattern = this._createPattern(n, s), this._pattern.length > 0 && (t > i && this._points.reverse(), this._points[1].price = this._points[0].price + this._patternPriceDiff(), this._points[1].index = this._points[0].index + (s - n), this.normalizePoints(), this.createServerPoints()), this._updatePointsCoordinatePricesDiff()
					}
					return n
				}
				setPoint(e, t, i, r) {
					1 === e && t.index <= this._points[0].index && (t.index = this._points[0].index + 1), 0 === e && t.index >= this._points[1].index && (t.index = this._points[1].index - 1), super.setPoint(e, t, i), this._updatePointsCoordinatePricesDiff()
				}
				move(e, t, i, r) {
					super.move(e, t, i, r), this._updatePointsCoordinatePricesDiff()
				}
				migrateVersion(e, t, i) {
					if (1 === e && this._pattern.length > 0) {
						const e = this._patternPriceDiff();
						2 === this._timePoint.length && (this._timePoint[1].price = this._timePoint[0].price + e), 2 === this._points.length && (this._points[1].price = this._points[0].price + e)
					}
				}
				getScale() {
					return this._scale = this._calculateScale()
				}
				static createProperties(e) {
					const t = new a.DefaultProperty("linetoolbarspattern", e);
					return m._configureProperties(t), t
				}
				_preparePoint(e, t) {
					var i;
					const n = this._alignPointToRangeOfActualData(e),
						s = this._model.mainSeries(),
						o = (0, r.ensureNotNull)(s.bars().valueAt(n.index));
					this.properties().childs().mode.value() === h.LineToolBarsPatternMode.Bars ? n.price = (0, r.ensure)(o[2]) : n.price = (0, r.ensure)(o[4]);
					const l = (0, r.ensureNotNull)(this.priceScale()),
						a = (0, r.ensure)(null === (i = this.ownerSource()) || void 0 === i ? void 0 : i.firstValue()),
						c = .05 * l.height(),
						u = l.priceToCoordinate(n.price, a) - c;
					return n.price = l.coordinateToPrice(u, a), super._preparePoint(n, t)
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 283027))).BarsPatternDefinitionsViewModel
				}
				static _configureProperties(e) {
					u.LineDataSource._configureProperties(e), e.addExclusion("mirrored"), e.addExclusion("flipped")
				}
				_calculatePatternCoordinatePricesDiff() {
					var e;
					return this._pattern.length > 0 && null !== (e = this._priceCoordinateDiff([this.firstPatternPrice(), this.lastPatternPrice()])) && void 0 !== e ? e : null
				}
				_updatePointsCoordinatePricesDiff() {
					this._pointsCoordinatePricesDiff = this._calculatePointsCoordinatePricesDiff()
				}
				_calculatePointsCoordinatePricesDiff() {
					var e;
					if (2 === this._points.length) {
						const [{
							price: t
						}, {
							price: i
						}] = this.points();
						return null !== (e = this._priceCoordinateDiff([t, i])) && void 0 !== e ? e : null
					}
					return null
				}
				_createPattern(e, t) {
					const i = this._model.mainSeries().data(),
						n = [];
					for (let s = e; s <= t; s++) n.push((0, o.clone)((0,
						r.ensureNotNull)(i.valueAt(s))));
					return n
				}
				_switchPointsPrice() {
					const e = this._points[0].price;
					this._timePoint[0].price = this._points[0].price = this._points[1].price, this._timePoint[1].price = this._points[1].price = e
				}
				_mirror() {
					const e = this._pattern;
					let t = Math.min(e[0][3], e[0][2]),
						i = Math.max(e[0][3], e[0][2]);
					for (let r = 1; r < e.length; r++) t = Math.min(t, e[r][3]), i = Math.max(i, e[r][2]);
					if (t < i) {
						const r = (t + i) / 2,
							n = e => r - (e - r);
						for (let t = 0; t < e.length; t++) e[t][2] = n(e[t][2]), e[t][3] = n(e[t][3]), e[t][1] = n(e[t][1]), e[t][4] = n(e[t][4])
					}
					this._switchPointsPrice(), this.updateAllViews((0, d.dataSourceChangeEvent)(this.id()))
				}
				_flip() {
					const e = this._pattern,
						t = e.length;
					for (let i = 0; i < t / 2; i++) {
						const r = e[i];
						e[i] = e[t - i - 1], e[t - i - 1] = r
					}
					this._switchPointsPrice(), this.updateAllViews((0, d.dataSourceChangeEvent)(this.id()))
				}
				_patternPriceDiff() {
					return this.lastPatternPrice() - this.firstPatternPrice()
				}
				_pricesToCoordinates(e) {
					var t, i;
					const r = this.priceScale(),
						n = null !== (i = null === (t = this.ownerSource()) || void 0 === t ? void 0 : t.firstValue()) && void 0 !== i ? i : null;
					if (null !== n && null !== r && !r.isEmpty()) return e.map((e => r.priceToCoordinate(e, n)))
				}
				_priceCoordinateDiff(e) {
					const t = this._pricesToCoordinates(e);
					if (t) return t[1] - t[0]
				}
				_calculateScale() {
					let e = 1;
					if (2 === this._points.length) {
						const t = this._calculatePatternCoordinatePricesDiff();
						if (!t) return e;
						const i = this._calculatePointsCoordinatePricesDiff();
						if (t && null !== i && (e = +(i / t).toFixed(8)), this._pointsCoordinatePricesDiff !== i) {
							if (this._scale !== e) return this._updateLastPoint(), this._scale;
							this._updatePointsCoordinatePricesDiff()
						}
					}
					return e
				}
				_updateLastPoint() {
					var e, t;
					if (this._points.length < 2) return;
					const i = this.priceScale(),
						r = null !== (t = null === (e = this.ownerSource()) || void 0 === e ? void 0 : e.firstValue()) && void 0 !== t ? t : null;
					if (null === r || null === i || i.isEmpty()) return;
					const n = this._calculatePatternCoordinatePricesDiff(),
						s = this._pricesToCoordinates([this.points()[0].price]);
					null !== n && s && (this._timePoint[1].price = this._points[1].price = i.coordinateToPrice(+(this._scale * n).toFixed(8) + s[0], r), this._updatePointsCoordinatePricesDiff())
				}
			}
		},
		595426: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolBezierCubic: () => o
			});
			var r = i(588537),
				n = i(346090),
				s = i(724145);
			class o extends s.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || o.createProperties();
					super(e, s, r, n), this._controlPoints = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 991042)).then((t => {
						this._setPaneViews([new t.BezierCubicPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Double Curve"
				}
				setLastPoint(e, t) {
					const i = super.setLastPoint(e, t);
					return this._controlPoints = this._calculateControlPoints(), i
				}
				addPoint(e, t, i) {
					const r = super.addPoint(e, t, i);
					if (r) {
						const e = this._calculateControlPoints();
						this._controlPoints = null, this._points.push(e[0]), this._points.push(e[1]), i || (this.normalizePoints(), this.createServerPoints()), this._createPointProperty(2), this._createPointProperty(3)
					}
					return r
				}
				restorePoints(e, t, i) {
					super.restorePoints(e, t, i), this._createPointProperty(2), this._createPointProperty(3)
				}
				controlPoints() {
					return this._controlPoints
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolbeziercubic", e);
					return o._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 942811)).then((e => e.GeneralBezierDefinitionsViewModel))
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e)
				}
				_calculateControlPoints() {
					const e = (0, r.ensureNotNull)(this.pointToScreenPoint(this.points()[0])),
						t = (0, r.ensureNotNull)(this.pointToScreenPoint(this.points()[1])),
						i = t.subtract(e).scaled(.5).transposed().scaled(.3),
						n = e.add(t).scaled(.33),
						s = e.add(t).scaled(.67),
						o = n.add(i),
						l = s.subtract(i);
					return [(0, r.ensureNotNull)(this.screenPointToPoint(o)), (0, r.ensureNotNull)(this.screenPointToPoint(l))]
				}
			}
		},
		781888: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolBezierQuadro: () => o
			});
			var r = i(588537),
				n = i(346090),
				s = i(724145);
			class o extends s.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || o.createProperties();
					super(e, s, r, n), this._controlPoint = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 251972)).then((t => {
						this._setPaneViews([new t.BezierQuadroPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Curve"
				}
				setLastPoint(e, t) {
					const i = super.setLastPoint(e, t);
					return this._controlPoint = this._calculateControlPoint(), i
				}
				addPoint(e, t, i) {
					const r = super.addPoint(e, t, i);
					if (r) {
						const e = this._calculateControlPoint();
						this._points.push(e), this._controlPoint = null, i || (this.normalizePoints(), this.createServerPoints()), this._createPointProperty(2)
					}
					return r
				}
				restorePoints(e, t, i) {
					super.restorePoints(e, t, i), this._createPointProperty(2)
				}
				controlPoint() {
					return this._controlPoint
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolbezierquadro", e);
					return o._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 942811)).then((e => e.GeneralBezierDefinitionsViewModel))
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e)
				}
				_calculateControlPoint() {
					const e = (0, r.ensureNotNull)(this.pointToScreenPoint(this.points()[0])),
						t = (0, r.ensureNotNull)(this.pointToScreenPoint(this.points()[1])),
						i = t.subtract(e).scaled(.5).transposed().scaled(.3),
						n = e.add(t).scaled(.5).add(i);
					return (0, r.ensureNotNull)(this.screenPointToPoint(n))
				}
			}
		},
		296484: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolBrushBase: () => s
			});
			var r = i(588537),
				n = i(724145);
			class s extends n.LineDataSource {
				constructor() {
					super(...arguments), this._finished = !1
				}
				pointsCount() {
					return -1
				}
				finished() {
					return this._finished
				}
				finish() {
					this._finished = !0, this._lastPoint = null, this.normalizePoints(), this.createServerPoints()
				}
				hasEditableCoordinates() {
					return !1
				}
				addPoint(e, t, i) {
					if (this._finished) return !0;
					if (this._lastPoint = null, this._points.length > 0) {
						const t = this._points[this._points.length - 1],
							i = (0, r.ensureNotNull)(this.pointToScreenPoint(t));
						if ((0, r.ensureNotNull)(this.pointToScreenPoint(e)).subtract(i).length() < 2) return this._finished
					}
					return super.addPoint(e), this._finished
				}
				restorePoints(e, t, i) {
					super.restorePoints(e, t, i), this._finished = !0
				}
			}
		},
		697537: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolBrush: () => o
			});
			var r = i(346090),
				n = i(296484),
				s = i(424146);
			class o extends n.LineToolBrushBase {
				constructor(e, t, i, r) {
					super(e, t || o.createProperties(), i, r), this._loadPaneViews(e)
				}
				smooth() {
					return this.properties().childs().smooth.value()
				}
				name() {
					return "Brush"
				}
				hasEditableCoordinates() {
					return !1
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolbrush", e);
					return o._configureProperties(t), t
				}
				_loadPaneViews(e) {
					Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 281443)).then((t => {
						this._setPaneViews([new t.BrushPaneView(this, e)])
					}))
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 648928)).then((e => e.BrushDefinitionsViewModel))
				}
				static _configureProperties(e) {
					n.LineToolBrushBase._configureProperties(e), e.addChild("backgroundsColors", new s.LineToolColorsProperty([e.childs().backgroundColor], e.childs().fillBackground))
				}
			}
		},
		386779: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolCallout: () => c
			});
			var r = i(575932),
				n = i(232567),
				s = i.n(n),
				o = i(346090),
				l = i(424146),
				a = i(724145);
			class c extends a.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), this._barOffset = 0, this._dragStartLeftEdgeIndex = NaN, this._timeScale = e.timeScale(), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 619783)).then((e => {
						this._setPaneViews([new e.CalloutPaneView(this, this._model)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Callout"
				}
				getBarOffset() {
					return this._barOffset
				}
				shouldBeRemovedOnDeselect() {
					return "" === this._properties.childs().text.value().trim()
				}
				addPoint(e) {
					const t = super.addPoint(e);
					return t && this._calculateBarOffset(), t
				}
				setLastPoint(e) {
					const t = super.setLastPoint(e);
					return 2 === this.points().length && this._calculateBarOffset(), t
				}
				setPoint(e, t) {
					switch (e) {
						case 0:
							super.setPoint(e, t), this._calculateBarOffset();
							break;
						case 1:
							const i = this.properties().childs();
							if (!i.wordWrapWidth) return;
							const r = this._points,
								n = this._dragStartLeftEdgeIndex,
								s = Math.round((t.index - n) / 2);
							if (isFinite(n) && isFinite(s)) {
								r[1] = {
									index: n + s,
									price: r[1].price
								}, this._calculateBarOffset(), this.normalizePoints();
								const e = this._timeScale.indexToCoordinate(n + 2 * s) - this._timeScale.indexToCoordinate(n) - 8 - 2;
								if (!isFinite(e)) return;
								i.wordWrapWidth.setValue(Math.max(100, e));
								break
							}
							r[1] = t, this._calculateBarOffset(), this.normalizePoints()
					}
				}
				setPoints(e) {
					super.setPoints(e);
					const t = this.properties().childs();
					if (!t.wordWrapWidth) return;
					const i = this._dragStartLeftEdgeIndex,
						r = Math.round((e[1].index - i) / 2);
					if (this._calculateBarOffset(), this.normalizePoints(), isFinite(i) && isFinite(r)) {
						const e = this._timeScale.indexToCoordinate(i + 2 * r) - this._timeScale.indexToCoordinate(i) - 8 - 2;
						if (!isFinite(e)) return;
						t.wordWrapWidth.setValue(Math.max(100, e))
					}
				}
				move(e, t, i) {
					super.move(e, t, i), this._calculateBarOffset()
				}
				state(e) {
					const t = super.state(e);
					return t.barOffset = this._barOffset, t
				}
				restoreData(e) {
					e.barOffset ? this._barOffset = e.barOffset : this._calculateBarOffset(), this.calculatePoint2()
				}
				setPriceScale(e) {
					super.setPriceScale(e), e && e.priceRange() && this.calculatePoint2()
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				calculatePoint2() {
					if (this._model.lineBeingEdited() === this || this._model.sourcesBeingMoved().includes(this)) return;
					if (this._points.length < 2) return;
					const [e, t] = this.points();
					this._points[1] = {
						price: t.price,
						index: e.index + this._barOffset
					}
				}
				static createProperties(e) {
					const t = new o.DefaultProperty("linetoolcallout", e);
					return c._configureProperties(t), t
				}
				_applyTemplateImpl(e) {
					this.properties().childs().text.setValue(e.text), super._applyTemplateImpl(e)
				}
				_correctPoints(e, t) {
					if (null === this._currentMovingPoint || void 0 === this._currentMovingPoint.logical || null === this._startMovingPoint || void 0 === this._startMovingPoint.logical) return !1;
					const i = this._currentMovingPoint.logical.index - this._startMovingPoint.logical.index,
						r = this._currentMovingPoint.logical.price - this._startMovingPoint.logical.price,
						n = e[1];
					return n.index = n.index + i, n.price += r, e[1] = n, !0
				}
				_onPointsetUpdated(e) {
					super._onPointsetUpdated(e), 0 !== e.length && (this._dragStartLeftEdgeIndex = this.points()[1].index)
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 939428))).CalloutDefinitionsViewModel
				}
				static _configureProperties(e) {
					a.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(s())((0, r.t)("Text"))), e.addExclusion("text"), e.addChild("textsColors", new l.LineToolColorsProperty([e.childs().color]))
				}
				_calculateBarOffset() {
					this.points().length > 1 && (this._barOffset = this.points()[1].index - this.points()[0].index)
				}
			}
		},
		847373: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, r, n) {
					super(e, t || s.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 905184, 19)).then((({
						LineToolCircleLinesPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Cyclic Lines"
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 664500))).CyclicAndSineLinesPatternDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetoolcirclelines", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolCircleLines = s
		},
		597314: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolCircle: () => a
			});
			var r = i(232567),
				n = i.n(r),
				s = i(346090),
				o = i(724145),
				l = i(424146);
			class a extends o.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || a.createProperties();
					super(e, s, r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 653622)).then((({
						CirclePaneView: t
					}) => {
						const i = [new t(this, e)];
						this._setPaneViews(i)
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Circle"
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				static createProperties(e) {
					const t = new s.DefaultProperty("linetoolcircle", e);
					return a._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 860677))).EllipseCircleDefinitionsViewModel
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				static _configureProperties(e) {
					o.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(n())("")), e.addChild("linesColors", new l.LineToolColorsProperty([e.childs().color])), e.addChild("linesWidths", new l.LineToolWidthsProperty([e.childs().linewidth])), e.addChild("backgroundsColors", new l.LineToolColorsProperty([e.childs().backgroundColor])), e.addChild("textsColors", new l.LineToolColorsProperty([e.childs().textColor], e.childs().showLabel)), e.addExclusion("linesColors"), e.addExclusion("linesWidths"), e.addExclusion("backgroundsColors"), e.addExclusion("text")
				}
			}
		},
		941527: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolCrossLine: () => l
			});
			var r = i(346090),
				n = i(367001),
				s = i(444234),
				o = i(724145);
			class l extends o.LineDataSource {
				constructor(e, t, r, o) {
					super(e, t || l.createProperties(), r, o), this._priceAxisView = new n.LineToolHorzLinePriceAxisView(this), this._timeAxisView = new s.LineToolVertLineTimeAxisView(this), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 520197)).then((({
						CrossLinePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Cross Line"
				}
				priceAxisViews(e, t) {
					return this.isSourceHidden() ? null : t === this.priceScale() && this.properties().childs().showPrice.value() && this._model.paneForSource(this) === e ? [this._priceAxisView] : null
				}
				timeAxisViews() {
					return this.isSourceHidden() ? null : this.properties().childs().showTime.value() ? [this._timeAxisView] : null
				}
				updateAllViews(e) {
					super.updateAllViews(e), this._priceAxisView.update(e), this._timeAxisView.update()
				}
				canHasAlert() {
					return !1
				}
				lineColor() {
					return this.properties().childs().linecolor.value()
				}
				lineWidth() {
					return this.properties().childs().linewidth.value()
				}
				lineStyle() {
					return this.properties().childs().linestyle.value()
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolcrossline", e);
					return l._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 717078)).then((e => e.CrossLineDefinitionsViewModel))
				}
				static _configureProperties(e) {
					o.LineDataSource._configureProperties(e)
				}
			}
		},
		513647: (e, t, i) => {
			"use strict";
			i.d(t, {
				CustomEventItem: () => s,
				LineToolCustomUrlEvent: () => o
			});
			var r = i(588537),
				n = i(674993);
			class s {
				constructor(e) {
					this._source = e
				}
				position() {
					return this._props().childs().position.value()
				}
				_props() {
					return this._source.properties()
				}
			}
			class o extends n.LineToolWithRelativePriceCoordinate {
				constructor() {
					super(...arguments), this._item = null, this._eventTimePointIndex = null
				}
				pointsCount() {
					return 1
				}
				cloneable() {
					return !1
				}
				eventTimePointIndex() {
					return this._eventTimePointIndex
				}
				customEvent() {
					return this._item
				}
				restorePoints(e, t, i) {
					i && t.length > 0 && (this._eventTimePointIndex = t[0].index), super.restorePoints(e, t, i)
				}
				priceAxisPoints() {
					return []
				}
				_baseSeriesIndexForPoint(e) {
					var t;
					return null !== (t = this._eventTimePointIndex) && void 0 !== t ? t : e.index
				}
				_alignPointHorizontallyOrVertically(e) {
					var t, i;
					if (null === this._eventTimePointIndex) return e;
					const n = this._points[0].index - this._eventTimePointIndex,
						s = (0, r.ensure)(null === (i = null === (t = this._startMovingPoint) || void 0 === t ? void 0 : t.logical) || void 0 === i ? void 0 : i.index) - n;
					return {
						price: e.price,
						index: s
					}
				}
				_snapPoint45Degree(e, t, i) {
					this._eventTimePointIndex && (e.index = this._eventTimePointIndex)
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				_allowChangeAnchorHorizontally() {
					return !0
				}
				_pointsForPointset() {
					return [
						[(0, r.ensureNotNull)(this._item).time(), 0], ...super._pointsForPointset()
					]
				}
				_onPointsetUpdated(e) {
					if (0 === e.length) return;
					const t = e.findIndex((e => 0 === e.index)); - 1 !== t && (this._eventTimePointIndex = e[t].value[0]);
					const i = e.slice(1).map((e => ({
						value: e.value,
						index: e.index - 1
					})));
					super._onPointsetUpdated(i)
				}
				_readyToCreatePointset() {
					return super._readyToCreatePointset() && null !== this._item
				}
			}
		},
		109562: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolCypherPattern: () => s
			});
			var r = i(821595),
				n = i(346090);
			class s extends r.LineTool5PointsPattern {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				name() {
					return "Cypher Pattern"
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolcypherpattern", e);
					return s._configureProperties(t), t
				}
				_loadPaneViews(e) {
					Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 756460)).then((t => {
						this._setPaneViews([new t.CypherPaneView(this, e)])
					}))
				}
				static _configureProperties(e) {
					r.LineTool5PointsPattern._configureProperties(e)
				}
			}
		},
		90281: (e, t, i) => {
			"use strict";
			i.d(t, {
				nonThemedFactoryDefaultsBase: () => a,
				themedFactoryDefaultsBase: () => c
			});
			var r = i(679520),
				n = i(61499),
				s = i(721386),
				o = i(194543);
			const l = (0, r.getHexColorByName)("color-tv-blue-500"),
				a = {
					linewidth: 1,
					fontsize: 12,
					fillLabelBackground: !0,
					fillBackground: !0,
					backgroundTransparency: 60,
					intervalsVisibilities: {
						...o.intervalsVisibilitiesDefaults
					}
				},
				c = new Map([
					[n.StdTheme.Light, {
						textcolor: (0, r.getHexColorByName)("color-black"),
						labelBackgroundColor: (0, r.getHexColorByName)("color-white"),
						linecolor: l,
						backgroundColor: (0, s.generateColor)(l, 85),
						shadow: "rgba(0, 0, 0, 0.2)"
					}],
					[n.StdTheme.Dark, {
						textcolor: (0, r.getHexColorByName)("color-white"),
						labelBackgroundColor: (0, r.getHexColorByName)("color-cold-gray-800"),
						linecolor: l,
						backgroundColor: (0, s.generateColor)(l, 85),
						shadow: "rgba(0, 0, 0, 0.4)"
					}]
				])
		},
		943975: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolDateAndPriceRange: () => f
			});
			var r = i(588537),
				n = i(724145),
				s = i(262203),
				o = i(61499),
				l = i(679520),
				a = i(326505),
				c = i(90281);
			const u = (0, l.getHexColorByName)("color-tv-blue-500"),
				h = {
					...c.nonThemedFactoryDefaultsBase,
					drawBorder: !1,
					borderWidth: 1
				},
				d = new Map([
					[o.StdTheme.Light, {
						...c.themedFactoryDefaultsBase.get(o.StdTheme.Light),
						borderColor: u
					}],
					[o.StdTheme.Dark, {
						...c.themedFactoryDefaultsBase.get(o.StdTheme.Dark),
						borderColor: u
					}]
				]),
				p = (0, a.extractAllPropertiesKeys)((0, r.ensureDefined)(d.get(o.StdTheme.Light))),
				_ = (0, a.extractAllPropertiesKeys)(h);
			class P extends a.ThemedDefaultProperty {
				static create(e) {
					return new P("linetooldateandpricerange", (() => (0, a.factoryDefaultsForCurrentTheme)(h, d)), _, p, e)
				}
			}
			class f extends n.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || f.createProperties(), r, n), this._volumeCalculator = null,
						Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 165440)).then((e => {
							this._setPaneViews([new e.DateAndPriceRangePaneView(this, this._model)])
						}))
				}
				destroy() {
					super.destroy(), null !== this._volumeCalculator && this._volumeCalculator.destroy()
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Date and Price Range"
				}
				volume() {
					if (null === this._volumeCalculator) return NaN;
					const e = this.points();
					return this._volumeCalculator.volume(e[0].index, e[1].index)
				}
				setOwnerSource(e) {
					e === this._model.mainSeries() && ((0, r.assert)(null === this._volumeCalculator), this._volumeCalculator = new s.SeriesTimeRangeVolumeCalculator(this._model.mainSeries())), super.setOwnerSource(e)
				}
				static createProperties(e) {
					const t = P.create(e);
					return f._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 950152))).GeneralDatePriceRangeDefinitionsViewModel
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e)
				}
			}
		},
		148317: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolDateRange: () => _
			});
			var r = i(588537),
				n = i(724145),
				s = i(262203),
				o = i(61499),
				l = i(326505),
				a = i(90281);
			const c = {
					...a.nonThemedFactoryDefaultsBase,
					extendTop: !1,
					extendBottom: !1
				},
				u = a.themedFactoryDefaultsBase,
				h = (0, l.extractAllPropertiesKeys)((0, r.ensureDefined)(u.get(o.StdTheme.Light))),
				d = (0, l.extractAllPropertiesKeys)(c);
			class p extends l.ThemedDefaultProperty {
				static create(e) {
					return new p("linetooldaterange", (() => (0, l.factoryDefaultsForCurrentTheme)(c, u)), d, h, e)
				}
			}
			class _ extends n.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || _.createProperties(), r, n), this._volumeCalculator = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 734481)).then((e => {
						this._setPaneViews([new e.DateRangePaneView(this, this._model)])
					}))
				}
				destroy() {
					super.destroy(), null !== this._volumeCalculator && this._volumeCalculator.destroy()
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Date Range"
				}
				volume() {
					if (null === this._volumeCalculator) return NaN;
					const e = this.points();
					return this._volumeCalculator.volume(e[0].index, e[1].index)
				}
				setOwnerSource(e) {
					e === this._model.mainSeries() && ((0, r.assert)(null === this._volumeCalculator), this._volumeCalculator = new s.SeriesTimeRangeVolumeCalculator(this._model.mainSeries())), super.setOwnerSource(e)
				}
				static createProperties(e) {
					const t = p.create(e);
					return _._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 950152))).GeneralDatePriceRangeDefinitionsViewModel
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e)
				}
			}
		},
		897364: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, r, n) {
					super(e, t || s.createProperties(), r, n), this.version = s.version, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 713463, 19)).then((({
						DisjointChannelPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Disjoint Channel"
				}
				hasEditableCoordinates() {
					return !1
				}
				addPoint(e, t) {
					return t && t.shift() && 2 === this.points().length && this._snapPoint45Degree(e, this.points()[this.points().length - 2]), r.prototype.addPoint.call(this, e)
				}
				setLastPoint(e, t) {
					return t && t.shift() && 2 === this.points().length && this._snapPoint45Degree(e, this.points()[this.points().length - 2]), r.prototype.setLastPoint.call(this, e)
				}
				setPoint(e, t, i) {
					var r = .5 * (this._points[1].price + this._points[2].price);
					if (i && i.shift() && 1 === e) {
						this._snapPoint45Degree(t, this.points()[0])
					}
					if (e < 3 && super.setPoint(e, t), 0 !== e && 2 !== e) {
						if (1 === e) {
							var n = this._points[1].price - r;
							this._points[2].price = this._points[1].price - 2 * n
						} else if (3 === e) {
							n = t.price - this._points[2].price;
							this._points[0].price = this._points[1].price - n, this._points[0].index = t.index
						}
						this.normalizePoints()
					}
				}
				getPoint(e) {
					if (e < 3) return r.prototype.getPoint.call(this, e);
					var t = this._points[0].price - this._points[2].price;
					return {
						index: this._points[0].index,
						price: this._points[1].price - t
					}
				}
				canHasAlert() {
					return !0
				}
				_getAlertPlots() {
					var e = this._points[0],
						t = this._points[1],
						i = [];
					e.index <= t.index ? (i.push(e), i.push(t)) : (i.push(t), i.push(e));
					var r = this._points[2];
					r.time = t.time, r.index = t.index;
					var n, s, o, l, a = {
							price: r.price + (t.price - e.price),
							time: e.time,
							index: e.index
						},
						c = [];
					r.index <= a.index ? (c.push(r), c.push(a)) : (c.push(a), c.push(r)), i[0].price > c[0].price ? (n = i, s = c) : c[0].price > i[0].price || c[1].price > i[1].price ? (n = c, s = i) : (n = i, s = c);
					var u = this.properties().extendLeft.value(),
						h = this.properties().extendRight.value();
					return e.index <= t.index ? (o = u, l = h) : (o = h, l = u), [this._linePointsToAlertPlot(n, "Upper", o, l), this._linePointsToAlertPlot(s, "Lower", o, l)]
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 356776))).GeneralTrendFiguresDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetooldisjointangle", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			s.version = 1, t.LineToolDisjointChannel = s
		},
		561708: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolElliott: () => d,
				LineToolElliottImpulse: () => P,
				LineToolElliottTriangle: () => g,
				LineToolElliottTripleCombo: () => m,
				LineToolElliottCorrection: () => T,
				LineToolElliottDoubleCombo: () => w
			});
			var r = i(575932),
				n = i(277036),
				s = i(724145),
				o = i(829770),
				l = i(346090),
				a = i(424146);
			const c = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
				u = new n.TranslatedString("change Elliott degree", (0, r.t)("change Elliott degree")),
				h = [{
					value: 0,
					title: (0, r.t)("Supermillennium")
				}, {
					value: 1,
					title: (0, r.t)("Millennium")
				}, {
					value: 2,
					title: (0, r.t)("Submillennium")
				}, {
					value: 3,
					title: (0, r.t)("Grand supercycle")
				}, {
					value: 4,
					title: (0, r.t)("Supercycle")
				}, {
					value: 5,
					title: (0, r.t)("Cycle")
				}, {
					value: 6,
					title: (0, r.t)("Primary")
				}, {
					value: 7,
					title: (0, r.t)("Intermediate")
				}, {
					value: 8,
					title: (0, r.t)("Minor", {
						context: "wave"
					})
				}, {
					value: 9,
					title: (0, r.t)("Minute", {
						context: "wave"
					})
				}, {
					value: 10,
					title: (0, r.t)("Minuette")
				}, {
					value: 11,
					title: (0, r.t)("Subminuette")
				}, {
					value: 12,
					title: (0, r.t)("Micro")
				}, {
					value: 13,
					title: (0, r.t)("Submicro")
				}, {
					value: 14,
					title: (0, r.t)("Minuscule")
				}];
			class d extends s.LineDataSource {
				constructor(e, t, r, n) {
					super(e, null != t ? t : d.createProperties(), r, n), this.version = 4,
						Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 820203)).then((e => {
							this._setPaneViews([new e.ElliottLabelsPaneView(this, this._model)])
						}))
				}
				migrateVersion(e, t, i) {
					if (i.properties.hasChild("background") && i.properties.removeProperty("background"), i.properties.hasChild("backgroundColor") && i.properties.removeProperty("backgroundColor"), i.properties.hasChild("showBackground") && i.properties.removeProperty("showBackground"), 1 === e) {
						const e = Object.assign({}, this._timePoint[0]);
						if (this._timePoint.unshift(e), this._points.length > 0) {
							const e = Object.assign({}, this._points[0]);
							this._points.unshift(e)
						}
					}
				}
				applyTemplate(e) {
					const t = e;
					delete t.background, delete t.backgroundColor, delete t.showBackground, super.applyTemplate(e)
				}
				name() {
					return "Elliott Labels"
				}
				additionalActions(e) {
					return [new o.Action({
						actionId: "Chart.LineTool.Elliot.ChangeDegreeProperty",
						label: (0, r.t)("Degree"),
						subItems: c.map((t => {
							const i = h.filter((e => e.value === t))[0];
							return new o.Action({
								actionId: "Chart.LineTool.Elliot.ChangeDegreeProperty",
								label: i.title,
								checkable: !0,
								checked: this.properties().childs().degree.value() === t,
								onExecute: () => {
									e.setProperty(this.properties().childs().degree, t, u)
								}
							})
						}))
					})]
				}
				label(e) {
					const t = c.length - this.properties().childs().degree.value() - 1,
						i = Math.floor(t / 3);
					return {
						group: i,
						bold: !!(i % 2),
						decoration: ["", "brackets", "circle"][t % 3],
						label: this.labelsGroup()[i][e]
					}
				}
				availableDegreesValues() {
					return h
				}
				static createProperties(e) {
					const t = new l.DefaultProperty("linetoolelliott", e);
					return d._configureProperties(t), t
				}
				static migrateState(e) {
					const t = {
							0: 11,
							1: 10,
							2: 9,
							3: 8,
							4: 7,
							5: 6,
							6: 5,
							7: 4,
							8: 3
						},
						i = {
							0: 11,
							1: 8
						};
					"LineToolElliottSubminuette" === e.type && (e.type = "LineToolElliottImpulse", e.state.degree = t[e.state.wavesize]), "LineToolElliottMinor" === e.type && (e.type = "LineToolElliottImpulse", e.state.degree = t[e.state.wavesize]), "LineToolElliottCircle" === e.type && (e.type = "LineToolElliottImpulse", e.state.degree = t[e.state.wavesize]), "LineToolElliottMinorRetr" === e.type && (e.type = "LineToolElliottCorrection", e.state.degree = i[e.state.wavesize]), "LineToolElliottMajorRetr" === e.type && (e.type = "LineToolElliottCorrection", e.state.degree = i[e.state.wavesize])
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 330139))).ElliottPatternDefinitionsViewModel
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e), e.addChild("linesColors", new a.LineToolColorsProperty([e.childs().color])), e.addExclusion("linesColors")
				}
			}
			class p extends d {
				pointsCount() {
					return 6
				}
				static _configureProperties(e) {
					d._configureProperties(e)
				}
			}
			const _ = [
				["0", "1", "2", "3", "4", "5"],
				["0", "i", "ii", "iii", "iv", "v"],
				["0", "1", "2", "3", "4", "5"],
				["0", "I", "II", "III", "IV", "V"],
				["0", "1", "2", "3", "4", "5"]
			];
			class P extends p {
				constructor(e, t, i, r) {
					super(e, t || P.createProperties(), i, r)
				}
				name() {
					return "Elliott Impulse Wave (12345)"
				}
				labelsGroup() {
					return _
				}
				static createProperties(e) {
					const t = new l.DefaultProperty("linetoolelliottimpulse", e);
					return P._configureProperties(t), t
				}
				static _configureProperties(e) {
					p._configureProperties(e)
				}
			}
			const f = [
				["0", "A", "B", "C", "D", "E"],
				["0", "a", "b", "c", "d", "e"],
				["0", "A", "B", "C", "D", "E"],
				["0", "a", "b", "c", "d", "e"],
				["0", "A", "B", "C", "D", "E"]
			];
			class g extends p {
				constructor(e, t, i, r) {
					super(e, t || g.createProperties(), i, r)
				}
				name() {
					return "Elliott Triangle Wave (ABCDE)"
				}
				labelsGroup() {
					return f
				}
				static createProperties(e) {
					const t = new l.DefaultProperty("linetoolelliotttriangle", e);
					return g._configureProperties(t), t
				}
				static _configureProperties(e) {
					p._configureProperties(e)
				}
			}
			const v = [
				["0", "W", "X", "Y", "X", "Z"],
				["0", "w", "x", "y", "x", "z"],
				["0", "W", "X", "Y", "X", "Z"],
				["0", "w", "x", "y", "x", "z"],
				["0", "W", "X", "Y", "X", "Z"]
			];
			class m extends p {
				constructor(e, t, i, r) {
					super(e, null != t ? t : m.createProperties(), i, r)
				}
				name() {
					return "Elliott Triple Combo Wave (WXYXZ)"
				}
				labelsGroup() {
					return v
				}
				static createProperties(e) {
					const t = new l.DefaultProperty("linetoolelliotttriplecombo", e);
					return m._configureProperties(t), t
				}
				static _configureProperties(e) {
					p._configureProperties(e)
				}
			}
			class C extends d {
				pointsCount() {
					return 4
				}
				static _configureProperties(e) {
					d._configureProperties(e)
				}
			}
			const y = [
				["0", "A", "B", "C"],
				["0", "a", "b", "c"],
				["0", "A", "B", "C"],
				["0", "a", "b", "c"],
				["0", "A", "B", "C"]
			];
			class T extends C {
				constructor(e, t, i, r) {
					super(e, null != t ? t : T.createProperties(), i, r)
				}
				name() {
					return "Elliott Correction Wave (ABC)"
				}
				labelsGroup() {
					return y
				}
				static createProperties(e) {
					const t = new l.DefaultProperty("linetoolelliottcorrection", e);
					return T._configureProperties(t), t
				}
				static _configureProperties(e) {
					C._configureProperties(e)
				}
			}
			const S = [
				["0", "W", "X", "Y"],
				["0", "w", "x", "y"],
				["0", "W", "X", "Y"],
				["0", "w", "x", "y"],
				["0", "W", "X", "Y"]
			];
			class w extends C {
				constructor(e, t, i, r) {
					super(e, null != t ? t : w.createProperties(), i, r)
				}
				name() {
					return "Elliott Double Combo Wave (WXY)"
				}
				labelsGroup() {
					return S
				}
				static createProperties(e) {
					const t = new l.DefaultProperty("linetoolelliottdoublecombo", e);
					return w._configureProperties(t), t
				}
				static _configureProperties(e) {
					C._configureProperties(e)
				}
			}
		},
		146913: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolEllipse: () => h
			});
			var r = i(588537),
				n = i(204652),
				s = i(86441),
				o = i(232567),
				l = i.n(o),
				a = i(724145),
				c = i(346090),
				u = i(424146);
			class h extends a.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || h.createProperties(), r, n), this.version = 2, this._dist = null, this._fakePointAdded = !1, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 233587)).then((({
						EllipsePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				startChanging(e, t) {
					if (super.startChanging(e, t), 0 === e || 1 === e) {
						const e = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
							t = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
							i = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[2]));
						this._dist = (0, n.distanceToLine)(e, t, i).distance || 0
					}
				}
				addPoint(e, t, i) {
					const r = a.LineDataSource.prototype.addPoint.call(this, e, t, i);
					return r && (this._fakePointAdded = !1), r
				}
				setPoint(e, t, i, o) {
					const l = {
						...t
					};
					let a = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						c = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
						u = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[2]));
					switch (e) {
						case 0: {
							if (i && i.shift()) {
								this._snapPoint45Degree(l, this._points[1]), this._points[0] = l, this._points[2] = this._preparePointInternal(this._points[2], i, !0), this._points[0].index === this._points[1].index && this._fixVerticalDiameterPoints(this._points[0], this._points[1], this._points[2]);
								break
							}
							a = (0, r.ensureNotNull)(this.pointToScreenPoint(l));
							const e = c.subtract(a),
								t = a.add(c).scaled(.5),
								n = new s.Point(-e.y, e.x).normalized();
							u = t.add(n.scaled((0, r.ensureNotNull)(this._dist))), this._points[0] = l, this._points[2] = (0, r.ensureNotNull)(this.screenPointToPoint(u));
							break
						}
						case 1: {
							if (i && i.shift()) {
								this._snapPoint45Degree(l, this._points[0]), this._points[1] = l, this._points[2] = this._preparePointInternal(this._points[2], i, !0), this._points[0].index === this._points[1].index && this._fixVerticalDiameterPoints(this._points[1], this._points[0], this._points[2]);
								break
							}
							c = (0, r.ensureNotNull)(this.pointToScreenPoint(l));
							const e = c.subtract(a),
								t = a.add(c).scaled(.5),
								n = new s.Point(-e.y, e.x).normalized();
							u = t.add(n.scaled((0, r.ensureNotNull)(this._dist))), this._points[1] = l, this._points[2] = (0, r.ensureNotNull)(this.screenPointToPoint(u));
							break
						}
						case 2: {
							const e = (0, r.ensureNotNull)(this.pointToScreenPoint(l)),
								t = (0, n.distanceToLine)(a, c, e).distance,
								i = c.subtract(a),
								o = a.add(c).scaled(.5),
								h = new s.Point(-i.y, i.x).normalized();
							u = o.add(h.scaled(t)), this._points[2] = (0, r.ensureNotNull)(this.screenPointToPoint(u));
							break
						}
						case 3: {
							const e = (0, r.ensureNotNull)(this.pointToScreenPoint(l)),
								t = (0, n.distanceToLine)(a, c, e).distance,
								i = c.subtract(a),
								o = a.add(c).scaled(.5),
								h = new s.Point(-i.y, i.x).normalized();
							u = o.add(h.scaled(t)), this._points[2] = (0, r.ensureNotNull)(this.screenPointToPoint(u));
							break
						}
					}
					this.normalizePoints()
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Ellipse"
				}
				hasEditableCoordinates() {
					return !1
				}
				migrateVersion(e, t, i) {
					if (1 === e && 2 === this._points.length) {
						const e = this._points[0].price,
							t = .5 * (this._points[0].price + this._points[1].price);
						this._points[0] = {
							price: t,
							index: this._points[0].index
						}, this._points[1] = {
							price: t,
							index: this._points[1].index
						}, this._points.push({
							price: e,
							index: this._points[0].index
						})
					}
					if (1 === e && 2 === this._timePoint.length) {
						const e = this._timePoint[0].price,
							t = .5 * (this._timePoint[0].price + this._timePoint[1].price);
						this._timePoint[0].price = t, this._timePoint[1].price = t;
						const i = {
							price: e,
							offset: this._timePoint[0].offset,
							time_t: this._timePoint[0].time_t
						};
						this._timePoint.push(i)
					}
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				static createProperties(e) {
					const t = new c.DefaultProperty("linetoolellipse", e);
					return h._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 860677))).EllipseCircleDefinitionsViewModel
				}
				_preparePoint(e, t) {
					const i = this._preparePointInternal(e, t, !1);
					return t && t.shift() && this._points[0].index === this._points[1].index && this._fixVerticalDiameterPoints(this._points[1], this._points[0], i), i
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				static _configureProperties(e) {
					a.LineDataSource._configureProperties(e),
						e.hasChild("text") || e.addChild("text", new(l())("")), e.addChild("linesColors", new u.LineToolColorsProperty([e.childs().color])), e.addChild("textsColors", new u.LineToolColorsProperty([e.childs().textColor], e.childs().showLabel)), e.addExclusion("text")
				}
				_preparePointInternal(e, t, i) {
					let n = {
						...e
					};
					if (t && t.shift()) {
						const t = this.points().length;
						if (!this._fakePointAdded && 3 === t && !i) return n;
						if (this._fakePointAdded || 2 === t || i) {
							this._snapPoint45Degree(e, this._points[0]), this._fakePointAdded ? this._points[1] = e : i || (this._fakePointAdded = !0, super._addPointIntenal(e));
							const t = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
								o = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
								l = o.x - t.x,
								a = o.y - t.y,
								c = Math.sqrt(l * l + a * a) / 2,
								u = o.subtract(t),
								h = t.add(o).scaled(.5),
								d = new s.Point(-u.y, u.x).normalized(),
								p = h.add(d.scaled(c));
							n = (0, r.ensureNotNull)(this.screenPointToPoint(p)), (isNaN(n.price) || isNaN(n.index)) && (n = (0, r.ensureNotNull)(this.screenPointToPoint(h)))
						}
					} else this._fakePointAdded && (this._points.splice(1, 1), this._fakePointAdded = !1);
					return n
				}
				_fixVerticalDiameterPoints(e, t, i) {
					const n = (0, r.ensureNotNull)(this.pointToScreenPoint(e)),
						o = (0, r.ensureNotNull)(this.pointToScreenPoint(t)),
						l = this._model.timeScale(),
						a = l.indexToCoordinate(e.index),
						c = l.indexToCoordinate(i.index);
					let u = 2 * Math.abs(a - c);
					u *= t.price > e.price ? 1 : -1, e.price = (0, r.ensureNotNull)(this.screenPointToPoint(new s.Point(n.x, o.y + u))).price
				}
			}
		},
		372353: (e, t, i) => {
			"use strict";
			var r = i(439195).LineToolTrendLine,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				name() {
					return "Extended Line"
				}
				static createProperties(e) {
					var t = new n("linetoolextended", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolExtended = s
		},
		28901: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolFibChannel: () => u
			});
			var r = i(588537),
				n = i(575932),
				s = i(277036),
				o = i(724145),
				l = i(755827),
				a = i(424146);
			const c = new s.TranslatedString("erase level line", (0, n.t)("erase level line"));
			class u extends o.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || u.createProperties(), r, n), this.version = 2, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 47329)).then((({
						FibChannelPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return 24
				}
				migrateVersion(e, t, i) {
					i.properties.removeProperty("reverse")
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Fib Channel"
				}
				processErase(e, t) {
					const i = "level" + t,
						r = this.properties().child(i).childs().visible;
					e.setProperty(r, !1, c)
				}
				static createProperties(e) {
					const t = new l.LevelsProperty("linetoolfibchannel", e, !1, {
						range: [1, 24],
						names: ["coeff", "color", "visible"]
					});
					return u._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 726457))).FibDrawingsWith24LevelsDefinitionsViewModel
				}
				static _configureProperties(e) {
					o.LineDataSource._configureProperties(e);
					const t = [];
					for (let i = 1; i <= 24; i++) {
						const n = (0, r.ensureDefined)(e.child("level" + i));
						t.push((0, r.ensureDefined)(n.child("color")))
					}
					e.addChild("linesColors", new a.LineToolColorsProperty(t))
				}
			}
		},
		951651: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(277036).TranslatedString,
				s = i(724145).LineDataSource,
				o = i(755827).LevelsProperty,
				l = i(424146),
				a = l.LineToolWidthsProperty,
				c = l.LineToolColorsProperty,
				u = new n("erase level line", r("erase level line"));
			class h extends s {
				constructor(e, t, r, n) {
					super(e, t || h.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 596763, 19)).then((({
						FibCirclesPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return h.LevelsCount
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Fib Circles"
				}
				processErase(e, t) {
					var i = "level" + t,
						r = this.properties()[i].visible;
					e.setProperty(r, !1, u)
				}
				static createProperties(e) {
					var t = new o("linetoolfibcircles", e, !1, {
						range: [1, 11]
					});
					return h._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 808086))).FibCirclesDefinitionsViewModel
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				static _configureProperties(e) {
					s._configureProperties(e);
					for (var t = [e.child("trendline").child("linewidth")], i = [e.child("trendline").child("color")], r = 1; r <= h.LevelsCount; r++) t.push(e.child("level" + r).child("linewidth")), i.push(e.child("level" + r).child("color"));
					e.addChild("linesColors", new c(i)), e.addChild("linesWidths", new a(t))
				}
			}
			h.LevelsCount = 11, t.LineToolFibCircles = h
		},
		945914: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolFibRetracement: () => c
			});
			var r = i(575932),
				n = i(277036),
				s = i(755827),
				o = i(724145),
				l = i(424146);
			const a = new n.TranslatedString("erase level line", (0, r.t)("erase level line"));
			class c extends o.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), this.version = 2, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 416858)).then((e => {
						this._setPaneViews([new e.FibRetracementPaneView(this, this._model)])
					}))
				}
				levelsCount() {
					return 24
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Fib Retracement"
				}
				migrateVersion(e) {
					1 === e && this.properties().childs().extendLines.setValue(!0)
				}
				processErase(e, t) {
					const i = "level" + t,
						{
							visible: r
						} = this.properties().childs()[i].childs();
					e.setProperty(r, !1, a)
				}
				fibLevelsBasedOnLogScale() {
					var e;
					return this.properties().childs().fibLevelsBasedOnLogScale.value() && !!(null === (e = this.priceScale()) || void 0 === e ? void 0 : e.isLog())
				}
				static createProperties(e) {
					const t = new s.LevelsProperty("linetoolfibretracement", e, !1, {
						range: [1, 24],
						names: ["coeff", "color", "visible"]
					});
					return c._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 726457))).FibDrawingsWith24LevelsDefinitionsViewModel
				}
				static _configureProperties(e) {
					var t;
					const i = e;
					super._configureProperties(i);
					const r = [i.childs().trendline.childs().linewidth, i.childs().levelsStyle.childs().linewidth],
						n = [i.childs().trendline.childs().color];
					for (let e = 1; e <= 24; e++) {
						const r = null === (t = i.child("level" + e)) || void 0 === t ? void 0 : t.child("color");
						n.push(r)
					}
					i.addChild("linesColors", new l.LineToolColorsProperty(n)),
						i.addChild("linesWidths", new l.LineToolWidthsProperty(r))
				}
			}
		},
		3971: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(277036).TranslatedString,
				s = i(724145).LineDataSource,
				o = i(755827).LevelsProperty,
				l = i(424146),
				a = l.LineToolWidthsProperty,
				c = l.LineToolColorsProperty,
				u = new n("erase level line", r("erase level line"));
			class h extends s {
				constructor(e, t, r, n) {
					super(e, t || h.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 227866)).then((({
						FibSpeedResistanceArcsPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return h.LevelsCount
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Fib Speed Resistance Arcs"
				}
				processErase(e, t) {
					var i = "level" + t,
						r = this.properties()[i].visible;
					e.setProperty(r, !1, u)
				}
				static createProperties(e) {
					var t = new o("linetoolfibspeedresistancearcs", e, !1, {
						range: [1, 11]
					});
					return h._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 937333))).FibSpeedResistanceArcsDefinitionsViewModel
				}
				static _configureProperties(e) {
					s._configureProperties(e);
					for (var t = [e.child("trendline").child("linewidth")], i = [e.child("trendline").child("color")], r = 1; r <= h.LevelsCount; r++) t.push(e.child("level" + r).child("linewidth")), i.push(e.child("level" + r).child("color"));
					e.addChild("linesColors", new c(i)), e.addChild("linesWidths", new a(t))
				}
			}
			h.LevelsCount = 11, t.LineToolFibSpeedResistanceArcs = h
		},
		758237: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(277036).TranslatedString,
				s = i(724145).LineDataSource,
				o = i(755827).LevelsProperty,
				l = i(424146).LineToolColorsProperty,
				a = new n("erase level line", r("erase level line"));
			class c extends s {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 565491)).then((({
						FibSpeedResistanceFanPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				hLevelsCount() {
					return c.HLevelsCount
				}
				vLevelsCount() {
					return c.VLevelsCount
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Fib Speed Resistance Fan"
				}
				processErase(e, t) {
					var i = "h" === t.type ? "hlevel" + t.index : "vlevel" + t.index,
						r = this.properties()[i].visible;
					e.setProperty(r, !1, a)
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 882868))).FibSpeedResistanceFanDefinitionsViewModel
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				static createProperties(e) {
					void 0 !== e && void 0 === e.reverse && (e.reverse = !0);
					var t = new o("linetoolfibspeedresistancefan", e, !1, {
						range: [1, 7],
						prefixes: ["h", "v"],
						names: ["coeff", "color", "visible"]
					});
					return c._configureProperties(t), t
				}
				static _configureProperties(e) {
					s._configureProperties(e);
					var t = [e.child("grid").child("color")];
					for (let i = 1; i <= c.HLevelsCount; i++) t.push(e.child("hlevel" + i).child("color"));
					for (let i = 1; i <= c.VLevelsCount; i++) t.push(e.child("vlevel" + i).child("color"));
					e.addChild("linesColors", new l(t)), e.addExclusion("linesColors")
				}
			}
			c.HLevelsCount = 7, c.VLevelsCount = 7, t.LineToolFibSpeedResistanceFan = c
		},
		739242: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, r, n) {
					super(e, t || s.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 254298)).then((({
						FibSpiralPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Fib Spiral"
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 737355))).FibSpiralDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetoolfibspiral", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolFibSpiral = s
		},
		358500: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolFibTimeZone: () => c
			});
			var r = i(575932),
				n = i(277036),
				s = i(424146),
				o = i(755827),
				l = i(724145);
			const a = new n.TranslatedString("erase level line", (0, r.t)("erase level line"));
			class c extends l.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), this.version = 2, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 928618)).then((({
						FibTimeZonePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return 11
				}
				migrateVersion(e, t, i) {
					if (1 === e) {
						const e = i.properties.childs(),
							t = i.properties,
							r = t.baselinecolor.value(),
							n = t.linecolor.value(),
							s = t.linewidth.value(),
							o = t.linestyle.value();
						e.level1.childs().color.setValue(r);
						for (let t = 2; t <= 11; t++) e["level" + t].childs().color.setValue(n);
						for (let t = 1; t <= 11; t++) e["level" + t].childs().linewidth.setValue(s), e["level" + t].childs().linestyle.setValue(o)
					}
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Fib Time Zone"
				}
				processErase(e, t) {
					const i = "level" + t,
						r = this.properties().childs()[i].childs().visible;
					e.setProperty(r, !1, a)
				}
				static createProperties(e) {
					const t = new o.LevelsProperty("linetoolfibtimezone", e, !1, {
						range: [1, 11]
					});
					return c._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 252752))).FibTimezoneDefinitionsViewModel
				}
				static _configureProperties(e) {
					l.LineDataSource._configureProperties(e);
					const t = [],
						i = [];
					for (let r = 1; r <= 11; r++) {
						const n = e.childs()["level" + r].childs();
						t.push(n.linewidth), i.push(n.color)
					}
					e.addChild("linesColors", new s.LineToolColorsProperty(i)), e.addChild("linesWidths", new s.LineToolWidthsProperty(t))
				}
			}
		},
		844040: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolFibWedgeBase: () => o
			});
			var r = i(588537),
				n = i(86441),
				s = i(724145);
			class o extends s.LineDataSource {
				pointsCount() {
					return 3
				}
				hasEditableCoordinates() {
					return !1
				}
				setPoint(e, t) {
					if (super.setPoint(e, t), !this._recursiveGuard) try {
						if (this._recursiveGuard = !0, 2 === e) {
							const e = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0]));
							let t = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1]));
							const i = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[2])).subtract(e).length();
							let s = t.subtract(e);
							s.length() <= 0 && (s = new n.Point(1, 0)), t = e.add(s.normalized().scaled(i));
							const o = (0, r.ensureNotNull)(this.screenPointToPoint(t)),
								l = this._pointsProperty.childs().points[1];
							l.childs().price.setValue(o.price), l.childs().bar.setValue(o.index)
						} else {
							const e = (0,
									r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
								t = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1]));
							let i = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[2]));
							const s = t.subtract(e).length();
							let o = i.subtract(e);
							o.length() <= 0 && (o = new n.Point(1, 0)), i = e.add(o.normalized().scaled(s));
							const l = (0, r.ensureNotNull)(this.screenPointToPoint(i)),
								a = this._pointsProperty.childs().points[2];
							a.childs().price.setValue(l.price), a.childs().bar.setValue(l.index)
						}
					} finally {
						this._recursiveGuard = !1
					}
				}
				addPoint(e) {
					if (2 === this._points.length) {
						const t = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
							i = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1]));
						let n = (0, r.ensureNotNull)(this.pointToScreenPoint(e));
						const s = i.subtract(t).length(),
							o = n.subtract(t).normalized();
						n = t.add(o.scaled(s));
						const l = (0, r.ensureNotNull)(this.ownerSource()),
							a = (0, r.ensureNotNull)(l.firstValue()),
							c = (0, r.ensureNotNull)(this.priceScale()).coordinateToPrice(n.y, a);
						e = {
							index: Math.round(this._model.timeScale().coordinateToIndex(n.x)),
							price: c
						}
					}
					return s.LineDataSource.prototype.addPoint.call(this, e)
				}
			}
		},
		924615: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(277036).TranslatedString,
				s = i(844040).LineToolFibWedgeBase,
				o = i(755827).LevelsProperty,
				l = i(424146),
				a = l.LineToolWidthsProperty,
				c = l.LineToolColorsProperty,
				u = new n("erase level line", r("erase level line"));
			class h extends s {
				constructor(e, t, r, n) {
					super(e, t || h.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 457257, 19)).then((({
						FibWedgePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				isSynchronizable() {
					return !1
				}
				levelsCount() {
					return h.LevelsCount
				}
				name() {
					return "Fib Wedge"
				}
				processErase(e, t) {
					var i = "level" + t,
						r = this.properties()[i].visible;
					e.setProperty(r, !1, u)
				}
				static createProperties(e) {
					var t = new o("linetoolfibwedge", e, !1, {
						range: [1, 11]
					});
					return h._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 981037))).FibWedgeDefinitionsViewModel
				}
				static _configureProperties(e) {
					s._configureProperties(e);
					for (var t = [e.child("trendline").child("linewidth")], i = [e.child("trendline").child("color")], r = 1; r <= h.LevelsCount; r++) t.push(e.child("level" + r).child("linewidth")), i.push(e.child("level" + r).child("color"));
					e.addChild("linesColors", new c(i)), e.addChild("linesWidths", new a(t))
				}
			}
			h.LevelsCount = 11, t.LineToolFibWedge = h
		},
		320874: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolFlagMark: () => l
			});
			var r = i(86441),
				n = i(724145),
				s = i(346090),
				o = i(424146);
			class l extends n.LineDataSource {
				constructor(e, t, n, s) {
					super(e, t || l.createProperties(), n, s), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 429884)).then((({
						FlagMarkPaneView: e
					}) => {
						const t = new e(this, this.model());
						t.setAnchors(new r.Point(0, 0)), this._setPaneViews([t])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Flag Mark"
				}
				static createProperties(e) {
					e && void 0 === e.flagColor && (e.flagColor = "#318757");
					const t = new s.DefaultProperty("linetoolflagmark", e);
					return l._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 589695)).then((e => e.FlagMarkDefinitionsViewModel))
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e), e.addChild("backgroundsColors", new o.LineToolColorsProperty([e.childs().flagColor])), e.addExclusion("backgroundsColors")
				}
			}
			l.version = 2
		},
		505047: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, r, n) {
					super(e, t || s.createProperties(), r, n), this.version = s.version, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 444157, 19)).then((({
						FlatBottomPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Flat Bottom"
				}
				hasEditableCoordinates() {
					return !1
				}
				addPoint(e, t) {
					return t && t.shift() && 2 === this.points().length && this._snapPoint45Degree(e, this.points()[this.points().length - 2]), r.prototype.addPoint.call(this, e)
				}
				setLastPoint(e, t) {
					return t && t.shift() && 2 === this.points().length && this._snapPoint45Degree(e, this.points()[this.points().length - 2]), r.prototype.setLastPoint.call(this, e)
				}
				setPoint(e, t, i) {
					if (i && i.shift() && 1 === e) {
						this._snapPoint45Degree(t, this.points()[0])
					}
					if (2 === e) this._points[1].index = t.index;
					else if (3 === e) return this._points[0].index = t.index, this._points[2].price = t.price, void this.normalizePoints();
					super.setPoint(e, t)
				}
				getPoint(e) {
					return e < 3 ? r.prototype.getPoint.call(this, e) : 3 === e ? {
						index: this._points[0].index,
						price: this._points[2].price
					} : void 0
				}
				canHasAlert() {
					return !0
				}
				_getAlertPlots() {
					var e = this._points[0],
						t = this._points[1],
						i = [];
					e.index <= t.index ? (i.push(e), i.push(t)) : (i.push(t), i.push(e));
					var r = this._points[2];
					r.time = t.time, r.index = t.index;
					var n, s, o, l, a = {
							price: r.price,
							time: e.time,
							index: e.index
						},
						c = [];
					r.index <= a.index ? (c.push(r), c.push(a)) : (c.push(a), c.push(r)), i[0].price > c[0].price ? (n = i, s = c) : c[0].price > i[0].price || c[1].price > i[1].price ? (n = c, s = i) : (n = i, s = c);
					var u = this.properties().extendLeft.value(),
						h = this.properties().extendRight.value();
					return e.index <= t.index ? (o = u, l = h) : (o = h, l = u), [this._linePointsToAlertPlot(n, "Upper", o, l), this._linePointsToAlertPlot(s, "Lower", u, l)]
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 356776))).GeneralTrendFiguresDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetoolflatbottom", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			s.version = 1, t.LineToolFlatBottom = s
		},
		228584: (e, t, i) => {
			"use strict";
			i.d(t, {
				createPropertiesObject: () => l
			});
			var r = i(270617),
				n = i(755827);

			function s(e, t, i) {
				var n;
				for (const s of Object.keys(null !== (n = e.levels) && void 0 !== n ? n : {}))
					if (e.levels[s] && (0, r.isSameType)(e.levels[s], t.typecheck())) {
						let r = t.tpl();
						i.names.forEach(((i, n) => {
							r = t.fill("" + n, i, e.levels[s], r)
						})), e.levels[s] = r
					} return e
			}
			class o extends n.LevelsProperty {
				constructor(e, t) {
					super(e, t, !1, {
						names: ["width", "color", "visible"]
					}, s)
				}
			}

			function l(e, t) {
				return new o(e, t)
			}
		},
		848807: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolGannComplex: () => h
			});
			var r = i(86441),
				n = i(588537),
				s = i(396484),
				o = i(724145),
				l = i(510196),
				a = i(228584),
				c = i(424146),
				u = i(588427);
			class h extends o.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || h.createProperties(), r, n), this.version = 2, this._scaleRatioFormatter = new s.LimitedPrecisionNumericFormatter(7), this.version = 2, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 499175)).then((({
						GannComplexPaneView: e
					}) => {
						this._setPaneViews([new e(this, this.model())])
					}));
					const o = this.properties();
					this._adjustScaleRatio(o), o.subscribe(this, this._adjustScaleRatio), o.childs().scaleRatio.subscribe(this, this._correctFirstPoint), this._syncStateExclusions = ["scaleRatio"], o.onRestoreFactoryDefaults().subscribe(this, this._handleRestoringFactoryDefaults), this._onTemplateApplying.subscribe(this, this._handleTemplateApplying), this._onTemplateApplied.subscribe(this, this._correctFirstPoint)
				}
				migrateVersion(e, t, i) {
					1 === e && (this._points.length >= this.pointsCount() ? setTimeout((() => this._migratePoint())) : this._timePoint.length >= this.pointsCount() && this._pointAdded.subscribe(this, this._migratePoint))
				}
				destroy() {
					const e = this.properties();
					e.unsubscribe(this, this._adjustScaleRatio), e.childs().scaleRatio.unsubscribe(this, this._correctFirstPoint), e.onRestoreFactoryDefaults().unsubscribe(this, this._handleRestoringFactoryDefaults), this._onTemplateApplying.unsubscribe(this, this._handleTemplateApplying), this._onTemplateApplied.unsubscribe(this, this._correctFirstPoint), super.destroy()
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Gann Square"
				}
				addPoint(e, t, i) {
					this._points.length > 1 && this._points.pop();
					const r = super.addPoint(e, t, i),
						s = this.priceScale();
					return !(0, n.ensureNotNull)(s).isLog() && r && this._correctFirstPoint(), r
				}
				setPoint(e, t, i) {
					super.setPoint(e, t, i), void 0 !== i && i.shift() ? this._correctPoint(e) : this._correctScaleRatio()
				}
				setLastPoint(e, t) {
					const i = this.priceScale();
					return (0, n.ensureNotNull)(i).isLog() || (this._points[1] = e, this._correctPoint(1)), super.setLastPoint(e, t)
				}
				isReversed() {
					return this.properties().childs().reverse.value()
				}
				levelsCount() {
					return this.properties().childs().levels.childCount()
				}
				levels() {
					const e = [],
						t = this.properties().childs(),
						i = t.levels.childCount();
					for (let r = 0; r < i; r++) {
						const i = t.levels.childs()[r].childs();
						e.push({
							index: r,
							visible: i.visible.value(),
							color: i.color.value(),
							width: i.width.value()
						})
					}
					return e
				}
				fanLinesCount() {
					return this.properties().childs().fanlines.childCount()
				}
				fanLines() {
					const e = [],
						t = this.properties().childs(),
						i = t.fanlines.childCount();
					for (let r = 0; r < i; r++) {
						const i = t.fanlines.childs()[r].childs();
						e.push({
							index: r,
							visible: i.visible.value(),
							x: i.x.value(),
							y: i.y.value(),
							color: i.color.value(),
							width: i.width.value()
						})
					}
					return e
				}
				arcsCount() {
					return this.properties().childs().arcs.childCount()
				}
				arcs() {
					const e = [],
						t = this.properties().childs(),
						i = t.arcs.childCount();
					for (let r = 0; r < i; r++) {
						const i = t.arcs.childs()[r].childs();
						e.push({
							index: r,
							visible: i.visible.value(),
							x: i.x.value(),
							y: i.y.value(),
							color: i.color.value(),
							width: i.width.value()
						})
					}
					return e
				}
				arcsBackgroundTransparency() {
					return this.properties().childs().arcsBackground.childs().transparency.value()
				}
				isArcsBackgroundFilled() {
					return this.properties().childs().arcsBackground.childs().fillBackground.value()
				}
				isLabelsVisible() {
					return this.properties().childs().showLabels.value()
				}
				getLabelsStyle() {
					const e = this.properties().childs(),
						{
							fontSize: t,
							bold: i,
							italic: r
						} = e.labelsStyle.childs(),
						n = e.levels.childCount();
					return {
						textColor: e.levels.childs()[n - 1].childs().color.value(),
						font: u.CHART_FONT_FAMILY,
						fontSize: t.value(),
						bold: i.value(),
						italic: r.value()
					}
				}
				getScaleRatioStep() {
					return 1e-7
				}
				getScaleRatioFormatter() {
					return this._scaleRatioFormatter
				}
				getPriceDiff() {
					const e = this.points();
					if (e.length < 2) return null;
					const [t, i] = e;
					return i.price - t.price
				}
				getIndexDiff() {
					const e = this.points();
					if (e.length < 2) return null;
					const [t, i] = e;
					return i.index - t.index
				}
				getScaleRatio() {
					const e = this.getPriceDiff(),
						t = this.getIndexDiff();
					return null !== e && null !== t && 0 !== t ? Math.abs(e / t) : null
				}
				static createProperties(e) {
					const t = (0, a.createPropertiesObject)("linetoolganncomplex", e);
					return h._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 729997)).then((e => e.GannComplexAndFixedDefinitionsViewModel))
				}
				static _configureProperties(e) {
					o.LineDataSource._configureProperties(e), e.addExclusion("scaleRatio");
					const t = [],
						i = [],
						r = e.childs(); {
						const e = r.levels.childCount();
						for (let n = 0; n < e; n++) {
							const e = r.levels.childs()[n].childs();
							t.push(e.width), i.push(e.color)
						}
					} {
						const e = r.fanlines.childCount();
						for (let n = 0; n < e; n++) {
							const e = r.fanlines.childs()[n].childs();
							t.push(e.width), i.push(e.color)
						}
					} {
						const e = r.arcs.childCount();
						for (let n = 0; n < e; n++) {
							const e = r.arcs.childs()[n].childs();
							t.push(e.width), i.push(e.color)
						}
					}
					e.addChild("linesColors", new c.LineToolColorsProperty(i)), e.addChild("linesWidths", new c.LineToolWidthsProperty(t))
				}
				_correctScaleRatio() {
					const e = this.properties().childs(),
						t = this.getScaleRatio();
					e.scaleRatio.setValue(t)
				}
				_getAdjustedScaleRatio() {
					const e = this.model().mainSeries().priceScale(),
						t = this.model().timeScale();
					return (0, l.scaleRatio)(t, e)
				}
				_adjustScaleRatio(e) {
					const t = e.scaleRatio.value();
					"" !== t && null !== t || e.scaleRatio.setValue(this._getAdjustedScaleRatio())
				}
				_correctPoint(e) {
					if (this._points.length < 2) return;
					const t = this.getIndexDiff();
					if (null === t) return;
					const i = this.properties().childs().scaleRatio.value();
					if (null !== i) {
						const r = this._points[e],
							n = 0 === e ? this._points[1] : this._points[0],
							s = r.price - n.price > 0,
							o = r.index - n.index > 0;
						let l = s && !o || !s && o ? -1 : 1;
						0 === e && (l = -l), r.price = n.price + l * t * i, this._pointChanged.fire(e)
					}
					this.normalizePoints()
				}
				_correctFirstPoint() {
					this._correctPoint(this.isReversed() ? 0 : 1)
				}
				_handleRestoringFactoryDefaults() {
					this.properties().childs().scaleRatio.setValue(this._getAdjustedScaleRatio())
				}
				_handleTemplateApplying(e) {
					"" === e.scaleRatio && (e.scaleRatio = this._getAdjustedScaleRatio())
				}
				_migratePoint() {
					if (this.points().length < this.pointsCount()) return;
					const e = this._getScreenPoints();
					if (null === e) return;
					const t = (0, n.ensureNotNull)(this.screenPointToPoint(e[1]));
					this.setPoint(1, t), this._pointAdded.unsubscribe(this, this._migratePoint)
				}
				_getScreenPoints() {
					const e = this._calcAngle();
					if (null === e) return null;
					let [t, i] = this.points();
					this.isReversed() && ([t, i] = [i, t]);
					const s = (0, n.ensureNotNull)(this.pointToScreenPoint(t)),
						o = (0, n.ensureNotNull)(this.pointToScreenPoint(i)),
						l = Math.sqrt(Math.pow(s.x - o.x, 2) + Math.pow(s.y - o.y, 2)),
						a = new r.Point(Math.cos(e), -Math.sin(e)),
						c = a.normalized(),
						u = c.x < 0 ? -1 : 1,
						h = c.y < 0 ? -1 : 1;
					return [s.addScaled(a, l), s.add(new r.Point(5 * l * u, 5 * l * h))]
				}
				_calcAngle() {
					const [e, t] = this.points(), i = (0, n.ensureNotNull)(this.pointToScreenPoint(e));
					let r = (0, n.ensureNotNull)(this.pointToScreenPoint(t)).subtract(i);
					if (r.length() > 0) {
						r = r.normalized();
						let e = Math.acos(r.x);
						return r.y > 0 && (e = -e), e
					}
					return null
				}
			}
		},
		273949: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(277036).TranslatedString,
				s = i(724145).LineDataSource,
				o = i(755827).LevelsProperty,
				l = i(424146),
				a = l.LineToolWidthsProperty,
				c = l.LineToolColorsProperty,
				u = new n("erase level line", r("erase level line"));
			class h extends s {
				constructor(e, t, r, n) {
					super(e, t || h.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 34501)).then((({
						GannFanPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return h.LevelsCount
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Gann Fan"
				}
				processErase(e, t) {
					var i = "level" + t,
						r = this.properties()[i].visible;
					e.setProperty(r, !1, u)
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 388222))).GannFanDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new o("linetoolgannfan", e, !1, {
						range: [1, 9]
					});
					return h._configureProperties(t), t
				}
				static _configureProperties(e) {
					s._configureProperties(e);
					for (var t = [], i = [], r = 1; r <= h.LevelsCount; r++) t.push(e.child("level" + r).child("linewidth")), i.push(e.child("level" + r).child("color"));
					e.addChild("linesColors", new c(i)), e.addChild("linesWidths", new a(t))
				}
			}
			h.LevelsCount = 9, t.LineToolGannFan = h
		},
		233091: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolGannFixed: () => a
			});
			var r = i(86441),
				n = i(588537),
				s = i(724145),
				o = i(424146),
				l = i(228584);
			class a extends s.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || a.createProperties(), r, n), this._constructor = "LineToolGannFixed", Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 580997)).then((({
						GannFixedPaneView: e
					}) => {
						this._setPaneViews([new e(this, this.model())])
					})), this.properties().childs().reverse.subscribe(this, this._reversePoints)
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Gann Square Fixed"
				}
				axisPoints() {
					const e = this.points(),
						t = this.getScreenPoints();
					return e.length < 2 || t.length < 2 ? [] : [e[0], (0, n.ensureNotNull)(this.screenPointToPoint(t[1]))]
				}
				getScreenPoints() {
					const e = this.points();
					if (e.length < 2) return [];
					const t = this._calcAngle();
					if (null === t) return [];
					const [i, s] = e, o = (0, n.ensureNotNull)(this.pointToScreenPoint(i)), l = (0, n.ensureNotNull)(this.pointToScreenPoint(s)), a = Math.sqrt(Math.pow(o.x - l.x, 2) + Math.pow(o.y - l.y, 2)), c = new r.Point(Math.cos(t), -Math.sin(t)), u = c.normalized(), h = u.x < 0 ? -1 : 1, d = u.y < 0 ? -1 : 1;
					return [o.addScaled(c, a), o.add(new r.Point(5 * a * h, 5 * a * d))]
				}
				levelsCount() {
					return this.properties().childs().levels.childCount()
				}
				levels() {
					const e = [],
						t = this.properties().childs(),
						i = t.levels.childCount();
					for (let r = 0; r < i; r++) {
						const i = t.levels.childs()[r].childs();
						e.push({
							index: r,
							visible: i.visible.value(),
							color: i.color.value(),
							width: i.width.value()
						})
					}
					return e
				}
				fanLinesCount() {
					return this.properties().childs().fanlines.childCount()
				}
				fanLines() {
					const e = [],
						t = this.properties().childs(),
						i = t.fanlines.childCount();
					for (let r = 0; r < i; r++) {
						const i = t.fanlines.childs()[r].childs();
						e.push({
							index: r,
							visible: i.visible.value(),
							x: i.x.value(),
							y: i.y.value(),
							color: i.color.value(),
							width: i.width.value()
						})
					}
					return e
				}
				arcsCount() {
					return this.properties().childs().arcs.childCount()
				}
				arcs() {
					const e = [],
						t = this.properties().childs(),
						i = t.arcs.childCount();
					for (let r = 0; r < i; r++) {
						const i = t.arcs.childs()[r].childs();
						e.push({
							index: r,
							visible: i.visible.value(),
							x: i.x.value(),
							y: i.y.value(),
							color: i.color.value(),
							width: i.width.value()
						})
					}
					return e
				}
				arcsBackgroundTransparency() {
					return this.properties().childs().arcsBackground.childs().transparency.value()
				}
				isArcsBackgroundFilled() {
					return this.properties().childs().arcsBackground.childs().fillBackground.value()
				}
				static createProperties(e) {
					const t = (0, l.createPropertiesObject)("linetoolgannfixed", e);
					return a._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 729997)).then((e => e.GannComplexAndFixedDefinitionsViewModel))
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e);
					const t = [],
						i = [],
						r = e.childs(); {
						const e = r.levels.childCount();
						for (let n = 0; n < e; n++) {
							const e = r.levels.childs()[n].childs();
							t.push(e.width), i.push(e.color)
						}
					} {
						const e = r.fanlines.childCount();
						for (let n = 0; n < e; n++) {
							const e = r.fanlines.childs()[n].childs();
							t.push(e.width), i.push(e.color)
						}
					} {
						const e = r.arcs.childCount();
						for (let n = 0; n < e; n++) {
							const e = r.arcs.childs()[n].childs();
							t.push(e.width), i.push(e.color)
						}
					}
					e.addChild("linesColors", new o.LineToolColorsProperty(i)), e.addChild("linesWidths", new o.LineToolWidthsProperty(t))
				}
				_calcAngle() {
					const e = this.points();
					if (e.length < 2) return null;
					const [t, i] = e, r = this.pointToScreenPoint(t), n = this.pointToScreenPoint(i);
					if (null === r || null === n) return null;
					let s = n.subtract(r);
					if (s.length() <= 0) return null;
					s = s.normalized();
					let o = Math.acos(s.x);
					return s.y > 0 && (o = -o), o
				}
				_reversePoints() {
					const [e, t] = this._points;
					this._points[0] = t, this._points[1] = e, this.normalizePoints(), this.restart()
				}
			}
		},
		990345: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(755827).LevelsProperty,
				s = i(424146).LineToolColorsProperty,
				o = [4.5, 9, 11.25, 18, 22.5, 36, 45],
				l = function() {
					for (var e = [], t = o.length - 1, i = 1, r = 0, n = 0; n < 1e10;) n = o[r] * i, e.push(Math.round(n)), e.push(Math.ceil(-n)), r === t - 1 && (i *= 10), r = (r + 1) % t;
					return e.sort((function(e, t) {
						return e < t ? -1 : e > t ? 1 : 0
					})), e
				}();
			class a extends r {
				constructor(e, t, r, n) {
					super(e, t || a.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 736650, 19)).then((({
						GannSquarePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				hLevelsCount() {
					return a.HLevelsCount
				}
				vLevelsCount() {
					return a.VLevelsCount
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Gann Box"
				}
				_alignPriceOnPattern(e, t) {
					var i = Math.round(1e6 * (e.price - t.price)) / 1e6;
					if (0 === i) return t.price;
					for (var r = o[0], n = o[o.length - 1], s = 1, l = Math.abs(i); l < r * s || n * s < l;) l < r * s ? s *= .1 : n * s < l && (s *= 10);
					for (var a = n * s, c = o.length - 2; c >= 0 && !(o[c] * s < l); --c) a = o[c] * s;
					return e.price = t.price + (i >= 0 ? a : -a), e
				}
				_alignTimeOnPattern(e, t) {
					var i = e.index - t.index;
					if (0 === i) return 0;
					for (var r = l.length - 2; r >= 0 && !(l[r] < i); --r);
					return r += i > 0 ? 1 : 0, e.index = t.index + l[r], e
				}
				_alignPointsFixedIncrement(e, t) {
					return this._alignTimeOnPattern(e, t), this._alignPriceOnPattern(e, t), e
				}
				_preparePoint(e, t) {
					return t && t.shift() && 0 !== this._points.length && this._alignPointsFixedIncrement(e, this._points[0]), super._preparePoint(e, t)
				}
				getPoint(e) {
					if (e < 2) return super.getPoint(e);
					var t = null;
					switch (e) {
						case 2:
						case 3:
							var i = this.points();
							if (i.length === this.pointsCount()) {
								var r = i[0].index,
									n = i[1].price;
								3 === e && (r = i[1].index, n = i[0].price), t = {
									index: r,
									price: n
								}
							}
					}
					return t
				}
				setPoint(e, t, i) {
					if (i && i.shift()) {
						var r = e % 2 == 0 ? this._points[1] : this._points[0];
						this._alignPointsFixedIncrement(t, r)
					}
					switch (e) {
						case 2:
							this._points[0].index = t.index, this._points[1].price = t.price;
							break;
						case 3:
							this._points[1].index = t.index, this._points[0].price = t.price;
							break;
						default:
							super.setPoint(e, t, i)
					}
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 373927))).GannSquareDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetoolgannsquare", e, !1, {
						range: [1, 7],
						prefixes: ["h", "v"],
						names: ["coeff", "color", "visible"]
					});
					return a._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e);
					for (var t = [e.child("color"), e.child("fans").child("color")], i = 1; i <= a.HLevelsCount; i++) t.push(e.child("hlevel" + i).child("color"));
					for (i = 1; i <= a.VLevelsCount; i++) t.push(e.child("vlevel" + i).child("color"));
					e.addChild("linesColors", new s(t)), e.addExclusion("linesColors")
				}
			}
			a.HLevelsCount = 7, a.VLevelsCount = 7, t.LineToolGannSquare = a
		},
		318440: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolGhostFeed: () => c
			});
			var r = i(346090),
				n = i(724145),
				s = i(588537),
				o = i(270617);
			class l {
				constructor(e, t, i) {
					this._source = e, this._segmentIndex = t, this._bars = null != i ? i : []
				}
				setBars(e) {
					this._bars = e
				}
				clone(e) {
					return new l(e, this._segmentIndex, (0, o.clone)(this._bars))
				}
				generate() {
					this._bars = [];
					const e = this._source.points(),
						t = e[this._segmentIndex],
						i = e[this._segmentIndex + 1];
					if (!t || !i || t.index === i.index) return;
					const r = this._segmentIndex ? t.index + 1 : t.index,
						n = Math.sign(i.index - t.index);
					for (let e = r; e !== i.index; e += n) this._bars.push(this._createBar())
				}
				bars() {
					return this._bars
				}
				setSize(e) {
					if (e < this._bars.length) this._bars.splice(e, this._bars.length - e);
					else
						for (; this._bars.length < e;) this._bars.push(this._createBar())
				}
				_createBar() {
					const e = this._source.properties().averageHL.value(),
						t = this._source.properties().variance.value() / 100,
						i = (0, s.ensureNotNull)(this._source.ownerSource()).base();
					let r = Math.random();
					const n = e * (1 - 2 * r) * t;
					r = Math.random();
					const o = e * (1 + (.5 - r) * t),
						l = n - o / 2,
						a = l + o;
					return {
						o: (l + Math.random() * o) / i,
						h: a / i,
						l: l / i,
						c: (l + Math.random() * o) / i
					}
				}
			}
			var a = i(194459);
			class c extends n.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || c.createProperties();
					if (super(e, s, r, n), this._segments = [], this._finished = !1,
						this._segmentsPixelsWhileMoving = null, !r) {
						const e = Math.round(this._calculateATR());
						s.childs().averageHL.setValue(e)
					}
					s.childs().averageHL.listeners().subscribe(this, c.prototype._regenerate), s.childs().variance.listeners().subscribe(this, c.prototype._regenerate), this._currentAverageHL = s.childs().averageHL.value(), this._currentVariance = s.childs().variance.value(), this._currentInterval = e.mainSeries().interval(), this.properties().onRestoreFactoryDefaults().subscribe(this, this._handleRestoringFactoryDefaults), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 660024)).then((t => {
						this._setPaneViews([new t.GhostFeedPaneView(this, e)])
					}))
				}
				isSynchronizable() {
					return !1
				}
				destroy() {
					this.properties().onRestoreFactoryDefaults().unsubscribe(this, this._handleRestoringFactoryDefaults), super.destroy()
				}
				propertiesChanged() {
					super.propertiesChanged(), this._currentAverageHL === this.properties().childs().averageHL.value() && this._currentVariance === this.properties().childs().variance.value() || this._regenerate()
				}
				pointsCount() {
					return -1
				}
				name() {
					return "Ghost Feed"
				}
				segmentBars(e) {
					return this._segments[e].bars()
				}
				segments() {
					return this._segments
				}
				generateBars(e) {
					this._segments.length <= e && this._segments.push(new l(this, e)), this._segments[e].generate()
				}
				addPoint(e, t, i) {
					if (this._finished) return !0;
					if (this._points.length > 0) {
						const i = this._points[this._points.length - 1];
						if (!(null == t ? void 0 : t.isApiEvent()) && i.index === e.index) {
							this._lastPoint = null, this.normalizePoints(), this.createServerPoints();
							for (let e = 0; e < this._points.length; e++) this._createPointProperty(e);
							return !0
						}
					}
					const r = super.addPoint(e, t, i);
					return this._points.length > 1 && this.generateBars(this._points.length - 2), r
				}
				finish() {
					this._finished = !0, this._lastPoint = null, this.normalizePoints(), this.createServerPoints()
				}
				setPoint(e, t, i, r) {
					if (super.setPoint(e, t, i), e > 0) {
						const i = this.points()[e - 1],
							r = t.index - i.index;
						this._segments[e - 1].setSize(Math.abs(r))
					}
					if (e < this.points().length - 1) {
						const i = this.points()[e + 1].index - t.index;
						this._segments[e].setSize(Math.abs(i))
					}
				}
				state(e) {
					const t = n.LineDataSource.prototype.state.call(this, e);
					return t.segments = this._segments.map((e => ({
						bars: [...e.bars()]
					}))), t
				}
				restoreData(e) {
					e.segments && (this._segments = e.segments.map(((e, t) => new l(this, t, e.bars)))), this._currentAverageHL = this.properties().childs().averageHL.value(), this._currentVariance = this.properties().childs().variance.value()
				}
				onData(e) {
					super.onData(e);
					if (!this.pointsProperty().childs().points.child("0"))
						for (let e = 0; e < this._points.length; e++) this._createPointProperty(e);
					this._currentInterval !== this._model.mainSeries().interval() && (this._regenerate(), this._currentInterval = this._model.mainSeries().interval())
				}
				cloneData(e) {
					this._segments = e._segments.map((e => e.clone(this)))
				}
				startMoving(e, t, i, r) {
					super.startMoving(e, t, i, r), this._preparePixelSegments()
				}
				move(e, t, i, r) {
					super.move(e, t, i, r), this._restoreSegmentsFromPixels()
				}
				endMoving(e, t) {
					return this._segmentsPixelsWhileMoving = null, super.endMoving(e, t)
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolghostfeed", e);
					return c._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 428205))).GhostFeedDefinitionsViewModel
				}
				_handleRestoringFactoryDefaults() {
					const e = Math.round(this._calculateATR());
					this.properties().childs().averageHL.setValue(e)
				}
				_regenerate() {
					this._currentAverageHL = this.properties().childs().averageHL.value(), this._currentVariance = this.properties().childs().variance.value(), this._segments.forEach((e => e.generate())), this.updateAllViews((0, a.dataSourceChangeEvent)(this.id())), this._model.updateSource(this)
				}
				_calculateATR() {
					const e = this._model.mainSeries(),
						t = [];
					e.bars().each(((e, i) => {
						const r = i[2],
							n = i[3];
						return null != r && null != n && t.push(r - n), !1
					}));
					let i = 0 === t.length ? 0 : t.reduce(((e, t) => e + t), 0) / t.length;
					return i *= e.base(), i
				}
				_preparePixelSegments() {
					var e, t;
					const i = this.priceScale(),
						r = null !== (t = null === (e = this.ownerSource()) || void 0 === e ? void 0 : e.firstValue()) && void 0 !== t ? t : null;
					if (null === i || null === r || i.isEmpty() || !i.isLog()) return;
					const n = this.points();
					this._segmentsPixelsWhileMoving = this._segments.map(((e, t) => {
						const s = n[t].price,
							o = n[t + 1].price,
							l = i.priceToCoordinate(s, r),
							a = (i.priceToCoordinate(o, r) - l) / (e.bars().length - 1);
						return {
							bars: e.bars().map(((e, t) => {
								const n = l + t * a,
									s = i.coordinateToPrice(n, r);
								return {
									open: i.priceToCoordinate(s + e.o, r) - n,
									high: i.priceToCoordinate(s + e.h, r) - n,
									low: i.priceToCoordinate(s + e.l, r) - n,
									close: i.priceToCoordinate(s + e.c, r) - n
								}
							}))
						}
					}))
				}
				_restoreSegmentsFromPixels() {
					var e, t;
					const i = this.priceScale(),
						r = null !== (t = null === (e = this.ownerSource()) || void 0 === e ? void 0 : e.firstValue()) && void 0 !== t ? t : null;
					if (null === i || null === r || null === this._segmentsPixelsWhileMoving) return;
					const n = this.points();
					this._segmentsPixelsWhileMoving.forEach(((e, t) => {
						const s = this._segments[t],
							o = n[t].price,
							l = n[t + 1].price,
							a = i.priceToCoordinate(o, r),
							c = (i.priceToCoordinate(l, r) - a) / (e.bars.length - 1),
							u = s.bars().map(((t, n) => {
								const s = e.bars[n],
									o = a + n * c,
									l = i.coordinateToPrice(o, r);
								return {
									...t,
									o: i.coordinateToPrice(s.open + o, r) - l,
									h: i.coordinateToPrice(s.high + o, r) - l,
									l: i.coordinateToPrice(s.low + o, r) - l,
									c: i.coordinateToPrice(s.close + o, r) - l
								}
							}));
						s.setBars(u)
					}))
				}
			}
		},
		550014: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolHeadAndShoulders: () => o
			});
			var r = i(346090),
				n = i(724145),
				s = i(424146);
			class o extends n.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || o.createProperties();
					super(e, s, r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 285444)).then((t => {
						this._setPaneViews([new t.LineToolHeadAndShouldersPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 7
				}
				name() {
					return "Head and Shoulders"
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolheadandshoulders", e);
					return o._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 949902)).then((e => e.PatternWithBackgroundDefinitionViewModel))
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e), e.addChild("linesColors", new s.LineToolColorsProperty([e.childs().color])), e.addChild("textsColors", new s.LineToolColorsProperty([e.childs().textcolor]))
				}
			}
		},
		133967: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolHighlighter: () => s
			});
			var r = i(346090),
				n = i(296484);
			class s extends n.LineToolBrushBase {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r), this._loadPaneViews(e)
				}
				smooth() {
					return this.properties().childs().smooth.value()
				}
				name() {
					return "Highlighter"
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolhighlighter", e);
					return s._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 516240)).then((e => e.HighlighterDefinitionsViewModel))
				}
				_loadPaneViews(e) {
					Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 856757)).then((t => {
						this._setPaneViews([new t.HighlighterPaneView(this, e)])
					}))
				}
				static _configureProperties(e) {
					n.LineToolBrushBase._configureProperties(e)
				}
			}
		},
		367001: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolHorzLinePriceAxisView: () => n
			});
			var r = i(498424);
			class n extends r.PriceAxisView {
				constructor(e) {
					super(), this._source = e
				}
				_updateRendererData(e, t, i) {
					e.visible = !1;
					const r = this._source.points(),
						n = this._source.priceScale();
					if (0 === r.length || null === n || n.isEmpty()) return;
					const s = r[0];
					if (!isFinite(s.price)) return;
					const o = this._source.ownerSource(),
						l = null !== o ? o.firstValue() : null;
					if (null === l) return;
					const a = this._source.properties().linecolor.value();
					i.background = a, i.textColor = this.generateTextColor(a), i.coordinate = n.priceToCoordinate(s.price, l), e.text = n.formatPrice(s.price, l), e.visible = !0
				}
			}
		},
		73224: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolHorzLine: () => a
			});
			var r = i(232567),
				n = i.n(r),
				s = i(346090),
				o = i(724145),
				l = i(367001);
			class a extends o.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || a.createProperties(), r, n), this._priceAxisView = new l.LineToolHorzLinePriceAxisView(this), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 51997)).then((({
						HorzLinePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				state(e) {
					const t = super.state(e);
					return t.points && 0 !== t.points.length && (t.points[0].offset = 0), t
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Horizontal Line"
				}
				priceAxisViews(e, t) {
					return this.isSourceHidden() || t !== this.priceScale() || !this._model.selection().isSelected(this) && !this.properties().childs().showPrice.value() || e !== this._model.paneForSource(this) ? null : [this._priceAxisView]
				}
				timeAxisViews() {
					return null
				}
				timeAxisPoints() {
					return []
				}
				updateAllViews(e) {
					super.updateAllViews(e), this._priceAxisView.update(e)
				}
				canHasAlert() {
					return !0
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				denormalizeTimePoints() {
					this._points = [], this._timePoint.length > 0 && this._points.push({
						price: this._timePoint[0].price,
						index: 0
					})
				}
				clearData() {
					const e = this._points;
					super.clearData(), this._points = e
				}
				static createProperties(e) {
					const t = new s.DefaultProperty("linetoolhorzline", e);
					return a._configureProperties(t), t
				}
				_getAlertPlots() {
					return [this.points()[0].price]
				}
				_pointsForPointset() {
					return []
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 654579)).then((e => e.HorizontalLineDefinitionsViewModel))
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e),
						this.properties().childs().text.setValue(e.text || "")
				}
				static _configureProperties(e) {
					o.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(n())("")), e.addExclusion("text")
				}
			}
		},
		499924: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolHorzRay: () => a
			});
			var r = i(346090),
				n = i(232567),
				s = i.n(n),
				o = i(367001),
				l = i(724145);
			class a extends l.LineDataSource {
				constructor(e, t, r, n) {
					super(e, null != t ? t : a.createProperties(), r, n), this._priceAxisView = new o.LineToolHorzLinePriceAxisView(this), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 313304)).then((({
						HorzRayPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Horizontal Ray"
				}
				priceAxisViews(e, t) {
					return this.isSourceHidden() || t !== this.priceScale() || !this._model.selection().isSelected(this) && !this.properties().childs().showPrice.value() || e !== this._model.paneForSource(this) ? null : [this._priceAxisView]
				}
				updateAllViews(e) {
					super.updateAllViews(e), this._priceAxisView.update(e)
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				canHasAlert() {
					return !0
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolhorzray", e);
					return a._configureProperties(t), t
				}
				_getAlertPlots() {
					const e = this._points[0],
						t = {
							index: e.index + 1,
							price: e.price
						};
					return [this._linePointsToAlertPlot([e, t], null, !1, !0)]
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 394039))).HorizontalRayDefinitionsViewModel
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text || "")
				}
				static _configureProperties(e) {
					l.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(s())("")), e.addExclusion("text")
				}
			}
		},
		171215: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolIcon: () => a
			});
			var r = i(588537),
				n = i(86441),
				s = i(346090),
				o = i(724145),
				l = i(424146);
			class a extends o.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || a.createProperties(), r, n), this.version = 1, Promise.all([i.e(9586).then(i.bind(i, 409691)), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 715429))]).then((([t, i]) => {
						this._setPaneViews([new i.IconPaneView(this, e, t.getPath2DbyCharCode)])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Icon"
				}
				hasEditableCoordinates() {
					return !1
				}
				getAnchorLimit() {
					return 80
				}
				applyTemplate(e) {
					delete e.icon, super.applyTemplate(e)
				}
				getChangePointForSync(e) {
					return null
				}
				setPoint(e, t, i) {
					const s = Object.assign({}, t),
						o = (0, r.ensureNotNull)(this.pointToScreenPoint(this.points()[0])),
						l = (0, r.ensureNotNull)(this.pointToScreenPoint(s)).subtract(o),
						a = this.properties().childs();
					if (0 === e || 1 === e) {
						const t = l.normalized();
						let i = Math.acos(-t.x);
						Math.asin(t.y) > 0 && (i = 2 * Math.PI - i), 0 === e && (i += Math.PI), a.angle.setValue(i)
					} else {
						const t = l.add(new n.Point(15 * (3 === e ? -1 : 1), 0));
						a.size.setValue(2 * Math.abs(t.x))
					}
				}
				getSourceIcon() {
					return {
						type: "charCode",
						charCode: this.properties().childs().icon.value()
					}
				}
				static createProperties(e) {
					const t = new s.DefaultProperty("linetoolicon", e);
					return a._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 248074)).then((e => e.IconsDefinitionsViewModel))
				}
				static _configureProperties(e) {
					o.LineDataSource._configureProperties(e), e.addChild("backgroundsColors", new l.LineToolColorsProperty([e.childs().color])), e.addExclusion("angle")
				}
			}
		},
		532962: (e, t, i) => {
			"use strict";
			i.d(t, {
				isIdeaUrl: () => c,
				isIdeaAuthorProfileImageUrl: () => u,
				createIdeaLineToolByUrl: () => d
			});
			var r = i(588537),
				n = i(62802),
				s = i(95935),
				o = i(694755),
				l = i(49318);
			const a = /^\/chart\/.+?\/([0-9a-zA-Z]{8})(-[-\w]+)?\/?$/;

			function c(e) {
				try {
					const t = new URL(e);
					return "https:" === t.protocol && t.hostname.endsWith(".tradingview.com") && a.test(t.pathname)
				} catch (e) {
					return !1
				}
			}

			function u(e) {
				if (e.startsWith("data:image/svg+xml,")) return !0;
				try {
					const t = new URL(e),
						i = new URL(window.AWS_S3_CDN);
					return t.protocol === i.protocol && t.hostname === i.hostname && t.pathname.includes("/userpics/")
				} catch (e) {
					return !1
				}
			}
			async function h(e) {
				const t = new URL(`/api/v1/ideas/${i=e,(0,r.ensureNotNull)(a.exec(new URL(i).pathname))[1]}/`, location.href);
				var i;
				return fetch(t.toString()).then((e => {
					if (!e.ok) throw new Error(`Error processing idea: ${e.statusText}`);
					return e.json()
				}))
			}

			function d(e, t, i = !1) {
				return h(e).then((e => {
					const a = function(e, t) {
							var i;
							const n = (0, r.ensureDefined)(e.user);
							let s;
							n.avatars && u(n.avatars.small) && (s = n.avatars.small.startsWith("data:image/svg+xml,") ? n.avatars.small : `${n.avatars.small.replace(window.AWS_S3_CDN,"")}?resetCache=true`);
							const l = {
								avatarUrl: s,
								badges: null === (i = n.badges) || void 0 === i ? void 0 : i.map((e => e.name)),
								username: n.username
							};
							return {
								createdAt: e.created_timestamp,
								direction: e.direction,
								name: (0, o.clean)(e.name, !0),
								author: l,
								uuid: e.uuid
							}
						}(e),
						c = {
							price: 0,
							time_t: a.createdAt,
							offset: 0
						},
						h = t.mainSeries(),
						d = (0, r.ensureNotNull)(t.model().paneForSource(h)),
						p = d.newLineToolZOrder(!0),
						_ = {
							type: "drawing",
							source: {
								id: (0, s.randomHashN)(6),
								zorder: p,
								type: "LineToolIdea",
								position: 50,
								state: {
									interval: "1",
									...l.LineToolIdea.createProperties().state()
								},
								ideaData: a,
								symbol: h.symbol(),
								ownerSource: h.id(),
								points: [c]
							},
							geometry: [],
							modelId: t.model().id()
						},
						P = t.pasteLineTool(d, _, !0, !0);
					return i && n.setValue("hint.pasteIdea", !0, {
						forceFlush: !0
					}), P.pointAdded().subscribe(null, (() => t.scrollToLineTool(P)), !0), P
				}))
			}
		},
		49318: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolIdea: () => w
			});
			var r = i(346090),
				n = i(724145),
				s = i(575932),
				o = i(62802),
				l = i(345848),
				a = i(911905),
				c = i(846778),
				u = i(63208),
				h = i(308170),
				d = i(676553),
				p = i(532962);
			const _ = (0, a.getLogger)("Chart.IdeaDialog"),
				P = (0, s.t)("Idea"),
				f = (0, s.t)("Insert a link to the idea");
			let g = null;

			function v(e) {
				"LineToolIdea" === e ? (window.is_authenticated || (0, h.resetToCursor)(!0), window.runOrSignIn((() => {
					h.tool.setValue("LineToolIdea"), g = (0, d.showCustomUrlEventDialog)({
						onConfirm: m,
						onClose: () => {
							g = null, "LineToolIdea" === h.tool.value() && (0, h.resetToCursor)(!0)
						},
						title: P,
						placeholderText: f
					}), (0, l.trackEvent)("Idea", "Open idea dialog")
				}), {
					source: "Change drawing tool state"
				})) : null !== g && g.then((e => e()))
			}

			function m(e) {
				const t = (0, u.chartWidgetCollectionService)();
				if (null === t) return;
				if (!(0, p.isIdeaUrl)(e)) return void _.logWarn(`Invalid idea url: ${e}`);
				const i = !Boolean(o.getBool("hint.pasteIdea")),
					r = t.activeChartWidget.value();
				(0, p.createIdeaLineToolByUrl)(e, r.model()).then((() => {
					i && (0, c.showPasteLineToolHint)(t.getContainer(), "hint.pasteIdea")
				}))
			}
			var C = i(232567),
				y = i.n(C),
				T = i(513647);
			class S extends T.CustomEventItem {
				constructor(e, t) {
					super(t), this._data = e
				}
				ideaData() {
					return this._data
				}
				index() {
					return this._source.eventTimePointIndex()
				}
				time() {
					return this._data.createdAt
				}
				avatar() {
					var e;
					return null === (e = this._data.author) || void 0 === e ? void 0 : e.avatarUrl
				}
			}
			class w extends T.LineToolCustomUrlEvent {
				constructor(e, t, r, n) {
					super(e, t || w.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 730302)).then((t => {
						this._setPaneViews([new t.IdeaPaneView(this, e)])
					}))
				}
				name() {
					return "Idea"
				}
				state(e) {
					const t = super.state(e);
					return this._item && (t.ideaData = this._item.ideaData()), e && (t.eventTimePointIndex = this._eventTimePointIndex), t
				}
				restoreData(e) {
					e.ideaData && (this._item = new S(e.ideaData, this)), void 0 !== e.eventTimePointIndex && (this._eventTimePointIndex = e.eventTimePointIndex)
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolIdea", e);
					return w._configureProperties(t), t.hasChild("position") || t.addChild("position", new(y())(50)), t.addExclusion("position"), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 400222)).then((e => e.IdeaDefinitionsViewModel))
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e)
				}
			}(0, h.runOnDrawingStateReady)((() => {
				h.tool.subscribe(v)
			}))
		},
		17588: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolImage: () => w,
				buildAbsoluteUserImageUrl: () => S
			});
			var r = i(588537),
				n = i(86441),
				s = i(911905),
				o = i(346090),
				l = i(232567),
				a = i.n(l),
				c = i(724145),
				u = i(194459),
				h = i(62802),
				d = i(345848),
				p = i(846778),
				_ = i(63208),
				P = i(308170);
			async function f(e, t) {
				return async function(e) {
					return (await Promise.all([i.e(10146), i.e(90519), i.e(90926), i.e(8834), i.e(30063), i.e(15107), i.e(80580), i.e(68074), i.e(52498), i.e(92617), i.e(74499), i.e(38489), i.e(99738), i.e(2984), i.e(75514), i.e(35189), i.e(92697), i.e(77038)]).then(i.bind(i, 173673))).renderImageDialog(e)
				}({
					onConfirm: e,
					onClose: t
				})
			}
			let g = null;

			function v(e) {
				if ("LineToolImage" !== e) return null == g || g.then((e => e())), void(g = null);
				window.is_authenticated || (0, P.resetToCursor)(!0), window.runOrSignIn((() => {
					P.tool.setValue("LineToolImage"), g = f(m, (() => {
						null == g || g.then((e => e())), g = null, "LineToolImage" === P.tool.value() && (0, P.resetToCursor)(!0)
					})), (0, d.trackEvent)("Image", "Open image dialog")
				}), {
					source: "Change drawing tool state"
				})
			}

			function m(e) {
				const t = (0, _.chartWidgetCollectionService)();
				if (null === t) return;
				const i = !Boolean(h.getBool("hint.pasteImage")),
					n = t.activeChartWidget.value();
				n.model().pasteImageAsLineTool(e.url, e.blobUrl, (0, r.ensureNotNull)(n.model().model().paneForSource(n.model().mainSeries())), e.transparency), i && (0, p.showPasteLineToolHint)(t.getContainer(), "hint.pasteImage")
			}
			const C = (0, s.getLogger)("Chart.LineToolImage");

			function y(e) {
				return e.toLowerCase().startsWith("blob:")
			}
			const T = window.AWS_BBS3_DOMAIN;

			function S(e) {
				if (y(e)) return e;
				const t = new URL(e, T),
					i = new URL(t.pathname, T);
				if ("/" === i.pathname) return null;
				const r = i.toString();
				return t.toString() !== r ? null : r
			}
			class w extends c.LineDataSource {
				constructor(e, t, r, n) {
					var s;
					super(e, t || w.createProperties(), r, n), this._image = null, this._originPoint = 4;
					const o = this.properties().childs().url;
					this._absoluteUserImageUrl = new(a())(null !== (s = S(this.properties().childs().url.value())) && void 0 !== s ? s : ""), this._absoluteUserImageUrl.subscribe(this, (e => {
						const t = e.value();
						if (y(t)) return;
						const i = S(t);
						null !== i && o.setValue(new URL(i).pathname)
					})), o.subscribe(this, (() => {
						const e = S(o.value());
						null !== e && this._absoluteUserImageUrl.setValue(e)
					})), this._loadImage(), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 760085)).then((({
						ImagePaneView: t
					}) => {
						this._setPaneViews([new t(this, e)])
					})), this.properties().childs().url.subscribe(this, (() => {
						this._loadImage()
					}))
				}
				absoluteUserImageUrl() {
					return this._absoluteUserImageUrl
				}
				cssWidth() {
					return this.properties().childs().cssWidth.value()
				}
				cssHeight() {
					return this.properties().childs().cssHeight.value()
				}
				angle() {
					return this.properties().childs().angle.value()
				}
				originPoint() {
					return this._originPoint
				}
				dOffsetX() {
					return this._dOffsetX || 0
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Image"
				}
				image() {
					return this._image
				}
				setBlobImageUrl(e) {
					this._image || (this._createImage(e), this._blobUrl = e)
				}
				getChangePointForSync(e) {
					return null
				}
				hasEditableCoordinates() {
					return !1
				}
				pointToScreenPoint({
					index: e,
					price: t
				}, i = 0) {
					const s = this._model.timeScale(),
						o = (0, r.ensureNotNull)(this.priceScale()),
						l = (0, r.ensureNotNull)((0, r.ensureNotNull)(this.ownerSource()).firstValue()),
						a = s.indexToCoordinate(e) + i,
						c = o.priceToCoordinate(t, l);
					return new n.Point(a, c)
				}
				setPoint(e, t, i) {
					if (null === this._image) return;
					const {
						width: n,
						height: s
					} = this._image, o = (0, r.ensureNotNull)(this.pointToScreenPoint(t)), l = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0], this.dOffsetX())), a = Math.max(Math.abs(l.x - o.x) / n, Math.abs(l.y - o.y) / s), c = Math.round(n * a), u = Math.round(s * a), h = this.properties().childs();
					h.cssWidth.setValue(c), h.cssHeight.setValue(u), this.propertiesChanged()
				}
				startChanging(e, t) {
					super.startChanging(e, t), this._changeOriginPoint(w._oppositePoints[e])
				}
				endChanging(e, t) {
					return this._changeOriginPoint(4), super.endChanging(e, t)
				}
				getPoint() {
					return null
				}
				syncLineStyleState() {
					const e = super.syncLineStyleState();
					return !e.url && this._blobUrl && (e.blobUrl = this._blobUrl), e
				}
				restoreExternalState(e) {
					const {
						blobUrl: t,
						...i
					} = e;
					t && this.setBlobImageUrl(t), super.restoreExternalState(i)
				}
				isSavedInChart() {
					return super.isSavedInChart() && "" !== this.absoluteUserImageUrl().value()
				}
				static createProperties(e) {
					const t = new o.DefaultProperty("linetoolimage", e);
					return w._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 35306))).ImageDefinitionsViewModel
				}
				static _configureProperties(e) {
					c.LineDataSource._configureProperties(e), e.hasChild("url") || e.addChild("url", new(a())("")), e.addExclusion("url"), e.addExclusion("cssWidth"), e.addExclusion("cssHeight"), e.addExclusion("angle")
				}
				_loadImage() {
					const e = this.properties(),
						t = (0, r.ensureDefined)(e.child("url")).value();
					t && this._createImage(t)
				}
				_changeOriginPoint(e) {
					const t = this.originPoint(),
						i = 4 === t ? w._correctOriginDirections[e] : w._correctOriginDirections[w._oppositePoints[t]],
						s = this.properties().childs().cssWidth.value() / 2,
						o = this.properties().childs().cssHeight.value() / 2,
						[l] = this._points,
						a = (0, r.ensureNotNull)(this.pointToScreenPoint(l)),
						c = new n.Point(a.x + s * i[0], a.y + o * i[1]),
						u = (0, r.ensureNotNull)(this.screenPointToPoint(c));
					this._dOffsetX = 4 === t ? c.x - (0, r.ensureNotNull)(this.pointToScreenPoint(u)).x : void 0, l.index = u.index, l.price = u.price, this._originPoint = e
				}
				_createImage(e) {
					var t;
					const i = y(e),
						n = S(e);
					if (null === n) return void C.logWarn(`Invalid image URL: ${e}`);
					if (n === (null === (t = this._image) || void 0 === t ? void 0 : t.src)) return;
					const s = document.createElement("img");
					s.crossOrigin = "anonymous", s.src = n, s.addEventListener("load", (() => {
						this._image = s;
						const e = this._model,
							t = this.properties().childs();
						if (!i) {
							const e = new URL(n).pathname;
							t.url.setValue(e), this._blobUrl = void 0
						}
						if (t.cssWidth.value() && t.cssHeight.value()) return void this._model.updateSource(this);
						const o = e.timeScale().width() / 4,
							l = (0, r.ensureNotNull)(this.priceScale()).height() / 4,
							a = s.naturalWidth,
							c = s.naturalHeight,
							h = Math.min(1, o / a),
							d = Math.min(1, l / c),
							p = Math.min(h, d),
							_ = Math.round(p * a),
							P = Math.round(p * c);
						t.cssWidth.setValue(_), t.cssHeight.setValue(P), this.updateAllViews((0, u.dataSourceChangeEvent)(this.id())), this._model.updateSource(this)
					})), s.addEventListener("error", (() => {
						this.model().removeSource(this)
					}))
				}
			}
			w._correctOriginDirections = [
				[-1, -1],
				[1, -1],
				[-1, 1],
				[1, 1],
				[0, 0]
			], w._oppositePoints = [3, 2, 1, 0, 4], (0, P.runOnDrawingStateReady)((() => {
				P.tool.subscribe(v)
			}))
		},
		687910: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolInfoLine: () => s
			});
			var r = i(346090),
				n = i(439195);
			class s extends n.LineToolTrendLine {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Info Line"
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolinfoline", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					n.LineToolTrendLine._configureProperties(e)
				}
			}
		},
		344900: (e, t, i) => {
			"use strict";
			var r = i(755827).LevelsProperty,
				n = i(119310).LineToolPitchfork;
			class s extends n {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				name() {
					return "Inside Pitchfork"
				}
				static createProperties(e) {
					var t = new r("linetoolinsidepitchfork", e, !1, {
						range: [0, 8]
					});
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					n._configureProperties(e)
				}
			}
			t.LineToolInsidePitchfork = s
		},
		29084: (e, t, i) => {
			"use strict";
			var r;
			i.r(t), i.d(t, {
				isMtpPredictorToolName: () => o,
				isStudyLineToolName: () => l,
				isLineToolName: () => a,
				isLineDrawnWithPressedButton: () => c,
				isLineToolFinishRequiredWhenCreatedByApi: () => u,
				isLineToolDrawWithoutPoints: () => h,
				isImageToolName: () => d,
				isTextToolName: () => p
			});
			var n = i(103573);
			const s = new Set(["LineStudyMtpAnalysis", "LineStudyMtpDecisionPoint", "LineStudyMtpRiskReward", "LineStudyMtpElliotWaveMain", "LineStudyMtpElliotWaveMajor", "LineStudyMtpElliotWaveMinor", "LineStudyMtpDownWave1OrA", "LineStudyMtpDownWave2OrB", "LineStudyMtpDownWave3", "LineStudyMtpDownWave4", "LineStudyMtpDownWave5", "LineStudyMtpDownWaveC", "LineStudyMtpUpWave1OrA", "LineStudyMtpUpWave2OrB", "LineStudyMtpUpWave3", "LineStudyMtpUpWave4", "LineStudyMtpUpWave5", "LineStudyMtpUpWaveC"]);

			function o(e) {
				return s.has(e)
			}

			function l(e) {
				let t = "LineToolRegressionTrend" === e || "LineToolVbPFixed" === e || "LineToolFixedRangeVolumeProfile" === e;
				return t || (t = "LineToolAnchoredVWAP" === e || o(e)), t
			}

			function a(e) {
				return e in (r || (r = i.t(n, 2))) || l(e)
			}

			function c(e) {
				return "LineToolBrush" === e || "LineToolHighlighter" === e
			}

			function u(e) {
				return c(e) || "LineToolPath" === e || "LineToolPolyline" === e || "LineToolGhostFeed" === e
			}

			function h(e) {
				return "LineToolTweet" === e || "LineToolIdea" === e || "LineToolImage" === e
			}

			function d(e) {
				return "LineToolImage" === e
			}

			function p(e) {
				switch (e) {
					case "LineToolBalloon":
					case "LineToolText":
					case "LineToolTextAbsolute":
					case "LineToolCallout":
					case "LineToolNote":
					case "LineToolNoteAbsolute":
					case "LineToolSignpost":
						return !0
				}
				return !1
			}
		},
		29494: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineDataSourceBase: () => E
			});
			var r = i(86441),
				n = i(588537),
				s = i(251954),
				o = i(911905),
				l = i(62949),
				a = i(308170),
				c = i(97639),
				u = i.n(c),
				h = i(232567),
				d = i.n(h),
				p = i(424146),
				_ = i(171073),
				P = i(652778);
			class f extends(d()) {
				constructor(e, t) {
					super(), this._lineSource = e, this._pointIndex = t, e.pointAdded().subscribe(this, (e => {
						this._pointIndex === e && this._listeners.fire(this)
					})), e.pointChanged().subscribe(this, (e => {
						this._pointIndex === e && this._listeners.fire(this)
					}))
				}
				value() {
					const e = this._lineSource.points()[this._pointIndex].price,
						t = (0, n.ensureNotNull)(this._lineSource.ownerSource()).formatter();
					if (t.parse) {
						const i = t.format(e),
							r = t.parse(i);
						return r.res ? r.value : e
					}
					return e
				}
				setValue(e) {
					const t = this._lineSource.points()[this._pointIndex];
					t.price = parseFloat("" + e), this._lineSource.startChanging(this._pointIndex, t), this._lineSource.setPoint(this._pointIndex, t), this._lineSource.model().updateSource(this._lineSource), this._listeners.fire(this);
					const i = this._lineSource.endChanging(!0, !1);
					this._lineSource.syncMultichartState(i)
				}
			}
			var g = i(839916),
				v = i(273044),
				m = i(746511),
				C = i(706342),
				y = i(749473),
				T = i(920358),
				S = i(262325),
				w = i.n(S),
				b = i(388230),
				x = i(364019),
				L = i(669415),
				A = i(194543),
				D = i(52500),
				V = i(270617),
				I = i(194459);
			const M = (0, o.getLogger)("Chart.LineDataSource");
			class R {
				constructor() {
					this._states = []
				}
				start(e) {
					this._states.push(e)
				}
				finish(e) {
					const t = (0, n.ensureDefined)(this._states.pop());
					return r = t, (i = e).length !== r.length ? {
						indexesChanged: !0,
						pricesChanged: !0
					} : i.reduce(((e, t, i) => {
						const n = r[i];
						return e.indexesChanged = e.indexesChanged || t.index !== n.index, e.pricesChanged = e.pricesChanged || t.price !== n.price, e
					}), {
						indexesChanged: !1,
						pricesChanged: !1
					});
					var i, r
				}
				isEmpty() {
					return 0 === this._states.length
				}
			}
			let B = 0;
			class E extends l.DataSource {
				constructor(e, t, i, r) {
					if (super(r), this.version = 1, this.customization = {
							forcePriceAxisLabel: !1,
							disableErasing: !1,
							disableSave: !1,
							showInObjectsTree: !0
						}, this._currentPointsetAndSymbolId = null, this._pointChanged = new(u()), this._pointAdded = new(u()), this._alertUndoMode = !1, this._priceAxisViews = [], this._timeAxisViews = [], this._timePoint = [], this._points = [], this._lastPoint = null, this._paneViews = new Map, this._normalizedPointsChanged = new(u()), this._fixedPointsChanged = new(u()), this._changeStatesStack = new R, this._startMovingPoint = null, this._currentMovingPoint = null, this._fixedPoints = [], this._isActualSymbol = !1, this._isActualInterval = !1, this._isActualCurrency = !1, this._isActualUnit = !1, this._isDestroyed = !1, this._sharingMode = new(w())(0), this._onTemplateApplying = new(u()), this._onTemplateApplied = new(u()), this._syncStateExclusions = [], this._definitionsViewModel = null, this._syncLineStyleMuted = !1, this._onIsActualIntervalChange = new(u()), this._linkKey = new(w())(null), this._serverUpdateTime = null, this._model = e, this._properties = t, this._localAndServerAlertsMismatch = !1, this._properties.hasChild("interval") || this._properties.addChild("interval", new(d())(e.mainSeries().interval())), this.calcIsActualSymbol(), this._properties.childs().intervalsVisibilities.listeners().subscribe(this, this.calcIsActualSymbol), this._properties.subscribe(this, (() => this.propertiesChanged())), this._createPointsProperties(), this.pointsCount() > 0)
						for (let e = 0; e < this.pointsCount(); e++) this._priceAxisViews.push(this.createPriceAxisView(e)), this._timeAxisViews.push(new P.LineDataSourceTimeAxisView(this, e));
					this._properties.childs().visible.subscribe(this, (e => {
						const t = !1 === (0, a.hideAllDrawings)().value();
						e.value() ? e.value() && t && s.emit("drawing_event", this._id, "show") : (this._model.selection().isSelected(this) && this._model.selectionMacro((e => {
							e.removeSourceFromSelection(this)
						})), t && s.emit("drawing_event", this._id, "hide")), this._onSourceHiddenMayChange()
					})), (0, a.hideAllDrawings)().subscribe(this, this._onSourceHiddenMayChange), this._definitionsViewModel = null, this._isDestroyed = !1
				}
				destroy() {
					this._paneViews.forEach(((e, t) => this._destroyPanePaneViews(t))), this.stop(), null !== this._definitionsViewModel && (this._definitionsViewModel.destroy(), this._definitionsViewModel = null), null !== this._ownerSource && (this._ownerSource.currencyChanged().unsubscribeAll(this), this._ownerSource.unitChanged().unsubscribeAll(this)), (0, a.hideAllDrawings)().unsubscribeAll(this), this.deleteAlert(), this._isDestroyed = !0
				}
				createPriceAxisView(e) {
					return new _.LineToolPriceAxisView(this, {
						pointIndex: e
					})
				}
				model() {
					return this._model
				}
				linkKey() {
					return this._linkKey
				}
				serverUpdateTime() {
					return this._serverUpdateTime
				}
				setServerUpdateTime(e) {
					this._serverUpdateTime = e
				}
				boundToSymbol() {
					return !0
				}
				isAvailableInFloatingWidget() {
					return !0
				}
				points() {
					const e = [];
					for (let t = 0; t < this._points.length; t++) {
						const i = this._points[t];
						e.push({
							index: i.index,
							price: i.price,
							time: i.time
						})
					}
					return this._lastPoint && e.push(this._correctLastPoint(this._lastPoint)), !this.isFixed() && this._currentMovingPoint && this._startMovingPoint && this._correctPoints(e), e
				}
				timeAxisPoints() {
					return this.points()
				}
				priceAxisPoints() {
					return this.points()
				}
				normalizedPoints() {
					return this._timePoint
				}
				normalizedPointsChanged() {
					return this._normalizedPointsChanged
				}
				fixedPointsChanged() {
					return this._fixedPointsChanged
				}
				widthsProperty() {
					var e;
					return null !== (e = this._properties.childs().linesWidths) && void 0 !== e ? e : null
				}
				lineColorsProperty() {
					var e;
					return null !== (e = this._properties.childs().linesColors) && void 0 !== e ? e : null
				}
				backgroundColorsProperty() {
					var e;
					return null !== (e = this._properties.childs().backgroundsColors) && void 0 !== e ? e : null
				}
				textColorsProperty() {
					var e;
					return null !== (e = this._properties.childs().textsColors) && void 0 !== e ? e : null
				}
				pointsProperty() {
					return this._pointsProperty
				}
				startMoving(e, t, i, r) {
					this.isFixed() && this.restoreFixedPoints(), this._startMovingPoint = e
				}
				move(e, t, i, r) {
					if (i && (i.shiftOnly() || i.modShift()))
						if (this.isFixed()) {
							const t = this._alignScreenPointHorizontallyOrVertically((0, n.ensureDefined)(e.screen));
							this._currentMovingPoint = {
								screen: t
							}
						} else {
							const t = this._alignPointHorizontallyOrVertically((0, n.ensureDefined)(e.logical)),
								i = (0, n.ensureNotNull)(this.pointToScreenPoint(t));
							this._currentMovingPoint = {
								logical: t,
								screen: i
							}
						}
					else this._currentMovingPoint = e;
					this.updateAllViews((0, I.dataSourceChangeEvent)(this.id()))
				}
				endMoving(e, t, i) {
					let r = !1,
						o = !1;
					if (this._currentMovingPoint && this._startMovingPoint) {
						if (this.isFixed()) this._correctFixedPoints(this._fixedPoints) && this._fixedPointsChanged.fire();
						else {
							const e = (0, n.ensureDefined)(this._currentMovingPoint.logical),
								t = (0, n.ensureDefined)(this._startMovingPoint.logical);
							r = e.index !== t.index, o = e.price !== t.price;
							if (this._correctPoints(this._points, i)) {
								s.emit("drawing_event", this._id, "move");
								for (let e = 0; e < this._points.length; e++) this._pointChanged.fire(e)
							}
						}
						this._startMovingPoint = null, this._currentMovingPoint = null
					}
					const l = {
						indexesChanged: r,
						pricesChanged: o
					};
					return this.isFixed() ? (this.calcPositionPercents(), this.updateAllViews((0, I.dataSourceChangeEvent)(this.id())), l) : (this.updateAllViews((0, I.dataSourceChangeEvent)(this.id())), r && !e ? (this._properties.childs().interval.setValue(this._model.mainSeries().interval()), this.normalizePoints(), this.createServerPoints()) : (this._copyPricesWithoutNormalization(), this._normalizedPointsChanged.fire()), t || !o && !r || this.synchronizeAlert(!this._alertUndoMode), l)
				}
				startMovingPoint() {
					return this._startMovingPoint ? {
						...this._startMovingPoint
					} : null
				}
				currentMovingPoint() {
					return this._currentMovingPoint ? {
						...this._currentMovingPoint
					} : null
				}
				startChanging(e, t) {
					void 0 !== e && void 0 !== t && (e < this._priceAxisViews.length && this._priceAxisViews[e].setActive(!0), e < this._timeAxisViews.length && this._timeAxisViews[e].setActive(!0)), this._changeStatesStack.start(this.points())
				}
				endChanging(e, t, i) {
					const r = this._changeStatesStack.finish(this.points());
					r.indexesChanged && this._changeStatesStack.isEmpty() ? (this._properties.childs().interval.setValue(this._model.mainSeries().interval()), this.normalizePoints(), t || this.createServerPoints()) : (this._copyPricesWithoutNormalization(), this._normalizedPointsChanged.fire());
					for (let e = 0; e < this._priceAxisViews.length; e++) this._priceAxisViews[e].setActive(!1);
					for (let e = 0; e < this._timeAxisViews.length; e++) this._timeAxisViews[e].setActive(!1);
					return i || this.synchronizeAlert(!e), r
				}
				setPoint(e, t, i, r) {
					if (i && i.shift() && this._snapTo45DegreesAvailable()) {
						const i = 0 === e ? 1 : e - 1;
						this._snapPoint45Degree(t, this.points()[i])
					}
					this._points[e].index === t.index ? (this._points[e].price = t.price, this._pointChanged.fire(e)) : (this._points[e] = t, this._pointChanged.fire(e))
				}
				getPoint(e) {
					return this.points()[e] || null
				}
				alignCrossHairToAnchor(e) {
					return !0
				}
				setLastPoint(e, t) {
					return this._lastPoint = this._preparePoint(e, t), this.updateAllViews((0, I.dataSourceChangeEvent)(this.id())), this._lastPoint
				}
				lastPoint() {
					return this._lastPoint
				}
				getChangePointForSync(e) {
					return this.getPoint(e)
				}
				setPoints(e) {
					this._points = e
				}
				isForcedDrawPriceAxisLabel() {
					return this.customization.forcePriceAxisLabel
				}
				clearData() {
					this._points = []
				}
				denormalizeTimePoints() {
					let e = [];
					for (let t = 0; t < this._timePoint.length; t++) {
						const i = this._model.timeScale().denormalizeTimePoint(this._timePoint[t]);
						if (void 0 === i) {
							e = [];
							break
						}
						e.push({
							index: i,
							price: this._timePoint[t].price
						})
					}
					e.length > 0 && (this._points = e)
				}
				restorePoints(e, t, i) {
					const r = this._timePoint.length > 0 && !(0, V.deepEquals)(this._timePoint, e)[0];
					this._timePoint = (0, m.deepCopy)(e), this._points = t, i || this.denormalizeTimePoints(), r && this._normalizedPointsChanged.fire()
				}
				restorePositionPercents(e) {
					this._positionPercents = e
				}
				calcIsActualSymbol() {
					if (this._model.mainSeries().hasDelayedSymbolIntervalChange()) return;
					const e = this.ownerSource();
					if (null === e) this._isActualSymbol = !1;
					else {
						const t = (0, n.ensureNotNull)(e.symbolSource());
						this._migrateSymbolProperty();
						const i = this._properties.childs().symbol,
							r = i.value();
						if (this._isActualSymbol = t.symbolSameAsCurrent(r), this._isActualSymbol) {
							const e = t.symbol();
							(0, C.areEqualSymbols)(r, e) || (M.logWarn('Possible drawing "migrating" detected from "' + r + '" to "' + e + '"'), M.logWarn("Series symbolInfo: " + JSON.stringify(t.symbolInfo())), M.logWarn(`${(new Error).stack}`)), i.setValue(e)
						}
					}
					this.calcIsActualInterval(), this.calcIsActualCurrency(), this.calcIsActualUnit(), this._onSourceHiddenMayChange()
				}
				calcIsActualCurrency() {
					const e = this.ownerSource();
					if (null === e) return void(this._isActualCurrency = !1);
					let t = this._properties.childs().currencyId.value();
					if (null !== t) {
						const i = e.symbolSource();
						"pct" === t && (this._properties.childs().currencyId.setValue(null), t = null), this._isActualCurrency = t === (0, y.symbolCurrency)(i.symbolInfo(), void 0, !0)
					} else {
						const t = (0, n.ensureNotNull)(e.symbolSource()).symbolInfo();
						this._isActualCurrency = null !== t && (0, y.symbolCurrency)(t) === (0, y.symbolOriginalCurrency)(t)
					}
					this._onSourceHiddenMayChange()
				}
				calcIsActualUnit() {
					const e = this.ownerSource();
					if (null === e) return void(this._isActualUnit = !1);
					const t = this._properties.childs().unitId.value();
					if (null !== t) this._isActualUnit = t === (0, n.ensureNotNull)(e.symbolSource()).unit();
					else {
						const t = (0, n.ensureNotNull)(e.symbolSource()).symbolInfo(),
							i = this._model.unitConversionEnabled();
						this._isActualUnit = null !== t && (0, y.symbolUnit)(t, i) === (0, y.symbolOriginalUnit)(t, i)
					}
					this._onSourceHiddenMayChange()
				}
				calcIsActualInterval() {
					const e = this._isActualInterval,
						t = this._properties,
						i = this._model.mainSeries();
					this._isActualInterval = (0,
						L.isActualInterval)(v.Interval.parse(i.interval()), t.childs().intervalsVisibilities), !this._isActualInterval && this._model.selection().isSelected(this) && this._model.selectionMacro((e => e.removeSourceFromSelection(this))), this._isActualInterval !== e && this._onIsActualIntervalChange.fire(), this._onSourceHiddenMayChange()
				}
				paneViews(e) {
					if (this.isSourceHidden()) return null;
					const t = this._getPaneViews(this.isMultiPaneAvailable() ? e : void 0);
					if (null === t) return null;
					if (1 === t.length) return [t[0]];
					const i = [];
					for (let e = t.length - 1; e >= 0; --e) i.push(t[e]);
					return i
				}
				isSavedInChart() {
					return !this.customization.disableSave
				}
				setSavingInChartEnabled(e) {
					this.customization.disableSave = !e
				}
				shouldBeRemovedOnDeselect() {
					return !1
				}
				detachAlert() {
					const e = this.getAlertSync();
					if (e && this._alertCallbacks) {
						const t = this._alertCallbacks;
						e.off("destroy", t.remove), e.off("change:hovered", t.hovered), e.off("change:selected", t.selected)
					}
					this.hasAlert.setValue(!1), this._alertId = void 0
				}
				removeAlert() {
					this._alertId = void 0, this.hasAlert.setValue(!1)
				}
				deleteAlert() {
					{
						if (!this.hasAlert.value() || void 0 === this._alertId) return;
						const e = (0, T.getPriceAlertsDispatcherIfExists)();
						e && e.deleteAlert(this._alertId), this.removeAlert()
					}
				}
				areLocalAndServerAlertsMismatch() {
					return this._localAndServerAlertsMismatch
				}
				showInObjectTree() {
					return this.customization.showInObjectsTree
				}
				setShowInObjectsTreeEnabled(e) {
					this.customization.showInObjectsTree = e
				}
				start() {
					this.createServerPoints()
				}
				processHibernate() {
					this.isSourceHidden() ? this.isStarted() && this.stop() : this.isStarted() || this.start()
				}
				onData(e) {
					"pointset_error" !== e.method ? e.params.customId === this._currentPointsetIdWithPrefix() && this._onPointsetUpdated(e.params.plots) : M.logError(`Error getting pointset: ${e.params[0]} ${e.params[1]}`)
				}
				isActualSymbol() {
					return this._isActualSymbol
				}
				isActualCurrency() {
					return this._isActualCurrency
				}
				isActualInterval() {
					return this._isActualInterval
				}
				isActualUnit() {
					return this._isActualUnit
				}
				onIsActualIntervalChange() {
					return this._onIsActualIntervalChange
				}
				setOwnerSource(e) {
					null !== this._ownerSource && (this._ownerSource.currencyChanged().unsubscribeAll(this), this._ownerSource.unitChanged().unsubscribeAll(this)), super.setOwnerSource(e), e && (this.setPriceScale(e.priceScale()), e.currencyChanged().subscribe(this, this.calcIsActualCurrency), e.unitChanged().subscribe(this, this.calcIsActualUnit), this.calcIsActualSymbol(), this._migrateZOrder())
				}
				dataAndViewsReady() {
					return this._paneViews.size > 0
				}
				pointAdded() {
					return this._pointAdded
				}
				pointChanged() {
					return this._pointChanged
				}
				pointToScreenPoint(e) {
					var t;
					const i = this._model.timeScale(),
						n = this.priceScale(),
						s = null === (t = this.ownerSource()) || void 0 === t ? void 0 : t.firstValue();
					if (!n || n.isEmpty() || i.isEmpty() || null == s) return null;
					const o = i.indexToCoordinate(e.index),
						l = n.priceToCoordinate(e.price, s);
					return new r.Point(o, l)
				}
				screenPointToPoint(e) {
					var t;
					const i = this.priceScale(),
						r = null === (t = this.ownerSource()) || void 0 === t ? void 0 : t.firstValue();
					if (null == r || !isFinite(r) || null === i) return null;
					const n = this._model.timeScale().coordinateToIndex(e.x);
					return {
						price: i.coordinateToPrice(e.y, r),
						index: n
					}
				}
				addPoint(e, t, i) {
					const r = this._preparePoint(e, t);
					return this._addPointIntenal(r, t, i)
				}
				propertiesChanged(e) {
					this.calcIsActualInterval(), this.updateAllViewsAndRedraw((0, I.dataSourceChangeEvent)(this.id())), e || this._syncLineStyleIfNeeded()
				}
				state(e) {
					var t, i;
					const r = {
						type: this.toolname,
						id: this.id(),
						state: this.properties().state(null !== (t = this._propertiesStateExclusions()) && void 0 !== t ? t : void 0),
						points: (0, m.deepCopy)(this._timePoint),
						zorder: this.zorder(),
						ownerSource: null === (i = this.ownerSource()) || void 0 === i ? void 0 : i.id()
					};
					return this.linkKey().value() && (r.linkKey = this.linkKey().value()), 0 !== this._sharingMode.value() && (r.sharingMode = this._sharingMode.value()), delete r.state.points, e && (r.indexes = this._points), this.isFixed() && (r.positionPercents = this._positionPercents || this.calcPositionPercents()), "version" in this && 1 !== this.version && (r.version = this.version), this._saveAlertIdInState() && this.hasAlert.value() && void 0 !== this._alertId && (r.alertId = this._alertId.toString()), r
				}
				updateAllViews(e) {
					this._isActualSymbol && this._isActualCurrency && this._isActualUnit && this._isActualInterval && this._properties.childs().visible.value() && (this._updateAllPaneViews(e), this._priceAxisViews.forEach((t => t.update(e))), this._timeAxisViews.forEach((t => t.update(e))))
				}
				updateAllViewsAndRedraw(e) {
					this.updateAllViews(e), this._model.updateSource(this)
				}
				properties() {
					return this._properties
				}
				restoreExternalPoints(e, t) {
					if (this._timePoint = (0, m.deepCopy)(e.points), t.indexesChanged) {
						if (this.properties().childs().interval.setValue(e.interval), !this.isActualSymbol()) return this._clearServerPoints(), void this._normalizedPointsChanged.fire();
						this.createServerPoints()
					} else {
						const t = Math.min(this._points.length, e.points.length);
						for (let i = 0; i < t; i++) this._points[i].price = e.points[i].price
					}
					this._normalizedPointsChanged.fire()
				}
				restoreExternalState(e) {
					this.properties().mergeAndFire(e)
				}
				applyTemplate(e) {
					this._onTemplateApplying.fire(e), this._applyTemplateImpl(e), this.calcIsActualSymbol(), this.updateAllViews((0, I.dataSourceChangeEvent)(this.id())), this.model().lightUpdate(), this._onTemplateApplied.fire()
				}
				template() {
					return this.properties().preferences()
				}
				isSourceHidden() {
					return !this._properties.childs().visible.value() || (0, a.hideAllDrawings)().value() && this.canBeHidden() || !this._isActualInterval || !this._isActualSymbol || !this._isActualCurrency || !this._isActualUnit
				}
				async getPropertyDefinitionsViewModel() {
					if (null === this._definitionsViewModel) {
						const e = await this._getPropertyDefinitionsViewModelClass();
						return null === e || this._isDestroyed ? null : (this._definitionsViewModel = new e(this._model.undoModel(), this), this._definitionsViewModel)
					}
					return this._definitionsViewModel
				}
				syncAlert(e) {
					this.hasAlert.value() || this.setAlert(e, {
						sync: !0,
						noChartSave: !0
					})
				}
				createServerPoints() {
					if (!this._isActualSymbol) return;
					if (!this._model.chartApi().isConnected().value()) return;
					if (this._clearServerPoints(), this._model.timeScale().isEmpty()) return;
					if (0 === this._timePoint.length && this._points.length > 0 && this.normalizePoints(), !this._readyToCreatePointset()) return;
					const e = this._pointsForPointset();
					if (0 === e.length) return;
					++B,
					this._currentPointsetAndSymbolId = {
						pointsetId: B,
						symbolId: (0, n.ensureNotNull)(this._model.mainSeries().seriesSource().symbolInstanceId())
					};
					const t = (0, x.getServerInterval)(this.properties().childs().interval.value());
					this._model.chartApi().createPointset(this._currentPointsetIdWithPrefix(), "turnaround", this._currentPointsetAndSymbolId.symbolId, t, e, this.onData.bind(this))
				}
				finish() {}
				realign() {
					var e;
					this.calcIsActualSymbol(), this.isFixed() || this.isSourceHidden() || this._model.lineBeingCreated() === this || this._model.lineBeingEdited() === this || (null === (e = this._currentPointsetAndSymbolId) || void 0 === e ? void 0 : e.symbolId) === this._model.mainSeries().seriesSource().symbolInstanceId() || this._clearServerPoints(), this.updateAllViews((0, I.dataSourceChangeEvent)(this.id()))
				}
				stop() {
					this._clearServerPoints()
				}
				restart() {
					this.isFixed() || (this._currentPointsetAndSymbolId = null, this.createServerPoints())
				}
				isStarted() {
					return null !== this._currentPointsetAndSymbolId
				}
				convertYCoordinateToPriceForMoving(e, t) {
					var i;
					const r = (0, n.ensureNotNull)(this.priceScale());
					if (r.isEmpty()) return null;
					const s = this.ownerSource(),
						o = (0, n.ensure)(null === (i = s || t) || void 0 === i ? void 0 : i.firstValue());
					return r.coordinateToPrice(e, o)
				}
				syncMultichartState(e) {
					const t = {
							points: this._timePoint,
							interval: this._model.mainSeries().interval()
						},
						i = this.linkKey().value();
					if (null !== i && this.isSynchronizable()) {
						const r = {
							model: this._model,
							linkKey: i,
							symbol: this._model.mainSeries().symbol(),
							finalState: t,
							changes: e
						};
						(0, a.finishChangingLineTool)(r)
					}
				}
				enableCurrentIntervalVisibility() {
					const e = this.properties().childs().intervalsVisibilities.state();
					void 0 !== e && ((0, L.makeIntervalsVisibilitiesVisibleAtInterval)(e, v.Interval.parse(this._model.mainSeries().interval())), this.properties().childs().intervalsVisibilities.mergeAndFire(e))
				}
				clonePositionOffset() {
					return this.isFixed() ? {
						barOffset: 0,
						xCoordOffset: 20,
						yCoordOffset: 20
					} : {
						barOffset: 0,
						xCoordOffset: 0,
						yCoordOffset: -40
					}
				}
				sharingMode() {
					return this._sharingMode
				}
				share(e) {
					this.isSynchronizable() && this._sharingMode.setValue(e)
				}
				syncLineStyleState() {
					const e = this.properties().state(this._syncStateExclusions);
					return delete e.interval, e.intervalsVisibilities = (0, L.mergeIntervalVisibilitiesDefaults)(e.intervalsVisibilities), e
				}
				_correctLastPoint(e) {
					return (0, V.clone)(e)
				}
				_pointsForPointset() {
					return this._timePoint.map((e => [e.time_t, e.offset]))
				}
				_snapPoint45Degree(e, t, i) {
					const r = this._model.timeScale(),
						s = r.indexToCoordinate(t.index),
						o = r.indexToCoordinate(e.index) - s,
						l = (0, n.ensureNotNull)(this.priceScale()),
						a = t.price,
						c = e.price,
						u = (0, n.ensureNotNull)((0, n.ensureNotNull)(this.ownerSource()).firstValue()),
						h = l.priceToCoordinate(a, u),
						d = l.priceToCoordinate(c, u) - h,
						p = Math.round(Math.atan2(o, d) / Math.PI * 4);
					if (2 === Math.abs(p)) i || (e.price = a);
					else if (0 === Math.abs(p) || 4 === Math.abs(p)) i || (e.index = t.index);
					else {
						const t = Math.sqrt(o * o + d * d),
							i = o < 0 ? -1 : 1,
							n = d < 0 ? -1 : 1;
						let a = Math.max(Math.abs(d), Math.abs(o));
						a /= a * Math.sqrt(2) / t;
						const c = Math.round(r.coordinateToIndex(s + a * i)),
							p = Math.abs(r.indexToCoordinate(c) - s),
							_ = l.coordinateToPrice(h + p * n, u);
						e.index = c, e.price = _
					}
				}
				normalizePoint(e) {
					return {
						...this._model.timeScale().normalizeBarIndex(e.index),
						price: e.price
					}
				}
				normalizePoints() {
					this._timePoint = [];
					for (let e = 0; e < this._points.length; e++)
						if (void 0 !== this._points[e].index) {
							const t = this.normalizePoint(this._points[e]);
							if (!t.time_t) {
								this._timePoint = [];
								break
							}
							this._timePoint.push(t)
						} this._normalizedPointsChanged.fire()
				}
				_setPaneViews(e, t, i) {
					this._paneViews.set(t, e), void 0 !== t && i && t.onDestroyed().subscribe(this, (() => this._destroyPanePaneViews(t))), this._model.lightUpdate()
				}
				_getPaneViews(e) {
					return this._paneViews.get(e) || null
				}
				_updateAllPaneViews(e) {
					this._paneViews.forEach((t => {
						for (const i of t) i.update(e)
					}))
				}
				_alignPointHorizontallyOrVertically(e) {
					const t = (0, n.ensureNotNull)(this.pointToScreenPoint(e)),
						i = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).logical),
						r = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).screen),
						s = Math.abs(r.x - t.x),
						o = Math.abs(r.y - t.y);
					if (s < 10 && o < 10) return e;
					return {
						index: s < o ? i.index : e.index,
						price: s < o ? e.price : i.price
					}
				}
				_alignScreenPointHorizontallyOrVertically(e) {
					const t = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).screen),
						i = Math.abs(t.x - e.x),
						s = Math.abs(t.y - e.y);
					return i < 10 && s < 10 ? e : i < s ? new r.Point(t.x, e.y) : new r.Point(e.x, t.y)
				}
				_correctPoints(e, t) {
					const i = (0, n.ensureDefined)((0, n.ensureNotNull)(this._currentMovingPoint).screen),
						r = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).screen),
						s = i.subtract(r);
					if (s.length() < 1 && !t) return !1;
					for (let t = 0; t < e.length; t++) {
						const i = e[t],
							r = (0, n.ensureNotNull)(this.pointToScreenPoint(i)).add(s),
							o = (0, n.ensureNotNull)(this.screenPointToPoint(r));
						e[t].index = o.index, e[t].price = o.price
					}
					return !0
				}
				_correctFixedPoints(e) {
					const t = (0, n.ensureDefined)((0, n.ensureNotNull)(this._currentMovingPoint).screen),
						i = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).screen),
						r = t.subtract(i);
					if (r.length() >= 1) {
						for (let t = 0; t < e.length; t++) e[t] = e[t].add(r);
						return !0
					}
					return !1
				}
				_currentPointsetIdWithPrefix() {
					return "pointset_" + (0, n.ensureNotNull)(this._currentPointsetAndSymbolId).pointsetId
				}
				_clearServerPoints() {
					null !== this._currentPointsetAndSymbolId && this._model.chartApi().isConnected().value() && this._model.chartApi().removePointset(this._currentPointsetIdWithPrefix()), this._currentPointsetAndSymbolId = null
				}
				_createPointProperty(e) {
					const t = this._pointsProperty.childs().points;
					t.addProperty("" + e, {});
					const i = t[e];
					i.addChild("price", new f(this, e)), i.addChild("bar", new g.LineDataSourcePointIndexProperty(this, e))
				}
				_createPointsProperties() {
					this._pointsProperty = new(d()), this._pointsProperty.addChild("points", new(d()));
					for (let e = 0; e < this.pointsCount(); e++) this._createPointProperty(e)
				}
				_alignPointToRangeOfActualData(e) {
					const t = (0, n.ensureNotNull)(this._model.mainSeries().bars().firstIndex()),
						i = (0, n.ensureNotNull)(this._model.mainSeries().bars().lastIndex());
					let r = Math.max(e.index, t);
					return r = Math.min(r, i), {
						...e,
						index: r
					}
				}
				_migrateSymbolProperty() {
					const e = this._properties.childs();
					if (e.symbolStateVersion.value() < 2) {
						const t = (0, n.ensureNotNull)(this.ownerSource()),
							i = (0, n.ensureNotNull)(t.symbolSource());
						if (i === this._model.mainSeries()) return void e.symbolStateVersion.setValueSilently(2);
						if (null === i.symbolInfo()) return;
						this._model.mainSeries().symbolSameAsCurrent(e.symbol.value()) && e.symbol.setValueSilently(i.symbol()), e.symbolStateVersion.setValueSilently(2)
					}
				}
				_migrateZOrder() {
					const e = this._properties.childs();
					e.zOrderVersion.value() < 2 && (this.ownerSource() === this.model().mainSeries() && this.setZorder(this.zorder() - this.model().mainSeries().obsoleteZOrder()), e.zOrderVersion.setValueSilently(2))
				}
				_preparePoint(e, t) {
					const i = e;
					return t && t.shift() && this.points().length >= 2 && this._snapTo45DegreesAvailable() && this._snapPoint45Degree(i, this.points()[this.points().length - 2]), i
				}
				_addPointIntenal(e, t, i) {
					this._points.push(e);
					const r = this._points.length === this.pointsCount();
					return r ? (this._lastPoint = null, i || (this.normalizePoints(), this.createServerPoints())) : this._lastPoint = e, this._pointAdded.fire(this._points.length - 1), r
				}
				_onSourceHiddenMayChange() {
					this._model.invalidate(b.InvalidationMask.validateAction((() => {
						this !== this._model.lineBeingCreated() && (this._isDestroyed || this.processHibernate())
					})))
				}
				_saveAlertIdInState() {
					return !0
				}
				_onPointsetUpdated(e) {
					if (0 === e.length) return;
					for (let t = 0; t < e.length; t++) {
						const i = e[t],
							r = this._timePoint[i.index],
							n = {
								index: i.value[0],
								time: new Date(1e3 * i.value[1]),
								price: r.price
							};
						this._points.length <= i.index ? (this._points.push(n), this._pointAdded.fire(this._points.length - 1)) : (this._points[i.index] = n, this._pointChanged.fire(i.index))
					}
					const t = this;
					t.checkAlert && t.checkAlert(), this.updateAllViewsAndRedraw((0, I.dataSourceChangeEvent)(this.id()))
				}
				_snapTo45DegreesAvailable() {
					return !1
				}
				_onMainSeriesSymbolResolved() {
					const e = this.ownerSource();
					null === e || this._model.mainSeries() === e.symbolSource() || this.isSourceHidden() || this.createServerPoints()
				}
				_readyToCreatePointset() {
					return this._timePoint.length > 0
				}
				_onAlertData(e) {}
				_propertiesStateExclusions() {
					return null
				}
				_syncLineStyleIfNeeded() {
					const e = this.linkKey().value();
					!this._syncLineStyleMuted && e && (0, a.changeLineStyle)({
						linkKey: e,
						state: this.syncLineStyleState(),
						model: this._model
					})
				}
				_muteSyncLineStyle() {
					this._syncLineStyleMuted = !0
				}
				_unmuteSyncLineStyleWithoutApplyingChanges() {
					this.propertiesChanged(), this._syncLineStyleMuted = !1
				}
				_applyTemplateImpl(e) {
					e.intervalsVisibilities = (0, L.mergeIntervalVisibilitiesDefaults)(e.intervalsVisibilities);
					const t = this.properties();
					t.mergePreferences(e), t.saveDefaults(), this.propertiesChanged()
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.resolve(null)
				}
				static _configureProperties(e) {
					if (E._addCollectedProperties(e), e.hasChild("symbolStateVersion") || e.addChild("symbolStateVersion", new(d())(E._initialSymbolStateVersion())), e.hasChild("zOrderVersion") || e.addChild("zOrderVersion", new(d())(E._initialZOrderVersion())), e.hasChild("visible") || e.addChild("visible", new(d())(!0)), e.hasChild("frozen") || e.addChild("frozen", new(d())(!1)), e.hasChild("symbol") || e.addChild("symbol", new(d())("")), e.hasChild("currencyId") || e.addChild("currencyId", new(d())(null)), e.hasChild("unitId") || e.addChild("unitId", new(d())(null)), e.addExclusion("symbolStateVersion"),
						e.addExclusion("zOrderVersion"), e.addExclusion("visible"), e.addExclusion("frozen"), e.addExclusion("symbol"), e.addExclusion("currencyId"), e.addExclusion("unitId"), e.hasChild("intervalsVisibilities")) {
						const t = (0, V.merge)((0, V.clone)(A.intervalsVisibilitiesDefaults), e.childs().intervalsVisibilities.state());
						e.removeProperty("intervalsVisibilities"), e.addChild("intervalsVisibilities", new D.IntervalsVisibilitiesProperty(t))
					} else e.addChild("intervalsVisibilities", new D.IntervalsVisibilitiesProperty(A.intervalsVisibilitiesDefaults));
					e.hasChild("title") || e.addChild("title", new(d())("")), e.addExclusion("symbolInfo"), e.addExclusion("points"), e.addExclusion("interval"), e.addExclusion("title"), e.hasChild("singleChartOnly") && e.removeProperty("singleChartOnly"), e.hasChild("font") && e.removeProperty("font")
				}
				static _addCollectedProperties(e) {
					e.hasChild("linewidth") && e.addChild("linesWidths", new p.LineToolWidthsProperty([(0, n.ensureDefined)(e.child("linewidth"))])), e.hasChild("linecolor") && e.addChild("linesColors", new p.LineToolColorsProperty([(0, n.ensureDefined)(e.child("linecolor"))])), e.hasChild("backgroundColor") && e.addChild("backgroundsColors", new p.LineToolColorsProperty([(0, n.ensureDefined)(e.child("backgroundColor"))])), e.hasChild("textColor") && e.addChild("textsColors", new p.LineToolColorsProperty([(0, n.ensureDefined)(e.child("textColor"))])), e.addExclusion("linesWidths"), e.addExclusion("linesColors"), e.addExclusion("backgroundsColors"), e.addExclusion("textsColors")
				}
				static _initialSymbolStateVersion() {
					return 1
				}
				static _initialZOrderVersion() {
					return 1
				}
				_destroyPanePaneViews(e) {
					const t = this._paneViews.get(e);
					if (void 0 !== t)
						for (const e of t) e.destroy && e.destroy();
					void 0 !== e && e.onDestroyed().unsubscribeAll(this), this._paneViews.delete(e)
				}
				_copyPricesWithoutNormalization() {
					const e = Math.min(this._points.length, this._timePoint.length);
					for (let t = 0; t < e; t++) this._timePoint[t].price = this._points[t].price
				}
			}
		},
		839916: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineDataSourcePointIndexProperty: () => s
			});
			var r = i(232567),
				n = i.n(r);
			class s extends(n()) {
				constructor(e, t) {
					super(), this._lineSource = e, this._pointIndex = t
				}
				value() {
					return this._lineSource.points()[this._pointIndex].index
				}
				setValue(e) {
					const t = this._lineSource.points()[this._pointIndex];
					t.index = e, this._lineSource.startChanging(this._pointIndex, t), this._setPointImpl(t), this._lineSource.model().updateSource(this._lineSource), this._listeners.fire(this);
					const i = this._lineSource.endChanging(!0, !1);
					this._lineSource.syncMultichartState(i)
				}
				_setPointImpl(e) {
					this._lineSource.setPoint(this._pointIndex, e)
				}
			}
		},
		171073: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolPriceAxisView: () => s
			});
			var r = i(588537),
				n = i(498424);
			class s extends n.PriceAxisView {
				constructor(e, t) {
					super(), this._active = !1, this._source = e, this._data = t, this._properties = e.model().properties().childs().scalesProperties
				}
				setActive(e) {
					this._active = e
				}
				_updateRendererData(e, t, i) {
					e.visible = !1;
					const r = this._source.model();
					if (!r.timeScale() || r.timeScale().isEmpty()) return;
					const n = this._source.priceScale();
					if (null === n || n.isEmpty()) return;
					if (!r.selection().isSelected(this._source) && !this._source.isForcedDrawPriceAxisLabel()) return;
					if (null === r.timeScale().visibleBarsStrictRange()) return;
					const s = this._source.priceAxisPoints(),
						o = this._data.pointIndex;
					if (s.length <= o) return;
					const l = s[o];
					if (!isFinite(l.price)) return;
					const a = this._source.ownerSource(),
						c = null !== a ? a.firstValue() : null;
					if (null === c) return;
					let u = this._data.backgroundPropertyGetter ? this._data.backgroundPropertyGetter() : null;
					null === u && (u = this._getBgColor()), i.background = u, i.borderColor = "#2E84A6", i.textColor = this.generateTextColor(u), i.coordinate = n.priceToCoordinate(l.price, c), e.text = this._formatPrice(l.price, c), e.visible = !0
				}
				_getBgColor() {
					return this._active ? this._properties.childs().axisLineToolLabelBackgroundColorActive.value() : this._properties.childs().axisLineToolLabelBackgroundColorCommon.value()
				}
				_formatPrice(e, t) {
					return (0, r.ensureNotNull)(this._source.priceScale()).formatPrice(e, t)
				}
			}
		},
		652778: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineDataSourceTimeAxisView: () => n
			});
			var r = i(642053);
			class n extends r.TimeAxisView {
				constructor(e, t) {
					super(e.model()), this._active = !1, this._source = e, this._pointIndex = t, this._properties = e.model().properties().childs().scalesProperties
				}
				setActive(e) {
					this._active = e
				}
				_getBgColor() {
					return this._active ? this._properties.childs().axisLineToolLabelBackgroundColorActive.value() : this._properties.childs().axisLineToolLabelBackgroundColorCommon.value()
				}
				_getIndex() {
					if (!this._model.selection().isSelected(this._source)) return null;
					const e = this._source.timeAxisPoints();
					return e.length <= this._pointIndex ? null : e[this._pointIndex].index
				}
				_isVisible() {
					return !0
				}
			}
		},
		724145: (e, t, i) => {
			"use strict";
			var r = i(86441).Point,
				n = i(171073).LineToolPriceAxisView,
				s = i(308170),
				o = i(273044).Interval,
				l = i(911905).getLogger("Chart.LineDataSource"),
				a = i(611688),
				c = i(552279).reloginOrGoPro,
				u = i(217540).canPlaceAlertOnResolution,
				h = i(844853).showGoProAlertsOnSecondsDialog,
				d = i(920358).getPriceAlertsDispatcher,
				p = i(920358).getPriceAlertsDispatcherIfExists,
				_ = i(985481).lineToolsLocalizedNames,
				P = a.enabled("datasource_copypaste"),
				f = i(29494).LineDataSourceBase;
			class g extends f {
				visibilityKeyByInterval(e) {
					var t, i = o.parse(e);
					return g.IntervalsVisibilities.forEach((function(e) {
						e.kind === i.kind() && e.from <= i.multiplier() && e.to >= i.multiplier() && (t = e.key)
					})), t
				}
				priceScale() {
					return this._ownerSource ? this._ownerSource.m_priceScale : null
				}
				symbol() {
					return this._properties.symbol.value()
				}
				isSavedInStudyTemplates() {
					return !1
				}
				fixedPoints() {
					var e = [];
					if (this._positionPercents && !this.priceScale().isEmpty())
						for (var t = 0; t < this._positionPercents.length; t++) {
							var i = this._positionPercents[t],
								n = this._model.timeScale().width() * i.x,
								s = this.priceScale().height() * i.y;
							e.push(new r(n, s))
						} else
							for (t = 0; t < this._fixedPoints.length; t++) e.push(this._fixedPoints[t].clone());
					return this._lastPoint && e.push(this._lastPoint.clone()), this._currentMovingPoint && this._startMovingPoint && this._correctFixedPoints(e), e
				}
				addFixedPoint(e) {
					this._fixedPoints.push(e);
					var t = this._fixedPoints.length === this.pointsCount();
					return t && this.calcPositionPercents(), t
				}
				calcPositionPercents() {
					if (!this.priceScale() || this.priceScale().isEmpty()) return [];
					this._positionPercents = [];
					for (var e = 0; e < this._fixedPoints.length; e++) {
						var t = this._fixedPoints[e],
							i = t.x / this._model.timeScale().width(),
							r = t.y / this.priceScale().height();
						this._positionPercents.push({
							x: i,
							y: r
						})
					}
					return this._positionPercents
				}
				calcMiddlePoint(e, t) {
					return new r((e.x + t.x) / 2, (e.y + t.y) / 2)
				}
				getPointByPosition(e, t, i, r) {
					return [t, i, r][e]
				}
				restoreFixedPoints() {
					this._fixedPoints = this.fixedPoints()
				}
				isSynchronizable() {
					return this.priceScale() === this._model.mainSeries().priceScale()
				}
				priceAxisViews(e, t) {
					if (t !== this.priceScale() || this.isSourceHidden()) return null;
					if (this._model.lineBeingEdited() === this) {
						var i = this._model.linePointBeingEdited();
						if (null !== i && i < this._priceAxisViews.length) {
							var r = this._priceAxisViews.slice(),
								n = r[i];
							return r.splice(i, 1), r.push(n), r
						}
						return this._priceAxisViews
					}
					return this._priceAxisViews
				}
				timeAxisViews() {
					if (this.isSourceHidden()) return null;
					if (this._model.lineBeingEdited() === this) {
						var e = this._model.linePointBeingEdited();
						if (null !== e && e < this._timeAxisViews.length) {
							var t = this._timeAxisViews.slice(),
								i = t[e];
							return t.splice(e, 1), t.push(i), t
						}
						return this._timeAxisViews
					}
					return this._timeAxisViews
				}
				setLastFixedPoint(e) {
					this._lastFixedPoint = e, this.updateAllViews()
				}
				title() {
					return this.translatedType()
				}
				translatedType() {
					return void 0 !== _[this.toolname] ? _[this.toolname] : "Line Tool"
				}
				name() {
					return "Line Tool"
				}
				isBeingEdited() {
					return this === this._model.lineBeingEdited() || this === this._model.sourceBeingMoved
				}
				isFixed() {
					return !1
				}
				isLocked() {
					return this.properties().frozen && this.properties().frozen.value()
				}
				tags() {
					return [this.toolname]
				}
				alertId() {
					return this._alertId
				}
				setAlert(e, t) {
					var i = this;
					t = t || {};
					if (!this.canHasAlert()) return Promise.reject("Line data source can not has alert");

					function r() {
						!t.noChartSave && window.saver && window.saver.saveChartSilently(null, (function(e) {
							e && 413 === e.status || c({
								feature: "savedChartsForAlertLimit"
							})
						}), {
							noDefaultOnFail: !0
						})
					}
					return i._alertId = parseInt(e), i.hasAlert.setValue(!0), i.getAlert().then((function(e) {
						var t = i._model.selection().isSelected(i);
						return e ? (i._processAlertHandlers("unsubscribe"), i._processAlertHandlers("subscribe"), e.set("selected", t), setTimeout(r, 0), i._onAlertData(e), e) : (l.logError("Failed to get alert, alert will not be saved with drawing in chart"), Promise.reject("got_no_alert"))
					})).then((() => {
						var i = this.linkKey().value();
						null === i || t.sync || s.changeLineStyle({
							linkKey: i,
							model: this._model,
							state: {},
							alertId: e
						})
					})).catch((function(t) {
						i._processAlertHandlers("unsubscribe"), "not_exists" === t ? d().then((function(t) {
							t.removeAlertFromAllChartsSilently(i.id(), e)
						})) : l.logError("Getting alert or Saving chart failed: " + t)
					}))
				}
				_processAlertHandlers(e) {
					var t, i, r = this;
					if ("unsubscribe" !== (e = "subscribe" === e ? "subscribe" : "unsubscribe") || r._alertCallbacks) {
						i = "subscribe" === e ? "on" : "off", t = r.properties();
						var n = r._alertCallbacks || {
							remove: r.removeAlert.bind(r),
							selected: function(e, t) {
								t ? r._model.selectionMacro((function(e) {
									e.addSourceToSelection(r)
								})) : r._model.selectionMacro((function(e) {
									e.removeSourceFromSelection(r)
								}))
							},
							synchronizeSilently: function(e) {
								r.synchronizeAlert(!1)
							}
						};
						r._alertCallbacks || (r._alertCallbacks = n), r.getAlert().then((function(s) {
							s && (s[i]("destroy", n.remove), s[i]("change:selected", n.selected), t.extendLeft && t.extendLeft[e](r, n.synchronizeSilently), t.extendRight && t.extendRight[e](r, n.synchronizeSilently))
						}))
					}
				}
				editAlert(e) {
					var t = this;
					t.hasAlert.value() && d().then((function(i) {
						i.openEditDialog(t._alertId, {
							actionSource: e,
							error: function(e) {
								"not_exists" === e && t.removeAlert()
							}
						})
					}))
				}
				getAlert() {
					var e = this;
					return new Promise((function(t, i) {
						d().then((function(r) {
							r.requestAlert(e._alertId, {
								success: t,
								error: i
							})
						}))
					}))
				}
				getAlertSync() {
					if (!this._alertId) return null;
					var e = p();
					return e && e.getAlertSync(this._alertId) || null
				}
				synchronizeAlert(e) {
					this.hasAlert.value() && setTimeout((() => {
						this._isDestroyed || this._synchronizeAlert(e)
					}), 0)
				}
				_synchronizeAlert(e) {
					var t = this,
						i = t._getUndoHistory();
					if (!t._undoCheckpointAlert && !t._alertUndoMode) {
						var r = i.undoStack().pop();
						t._undoCheckpointAlert = i.createUndoCheckpoint(), r && i.undoStack().push(r)
					}

					function n() {
						t._alertUndoMode = !0, i.undoToCheckpoint(t._undoCheckpointAlert), setTimeout((function() {
							t._alertUndoMode = !1, t._localAndServerAlertsMismatch = !1
						}), 0)
					}

					function s(e) {
						"not_exists" !== e && (l.logError("Getting alert failed: " + e), n())
					}
					u(t.stateForAlert().interval) ? t.getAlert().then((function(i) {
						i ? (! function(e) {
							var i = e.get("description") !== e.defaultDescription(),
								r = e.get("extra"),
								n = r.alertSeries(),
								s = t._model.mainSeries().stateForAlert();
							"MainSeries" === n.type && s.actualSymbol === n.actualSymbol && r.alertSeries(s);
							r.mainSeries(s), e.set("symbolInternal", s.symbolString), e.set("resolution", t.stateForAlert().interval), r.drawing(t), i || e.setDefaultDescription();
							t._localAndServerAlertsMismatch = !0
						}(i), e && (! function(e) {
							d().then((function(i) {
								i.restartAlert(e, {
									success: function() {
										t._localAndServerAlertsMismatch = !1
									},
									error: s,
									complete: function() {
										delete t._undoCheckpointAlert
									},
									actionSource: "drawing_sync"
								})
							}))
						}(i), t._onAlertData(i))) : l.logError("Failed to get alert, drawing and alert are not synchronized")
					})).catch(s) : t._alertUndoMode || (h(), n(), delete t._undoCheckpointAlert)
				}
				_getUndoHistory() {
					return this._model._undoModel.undoHistory()
				}
				stateForAlert() {
					if (!this.canHasAlert()) return null;
					var e = this.state();
					e.id = this.idForAlert(), e.uniqueId = this.idForAlert(), e.title = this.title(), e.interval = this._model.mainSeries().interval();
					var t = this._getAlertPlots();
					return t && (e.plots = t), e
				}
				_getAlertPlots() {
					return null
				}
				_linePointsToAlertPlot(e, t, i, r) {
					if (2 !== e.length) return l.logError("[Drawing Alert] Wrong points"), null;
					var n = this._model.timeScale();
					return !n || n.isEmpty() ? null : {
						type: "LinePlot",
						title: t || this.title(),
						timestamp: n.indexToTimePoint(0),
						offset1: e[0].index,
						offset2: e[1].index,
						price1: e[0].price,
						price2: e[1].price,
						extendBackward: i || !1,
						extendForward: r || !1
					}
				}
				getAlertIsActive() {
					if (!this._alertId) return !1;
					var e = this.getAlertSync(this._alertId);
					return Boolean(e && e.get("active"))
				}
				geometry() {
					var e = this;
					return this.points().map((function(t) {
						return function(t) {
							var i = t.x / e._model.timeScale().width(),
								n = t.y / e.priceScale().height();
							return new r(i, n)
						}(e.pointToScreenPoint(t))
					}))
				}
				hasEditableCoordinates() {
					return !0
				}
				getSourceIcon() {
					return {
						type: "loadSvg",
						svgId: "linetool." + this.toolname
					}
				}
				getOrderTemplate() {
					return null
				}
				copiable() {
					return P
				}
				cloneable() {
					return null !== this._ownerSource && null !== this._ownerSource.firstValue()
				}
				movable() {
					return !0
				}
			}
			g.prototype.version = 1, t.LineDataSource = g
		},
		424146: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				LineToolMultiplePropertyBaseImpl: () => a,
				LineToolCollectedProperty: () => c,
				LineToolWidthsProperty: () => u,
				LineToolColorsProperty: () => h,
				MultipleLineWidthsProperty: () => p,
				MultipleLineColorsProperty: () => _
			});
			var r = i(911905),
				n = i(97639),
				s = i.n(n);
			const o = (0, r.getLogger)("Chart.LineToolCollectedProperty");
			class l {
				applyValue(e, t) {
					e.setValue(t)
				}
			}
			class a {
				constructor(e, t) {
					this._onChange = new(s()), this._properties = e, e.forEach((e => e.subscribe(this, (() => {
						this._onChange.fire(this)
					})))), this._showIfProperty = t
				}
				visible() {
					var e;
					return !this._showIfProperty || (null === (e = this._showIfProperty) || void 0 === e ? void 0 : e.value())
				}
				value() {
					if (0 === this._properties.length) return o.logError("Incorrect call, should not request value of 0 properties"), "mixed";
					const e = this._properties[0].value();
					return 1 === this._properties.length || this._properties.every((t => t.value() === e)) ? e : "mixed"
				}
				state() {}
				merge() {}
				destroy() {
					this._properties.forEach((e => e.unsubscribeAll(this)))
				}
				subscribe(e, t) {
					this._onChange.subscribe(e, t)
				}
				unsubscribe(e, t) {
					this._onChange.unsubscribe(e, t)
				}
				unsubscribeAll(e) {
					this._onChange.unsubscribeAll(e)
				}
				storeStateIfUndefined() {
					return !0
				}
			}
			class c extends a {
				setValue(e, t, i) {
					if ("mixed" === e) return;
					const r = null != i ? i : new l;
					this._properties.forEach((t => r.applyValue(t, e)))
				}
			}
			class u extends c {}
			class h extends c {
				firstColor() {
					return this._properties[0].value()
				}
			}
			class d extends a {
				setValue(e, t, i) {
					if ("mixed" === e) return;
					const r = null != i ? i : new l;
					this._properties.forEach((t => t.setValue(e, void 0, r)))
				}
			}
			class p extends d {}
			class _ extends d {}
		},
		103573: (e, t, i) => {
			"use strict";
			t.LineToolFibRetracement = i(945914).LineToolFibRetracement, t.LineToolFibChannel = i(28901).LineToolFibChannel, t.LineToolFibSpeedResistanceArcs = i(3971).LineToolFibSpeedResistanceArcs, t.LineToolProjection = i(789789).LineToolProjection, t.LineToolTrendBasedFibExtension = i(451848).LineToolTrendBasedFibExtension, t.LineToolElliott = i(561708).LineToolElliott, t.LineToolFibCircles = i(951651).LineToolFibCircles, t.LineToolVertLine = i(308374).LineToolVertLine, t.LineToolCrossLine = i(941527).LineToolCrossLine, t.LineToolBarsPattern = i(183819).LineToolBarsPattern, t.LineToolTrendBasedFibTime = i(821564).LineToolTrendBasedFibTime, t.LineToolFibTimeZone = i(358500).LineToolFibTimeZone, t.LineToolCircleLines = i(847373).LineToolCircleLines, t.LineToolDateRange = i(148317).LineToolDateRange, t.LineToolPriceRange = i(268368).LineToolPriceRange, t.LineToolDateAndPriceRange = i(943975).LineToolDateAndPriceRange, t.LineToolParallelChannel = i(101421).LineToolParallelChannel, t.LineToolTrendAngle = i(409304).LineToolTrendAngle, t.LineToolTrendLine = i(439195).LineToolTrendLine, t.LineToolInfoLine = i(687910).LineToolInfoLine, t.LineToolArrowMark = i(650581).LineToolArrowMark, t.LineToolImage = i(17588).LineToolImage,
				t.LineToolPitchfan = i(359488).LineToolPitchfan, t.LineToolGannSquare = i(990345).LineToolGannSquare, t.LineToolFibSpeedResistanceFan = i(758237).LineToolFibSpeedResistanceFan, t.LineToolGannComplex = i(848807).LineToolGannComplex, t.LineToolGannFixed = i(233091).LineToolGannFixed, t.LineToolGannFan = i(273949).LineToolGannFan, t.LineToolFibWedge = i(924615).LineToolFibWedge, t.LineToolPitchfork = i(119310).LineToolPitchfork, t.LineToolDisjointAngle = i(897364).LineToolDisjointChannel, t.LineToolFlatBottom = i(505047).LineToolFlatBottom, t.LineToolIcon = i(171215).LineToolIcon, t.LineToolRotatedRectangle = i(791983).LineToolRotatedRectangle, t.LineToolFibSpiral = i(739242).LineToolFibSpiral, t.LineToolHeadAndShoulders = i(550014).LineToolHeadAndShoulders, t.LineToolTriangle = i(953077).LineToolTriangle, t.LineToolTrianglePattern = i(679963).LineToolTrianglePattern, t.LineTool5PointsPattern = i(821595).LineTool5PointsPattern, t.LineToolThreeDrivers = i(452078).LineToolThreeDrivers, t.LineToolABCD = i(496807).LineToolABCD, t.LineToolPolyline = i(647244).LineToolPolyline, t.LineToolPath = i(937575).LineToolPath, t.LineToolPrediction = i(445178).LineToolPrediction, t.LineToolPriceLabel = i(483258).LineToolPriceLabel, t.LineToolArrowMarker = i(665851).LineToolArrowMarker, t.LineToolNote = i(925143).LineToolNote, t.LineToolNoteAbsolute = i(925143).LineToolNoteAbsolute, t.LineToolSignpost = i(706029).LineToolSignpost, t.LineToolBrush = i(697537).LineToolBrush, t.LineToolArc = i(389886).LineToolArc, t.LineToolCallout = i(386779).LineToolCallout, t.LineToolBalloon = i(97807).LineToolBalloon, t.LineToolText = i(491458).LineToolText, t.LineToolHorzLine = i(73224).LineToolHorzLine, t.LineToolHorzRay = i(499924).LineToolHorzRay, t.LineToolRectangle = i(438642).LineToolRectangle, t.LineToolCircle = i(597314).LineToolCircle, t.LineToolEllipse = i(146913).LineToolEllipse, t.LineToolTimeCycles = i(124214).LineToolTimeCycles, t.LineToolSineLine = i(210646).LineToolSineLine, t.LineToolGhostFeed = i(318440).LineToolGhostFeed, t.LineToolBezierQuadro = i(781888).LineToolBezierQuadro, t.LineToolBezierCubic = i(595426).LineToolBezierCubic, t.LineToolArrow = i(60046).LineToolArrow, t.LineToolRay = i(294678).LineToolRay, t.LineToolExtended = i(372353).LineToolExtended, t.LineToolSchiffPitchfork = i(173758).LineToolSchiffPitchfork, t.LineToolSchiffPitchfork2 = i(792621).LineToolSchiffPitchfork2, t.LineToolInsidePitchfork = i(344900).LineToolInsidePitchfork, t.LineToolTextAbsolute = i(491458).LineToolTextAbsolute, t.LineToolArrowMarkLeft = i(650581).LineToolArrowMarkLeft, t.LineToolArrowMarkRight = i(650581).LineToolArrowMarkRight, t.LineToolArrowMarkUp = i(650581).LineToolArrowMarkUp, t.LineToolArrowMarkDown = i(650581).LineToolArrowMarkDown, t.LineToolFlagMark = i(320874).LineToolFlagMark, t.LineToolCypherPattern = i(109562).LineToolCypherPattern, t.LineToolElliottImpulse = i(561708).LineToolElliottImpulse, t.LineToolElliottTriangle = i(561708).LineToolElliottTriangle, t.LineToolElliottTripleCombo = i(561708).LineToolElliottTripleCombo, t.LineToolElliottCorrection = i(561708).LineToolElliottCorrection, t.LineToolElliottDoubleCombo = i(561708).LineToolElliottDoubleCombo,
				t.LineToolRiskRewardLong = i(706711).LineToolRiskRewardLong, t.LineToolRiskRewardShort = i(706711).LineToolRiskRewardShort, t.LineToolPosition = i(731113).LineToolPosition, t.LineToolOrder = i(139344).LineToolOrder, t.LineToolHighlighter = i(133967).LineToolHighlighter, t.LineToolPriceNote = i(142754).LineToolPriceNote, t.LineToolTweet = i(104129).LineToolTweet, t.LineToolIdea = i(49318).LineToolIdea
		},
		674993: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolWithRelativePriceCoordinate: () => l
			});
			var r = i(588537),
				n = i(724145),
				s = i(499452),
				o = i(308170);
			class l extends n.LineDataSource {
				constructor() {
					super(...arguments), this._startMovingAnchorY = NaN
				}
				priceSource() {
					return this.ownerSource()
				}
				addPoint(e, t, i) {
					return super.addPoint(this._updatePositionAndCorrectPoint(e), t, i)
				}
				setPoint(e, t, i) {
					super.setPoint(e, this._updatePositionAndCorrectPoint(t, !this.isPhantom() && !this._allowChangeAnchorHorizontally()), i), this._syncPosition()
				}
				setPointAndChangeIndex(e, t, i) {
					super.setPoint(e, this._updatePositionAndCorrectPoint(t, !1), i), this._syncPosition()
				}
				startMoving(e, t, i, n) {
					n || (this._startMovingAnchorY = (0, r.ensureNotNull)(this._anchorYCoordinate())), super.startMoving(e, t, i)
				}
				move(e, t, i, n) {
					var s;
					const o = (0, r.ensureDefined)((0, r.ensureNotNull)(this.startMovingPoint()).logical),
						l = (0, r.ensureDefined)(e.logical);
					if (!n && 0 === t) {
						const e = this._points[0],
							t = l.index - o.index,
							i = (0, r.ensureNotNull)(this.priceScale()),
							n = (0, r.ensure)(null === (s = this.ownerSource()) || void 0 === s ? void 0 : s.firstValue()),
							a = i.priceToCoordinate(l.price, n) - i.priceToCoordinate(o.price, n),
							c = this._startMovingAnchorY + a,
							u = i.coordinateToPrice(c, n);
						this._updatePositionAndCorrectPoint({
							index: e.index + t,
							price: u
						})
					}
					super.move(e, t, i), n || this._syncPosition()
				}
				_allowChangeAnchorHorizontally() {
					return !1
				}
				_updatePositionAndCorrectPoint(e, t) {
					t && (e.index = this._points[0].index);
					const i = this.priceSource();
					if (null === i) return e;
					const r = i.priceScale(),
						n = i.firstValue();
					if (null === r || r.isEmpty() || null === n) return e;
					const o = r.height();
					let l = o / 2,
						a = e.price >= r.coordinateToPrice(l, n) ? 1 : -1;
					const c = this._model.mainSeries();
					if (i === c) {
						const t = c.data().search(this._baseSeriesIndexForPoint(e));
						if (null !== t) {
							const i = (0, s.seriesPrice)(c, t, -1),
								o = (0, s.seriesPrice)(c, t, 1);
							a = e.price >= i ? 1 : -1, l = r.priceToCoordinate(1 === a ? o : i, n), e.price = 1 === a ? Math.max(o, e.price) : e.price
						}
					}
					const u = 1 === (-1 === a !== r.isInverted() ? -1 : 1) ? l : o - l,
						h = r.priceToCoordinate(e.price, n),
						d = Math.min(o, Math.abs(h - l)),
						p = Math.max(0, Math.min(100, 100 * d / u)) * a;
					return this.properties().childs().position.setValue(p), e
				}
				_baseSeriesIndexForPoint(e) {
					return e.index
				}
				_syncPosition() {
					const e = this.linkKey().value();
					if (null !== e) {
						const t = {
							position: this.properties().childs().position.value()
						};
						(0, o.changeLineStyle)({
							linkKey: e,
							state: t,
							model: this._model
						})
					}
				}
				_anchorYCoordinate() {
					const e = this.priceSource();
					if (null === e) return null;
					const t = e.priceScale(),
						i = e.firstValue();
					if (null === t || t.isEmpty() || null === i) return null;
					const r = this._model.mainSeries(),
						n = this.customEvent();
					if (null === n) return null;
					let o = null;
					if (e === r && (o = (0, s.seriesBasePosition)(r, n)), null === o && (o = (0, s.noDataBasePosition)(n, t, i)), null === o) return null;
					const l = n.position(),
						a = t.priceToCoordinate(o.price, i);
					return (0, s.positionToCoordinate)(l, t.height(), a, (0, s.positionVisualDirection)(l, t.isInverted()))
				}
			}
		},
		985481: (e, t, i) => {
			"use strict";
			i.d(t, {
				lineToolsLocalizedNames: () => s
			});
			var r = i(125226),
				n = i(575932);
			const s = {
				LineTool5PointsPattern: (0, n.t)("XABCD Pattern"),
				LineToolABCD: (0, n.t)("ABCD Pattern"),
				LineToolArc: (0, n.t)("Arc"),
				LineToolArrow: (0, n.t)("Arrow"),
				LineToolArrowMarkDown: (0, n.t)("Arrow Mark Down"),
				LineToolArrowMarkLeft: (0, n.t)("Arrow Mark Left"),
				LineToolArrowMarkRight: (0, n.t)("Arrow Mark Right"),
				LineToolArrowMarkUp: (0, n.t)("Arrow Mark Up"),
				LineToolBalloon: (0, n.t)("Balloon"),
				LineToolBarsPattern: (0, n.t)("Bars Pattern"),
				LineToolBezierCubic: (0, n.t)("Double Curve"),
				LineToolBezierQuadro: (0, n.t)("Curve"),
				LineToolBrush: (0, n.t)("Brush"),
				LineToolCallout: (0, n.t)("Callout"),
				LineToolCircleLines: (0, n.t)("Cyclic Lines"),
				LineToolCypherPattern: (0, n.t)("Cypher Pattern"),
				LineToolDateAndPriceRange: (0, n.t)("Date and Price Range"),
				LineToolDateRange: (0, n.t)("Date Range"),
				LineToolDisjointAngle: (0, n.t)("Disjoint Channel"),
				LineToolElliottCorrection: (0, n.t)("Elliott Correction Wave (ABC)"),
				LineToolElliottDoubleCombo: (0, n.t)("Elliott Double Combo Wave (WXY)"),
				LineToolElliottImpulse: (0, n.t)("Elliott Impulse Wave (12345)"),
				LineToolElliottTriangle: (0, n.t)("Elliott Triangle Wave (ABCDE)"),
				LineToolElliottTripleCombo: (0, n.t)("Elliott Triple Combo Wave (WXYXZ)"),
				LineToolEllipse: (0, n.t)("Ellipse"),
				LineToolExtended: (0, n.t)("Extended Line"),
				LineToolFibChannel: (0, n.t)("Fib Channel"),
				LineToolFibCircles: (0, n.t)("Fib Circles"),
				LineToolFibRetracement: (0, n.t)("Fib Retracement"),
				LineToolFibSpeedResistanceArcs: (0, n.t)("Fib Speed Resistance Arcs"),
				LineToolFibSpeedResistanceFan: (0, n.t)("Fib Speed Resistance Fan"),
				LineToolFibSpiral: (0, n.t)("Fib Spiral"),
				LineToolFibTimeZone: (0, n.t)("Fib Time Zone"),
				LineToolFibWedge: (0, n.t)("Fib Wedge"),
				LineToolFlagMark: (0, n.t)("Flag Mark"),
				LineToolImage: (0, n.t)("Image"),
				LineToolFlatBottom: (0, n.t)("Flat Top/Bottom"),
				LineToolAnchoredVWAP: (0, n.t)("Anchored VWAP"),
				LineToolGannComplex: (0, n.t)("Gann Square"),
				LineToolGannFixed: (0, n.t)("Gann Square Fixed"),
				LineToolGannFan: (0, n.t)("Gann Fan"),
				LineToolGannSquare: (0, n.t)("Gann Box"),
				LineToolHeadAndShoulders: (0, n.t)("Head and Shoulders"),
				LineToolHorzLine: (0, n.t)("Horizontal Line"),
				LineToolHorzRay: (0, n.t)("Horizontal Ray"),
				LineToolIcon: (0, n.t)("Icon"),
				LineToolInsidePitchfork: (0, n.t)("Inside Pitchfork"),
				LineToolNote: (0, n.t)("Note"),
				LineToolNoteAbsolute: (0, n.t)("Anchored Note"),
				LineToolSignpost: (0, n.t)("Signpost"),
				LineToolParallelChannel: (0, n.t)("Parallel Channel"),
				LineToolPitchfan: (0, n.t)("Pitchfan"),
				LineToolPitchfork: (0, n.t)("Pitchfork"),
				LineToolPolyline: (0, n.t)("Polyline"),
				LineToolPath: (0, n.t)("Path"),
				LineToolPrediction: (0, n.t)("Forecast"),
				LineToolPriceLabel: (0, n.t)("Price Label"),
				LineToolArrowMarker: (0, n.t)("Arrow Marker"),
				LineToolPriceRange: (0, n.t)("Price Range"),
				LineToolProjection: (0, n.t)("Projection"),
				LineToolRay: (0, n.t)("Ray"),
				LineToolRectangle: (0, n.t)("Rectangle"),
				LineToolCircle: (0, n.t)("Circle"),
				LineToolRegressionTrend: (0,
					n.t)("Regression Trend"),
				LineToolRiskRewardLong: (0, n.t)("Long Position"),
				LineToolRiskRewardShort: (0, n.t)("Short Position"),
				LineToolFixedRangeVolumeProfile: (0, n.t)("Fixed Range Volume Profile"),
				LineToolRotatedRectangle: (0, n.t)("Rotated Rectangle"),
				LineToolSchiffPitchfork: (0, n.t)("Modified Schiff Pitchfork"),
				LineToolSchiffPitchfork2: (0, n.t)("Schiff Pitchfork"),
				LineToolSineLine: (0, n.t)("Sine Line"),
				LineToolText: (0, n.t)("Text", {
					context: "tool"
				}),
				LineToolTextAbsolute: (0, n.t)("Anchored Text"),
				LineToolThreeDrivers: (0, n.t)("Three Drives Pattern"),
				LineToolTimeCycles: (0, n.t)("Time Cycles"),
				LineToolTrendAngle: (0, n.t)("Trend Angle"),
				LineToolTrendBasedFibExtension: (0, n.t)("Trend-Based Fib Extension"),
				LineToolTrendBasedFibTime: (0, n.t)("Trend-Based Fib Time"),
				LineToolTrendLine: (0, n.t)("Trend Line"),
				LineToolInfoLine: (0, n.t)("Info Line"),
				LineToolTriangle: (0, n.t)("Triangle"),
				LineToolTrianglePattern: (0, n.t)("Triangle Pattern"),
				LineToolVertLine: (0, n.t)("Vertical Line"),
				LineToolCrossLine: (0, n.t)("Cross Line"),
				LineToolHighlighter: (0, n.t)("Highlighter"),
				LineToolPriceNote: (0, n.t)("Price Note"),
				LineToolVbPFixed: (0, n.t)("Volume Profile Fixed Range")
			};
			(0, r.isFeatureEnabled)("remove-line-tool-ghost-feed") || (s.LineToolGhostFeed = (0, n.t)("Ghost Feed")), s.LineToolTweet = (0, n.t)("Tweet"), s.LineToolIdea = (0, n.t)("Idea")
		},
		925143: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(724145).LineDataSource,
				s = i(232567),
				o = i(346090).DefaultProperty;
			class l extends n {
				constructor(e, t, r, n) {
					super(e, t || l.createProperties(), r, n), this.version = l.version, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 991453)).then((({
						NotePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Note"
				}
				getTooltipWidth() {
					return l.TOOLTIP_WIDTH
				}
				getTooltipPadding() {
					return l.TOOLTIP_PADDING
				}
				getTooltipLineSpacing() {
					return l.TOOLTIP_LINESPACING
				}
				template() {
					var e = n.prototype.template.call(this);
					return e.text = this.properties().childs().text.value(), e
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				static createProperties(e) {
					void 0 !== e && void 0 !== e.markerColor && void 0 === e.borderColor && (e.borderColor = e.markerColor);
					var t = new o("linetoolnote", e);
					return l._configureProperties(t), t
				}
				state(e) {
					var t = n.prototype.state.call(this, e);
					return e && (t.state.fixedSize = !1), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 121332))).NoteDefinitionsViewModel
				}
				static _configureProperties(e) {
					n._configureProperties(e), e.hasChild("text") || e.addChild("text", new s(r("Text"))), e.addExclusion("text")
				}
			}
			l.TOOLTIP_WIDTH = 300, l.TOOLTIP_PADDING = 10, l.TOOLTIP_LINESPACING = 5, l.version = 1;
			class a extends l {
				constructor(e, t) {
					super(e, t || a.createProperties())
				}
				title() {
					return r("Anchored Note")
				}
				name() {
					return "Anchored Note"
				}
				isFixed() {
					return !0
				}
				hasEditableCoordinates() {
					return !1
				}
				static createProperties(e) {
					var t = new o("linetoolnoteabsolute", e);
					return a._configureProperties(t), t
				}
				static _configureProperties(e) {
					l._configureProperties(e)
				}
			}
			t.LineToolNote = l, t.LineToolNoteAbsolute = a
		},
		139344: (e, t, i) => {
			"use strict";
			var r = i(157759).LineToolTrading,
				n = i(171073).LineToolPriceAxisView,
				s = i(556616),
				o = i(724145).LineDataSource,
				l = i(346090).DefaultProperty;
			const a = i(611688);
			var c = i(534953).sortSourcesPreOrdered.LineToolOrder;

			function u(e) {
				return null == e ? e = "" : e += "", e
			}
			class h {
				constructor(e) {
					this._line = e, this._data = {
						bodyText: "order",
						quantityText: "0"
					}, this._editable = !0, this._cancellable = !0, this._mode = "", this._direction = "buy", this._active = !0
				}
				setMode(e) {
					return this._mode = e, this._line.updateAllViewsAndRedraw(), this
				}
				setDirection(e) {
					return this._direction = e, this._line.updateAllViewsAndRedraw(), this
				}
				setActive(e) {
					return this._active = e, this._line.updateAllViewsAndRedraw(), this
				}
				setEditable(e) {
					return this._editable = e, this._line.updateAllViewsAndRedraw(), this
				}
				getEditable() {
					return this._editable
				}
				setCancellable(e) {
					return this._cancellable = e, this._line.updateAllViewsAndRedraw(), this
				}
				getCancellable() {
					return this._cancellable
				}
				hasMoveCallback() {
					return this.isFunction(this._onMoveCallback)
				}
				hasModifyCallback() {
					return this.isFunction(this._onModifyCallback)
				}
				getPrice() {
					return this._line.points().length > 0 ? this._line.points()[0].price : this._line._timePoint.length > 0 ? this._line._timePoint[0].price : void 0
				}
				setPrice(e) {
					if (this._line.points().length > 0) {
						var t = this._line.points()[0];
						t.price = e, this._line._points[0] = t, this._line.normalizePoints(), this._line.updateAllViewsAndRedraw()
					}
					return this._line._timePoint.length > 0 && (this._line._timePoint[0].price = e), this
				}
				getText() {
					return this._data.bodyText
				}
				setText(e) {
					return this._data.bodyText = e || "", this._line.updateAllViewsAndRedraw(), this
				}
				setTooltip(e) {
					return this._line.properties().tooltip.setValue(u(e)), this
				}
				getTooltip() {
					return this._line.properties().tooltip.value()
				}
				setModifyTooltip(e) {
					return this._line.properties().modifyTooltip.setValue(u(e)), this
				}
				getModifyTooltip() {
					return this._line.properties().modifyTooltip.value()
				}
				setCancelTooltip(e) {
					return this._line.properties().cancelTooltip.setValue(u(e)), this
				}
				getCancelTooltip() {
					return this._line.properties().cancelTooltip.value()
				}
				getQuantity() {
					return this._data.quantityText
				}
				setQuantity(e) {
					return this._data.quantityText = e || "", this._line.updateAllViewsAndRedraw(), this
				}
				getExtendLeft() {
					var e = this._line.properties().extendLeft.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.extendLeft.value() : e
				}
				setExtendLeft(e) {
					return this._line.properties().extendLeft.setValue(e), this
				}
				getLineLength() {
					var e = this._line.properties().lineLength.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.lineLength.value() : e
				}
				setLineLength(e) {
					return this._line.properties().lineLength.setValue(Math.max(0, Math.min(e, 100))), this
				}
				getLineColor() {
					var e = this._line.properties();
					return "buy" === this._direction ? this._active ? e.lineActiveBuyColor.value() : e.lineInactiveBuyColor.value() : this._active ? e.lineActiveSellColor.value() : e.lineInactiveSellColor.value()
				}
				setLineColor(e) {
					return "buy" === this._direction ? this._active ? this.setLineActiveBuyColor(e) : this.setLineInactiveBuyColor(e) : this._active ? this.setLineActiveSellColor(e) : this.setLineInactiveSellColor(e), this
				}
				setLineActiveBuyColor(e) {
					return this._line.properties().lineActiveBuyColor.setValue(e), this
				}
				setLineInactiveBuyColor(e) {
					return this._line.properties().lineInactiveBuyColor.setValue(e), this
				}
				setLineActiveSellColor(e) {
					return this._line.properties().lineActiveSellColor.setValue(e), this
				}
				setLineInactiveSellColor(e) {
					return this._line.properties().lineInactiveSellColor.setValue(e), this
				}
				getLineStyle() {
					var e = this._line.properties().lineStyle.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.lineStyle.value() : e
				}
				setLineStyle(e) {
					return this._line.properties().lineStyle.setValue(e), this
				}
				getLineWidth() {
					var e = this._line.properties().lineWidth.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.lineWidth.value() : e
				}
				setLineWidth(e) {
					return this._line.properties().lineWidth.setValue(e), this
				}
				getBodyBorderColor() {
					var e = this._line.properties();
					return "buy" === this._direction ? this._active ? e.bodyBorderActiveBuyColor.value() : e.bodyBorderInactiveBuyColor.value() : this._active ? e.bodyBorderActiveSellColor.value() : e.bodyBorderInactiveSellColor.value()
				}
				setBodyBorderColor(e) {
					return "buy" === this._direction ? this._active ? this.setBodyBorderActiveBuyColor(e) : this.setBodyBorderInactiveBuyColor(e) : this._active ? this.setBodyBorderActiveSellColor(e) : this.setBodyBorderInactiveSellColor(e), this
				}
				setBodyBorderActiveBuyColor(e) {
					return this._line.properties().bodyBorderActiveBuyColor.setValue(e), this
				}
				setBodyBorderInactiveBuyColor(e) {
					return this._line.properties().bodyBorderInactiveBuyColor.setValue(e), this
				}
				setBodyBorderActiveSellColor(e) {
					return this._line.properties().bodyBorderActiveSellColor.setValue(e), this
				}
				setBodyBorderInactiveSellColor(e) {
					return this._line.properties().bodyBorderInactiveSellColor.setValue(e), this
				}
				getBodyBackgroundColor() {
					return s.getColorFromProperties(this._line.properties().bodyBackgroundColor, this._line.properties().bodyBackgroundTransparency)
				}
				setBodyBackgroundColor(e) {
					return s.setColorToProperties(e, this._line.properties().bodyBackgroundColor, this._line.properties().bodyBackgroundTransparency), this
				}
				getBodyTextColor() {
					var e = this._line.properties();
					return "limit" === this._mode ? this._active ? e.bodyTextActiveLimitColor.value() : e.bodyTextInactiveLimitColor.value() : "stop" === this._mode ? this._active ? e.bodyTextActiveStopColor.value() : e.bodyTextInactiveStopColor.value() : "buy" === this._direction ? this._active ? e.bodyTextActiveBuyColor.value() : e.bodyTextInactiveBuyColor.value() : this._active ? e.bodyTextActiveSellColor.value() : e.bodyTextInactiveSellColor.value()
				}
				setBodyTextColor(e) {
					return "limit" === this._mode ? this._active ? this.setBodyTextActiveLimitColor(e) : this.setBodyTextInactiveLimitColor(e) : "stop" === this._mode ? this._active ? this.setBodyTextActiveStopColor(e) : this.setBodyTextInactiveStopColor(e) : "buy" === this._direction ? this._active ? this.setBodyTextActiveBuyColor(e) : this.setBodyTextInactiveBuyColor(e) : this._active ? this.setBodyTextActiveSellColor(e) : this.setBodyTextInactiveSellColor(e), this
				}
				setBodyTextInactiveLimitColor(e) {
					return this._line.properties().bodyTextInactiveLimitColor.setValue(e), this
				}
				setBodyTextActiveLimitColor(e) {
					return this._line.properties().bodyTextActiveLimitColor.setValue(e), this
				}
				setBodyTextInactiveStopColor(e) {
					return this._line.properties().bodyTextInactiveStopColor.setValue(e), this
				}
				setBodyTextActiveStopColor(e) {
					return this._line.properties().bodyTextActiveStopColor.setValue(e), this
				}
				setBodyTextInactiveBuyColor(e) {
					return this._line.properties().bodyTextInactiveBuyColor.setValue(e), this
				}
				setBodyTextActiveBuyColor(e) {
					return this._line.properties().bodyTextActiveBuyColor.setValue(e), this
				}
				setBodyTextInactiveSellColor(e) {
					return this._line.properties().bodyTextInactiveSellColor.setValue(e), this
				}
				setBodyTextActiveSellColor(e) {
					return this._line.properties().bodyTextActiveSellColor.setValue(e), this
				}
				getBodyFont() {
					return s.getFontFromProperties(this._line.properties().bodyFontFamily, this._line.properties().bodyFontSize, this._line.properties().bodyFontBold, this._line.properties().bodyFontItalic)
				}
				setBodyFont(e) {
					return s.setFontToProperties(e, this._line.properties().bodyFontFamily, this._line.properties().bodyFontSize, this._line.properties().bodyFontBold, this._line.properties().bodyFontItalic), this
				}
				getQuantityBorderColor() {
					var e = this._line.properties();
					return "buy" === this._direction ? this._active ? e.quantityBorderActiveBuyColor.value() : e.quantityBorderInactiveBuyColor.value() : this._active ? e.quantityBorderActiveSellColor.value() : e.quantityBorderInactiveSellColor.value()
				}
				setQuantityBorderColor(e) {
					return "buy" === this._direction ? this._active ? this.setQuantityBorderActiveBuyColor(e) : this.setQuantityBorderInactiveBuyColor(e) : this._active ? this.setQuantityBorderActiveSellColor(e) : this.setQuantityBorderInactiveSellColor(e), this
				}
				setQuantityBorderActiveBuyColor(e) {
					return this._line.properties().quantityBorderActiveBuyColor.setValue(e), this
				}
				setQuantityBorderInactiveBuyColor(e) {
					return this._line.properties().quantityBorderInactiveBuyColor.setValue(e), this
				}
				setQuantityBorderActiveSellColor(e) {
					return this._line.properties().quantityBorderActiveSellColor.setValue(e), this
				}
				setQuantityBorderInactiveSellColor(e) {
					return this._line.properties().quantityBorderInactiveSellColor.setValue(e), this
				}
				getQuantityBackgroundColor() {
					var e = this._line.properties();
					return "buy" === this._direction ? this._active ? e.quantityBackgroundActiveBuyColor.value() : e.quantityBackgroundInactiveBuyColor.value() : this._active ? e.quantityBackgroundActiveSellColor.value() : e.quantityBackgroundInactiveSellColor.value()
				}
				setQuantityBackgroundColor(e) {
					return "buy" === this._direction ? this._active ? this.setQuantityBackgroundActiveBuyColor(e) : this.setQuantityBackgroundInactiveBuyColor(e) : this._active ? this.setQuantityBackgroundActiveSellColor(e) : this.setQuantityBackgroundInactiveSellColor(e), this
				}
				setQuantityBackgroundActiveBuyColor(e) {
					return this._line.properties().quantityBackgroundActiveBuyColor.setValue(e), this
				}
				setQuantityBackgroundInactiveBuyColor(e) {
					return this._line.properties().quantityBackgroundInactiveBuyColor.setValue(e), this
				}
				setQuantityBackgroundActiveSellColor(e) {
					return this._line.properties().quantityBackgroundActiveSellColor.setValue(e), this
				}
				setQuantityBackgroundInactiveSellColor(e) {
					return this._line.properties().quantityBackgroundInactiveSellColor.setValue(e), this
				}
				getQuantityTextColor() {
					return s.getColorFromProperties(this._line.properties().quantityTextColor, this._line.properties().quantityTextTransparency)
				}
				setQuantityTextColor(e) {
					return s.setColorToProperties(e, this._line.properties().quantityTextColor, this._line.properties().quantityTextTransparency), this
				}
				getQuantityFont() {
					return s.getFontFromProperties(this._line.properties().quantityFontFamily, this._line.properties().quantityFontSize, this._line.properties().quantityFontBold, this._line.properties().quantityFontItalic)
				}
				setQuantityFont(e) {
					return s.setFontToProperties(e, this._line.properties().quantityFontFamily, this._line.properties().quantityFontSize, this._line.properties().quantityFontBold, this._line.properties().quantityFontItalic), this
				}
				getCancelButtonBorderColor() {
					var e = this._line.properties();
					return "buy" === this._direction ? this._active ? e.cancelButtonBorderActiveBuyColor.value() : e.cancelButtonBorderInactiveBuyColor.value() : this._active ? e.cancelButtonBorderActiveSellColor.value() : e.cancelButtonBorderInactiveSellColor.value()
				}
				setCancelButtonBorderColor(e) {
					return "buy" === this._direction ? this._active ? this.setCancelButtonBorderActiveBuyColor(e) : this.setCancelButtonBorderInactiveBuyColor(e) : this._active ? this.setCancelButtonBorderActiveSellColor(e) : this.setCancelButtonBorderInactiveSellColor(e), this
				}
				setCancelButtonBorderActiveBuyColor(e) {
					return this._line.properties().cancelButtonBorderActiveBuyColor.setValue(e), this
				}
				setCancelButtonBorderInactiveBuyColor(e) {
					return this._line.properties().cancelButtonBorderInactiveBuyColor.setValue(e), this
				}
				setCancelButtonBorderActiveSellColor(e) {
					return this._line.properties().cancelButtonBorderActiveSellColor.setValue(e), this
				}
				setCancelButtonBorderInactiveSellColor(e) {
					return this._line.properties().cancelButtonBorderInactiveSellColor.setValue(e), this
				}
				getCancelButtonBackgroundColor() {
					return s.getColorFromProperties(this._line.properties().cancelButtonBackgroundColor, this._line.properties().cancelButtonBackgroundTransparency)
				}
				setCancelButtonBackgroundColor(e) {
					return s.setColorToProperties(e, this._line.properties().cancelButtonBackgroundColor, this._line.properties().cancelButtonBackgroundTransparency), this
				}
				getCancelButtonIconColor() {
					var e = this._line.properties();
					return "buy" === this._direction ? this._active ? e.cancelButtonIconActiveBuyColor.value() : e.cancelButtonIconInactiveBuyColor.value() : this._active ? e.cancelButtonIconActiveSellColor.value() : e.cancelButtonIconInactiveSellColor.value()
				}
				setCancelButtonIconColor(e) {
					return "buy" === this._direction ? this._active ? this.setCancelButtonIconActiveBuyColor(e) : this.setCancelButtonIconInactiveBuyColor(e) : this._active ? this.setCancelButtonIconActiveSellColor(e) : this.setCancelButtonIconInactiveSellColor(e), this
				}
				setCancelButtonIconActiveBuyColor(e) {
					return this._line.properties().cancelButtonIconActiveBuyColor.setValue(e), this
				}
				setCancelButtonIconInactiveBuyColor(e) {
					return this._line.properties().cancelButtonIconInactiveBuyColor.setValue(e), this
				}
				setCancelButtonIconActiveSellColor(e) {
					return this._line.properties().cancelButtonIconActiveSellColor.setValue(e), this
				}
				setCancelButtonIconInactiveSellColor(e) {
					return this._line.properties().cancelButtonIconInactiveSellColor.setValue(e), this
				}
				block() {
					this._blocked = !0, this._line.updateAllViewsAndRedraw()
				}
				unblock() {
					this._blocked = !1, this._line.updateAllViewsAndRedraw()
				}
				getBlocked() {
					return this._blocked
				}
				isFunction(e) {
					return "function" == typeof e
				}
				onCancel(e, t) {
					return t ? this.isFunction(t) && (this._onCancelData = e, this._onCancelCallback = t) : this.isFunction(e) && (this._onCancelCallback = e), this
				}
				callOnCancel() {
					this.isFunction(this._onCancelCallback) && this._onCancelCallback.call(this, this._onCancelData)
				}
				isOnCancelCallbackPresent() {
					return this.isFunction(this._onCancelCallback)
				}
				onModify(e, t) {
					return t ? this.isFunction(t) && (this._onModifyData = e, this._onModifyCallback = t) : this.isFunction(e) && (this._onModifyCallback = e), this
				}
				callOnModify() {
					this.isFunction(this._onModifyCallback) && this._onModifyCallback.call(this, this._onModifyData)
				}
				onMove(e, t) {
					return t ? this.isFunction(t) && (this._onMoveData = e, this._onMoveCallback = t) : this.isFunction(e) && (this._onMoveCallback = e), this
				}
				callOnMove() {
					this.isFunction(this._onMoveCallback) && this._onMoveCallback.call(this, this._onMoveData)
				}
				onContextMenu(e, t) {
					return t ? this.isFunction(t) && (this._onContextMenuData = e, this._onContextMenuCallback = t) : this.isFunction(e) && (this._onContextMenuCallback = e), this
				}
				shouldShowContextMenu() {
					return this.isFunction(this._onContextMenuCallback)
				}
				callOnContextMenu() {
					if (this.isFunction(this._onContextMenuCallback)) return this._onContextMenuCallback.call(this, this._onContextMenuData)
				}
				remove() {
					this._line._model.removeSource(this._line), delete this._line
				}
			}
			class d extends r {
				constructor(e, t) {
					super(e, t || d.createProperties()), this._adapter = new h(this), this.setSelectionEnabled(!0), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 828912)).then((({
						OrderPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				zorder() {
					return c
				}
				isSpeciallyZOrderedSource() {
					return !0
				}
				setPoint(e, t, i) {
					this._points[e] = t, this.normalizePoints()
				}
				addPoint(e, t) {
					return this._points.push(e), this._lastPoint = null, this.normalizePoints(), this.createServerPoints(), !0
				}
				name() {
					return "Order"
				}
				endMoving(e) {
					var t = this._startMovingPoint && this._currentMovingPoint && this._startMovingPoint.logical.price !== this._currentMovingPoint.logical.price;
					super.endMoving(), !e && t && this._adapter.callOnMove()
				}
				createPriceAxisView(e) {
					var t = {
						pointIndex: e,
						backgroundPropertyGetter: () => this._adapter.getLineColor()
					};
					return this._priceAxisView = new n(this, t), this._priceAxisView
				}
				paneViews() {
					return TradingView.printing && !a.enabled("snapshot_trading_drawings") ? null : this._model.properties().tradingProperties.showOrders.value() ? o.prototype.paneViews.call(this) : null
				}
				priceAxisViews(e, t) {
					return TradingView.printing && !a.enabled("snapshot_trading_drawings") ? null : this._model.properties().tradingProperties.showOrders.value() ? o.prototype.priceAxisViews.call(this, e, t) : null
				}
				adapter() {
					return this._adapter
				}
				hasContextMenu() {
					return this._adapter.shouldShowContextMenu()
				}
				contextMenuItems() {
					return this._adapter.callOnContextMenu()
				}
				movable() {
					return Boolean(this._adapter._onMoveCallback)
				}
				static createProperties(e) {
					var t = new l("linetoolorder", e, !1, !1);
					return d._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolOrder = d
		},
		101421: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolParallelChannel: () => c
			});
			var r = i(588537),
				n = i(86441),
				s = i(346090),
				o = i(308170),
				l = i(724145),
				a = i(270617);
			class c extends l.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), this._priceAxisViews.push(this.createPriceAxisView(3)), this._coordOffsetWhileMovingOrChanging = null, this._pendingPriceOffset = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 9779)).then((({
						ParallelChannelPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				paneViews(e) {
					return null !== this._pendingPriceOffset && this._applyPendingPriceOffset(), super.paneViews(e)
				}
				setLastPoint(e, t) {
					t && t.shift() && 2 === this.points().length && this._snapPoint45Degree(e, this.points()[0]);
					const i = (0, a.clone)(e);
					return super.setLastPoint(e), i
				}
				startMoving(e, t, i, r) {
					super.startMoving(e, t, i, r), this._coordOffsetWhileMovingOrChanging = this._findPixelsHeight()
				}
				endMoving(e, t, i) {
					return this._coordOffsetWhileMovingOrChanging = null, super.endMoving(e, t, i)
				}
				startChanging(e, t) {
					super.startChanging(e, t), this._coordOffsetWhileMovingOrChanging = this._findPixelsHeight()
				}
				endChanging(e, t, i) {
					return this._coordOffsetWhileMovingOrChanging = null, super.endChanging(e, t)
				}
				restoreExternalPoints(e, t, i) {
					const r = i ? e.points : this._timePoint.map(((t, i) => ({
						price: t.price,
						offset: e.points[i].offset,
						time_t: e.points[i].time_t
					})));
					if (super.restoreExternalPoints({
							...e,
							points: r
						}, t), t.pricesChanged && this._points.length === r.length)
						for (let e = 0; e < r.length; e++) this._points[e].price = r[e].price
				}
				setPoint(e, t, i, n) {
					var s;
					if (this._points[0].index === this._points[1].index && e >= 4) return;
					this._snapPointBeforeChange(e, t, i);
					const l = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						a = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
						c = (0, r.ensureNotNull)(this.pointToScreenPoint(t)),
						u = (0, r.ensureNotNull)(this._coordOffsetWhileMovingOrChanging),
						h = (0, r.ensureNotNull)(this.priceScale()),
						d = (0,
							r.ensure)(null === (s = this.ownerSource()) || void 0 === s ? void 0 : s.firstValue());
					switch (e) {
						case 0:
							super.setPoint(e, t, i), this._points[2].price = h.coordinateToPrice(c.y + u, d);
							break;
						case 1:
							super.setPoint(e, t, i);
							break;
						case 2:
							super.setPoint(e, t, i), this._points[0].price = h.coordinateToPrice(c.y - u, d), this._points[0].index = t.index;
							break;
						case 3:
							this._points[1].price = h.coordinateToPrice(c.y - u, d), this._points[1].index = t.index;
							break;
						case 4: {
							const e = a.subtract(l),
								t = (c.x - l.x) / e.x,
								i = l.addScaled(e, t),
								r = c.y - i.y;
							this._points[2].price = h.coordinateToPrice(l.y + r, d);
							break
						}
						case 5: {
							const e = a.subtract(l),
								t = (c.x - l.x) / e.x,
								i = l.addScaled(e, t),
								r = c.y - i.y;
							this._points[0].price = h.coordinateToPrice(l.y + r, d), this._points[1].price = h.coordinateToPrice(a.y + r, d);
							break
						}
					}
					const p = this.linkKey().value();
					if (p && !n && e < 4) {
						const e = this._points.map((e => e.price));
						(0, o.changeLineStyle)({
							model: this._model,
							linkKey: p,
							state: {
								prices: e
							}
						})
					}
				}
				state(e) {
					const t = l.LineDataSource.prototype.state.call(this, e);
					return this._pendingPriceOffset && (t.priceOffset = this._pendingPriceOffset), t
				}
				restoreExternalState(e) {
					const t = {
						...e
					};
					if (t.prices && this.isActualSymbol())
						for (let e = 0; e < t.prices.length; e++) this._points[e].price = t.prices[e], this._timePoint[e].price = t.prices[e];
					delete t.prices, super.restoreExternalState(t)
				}
				restoreData(e) {
					void 0 !== e.priceOffset && (this._pendingPriceOffset = e.priceOffset)
				}
				getPoint(e) {
					if (e < 3) return l.LineDataSource.prototype.getPoint.call(this, e);
					const t = this.pointToScreenPoint(this._points[0]),
						i = this.pointToScreenPoint(this._points[1]),
						r = this.pointToScreenPoint(this._points[2]);
					if (!t || !i || !r) return null;
					switch (e) {
						case 3: {
							const e = r.y - t.y,
								s = i.add(new n.Point(0, e));
							return this.screenPointToPoint(s)
						}
						case 4: {
							const e = r.y - t.y,
								s = i.add(new n.Point(0, e)),
								o = r.add(s).scaled(.5);
							return this.screenPointToPoint(o)
						}
						case 5: {
							const e = t.add(i).scaled(.5);
							return this.screenPointToPoint(e)
						}
					}
					return null
				}
				alignCrossHairToAnchor(e) {
					return e <= 3
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Parallel Channel"
				}
				hasEditableCoordinates() {
					return !1
				}
				addPoint(e, t, i) {
					const n = this.points().length;
					return t && t.shift() && 2 === n && this._snapPoint45Degree(e, this.points()[0]), 2 === this._points.length && (e = this._convertLastPointTo3rdPoint((0, r.ensureNotNull)(this._lastPoint))), l.LineDataSource.prototype.addPoint.call(this, e, t)
				}
				timeAxisPoints() {
					return this._axisPoints()
				}
				priceAxisPoints() {
					return this._axisPoints()
				}
				canHasAlert() {
					return !0
				}
				static createProperties(e) {
					const t = new s.DefaultProperty("linetoolparallelchannel", e);
					return c._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 845109))).ParallelChannelDefinitionsViewModel
				}
				_getAlertPlots() {
					const e = this.getPoint(3);
					if (!e) return [];
					const t = [this._points[0], this._points[1], this._points[2], e],
						i = (e, t) => e.index <= t.index ? [e, t] : [t, e],
						r = i(t[0], t[1]),
						n = i(t[2], t[3]);
					let s, o, l, a;
					t[2].price < t[0].price ? (o = n, s = r) : (o = r, s = n);
					const c = this.properties().childs().extendLeft.value(),
						u = this.properties().childs().extendRight.value();
					return t[0].index <= t[1].index ? (l = c, a = u) : (l = u, a = c),
						[this._linePointsToAlertPlot(s, "Upper", l, a), this._linePointsToAlertPlot(o, "Lower", l, a)]
				}
				_correctLastPoint(e) {
					if (this._points.length < 2 || this._points[1].index === this._points[0].index) return e;
					const t = (0, r.ensureNotNull)(this.pointToScreenPoint(e)),
						i = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
						s = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						o = i.subtract(s),
						l = (t.x - s.x) / o.x,
						a = s.addScaled(o, l),
						c = t.y - a.y,
						u = s.add(new n.Point(0, c));
					return (0, r.ensureNotNull)(this.screenPointToPoint(u))
				}
				static _configureProperties(e) {
					l.LineDataSource._configureProperties(e)
				}
				_axisPoints() {
					const e = this.points(),
						t = this._points[0] ? this.pointToScreenPoint(this._points[0]) : null,
						i = this._points[1] ? this.pointToScreenPoint(this._points[1]) : null,
						s = this._points[2] ? this.pointToScreenPoint(this._points[2]) : null;
					if (t && i && s) {
						const o = i.y - t.y,
							l = s.add(new n.Point(0, o));
						e.push((0, r.ensureNotNull)(this.screenPointToPoint(l)))
					}
					return e
				}
				_convertLastPointTo3rdPoint(e) {
					const t = (0, r.ensureNotNull)(this.pointToScreenPoint(e)),
						i = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
						s = (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						o = i.subtract(s),
						l = (t.x - s.x) / o.x,
						a = s.addScaled(o, l),
						c = t.y - a.y,
						u = s.add(new n.Point(0, c));
					return (0, r.ensureNotNull)(this.screenPointToPoint(u))
				}
				_findPixelsHeight() {
					const e = this.pointToScreenPoint(this._points[2]),
						t = this.pointToScreenPoint(this._points[0]);
					return e && t ? e.y - t.y : null
				}
				_applyPendingPriceOffset() {
					const e = this._pendingPriceOffset;
					if (null === e || this._points.length < 3) return;
					const t = this.priceScale(),
						i = (0, r.ensureNotNull)(this.ownerSource()).firstValue();
					if (!t || t.isEmpty() || null === i) return;
					const n = e + this._points[0].price,
						s = e + this._points[1].price,
						o = .5 * (n + s) - e,
						l = .5 * (n + s),
						a = t.priceToCoordinate(o, i),
						c = t.priceToCoordinate(l, i) - a,
						u = t.priceToCoordinate(this._points[0].price, i) + c,
						h = t.coordinateToPrice(u, i);
					this._points[2].price = h, this._timePoint[2].price = h, this._points[2].index = this._points[0].index, this._timePoint[2].time_t = this._timePoint[0].time_t, this._timePoint[2].offset = this._timePoint[0].offset, this._pendingPriceOffset = null
				}
				_snapPointBeforeChange(e, t, i) {
					if (i && i.shift()) switch (e) {
						case 0:
						case 1:
							this._snapPoint45Degree(t, this._points[1 - e]);
							break;
						case 2:
						case 3:
							const i = (0, r.ensureNotNull)(this.getPoint(5 - e));
							this._snapPoint45Degree(t, i)
					}
				}
			}
		},
		937575: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolPath: () => c
			});
			var r = i(588537),
				n = i(86441),
				s = i(346090),
				o = i(601132),
				l = i(724145),
				a = i(424146);
			class c extends l.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || c.createProperties();
					super(e, s, r, n), this._finished = !1, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 943093)).then((t => {
						this._setPaneViews([new t.PathPaneView(this, e)])
					}))
				}
				pointsCount() {
					return -1
				}
				name() {
					return "Path"
				}
				hasEditableCoordinates() {
					return !1
				}
				finish() {
					this._finished = !0, this._lastPoint = null, this.normalizePoints(), this.createServerPoints()
				}
				addPoint(e, t, i) {
					var s;
					if (this._finished) return !0;
					const l = (0, r.ensureNotNull)(this.priceScale()),
						a = this._model.timeScale().indexToCoordinate(e.index),
						c = e.price,
						u = (0,
							r.ensure)(null === (s = this.ownerSource()) || void 0 === s ? void 0 : s.firstValue()),
						h = l.priceToCoordinate(c, u);
					if (this._points.length > 0) {
						const e = this._points[this._points.length - 1],
							i = this._model.timeScale().indexToCoordinate(e.index),
							r = e.price,
							s = l.priceToCoordinate(r, u),
							c = new n.Point(a, h).subtract(new n.Point(i, s)).length();
						if (!(null == t ? void 0 : t.isApiEvent()) && c < (0, o.interactionTolerance)().minDistanceBetweenPoints) return this._lastPoint = null, this.normalizePoints(), this.createServerPoints(), !0
					}
					return super.addPoint(e, t, i)
				}
				static createProperties(e) {
					const t = new s.DefaultProperty("linetoolpath", e);
					return c._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 505782)).then((e => e.PathDefinitionsViewModel))
				}
				static _configureProperties(e) {
					l.LineDataSource._configureProperties(e), e.addChild("linesWidths", new a.LineToolWidthsProperty([(0, r.ensureDefined)(e.child("lineWidth"))])), e.addChild("linesColors", new a.LineToolColorsProperty([e.childs().lineColor]))
				}
			}
		},
		359488: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(277036).TranslatedString,
				s = i(724145).LineDataSource,
				o = i(755827).LevelsProperty,
				l = i(424146),
				a = l.LineToolWidthsProperty,
				c = l.LineToolColorsProperty,
				u = new n("erase level line", r("erase level line"));
			class h extends s {
				constructor(e, t, r, n) {
					super(e, t || h.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 995491)).then((({
						PitchfanLinePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return h.LevelsCount
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Pitchfan"
				}
				processErase(e, t) {
					var i = "level" + t,
						r = this.properties()[i].visible;
					e.setProperty(r, !1, u)
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 799025))).PitchBaseDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new o("linetoolpitchfan", e, !1, {
						range: [0, 8]
					});
					return h._configureProperties(t), t
				}
				static _configureProperties(e) {
					s._configureProperties(e);
					for (var t = [e.child("median").child("linewidth")], i = [e.child("median").child("color")], r = 0; r <= h.LevelsCount; r++) t.push(e.child("level" + r).child("linewidth")), i.push(e.child("level" + r).child("color"));
					e.addChild("linesColors", new c(i)), e.addChild("linesWidths", new a(t))
				}
			}
			h.LevelsCount = 8, t.LineToolPitchfan = h
		},
		119310: (e, t, i) => {
			"use strict";
			var r = i(575932).t,
				n = i(277036).TranslatedString,
				s = i(724145).LineDataSource,
				o = i(755827).LevelsProperty,
				l = i(829770).Action,
				a = i(363585).ACTION_ID,
				c = i(278142).LineToolPitchforkStyle,
				u = null,
				h = i(424146),
				d = h.LineToolWidthsProperty,
				p = h.LineToolColorsProperty,
				_ = new n("erase level line", r("erase level line")),
				P = new n("change {title} style", r("change {title} style"));
			class f extends s {
				constructor(e, t, i, r) {
					super(e, t || f.createProperties(), i, r), this._properties.style.listeners().subscribe(this, f.prototype._recreatePaneView), this._recreatePaneView()
				}
				levelsCount() {
					return f.LevelsCount
				}
				additionalActions(e) {
					for (var t = [], i = [{
							title: r("Original"),
							actionId: a.ChartLineToolPitchforkChangeTypeToOriginal
						}, {
							title: r("Modified Schiff"),
							actionId: a.ChartLineToolPitchforkChangeTypeToModifiedSchiff
						}, {
							title: r("Inside"),
							actionId: a.ChartLineToolPitchforkChangeTypeToInside
						}, {
							title: r("Schiff"),
							actionId: a.ChartLineToolPitchforkChangeTypeToSchiff
						}], s = 0; s < 4; s++) {
						var o = new l({
							actionId: i[s].actionId,
							checked: this.properties().style.value() === s,
							checkable: !0,
							label: i[s].title,
							payload: {
								target: this,
								value: s
							},
							onExecute: function(t) {
								var i = t.getPayload(),
									r = i.target;
								e.setProperty(r.properties().style, i.value, P.format({
									title: new n(r.name(), r.title())
								})), r.updateAllViews(), r._model.updateSource(r)
							}
						});
						t.push(o)
					}
					return [t[0], t[3], t[1], t[2]]
				}
				_recreatePaneView() {
					if (null !== u) {
						var e = [];
						this._properties.style.value() === c.Original ? e = [new u.PitchforkLinePaneView(this, this._model)] : this._properties.style.value() === c.Schiff ? e = [new u.SchiffPitchforkLinePaneView(this, this._model)] : this._properties.style.value() === c.Schiff2 ? e = [new u.SchiffPitchfork2LinePaneView(this, this._model)] : this._properties.style.value() === c.Inside && (e = [new u.InsidePitchforkLinePaneView(this, this._model)]), this._setPaneViews(e)
					} else Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 823440)).then((e => {
						null === u && (u = e), this._recreatePaneView()
					}))
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Pitchfork"
				}
				processErase(e, t) {
					var i = "level" + t,
						r = this.properties()[i].visible;
					e.setProperty(r, !1, _)
				}
				static createProperties(e) {
					var t = new o("linetoolpitchfork", e, !1, {
						range: [0, 8]
					});
					return f._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 948195))).PitchForkDefinitionsViewModel
				}
				static _configureProperties(e) {
					s._configureProperties(e);
					for (var t = [e.child("median").child("linewidth")], i = [e.child("median").child("color")], r = 0; r <= f.LevelsCount; r++) t.push(e.child("level" + r).child("linewidth")), i.push(e.child("level" + r).child("color"));
					e.addChild("linesColors", new p(i)), e.addChild("linesWidths", new d(t))
				}
			}
			f.LevelsCount = 8, t.LineToolPitchfork = f
		},
		647244: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolPolyline: () => a
			});
			var r = i(588537),
				n = i(86441),
				s = i(346090),
				o = i(601132),
				l = i(724145);
			class a extends l.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || a.createProperties();
					super(e, s, r, n), this._finished = !1, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 862955)).then((t => {
						this._setPaneViews([new t.PolylinePaneView(this, e)])
					}))
				}
				pointsCount() {
					return -1
				}
				name() {
					return "Polyline"
				}
				hasEditableCoordinates() {
					return !1
				}
				finish() {
					this._finished = !0, this._lastPoint = null, this.normalizePoints(), this.createServerPoints()
				}
				addPoint(e, t, i) {
					var s;
					if (this._finished) return !0;
					const l = (0, r.ensureNotNull)(this.priceScale()),
						a = this._model.timeScale().indexToCoordinate(e.index),
						c = e.price,
						u = (0, r.ensure)(null === (s = this.ownerSource()) || void 0 === s ? void 0 : s.firstValue()),
						h = l.priceToCoordinate(c, u),
						d = (0, o.interactionTolerance)().minDistanceBetweenPoints;
					if (this._points.length > 0) {
						const e = this._points[this._points.length - 1],
							i = this._model.timeScale().indexToCoordinate(e.index),
							r = e.price,
							s = l.priceToCoordinate(r, u),
							o = new n.Point(a, h).subtract(new n.Point(i, s)).length();
						if (!(null == t ? void 0 : t.isApiEvent()) && o < d) return this._lastPoint = null, this.normalizePoints(), this.createServerPoints(), !0;
						const c = this._points[0],
							p = this._model.timeScale().indexToCoordinate(c.index),
							_ = l.priceToCoordinate(c.price, u),
							P = new n.Point(a, h).subtract(new n.Point(p, _)).length();
						if (!(null == t ? void 0 : t.isApiEvent()) && P < d) return this.properties().childs().filled.setValue(!0), this._lastPoint = null, this.normalizePoints(), this.createServerPoints(), !0
					}
					return super.addPoint(e, t, i)
				}
				setPoint(e, t, i) {
					var s;
					super.setPoint(e, t, i);
					const l = this.priceScale();
					if (!(this._model.timeScale().isEmpty() || null === l || l.isEmpty() || e !== this._points.length - 1 && 0 !== e)) {
						const i = (0, r.ensure)(null === (s = this.ownerSource()) || void 0 === s ? void 0 : s.firstValue()),
							a = this._model.timeScale().indexToCoordinate(t.index),
							c = l.priceToCoordinate(t.price, i),
							u = e === this._points.length - 1 ? this._points[0] : this._points[this._points.length - 1],
							h = this._model.timeScale().indexToCoordinate(u.index),
							d = l.priceToCoordinate(u.price, i);
						new n.Point(a, c).subtract(new n.Point(h, d)).length() < (0, o.interactionTolerance)().minDistanceBetweenPoints && this.properties().childs().filled.setValue(!0)
					}
				}
				static createProperties(e) {
					const t = new s.DefaultProperty("linetoolpolyline", e);
					return a._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 538645)).then((e => e.PolylinesDefinitionsViewModel))
				}
				static _configureProperties(e) {
					l.LineDataSource._configureProperties(e), e.addExclusion("filled")
				}
			}
		},
		342651: (e, t, i) => {
			"use strict";
			i.d(t, {
				PositionAveragePriceAxisView: () => n
			});
			var r = i(171073);
			class n extends r.LineToolPriceAxisView {
				_formatPrice(e, t) {
					return this._source.formatter().format(e)
				}
			}
		},
		731113: (e, t, i) => {
			"use strict";
			var r = i(157759).LineToolTrading,
				n = i(724145).LineDataSource,
				s = i(342651).PositionAveragePriceAxisView,
				o = i(556616),
				l = i(346090).DefaultProperty,
				a = i(689765).PriceFormatter;
			const c = i(611688);
			var u = i(534953).sortSourcesPreOrdered.LineToolPosition;

			function h(e) {
				return null == e ? e = "" : e += "", e
			}
			class d {
				constructor(e) {
					this._line = e, this._data = {
						bodyText: "position",
						quantityText: "0"
					}, this._closeEnabled = !0, this._direction = "buy", this._profitState = "neutral"
				}
				setDirection(e) {
					return this._direction = e, this._line.updateAllViewsAndRedraw(), this
				}
				setProfitState(e) {
					return this._profitState = e, this._line.updateAllViewsAndRedraw(), this
				}
				getPrice() {
					return this._line.points().length > 0 ? this._line.points()[0].price : this._line._timePoint.length > 0 ? this._line._timePoint[0].price : void 0
				}
				setPrice(e) {
					if (this._line.points().length > 0) {
						var t = this._line.points()[0];
						t.price = e, this._line._points[0] = t, this._line.normalizePoints(), this._line.updateAllViewsAndRedraw()
					}
					return this._line._timePoint.length > 0 && (this._line._timePoint[0].price = e), this
				}
				getText() {
					return this._data.bodyText
				}
				setText(e) {
					return this._data.bodyText = e || "", this._line.updateAllViewsAndRedraw(), this
				}
				setTooltip(e) {
					return this._line.properties().tooltip.setValue(h(e)), this
				}
				getTooltip() {
					return this._line.properties().tooltip.value()
				}
				setProtectTooltip(e) {
					return this._line.properties().protectTooltip.setValue(h(e)), this
				}
				getProtectTooltip() {
					return this._line.properties().protectTooltip.value()
				}
				setCloseTooltip(e) {
					return this._line.properties().closeTooltip.setValue(h(e)), this
				}
				getCloseTooltip() {
					return this._line.properties().closeTooltip.value()
				}
				setReverseTooltip(e) {
					return this._line.properties().reverseTooltip.setValue(h(e)), this
				}
				getReverseTooltip() {
					return this._line.properties().reverseTooltip.value()
				}
				getQuantity() {
					return this._data.quantityText
				}
				setQuantity(e) {
					return this._data.quantityText = e || "", this._line.updateAllViewsAndRedraw(), this
				}
				getExtendLeft() {
					var e = this._line.properties().extendLeft.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.extendLeft.value() : e
				}
				setExtendLeft(e) {
					return this._line.properties().extendLeft.setValue(e), this
				}
				getLineLength() {
					var e = this._line.properties().lineLength.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.lineLength.value() : e
				}
				setLineLength(e) {
					return this._line.properties().lineLength.setValue(Math.max(0, Math.min(e, 100))), this
				}
				getLineColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.lineBuyColor : e.lineSellColor).value()
				}
				setLineColor(e) {
					return "buy" === this._direction ? this.setLineBuyColor(e) : this.setLineSellColor(e), this
				}
				setLineBuyColor(e) {
					return this._line.properties().lineBuyColor.setValue(e), this
				}
				setLineSellColor(e) {
					return this._line.properties().lineSellColor.setValue(e), this
				}
				getLineStyle() {
					var e = this._line.properties().lineStyle.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.lineStyle.value() : e
				}
				setLineStyle(e) {
					return this._line.properties().lineStyle.setValue(e), this
				}
				getLineWidth() {
					var e = this._line.properties().lineWidth.value();
					return "inherit" === e ? this._line._model.properties().tradingProperties.lineWidth.value() : e
				}
				setLineWidth(e) {
					return this._line.properties().lineWidth.setValue(e), this
				}
				getBodyBorderColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.bodyBorderBuyColor : e.bodyBorderSellColor).value()
				}
				setBodyBorderColor(e) {
					return "buy" === this._direction ? this.setBodyBorderBuyColor(e) : this.setBodyBorderSellColor(e), this
				}
				setBodyBorderBuyColor(e) {
					return this._line.properties().bodyBorderBuyColor.setValue(e), this
				}
				setBodyBorderSellColor(e) {
					return this._line.properties().bodyBorderSellColor.setValue(e), this
				}
				getBodyBackgroundColor() {
					return o.getColorFromProperties(this._line.properties().bodyBackgroundColor, this._line.properties().bodyBackgroundTransparency)
				}
				setBodyBackgroundColor(e) {
					return o.setColorToProperties(e, this._line.properties().bodyBackgroundColor, this._line.properties().bodyBackgroundTransparency), this
				}
				getBodyTextColor() {
					var e = this._line.properties();
					return ("positive" === this._profitState ? e.bodyTextPositiveColor : "negative" === this._profitState ? e.bodyTextNegativeColor : e.bodyTextNeutralColor).value()
				}
				setBodyTextColor(e) {
					return "positive" === this._profitState ? this.setBodyTextPositiveColor(e) : "negative" === this._profitState ? this.setBodyTextNegativeColor(e) : this.setBodyTextNeutralColor(e), this
				}
				setBodyTextPositiveColor(e) {
					return this._line.properties().bodyTextPositiveColor.setValue(e), this
				}
				setBodyTextNegativeColor(e) {
					return this._line.properties().bodyTextNegativeColor.setValue(e), this
				}
				setBodyTextNeutralColor(e) {
					return this._line.properties().bodyTextNeutralColor.setValue(e), this
				}
				getBodyFont() {
					return o.getFontFromProperties(this._line.properties().bodyFontFamily, this._line.properties().bodyFontSize, this._line.properties().bodyFontBold, this._line.properties().bodyFontItalic)
				}
				setBodyFont(e) {
					return o.setFontToProperties(e, this._line.properties().bodyFontFamily, this._line.properties().bodyFontSize, this._line.properties().bodyFontBold, this._line.properties().bodyFontItalic), this
				}
				getQuantityBorderColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.quantityBorderBuyColor : e.quantityBorderSellColor).value()
				}
				setQuantityBorderColor(e) {
					return "buy" === this._direction ? this.setQuantityBorderBuyColor(e) : this.setQuantityBorderSellColor(e), this
				}
				setQuantityBorderBuyColor(e) {
					return this._line.properties().quantityBorderBuyColor.setValue(e), this
				}
				setQuantityBorderSellColor(e) {
					return this._line.properties().quantityBorderSellColor.setValue(e), this
				}
				getQuantityBackgroundColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.quantityBackgroundBuyColor : e.quantityBackgroundSellColor).value()
				}
				setQuantityBackgroundColor(e) {
					return "buy" === this._direction ? this.setQuantityBackgroundBuyColor(e) : this.setQuantityBackgroundSellColor(e), this
				}
				setQuantityBackgroundBuyColor(e) {
					return this._line.properties().quantityBackgroundBuyColor.setValue(e), this
				}
				setQuantityBackgroundSellColor(e) {
					return this._line.properties().quantityBackgroundSellColor.setValue(e), this
				}
				getQuantityTextColor() {
					return o.getColorFromProperties(this._line.properties().quantityTextColor, this._line.properties().quantityTextTransparency)
				}
				setQuantityTextColor(e) {
					return o.setColorToProperties(e, this._line.properties().quantityTextColor, this._line.properties().quantityTextTransparency), this
				}
				getQuantityFont() {
					return o.getFontFromProperties(this._line.properties().quantityFontFamily, this._line.properties().quantityFontSize, this._line.properties().quantityFontBold, this._line.properties().quantityFontItalic)
				}
				setQuantityFont(e) {
					return o.setFontToProperties(e, this._line.properties().quantityFontFamily, this._line.properties().quantityFontSize, this._line.properties().quantityFontBold, this._line.properties().quantityFontItalic), this
				}
				getReverseButtonBorderColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.reverseButtonBorderBuyColor : e.reverseButtonBorderSellColor).value()
				}
				setReverseButtonBorderColor(e) {
					return "buy" === this._direction ? this.setReverseButtonBorderBuyColor(e) : this.setReverseButtonBorderSellColor(e), this
				}
				setReverseButtonBorderBuyColor(e) {
					return this._line.properties().reverseButtonBorderBuyColor.setValue(e), this
				}
				setReverseButtonBorderSellColor(e) {
					return this._line.properties().reverseButtonBorderSellColor.setValue(e), this
				}
				getReverseButtonBackgroundColor() {
					return o.getColorFromProperties(this._line.properties().reverseButtonBackgroundColor, this._line.properties().reverseButtonBackgroundTransparency)
				}
				setReverseButtonBackgroundColor(e) {
					return o.setColorToProperties(e, this._line.properties().reverseButtonBackgroundColor, this._line.properties().reverseButtonBackgroundTransparency), this
				}
				getReverseButtonIconColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.reverseButtonIconBuyColor : e.reverseButtonIconSellColor).value()
				}
				setReverseButtonIconColor(e) {
					return "buy" === this._direction ? this.setReverseButtonIconBuyColor(e) : this.setReverseButtonIconSellColor(e), this
				}
				setReverseButtonIconBuyColor(e) {
					return this._line.properties().reverseButtonIconBuyColor.setValue(e), this
				}
				setReverseButtonIconSellColor(e) {
					return this._line.properties().reverseButtonIconSellColor.setValue(e), this
				}
				getCloseButtonBorderColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.closeButtonBorderBuyColor : e.closeButtonBorderSellColor).value()
				}
				setCloseButtonBorderColor(e) {
					return "buy" === this._direction ? this.setCloseButtonBorderBuyColor(e) : this.setCloseButtonBorderSellColor(e), this
				}
				setCloseButtonBorderBuyColor(e) {
					return this._line.properties().closeButtonBorderBuyColor.setValue(e), this
				}
				setCloseButtonBorderSellColor(e) {
					return this._line.properties().closeButtonBorderSellColor.setValue(e), this
				}
				getCloseButtonBackgroundColor() {
					return o.getColorFromProperties(this._line.properties().closeButtonBackgroundColor, this._line.properties().closeButtonBackgroundTransparency)
				}
				setCloseButtonBackgroundColor(e) {
					return o.setColorToProperties(e, this._line.properties().closeButtonBackgroundColor, this._line.properties().closeButtonBackgroundTransparency), this
				}
				getCloseButtonIconColor() {
					var e = this._line.properties();
					return ("buy" === this._direction ? e.closeButtonIconBuyColor : e.closeButtonIconSellColor).value()
				}
				setCloseButtonIconColor(e) {
					return "buy" === this._direction ? this.setCloseButtonIconBuyColor(e) : this.setCloseButtonIconSellColor(e), this
				}
				setCloseButtonIconBuyColor(e) {
					return this._line.properties().closeButtonIconBuyColor.setValue(e), this
				}
				setCloseButtonIconSellColor(e) {
					return this._line.properties().closeButtonIconSellColor.setValue(e), this
				}
				block() {
					this._blocked = !0, this._line.updateAllViewsAndRedraw()
				}
				unblock() {
					this._blocked = !1, this._line.updateAllViewsAndRedraw()
				}
				isFunction(e) {
					return "function" == typeof e
				}
				onReverse(e, t) {
					return t ? this.isFunction(t) && (this._onReverseData = e, this._onReverseCallback = t) : this.isFunction(e) && (this._onReverseCallback = e), this
				}
				callOnReverse() {
					this.isFunction(this._onReverseCallback) && this._onReverseCallback.call(this, this._onReverseData)
				}
				isOnReverseCallbackPresent() {
					return this.isFunction(this._onReverseCallback)
				}
				onClose(e, t) {
					return t ? this.isFunction(t) && (this._onCloseData = e, this._onCloseCallback = t) : this.isFunction(e) && (this._onCloseCallback = e), this
				}
				setCloseEnabled(e) {
					return this._closeEnabled === e || (this._closeEnabled = e, this._onCloseCallback && this._line.updateAllViewsAndRedraw()), this
				}
				isCloseEnabled() {
					return this._closeEnabled
				}
				callOnClose() {
					this.isFunction(this._onCloseCallback) && this._closeEnabled && this._onCloseCallback.call(this, this._onCloseData)
				}
				isOnCloseCallbackPresent() {
					return this._closeEnabled && this.isFunction(this._onCloseCallback)
				}
				onModify(e, t) {
					return t ? this.isFunction(t) && (this._onModifyData = e, this._onModifyCallback = t) : this.isFunction(e) && (this._onModifyCallback = e), this
				}
				callOnModify() {
					this.isFunction(this._onModifyCallback) && this._onModifyCallback.call(this, this._onModifyData)
				}
				onContextMenu(e, t) {
					return t ? this.isFunction(t) && (this._onContextMenuData = e, this._onContextMenuCallback = t) : this.isFunction(e) && (this._onContextMenuCallback = e), this
				}
				shouldShowContextMenu() {
					return this.isFunction(this._onContextMenuCallback)
				}
				callOnContextMenu() {
					if (this.isFunction(this._onContextMenuCallback)) return this._onContextMenuCallback.call(this, this._onContextMenuData)
				}
				remove() {
					this._line._model.removeSource(this._line), delete this._line
				}
			}
			class p extends r {
				constructor(e, t) {
					super(e, t || p.createProperties()), this._adapter = new d(this), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 946738, 19)).then((({
						PositionPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}));
					var r = e.mainSeries().symbolInfo(),
						n = null !== r ? r.pricescale : 100,
						s = null !== r && r.fractional ? r.minmov : 1,
						o = null !== r && r.fractional,
						l = null !== r ? r.minmove2 : void 0;
					this._formatter = new a(n, s, o, l)
				}
				zorder() {
					return u
				}
				isSpeciallyZOrderedSource() {
					return !0
				}
				setPoint(e, t, i) {
					this._points[e] = t, this.normalizePoints()
				}
				addPoint(e, t) {
					return this._points.push(e), this._lastPoint = null, this.normalizePoints(), this.createServerPoints(), !0
				}
				name() {
					return "Position"
				}
				createPriceAxisView(e) {
					return this._priceAxisView = new s(this, {
						pointIndex: e,
						backgroundPropertyGetter: () => this._adapter.getLineColor()
					}), this._priceAxisView
				}
				paneViews() {
					return TradingView.printing && !c.enabled("snapshot_trading_drawings") ? null : this._model.properties().tradingProperties.showPositions.value() ? n.prototype.paneViews.call(this) : null
				}
				priceAxisViews(e, t) {
					return TradingView.printing && !c.enabled("snapshot_trading_drawings") ? null : this._model.properties().tradingProperties.showPositions.value() ? n.prototype.priceAxisViews.call(this, e, t) : null
				}
				hasContextMenu() {
					return this._adapter.shouldShowContextMenu()
				}
				contextMenuItems() {
					return this._adapter.callOnContextMenu()
				}
				formatter() {
					return this._formatter
				}
				static createProperties(e) {
					var t = new l("linetoolposition", e, !1, !1);
					return p._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolPosition = p
		},
		29377: (e, t, i) => {
			"use strict";
			var r, n;
			i.r(t), i.d(t, {
					AlertStatus: () => r,
					Direction: () => n
				}),
				function(e) {
					e[e.Waiting = 0] = "Waiting", e[e.Success = 1] = "Success", e[e.Failure = 2] = "Failure"
				}(r || (r = {})),
				function(e) {
					e[e.Up = 1] = "Up", e[e.Down = 2] = "Down"
				}(n || (n = {}))
		},
		445178: (e, t, i) => {
			"use strict";
			var r = i(588537).ensureNotNull,
				n = i(724145).LineDataSource,
				s = i(346090).DefaultProperty,
				o = i(29377);
			class l extends n {
				constructor(e, t, r, n) {
					super(e, t || l.createProperties(), r, n), this._predictionPaneView = null;
					const s = this._model.mainSeries();
					s.properties().interval.subscribe(this, (() => {
						this.setStatus(o.AlertStatus.Waiting)
					})), s.dataEvents().dataUpdated().subscribe(this, this.checkAlert), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 777053, 19)).then((({
						PredictionPaneView: e
					}) => {
						this._predictionPaneView = new e(this, this._model), this._setPaneViews([this._predictionPaneView])
					}))
				}
				destroy() {
					const e = this._model.mainSeries();
					e.properties().interval.unsubscribeAll(this), e.dataEvents().dataUpdated().unsubscribeAll(this), super.destroy()
				}
				dataAndViewsReady() {
					return n.prototype.dataAndViewsReady.call(this) && this._predictionPaneView && this._predictionPaneView.iconsReady()
				}
				isSynchronizable() {
					return !1
				}
				status() {
					return this._properties.status.value()
				}
				setStatus(e) {
					return this._properties.status.setValue(e)
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Forecast"
				}
				restorePoints(e, t, i) {
					super.restorePoints(e, t, i), this.checkAlert()
				}
				checkAlert() {
					if (!this.isSourceHidden() && !(this._points.length < 2 || this._model.mainSeries().bars().isEmpty())) {
						var e = this._points[1];
						if (this.status()) e.index > this._model.timeScale().baseIndex() && this.setStatus(o.AlertStatus.Waiting);
						else {
							var t = this._model.mainSeries().bars().valueAt(e.index);
							if (null !== t) {
								var i = this.direction();
								if (i === o.Direction.Up && t[TradingView.HIGH_PLOT] >= e.price) this.setStatus(o.AlertStatus.Success);
								else if (i === o.Direction.Down && t[TradingView.LOW_PLOT] <= e.price) this.setStatus(o.AlertStatus.Success);
								else {
									var n = r(this._model.mainSeries().bars().lastIndex());
									e.index !== n && this.setStatus(o.AlertStatus.Failure)
								}
							}
						}
					}
				}
				addPoint(e) {
					var t = n.prototype.addPoint.call(this, e);
					return t && this.checkAlert(), t
				}
				endChanging() {
					super.endChanging(), this.setStatus(o.AlertStatus.Waiting), this.checkAlert()
				}
				onData(e) {
					super.onData(e), this.checkAlert()
				}
				endMoving(e, t, i) {
					super.endMoving(e, t, i), this.setStatus(o.AlertStatus.Waiting), this.checkAlert()
				}
				direction() {
					if (this.points().length < 2) return o.Direction.Up;
					var e = this.points()[0];
					return this.points()[1].price > e.price ? o.Direction.Up : o.Direction.Down
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 989062))).PredictionDefinitionsViewModel
				}
				cloneable() {
					return !1
				}
				static createProperties(e) {
					var t = new s("linetoolprediction", e);
					return l._configureProperties(t), t
				}
				static _configureProperties(e) {
					n._configureProperties(e), e.merge({
						status: o.AlertStatus.Waiting
					})
				}
			}
			t.LineToolPrediction = l
		},
		483258: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(346090).DefaultProperty,
				s = i(424146).LineToolColorsProperty;
			class o extends r {
				constructor(e, t, r, n) {
					super(e, t || o.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 886314, 19)).then((({
						PriceLabelPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Price Label"
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 411798))).PriceLabelDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetoolpricelabel", e);
					return o._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e),
						e.addChild("linesColors", new s([e.childs().borderColor])), e.addChild("textsColors", new s([e.childs().color]))
				}
			}
			t.LineToolPriceLabel = o
		},
		142754: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolPriceNote: () => c
			});
			var r = i(588537),
				n = i(346090),
				s = i(232567),
				o = i.n(s),
				l = i(724145),
				a = i(194459);
			class c extends l.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), this._labelMovingDelta = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 184122)).then((t => {
						this._setPaneViews([new t.PriceNotePaneView(this, e)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Price Note"
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				startMoving(e, t, i) {
					if (1 === t) {
						if (this.isSourceHidden()) return;
						const i = (0, r.ensureDefined)(e.logical),
							n = this.points()[1];
						this._labelMovingDelta = {
							index: n.index - i.index,
							price: n.price - i.price
						}, this.startChanging(t, i)
					} else this._labelMovingDelta = null, super.startMoving(e, t, i)
				}
				move(e, t, i) {
					if (null !== this._labelMovingDelta) {
						const t = (0, r.ensureDefined)(e.logical),
							n = {
								index: t.index + this._labelMovingDelta.index,
								price: t.price + this._labelMovingDelta.price
							};
						this.setPoint(1, n, i), this.updateAllViews((0, a.dataSourceChangeEvent)(this.id()))
					} else super.move(e, t, i)
				}
				endMoving(e, t, i) {
					return null !== this._labelMovingDelta ? (this._labelMovingDelta = null, this.endChanging(!1, e)) : super.endMoving(e, t, i)
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolpricenote", e);
					return c._configureProperties(t), t
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 908387)).then((e => e.PriceNoteDefinitionsViewModel))
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				static _configureProperties(e) {
					l.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(o())("")), e.addExclusion("text"), e.hasChild("backgroundsColors") && e.removeProperty("backgroundsColors"), e.hasChild("textsColors") && e.removeProperty("textsColors")
				}
			}
		},
		268368: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolPriceRange: () => p
			});
			var r = i(724145),
				n = i(588537),
				s = i(61499),
				o = i(326505),
				l = i(90281);
			const a = {
					...l.nonThemedFactoryDefaultsBase,
					extendLeft: !1,
					extendRight: !1
				},
				c = l.themedFactoryDefaultsBase,
				u = (0, o.extractAllPropertiesKeys)((0, n.ensureDefined)(c.get(s.StdTheme.Light))),
				h = (0, o.extractAllPropertiesKeys)(a);
			class d extends o.ThemedDefaultProperty {
				static create(e) {
					return new d("linetoolpricerange", (() => (0, o.factoryDefaultsForCurrentTheme)(a, c)), h, u, e)
				}
			}
			class p extends r.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || p.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 241331)).then((e => {
						this._setPaneViews([new e.PriceRangePaneView(this, this._model)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Price Range"
				}
				static createProperties(e) {
					const t = d.create(e);
					return p._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 950152))).GeneralDatePriceRangeDefinitionsViewModel
				}
				static _configureProperties(e) {
					r.LineDataSource._configureProperties(e)
				}
			}
		},
		789789: (e, t, i) => {
			"use strict";
			var r = i(755827).LevelsProperty,
				n = i(844040).LineToolFibWedgeBase,
				s = i(424146).LineToolColorsProperty;
			class o extends n {
				constructor(e, t, r, n) {
					super(e, t || o.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 587265, 19)).then((({
						ProjectionLinePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return 1
				}
				name() {
					return "Projection"
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 411937))).ProjectionDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new r("linetoolprojection", e, !1, {
						range: [1, 1]
					});
					return o._configureProperties(t), t
				}
				static _configureProperties(e) {
					n._configureProperties(e), e.addChild("linesColors", new s([e.trendline.color]))
				}
			}
			t.LineToolProjection = o
		},
		294678: (e, t, i) => {
			"use strict";
			var r = i(439195).LineToolTrendLine,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				name() {
					return "Ray"
				}
				static createProperties(e) {
					var t = new n("linetoolray", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolRay = s
		},
		438642: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolRectangle: () => u
			});
			var r = i(86441),
				n = i(346090),
				s = i(232567),
				o = i.n(s),
				l = i(724145),
				a = i(424146),
				c = i(588537);
			class u extends l.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || u.createProperties();
					super(e, s, r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 189314)).then((({
						RectanglePaneView: t
					}) => {
						const i = [new t(this, e)];
						this._setPaneViews(i)
					}))
				}
				pointsCount() {
					return 2
				}
				textColorsProperty() {
					return this.properties().childs().showLabel.value() ? super.textColorsProperty() : null
				}
				name() {
					return "Rectangle"
				}
				setPoint(e, t, i) {
					if (e < 2 && super.setPoint(e, t, i), i && i.shift()) {
						const i = this._getAnchorPointForIndex(e);
						if (e >= 4) return this._correctMiddlePoints(e, t, i), void this.normalizePoints();
						this._snapPoint45Degree(t, i)
					}
					switch (e) {
						case 2:
							this._points[1].price = t.price, this._points[0].index = t.index;
							break;
						case 3:
							this._points[0].price = t.price, this._points[1].index = t.index;
							break;
						case 4:
							this._points[0].index = t.index;
							break;
						case 5:
							this._points[1].index = t.index;
							break;
						case 6:
							this._points[0].price = t.price;
							break;
						case 7:
							this._points[1].price = t.price
					}
					this.normalizePoints()
				}
				getPoint(e) {
					return e < 2 ? super.getPoint(e) : this._getAnchorPointForIndex(e)
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolrectangle", e);
					return u._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 695069)).then((e => e.RectangleDefinitionsViewModel))
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				_snapPoint45Degree(e, t, i) {
					const r = this.m_priceScale,
						n = this.ownerSource();
					if (null === r || null === n) return;
					const s = n.firstValue();
					if (null === s) return;
					const o = this._model.timeScale(),
						l = (0, c.ensureNotNull)(this.pointToScreenPoint(e)),
						a = (0, c.ensureNotNull)(this.pointToScreenPoint(t)),
						u = l.x - a.x,
						h = l.y - a.y,
						d = u < 0 ? -1 : 1,
						p = h < 0 ? -1 : 1,
						_ = Math.max(Math.abs(u), Math.abs(h)),
						P = Math.round(o.coordinateToIndex(a.x + _ * d)),
						f = Math.abs(o.indexToCoordinate(P) - a.x),
						g = r.coordinateToPrice(a.y + f * p, s);
					e.index = P, e.price = g
				}
				_correctMiddlePoints(e, t, i) {
					e < 6 ? this._correctRightLeftMiddlePoint(e, t, i) : this._correctTopBottomMiddlePoint(e, t, i)
				}
				_correctRightLeftMiddlePoint(e, t, i) {
					const n = (0, c.ensureNotNull)(this.pointToScreenPoint(t)),
						s = (0, c.ensureNotNull)(this.pointToScreenPoint(i)),
						o = (0, c.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						l = (0, c.ensureNotNull)(this.pointToScreenPoint(this._points[1]));
					let a = n.x - s.x;
					if (0 === a) return;
					const u = o.x < l.x ? 1 : -1,
						h = o.y < l.y ? 1 : -1;
					switch (a *= u, e) {
						case 4: {
							const e = l.y - h * a / 2,
								t = (0, c.ensureNotNull)(this.screenPointToPoint(new r.Point(l.x, e)));
							this._points[1].price = t.price;
							const i = (0, c.ensureNotNull)(this.screenPointToPoint(new r.Point(o.x + u * a, o.y + h * a / 2)));
							this._points[0].price = i.price, this._points[0].index = i.index;
							break
						}
						case 5: {
							const e = o.y - h * a / 2,
								t = (0, c.ensureNotNull)(this.screenPointToPoint(new r.Point(o.x, e)));
							this._points[0].price = t.price;
							const i = (0, c.ensureNotNull)(this.screenPointToPoint(new r.Point(l.x + u * a, l.y + h * a / 2)));
							this._points[1].price = i.price, this._points[1].index = i.index;
							break
						}
					}
				}
				_correctTopBottomMiddlePoint(e, t, i) {
					const n = this.m_priceScale,
						s = this.ownerSource();
					if (null === n || null === s) return;
					const o = this._model.timeScale(),
						l = s.firstValue();
					if (null === l) return;
					const a = (0, c.ensureNotNull)(this.pointToScreenPoint(t)),
						u = (0, c.ensureNotNull)(this.pointToScreenPoint(i)),
						h = (0, c.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						d = (0, c.ensureNotNull)(this.pointToScreenPoint(this._points[1])),
						p = a.y - u.y,
						_ = p < 0 ? -1 : 1,
						P = h.x < d.x ? 1 : -1,
						f = h.y < d.y ? 1 : -1;
					switch (e) {
						case 6: {
							const e = Math.floor(d.x - P * p / 2),
								t = (0, c.ensureNotNull)(this.screenPointToPoint(new r.Point(e, d.y))),
								i = Math.abs(this._points[1].index - t.index),
								s = P * f * _ * Math.ceil(i / 2);
							if (0 === s) return;
							this._points[1].index = this._points[1].index - s;
							const a = _ * Math.abs(o.indexToCoordinate(this._points[1].index) - d.x);
							this._points[0].price = n.coordinateToPrice(h.y + a, l), this._points[0].index = this._points[0].index + s;
							break
						}
						case 7: {
							const e = Math.floor(h.x - P * p / 2),
								t = (0, c.ensureNotNull)(this.screenPointToPoint(new r.Point(e, h.y))),
								i = Math.abs(this._points[0].index - t.index),
								s = P * f * _ * Math.ceil(i / 2);
							if (0 === s) return;
							this._points[0].index = this._points[0].index - s;
							const a = _ * Math.abs(o.indexToCoordinate(this._points[0].index) - h.x);
							this._points[1].price = n.coordinateToPrice(d.y + a, l), this._points[1].index = this._points[1].index + s;
							break
						}
					}
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				static _configureProperties(e) {
					l.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(o())("")), e.addChild("linesColors", new a.LineToolColorsProperty([e.childs().color])),
						e.addChild("textsColors", new a.LineToolColorsProperty([e.childs().textColor], e.childs().showLabel)), e.addExclusion("text"), e.addExclusion("linesColors"), e.addExclusion("textsColors")
				}
				_getAnchorPointForIndex(e) {
					const t = this.points(),
						i = t[0],
						r = t[1];
					let n = 0,
						s = 0;
					switch (e) {
						case 0:
							n = i.price, s = i.index;
							break;
						case 1:
							n = r.price, s = r.index;
							break;
						case 2:
							n = r.price, s = i.index;
							break;
						case 3:
							n = i.price, s = r.index;
							break;
						case 4:
							n = (r.price + i.price) / 2, s = i.index;
							break;
						case 5:
							n = (r.price + i.price) / 2, s = r.index;
							break;
						case 6:
							n = i.price, s = (r.index + i.index) / 2;
							break;
						case 7:
							n = r.price, s = (r.index + i.index) / 2
					}
					return {
						index: s,
						price: n
					}
				}
			}
		},
		155277: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolRiskRewardBase: () => v
			});
			var r = i(588537),
				n = i(701336),
				s = i(752280),
				o = i(559270),
				l = i(724145),
				a = i(234021),
				c = i(690283),
				u = i(498424);
			class h extends u.PriceAxisView {
				constructor(e, t) {
					super(), this._source = e, this._data = t
				}
				_updateRendererData(e, t, i) {
					if (e.visible = !1, !this._showAxisLabel()) return;
					const r = this._source.priceScale();
					if (0 === this._source.points().length || null === r || r.isEmpty()) return;
					const n = this._source.ownerSource(),
						s = null !== n ? n.firstValue() : null;
					if (null === s) return;
					const o = this._data.priceProperty.value(),
						l = this._data.colorProperty.value();
					i.background = l, i.textColor = this.generateTextColor(l), i.coordinate = r.priceToCoordinate(o, s), e.text = r.formatPrice(o, s), e.visible = !0
				}
				_showAxisLabel() {
					return this._source.properties().childs().showPriceLabels.value()
				}
			}
			var d = i(232567),
				p = i.n(d);
			class _ extends(p()) {
				constructor(e, t) {
					super(), this._lineSource = e, this._pointIndex = t
				}
				value() {
					const e = this._lineSource.points()[this._pointIndex].price;
					return this._formatAndParsePrice(e)
				}
				state() {
					return this.value()
				}
				merge(e, t) {
					return this.setValue(e), t ? [] : null
				}
				_formatAndParsePrice(e) {
					const t = (0, r.ensureNotNull)(this._lineSource.ownerSource()).formatter();
					if (t.parse) {
						const i = t.format(e),
							r = t.parse(i);
						return r.res ? r.value : e
					}
					return e
				}
			}
			class P extends _ {
				constructor(e) {
					super(e, 0)
				}
				setValue(e) {
					const t = this._lineSource.points()[this._pointIndex];
					this._lineSource.startChanging(this._pointIndex, t), t.price = parseFloat("" + e), this._lineSource.setPoint(this._pointIndex, t), this._lineSource.recalculate(), this._lineSource.model().updateSource(this._lineSource), this._listeners.fire(this), this._lineSource.endChanging(!1, !1), this._lineSource.syncPriceLevels()
				}
			}
			class f extends _ {
				constructor(e) {
					super(e, 1)
				}
				value() {
					const e = this._lineSource.stopPrice();
					return this._formatAndParsePrice(e)
				}
				setValue(e) {
					const t = Math.round(Math.abs(e - this._lineSource.entryPrice()) * this._lineSource.model().mainSeries().base());
					this._lineSource.properties().childs().stopLevel.setValue(t), this._lineSource.syncPriceLevels()
				}
			}
			class g extends _ {
				constructor(e) {
					super(e, 2)
				}
				value() {
					const e = this._lineSource.profitPrice();
					return this._formatAndParsePrice(e)
				}
				setValue(e) {
					const t = Math.round(Math.abs(e - this._lineSource.entryPrice()) * this._lineSource.model().mainSeries().base());
					this._lineSource.properties().childs().profitLevel.setValue(t), this._lineSource.syncPriceLevels()
				}
			}
			class v extends l.LineDataSource {
				constructor(e, t, s, l) {
					if (super(e, t, s, l),
						this._syncStateExclusions = ["points", "entryPrice", "stopPrice", "targetPrice", "stopLevel", "profitLevel", "riskSize", "qty", "amountTarget", "amountStop"], !t.hasChild("stopLevel") && !t.hasChild("profitLevel")) {
						const i = (0, r.ensureNotNull)(e.timeScale().visibleBarsStrictRange()),
							n = i.firstBar(),
							s = i.lastBar();
						let l = (0, r.ensureNotNull)(e.mainSeries().priceRange(n, s));
						const a = e.mainSeries().priceScale();
						if (a.isLog()) {
							const e = a.logicalToPrice(l.minValue()),
								t = a.logicalToPrice(l.maxValue());
							l = new o.PriceRange(e, t)
						}
						if (l && !l.isEmpty()) {
							const i = Math.round(.2 * l.length() * e.mainSeries().base());
							t.merge({
								stopLevel: i,
								profitLevel: i
							})
						}
					}
					t.childs().stopLevel.listeners().subscribe(this, this.recalculate), t.childs().stopLevel.listeners().subscribe(null, (() => {
						this.properties().childs().stopPrice.childChanged(null)
					})), t.childs().profitLevel.listeners().subscribe(this, this.recalculate), t.childs().profitLevel.listeners().subscribe(null, (() => {
						this.properties().childs().targetPrice.childChanged(null)
					})), t.addChild("entryPrice", new P(this)), t.addChild("stopPrice", new f(this)), t.addChild("targetPrice", new g(this)), t.hasChild("riskSize") || t.addProperty("riskSize", 0), t.hasChild("qty") || t.addProperty("qty", 0), t.hasChild("amountTarget") || t.addProperty("amountTarget", t.childs().accountSize.value()), t.hasChild("amountStop") || t.addProperty("amountStop", t.childs().accountSize.value()), t.addExclusion("riskSize"), t.addExclusion("qty"), t.addExclusion("amountTarget"), t.addExclusion("amountStop"), this._riskInPercentsFormatter = new n.NumericFormatter(2), this._riskInMoneyFormatter = new n.NumericFormatter, t.childs().risk.subscribe(this, this._recalculateRiskSize), t.childs().accountSize.subscribe(this, this._recalculateRiskSize), t.childs().riskDisplayMode.subscribe(this, this._recalculateRisk), t.childs().riskDisplayMode.subscribe(this, this._recalculateRiskSize), t.childs().entryPrice.subscribe(this, this._recalculateRiskSize), t.childs().stopPrice.subscribe(this, this._recalculateRiskSize), t.childs().profitLevel.subscribe(this, this._recalculateRiskSize), t.childs().profitLevel.subscribe(this, this.syncPriceLevels.bind(this)), t.childs().stopLevel.subscribe(this, this._recalculateRiskSize), t.childs().stopLevel.subscribe(this, this.syncPriceLevels.bind(this)), t.childs().qty.subscribe(this, this._recalculateRiskSize), e.mainSeries().dataEvents().dataUpdated().subscribe(this, this._onSeriesUpdated), this.pointAdded().subscribe(this, (e => {
						switch (e) {
							case c.RiskRewardPointIndex.Entry:
							case c.RiskRewardPointIndex.Close:
								this._recalculateRiskSize(), this._recalculateQty()
						}
					})), this.pointChanged().subscribe(this, (e => {
						switch (e) {
							case c.RiskRewardPointIndex.Entry:
							case c.RiskRewardPointIndex.Close:
								this._recalculateRiskSize(), this._recalculateQty()
						}
					})), t.childs().riskDisplayMode.value() === a.RiskDisplayMode.Percentage && t.childs().risk.value() > 100 && t.childs().riskDisplayMode.setValueSilently(a.RiskDisplayMode.Money), this.version = 2, this._entryPriceAxisView = new h(this, {
						colorProperty: t.childs().linecolor,
						priceProperty: t.childs().entryPrice
					}), this._stopPriceAxisView = new h(this, {
						colorProperty: t.childs().stopBackground,
						priceProperty: t.childs().stopPrice
					}), this._profitPriceAxisView = new h(this, {
						colorProperty: t.childs().profitBackground,
						priceProperty: t.childs().targetPrice
					}), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 773075)).then((({
						RiskRewardPaneView: t
					}) => {
						const i = [new t(this, e)];
						this._setPaneViews(i)
					}))
				}
				destroy() {
					this._model.mainSeries().dataEvents().dataUpdated().unsubscribeAll(this), super.destroy()
				}
				checkAlert() {
					this.recalculate()
				}
				calculatePL(e) {
					return this.entryPrice() - e
				}
				lastBarData() {
					const e = this._model.mainSeries().bars().firstIndex(),
						t = this._model.mainSeries().bars().lastIndex();
					if (null === e || null === t || isNaN(e) || isNaN(t)) return null;
					const i = this.points();
					if (4 === i.length) {
						const r = i[c.RiskRewardPointIndex.ActualClose];
						return r.index < e ? null : {
							closePrice: r.price,
							index: Math.min(t, r.index)
						}
					}
					const n = i[c.RiskRewardPointIndex.Close];
					if (n.index < e) return null;
					const o = Math.min(t, n.index),
						l = this._model.mainSeries().bars().search(o, s.PlotRowSearchMode.NearestLeft);
					return null === l ? null : {
						closePrice: (0, r.ensure)(l.value[4]),
						index: l.index
					}
				}
				_onSeriesUpdated(e, t, i) {
					this.isSourceHidden() || this._points.length < 2 || null !== i && i.index > Math.max(this._points[0].index, this._points[1].index) || this.checkAlert()
				}
			}
		},
		234021: (e, t, i) => {
			"use strict";
			var r;
			i.d(t, {
					RiskDisplayMode: () => r
				}),
				function(e) {
					e.Percentage = "percents", e.Money = "money"
				}(r || (r = {}))
		},
		690283: (e, t, i) => {
			"use strict";
			var r;
			i.d(t, {
					RiskRewardPointIndex: () => r
				}),
				function(e) {
					e[e.Entry = 0] = "Entry", e[e.Close = 1] = "Close", e[e.ActualEntry = 2] = "ActualEntry", e[e.ActualClose = 3] = "ActualClose"
				}(r || (r = {}))
		},
		706711: (e, t, i) => {
			"use strict";
			var r = i(588537).ensureNotNull,
				n = i(724145).LineDataSource,
				s = i(308170),
				o = i(346090).DefaultProperty,
				l = i(690283).RiskRewardPointIndex,
				a = i(234021).RiskDisplayMode,
				c = i(155277).LineToolRiskRewardBase,
				u = i(270617).isNumber,
				h = i(180560),
				d = h.SIDE,
				p = h.ORDERTYPE;
			class _ extends c {
				riskFormatter(e) {
					return e === a.Percentage ? this._riskInPercentsFormatter : this._riskInMoneyFormatter
				}
				getRiskStep(e) {
					return e === a.Percentage ? .01 : 1
				}
				_roundValue(e) {
					return parseFloat(e.toFixed(2))
				}
				hasEditableCoordinates() {
					return !1
				}
				_recalculateRisk() {
					var e = this.properties(),
						t = e.riskDisplayMode.value(),
						i = e.riskSize.value(),
						r = e.accountSize.value(),
						n = e.risk.value();
					n = t === a.Percentage ? this._roundValue(i / r * 100) : this._roundValue(r / 100 * n), this._riskInChange = !0, e.risk.setValue(this.riskFormatter(t).format(n)), this._riskInChange = !1
				}
				_recalculateRiskSize() {
					if (!this._riskInChange) {
						var e = this.properties(),
							t = e.risk.value(),
							i = e.riskDisplayMode.value(),
							r = e.accountSize.value();
						i === a.Percentage ? e.riskSize.setValue(t / 100 * r) : t > r ? (e.risk.setValue(r), e.riskSize.setValue(r)) : e.riskSize.setValue(t)
					}
				}
				migrateVersion(e, t, i) {
					if (1 === e && this._points.length >= 1) {
						var r = [];
						if (r.push(this._points[0]), s = {
								price: (s = this._points[0]).price,
								index: this._getClosePointIndex(s.index)
							}, r.push(s), this._points[1] && r.push(this._points[1]), this._points[2] && r.push(this._points[2]), this._points = r, this._timePoint.length >= 1) {
							var n = [],
								s = this._timePoint[0];
							n.push(s);
							var o = {
								price: s.price,
								time_t: s.time_t,
								offset: this._getClosePointIndex(s.offset)
							};
							n.push(o), this._timePoint[1] && r.push(this._points[1]), this._timePoint[2] && r.push(this._points[2]), this._timePoint = n
						}
					}
				}
				priceAxisViews(e, t) {
					return this.isSourceHidden() || t !== this.priceScale() || this._model.paneForSource(this) !== e ? null : [this._entryPriceAxisView, this._stopPriceAxisView, this._profitPriceAxisView]
				}
				updateAllViews() {
					this.isActualSymbol() && this._properties.visible.value() && (s.hideAllDrawings().value() && this.userEditEnabled() || (super.updateAllViews(), this._entryPriceAxisView.update(), this._stopPriceAxisView.update(), this._profitPriceAxisView.update()))
				}
				restoreExternalState(e) {
					if (u(e.entryPrice)) {
						if (e = Object.assign({}, e), !this.isActualSymbol()) this._timePoint[0].price = e.entryPrice, delete e.entryPrice;
						this.properties().merge(e)
					} else super.restoreExternalState(e)
				}
				_changeEntryPoint(e) {
					var t = this.properties().stopPrice.value(),
						i = this.properties().targetPrice.value(),
						r = 1 / this._model.mainSeries().base(),
						n = Math.min(t, i) + r,
						s = Math.max(t, i) - r;
					e.price = Math.max(n, Math.min(s, this._roundPrice(e.price))), super.setPoint(0, e), this.properties().stopPrice.setValue(t), this.properties().targetPrice.setValue(i)
				}
				setPoint(e, t, i) {
					if (this.isActualSymbol()) {
						switch (this._muteSyncLineStyle(), e) {
							case 0:
								this._changeEntryPoint(t);
								break;
							case 2:
								this.properties().stopPrice.setValue(this.preparseStopPrice(t.price));
								break;
							case 3:
								this.properties().targetPrice.setValue(this.preparseProfitPrice(t.price));
								break;
							case 1:
								t.price = this._roundPrice(t.price), super.setPoint(1, t), this.recalculate()
						}
						this._unmuteSyncLineStyleWithoutApplyingChanges(), this.syncPriceLevels()
					}
				}
				getPoint(e) {
					switch (e) {
						case 0:
							return this._points[0];
						case 1:
							return {
								index: this._points[1].index, price: this._points[0].price
							};
						case 2:
							return {
								index: this._points[0].index, price: this.stopPrice()
							};
						case 3:
							return {
								index: this._points[0].index, price: this.profitPrice()
							}
					}
					return null
				}
				setPoints(e) {
					this._muteSyncLineStyle(), super.setPoints(e), this.recalculate(), this._unmuteSyncLineStyleWithoutApplyingChanges(), this.syncPriceLevels()
				}
				syncPriceLevels() {
					if (this.linkKey().value()) {
						var e = this.properties(),
							t = {
								entryPrice: e.entryPrice.value(),
								stopLevel: e.stopLevel.value(),
								profitLevel: e.profitLevel.value()
							};
						s.changeLineStyle({
							linkKey: this.linkKey().value(),
							state: t,
							model: this._model
						})
					}
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Risk/Reward"
				}
				addPoint(e) {
					e.price = this._roundPrice(e.price), super.addPoint(e, null, !0);
					var t = {
						price: e.price,
						index: this._getClosePointIndex(e.index)
					};
					super._addPointIntenal(t, null, !0);
					var i = this.calculateActualEntry(e, t);
					i && (super._addPointIntenal(i, null, !0), (t = this.findClosePoint(i, t)) && super._addPointIntenal(t, null, !0));
					return this._lastPoint = null, this.normalizePoints(), this.createServerPoints(), !0
				}
				setOwnerSource(e) {
					super.setOwnerSource(e), this._model.mainSeries().symbolInfo() && (this._recalculateAmount(), this._recalculateRiskSize(), this._recalculateQty())
				}
				_roundPrice(e) {
					var t = this._model.mainSeries().base();
					return Math.round(e * t) / t
				}
				recalculate() {
					if (0 !== this.points().length) {
						var e = this.properties().targetPrice.value(),
							t = this.properties().stopPrice.value(),
							i = [this._points[0], this._points[1]],
							r = this.calculateActualEntry(this.points()[0], this.points()[1]);
						if (r) {
							i.push(r);
							var n = this.findClosePoint(r, this.points()[1]);
							n && i.push(n)
						}
						this._points = i, e !== this.properties().targetPrice.value() && this.properties().targetPrice._listeners.fire(this.properties().targetPrice), t !== this.properties().stopPrice.value() && this.properties().stopPrice._listeners.fire(this.properties().stopPrice)
					}
				}
				start() {
					super.start(), this.recalculate()
				}
				startMoving(e, t, i) {
					e.logical.price = this._roundPrice(e.logical.price), super.startMoving(e, t, i)
				}
				move(e, t, i) {
					e.logical.price = this._roundPrice(e.logical.price), super.move(e, t, i), this.recalculate(), this._entryPriceAxisView.update()
				}
				_correctPoints(e, t) {
					return !!this.isActualSymbol() && n.prototype._correctPoints.call(this, [e[0], e[1]], t)
				}
				entryPrice() {
					return this.points()[0].price
				}
				findClosePoint(e, t) {
					for (var i = this._model.mainSeries().bars(), n = r(i.firstIndex()), s = Math.max(e.index, n), o = r(i.lastIndex()), l = Math.min(o, t.index), a = s; a <= l; a++) {
						var c = i.valueAt(a);
						if (null !== c) {
							var u = this.checkStopPrice(c);
							if (null != u) return {
								index: a,
								price: u
							}
						}
					}
					return null
				}
				calculateActualEntry(e, t) {
					var i = this._model.mainSeries().bars();
					if (i.isEmpty()) return null;
					for (var n = r(i.firstIndex()), s = Math.max(e.index, n), o = e.price, l = r(i.lastIndex()), a = Math.min(l, t.index), c = s; c <= a; c++) {
						var u = i.valueAt(c);
						if (null !== u && u[TradingView.HIGH_PLOT] >= o && u[TradingView.LOW_PLOT] <= o) return {
							index: c,
							price: o
						}
					}
					return null
				}
				axisPoints() {
					if (!this._points[l.ActualEntry]) return [];
					var e = this._points[l.ActualEntry],
						t = null;
					if (4 === this._points.length) t = this._points[l.ActualClose];
					else {
						var i = this.lastBarData();
						if (!i) return [];
						t = {
							index: i.index,
							price: i.closePrice
						}
					}
					return [e, t]
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 814946))).RiskRewardDefinitionsViewModel
				}
				template() {
					var e = this.properties(),
						t = n.prototype.template.call(this);
					return t.stopLevel = e.stopLevel.value(), t.profitLevel = e.profitLevel.value(), t
				}
				_applyTemplateImpl(e) {
					delete e.targetPrice, delete e.stopPrice, delete e.entryPrice, super._applyTemplateImpl(e);
					var t = this.properties();
					void 0 !== e.stopLevel && t.stopLevel.setValue(e.stopLevel), void 0 !== e.profitLevel && t.profitLevel.setValue(e.profitLevel)
				}
				getOrderTemplate() {
					var e = this.properties();
					return {
						qty: e.qty.value() / e.lotSize.value(),
						limitPrice: e.entryPrice.value(),
						stopLoss: e.stopPrice.value(),
						takeProfit: e.targetPrice.value(),
						side: this._orderSide(),
						type: p.LIMIT,
						seenPrice: null
					}
				}
				_propertiesStateExclusions() {
					return ["entryPrice", "stopPrice", "targetPrice"]
				}
				static _configureProperties(e) {
					n._configureProperties(e), e.addExclusion("stopLevel"), e.addExclusion("profitLevel"), e.addExclusion("stopPrice"), e.addExclusion("targetPrice"), e.addExclusion("entryPrice")
				}
				_getClosePointIndex(e) {
					var t = this._model.timeScale(),
						i = Math.round(t.width() / t.barSpacing());
					return e + Math.max(3, Math.round(.15 * i))
				}
			}
			_.version = 2;
			class P extends _ {
				constructor(e, t, i, r) {
					super(e, t || P.createProperties(), i, r);
					var n = this.properties();
					n.entryPrice.subscribe(this, this._recalculateQty), n.stopPrice.subscribe(this, this._recalculateQty), n.riskSize.subscribe(this, this._recalculateQty), n.entryPrice.subscribe(this, this._recalculateAmount), n.profitLevel.subscribe(this, this._recalculateAmount), n.stopLevel.subscribe(this, this._recalculateAmount), n.accountSize.subscribe(this, this._recalculateAmount), n.riskSize.subscribe(this, this._recalculateAmount), n.qty.subscribe(this, this._recalculateAmount)
				}
				_recalculateQty() {
					if (0 !== this.points().length) {
						var e = this.properties(),
							t = e.entryPrice.value(),
							i = e.stopPrice.value(),
							r = e.riskSize.value(),
							n = this._model.mainSeries().pointValue(),
							s = r / (Math.abs(i - t) * n);
						e.qty.setValue(s)
					}
				}
				_recalculateAmount() {
					if (0 !== this.points().length) {
						var e = this.properties(),
							t = e.accountSize.value(),
							i = e.entryPrice.value(),
							r = e.qty.value(),
							n = e.stopPrice.value(),
							s = e.targetPrice.value(),
							o = this._model.mainSeries().pointValue(),
							l = this._roundValue(t + (i - s) * r * o),
							a = this._roundValue(t - (n - i) * r * o);
						e.amountTarget.setValue(l), e.amountStop.setValue(a)
					}
				}
				name() {
					return "Risk/Reward short"
				}
				stopPrice() {
					return this.entryPrice() + this.properties().stopLevel.value() / this._model.mainSeries().base()
				}
				profitPrice() {
					return this.entryPrice() - this.properties().profitLevel.value() / this._model.mainSeries().base()
				}
				preparseStopPrice(e) {
					e = this._roundPrice(e);
					var t = this.entryPrice() + 1 / this._model.mainSeries().base();
					return Math.max(e, t)
				}
				preparseProfitPrice(e) {
					e = this._roundPrice(e);
					var t = this.entryPrice() - 1 / this._model.mainSeries().base();
					return Math.min(e, t)
				}
				checkStopPrice(e) {
					var t = this.stopPrice(),
						i = this.profitPrice();
					return e[TradingView.HIGH_PLOT] >= t ? this.stopPrice() : e[TradingView.LOW_PLOT] <= i ? this.profitPrice() : null
				}
				_orderSide() {
					return d.SELL
				}
				static createProperties(e) {
					var t = new o("linetoolriskrewardshort", e);
					return P._configureProperties(t), t
				}
				static _configureProperties(e) {
					_._configureProperties(e)
				}
			}
			class f extends _ {
				constructor(e, t, i, r) {
					super(e, t || f.createProperties(), i, r);
					var n = this.properties();
					n.entryPrice.subscribe(this, this._recalculateQty), n.stopPrice.subscribe(this, this._recalculateQty), n.riskSize.subscribe(this, this._recalculateQty), n.entryPrice.subscribe(this, this._recalculateAmount), n.profitLevel.subscribe(this, this._recalculateAmount), n.stopLevel.subscribe(this, this._recalculateAmount), n.accountSize.subscribe(this, this._recalculateAmount), n.riskSize.subscribe(this, this._recalculateAmount), n.qty.subscribe(this, this._recalculateAmount)
				}
				_recalculateQty() {
					if (0 !== this.points().length) {
						var e = this.properties(),
							t = e.entryPrice.value(),
							i = e.stopPrice.value(),
							r = e.riskSize.value(),
							n = this._model.mainSeries().pointValue(),
							s = r / (Math.abs(t - i) * n);
						e.qty.setValue(s)
					}
				}
				_recalculateAmount() {
					if (0 !== this.points().length) {
						var e = this.properties(),
							t = e.accountSize.value(),
							i = e.entryPrice.value(),
							r = e.qty.value(),
							n = e.stopPrice.value(),
							s = e.targetPrice.value(),
							o = this._model.mainSeries().pointValue(),
							l = this._roundValue(t + (s - i) * r * o),
							a = this._roundValue(t - (i - n) * r * o);
						e.amountTarget.setValue(l), e.amountStop.setValue(a)
					}
				}
				stopPrice() {
					return this.entryPrice() - this.properties().stopLevel.value() / this._model.mainSeries().base()
				}
				profitPrice() {
					return this.entryPrice() + this.properties().profitLevel.value() / this._model.mainSeries().base()
				}
				calculatePL(e) {
					return e - this.entryPrice()
				}
				preparseStopPrice(e) {
					e = this._roundPrice(e);
					var t = this.entryPrice() - 1 / this._model.mainSeries().base();
					return Math.min(e, t)
				}
				preparseProfitPrice(e) {
					e = this._roundPrice(e);
					var t = this.entryPrice() + 1 / this._model.mainSeries().base();
					return Math.max(e, t)
				}
				checkStopPrice(e) {
					var t = this.stopPrice(),
						i = this.profitPrice();
					return e[TradingView.LOW_PLOT] <= t ? this.stopPrice() : e[TradingView.HIGH_PLOT] >= i ? this.profitPrice() : null
				}
				name() {
					return "Risk/Reward long"
				}
				_orderSide() {
					return d.BUY
				}
				static createProperties(e) {
					var t = new o("linetoolriskrewardlong", e);
					return f._configureProperties(t), t
				}
				static _configureProperties(e) {
					_._configureProperties(e)
				}
			}
			t.LineToolRiskRewardLong = f, t.LineToolRiskRewardShort = P
		},
		791983: (e, t, i) => {
			"use strict";
			var r = i(86441).Point,
				n = i(204652).distanceToLine,
				s = i(724145).LineDataSource,
				o = i(346090).DefaultProperty,
				l = i(424146).LineToolColorsProperty;
			class a extends s {
				constructor(e, t, r, n) {
					super(e, t || a.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 951282, 19)).then((({
						RotatedRectanglePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				startChanging(e, t) {
					if (super.startChanging(e, t), 0 === e || 1 === e) {
						var i = this._getPaneViews()[0],
							r = i._points[0],
							s = i._points[1],
							o = i._points[2];
						this._distance = n(r, s, o).distance
					}
				}
				setPoint(e, t, i) {
					if (super.setPoint(e, t, i), 0 === e || 1 === e) {
						var n = this._getPaneViews()[0];
						n.update();
						var s = n._points[0],
							o = n._points[1].subtract(s),
							l = new r(o.y, -o.x).normalized().scaled(this._distance),
							a = s.add(l),
							c = this.screenPointToPoint(a);
						this._points[2] = c
					}
				}
				endChanging(e, t) {
					delete this._distance, super.endChanging(e, t)
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Rotated Rectangle"
				}
				hasEditableCoordinates() {
					return !1
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 880717))).GeneralFiguresDefinitionsViewModel
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				static createProperties(e) {
					var t = new o("linetoolrotatedrectangle", e);
					return a._configureProperties(t), t
				}
				static _configureProperties(e) {
					s._configureProperties(e), e.addChild("linesColors", new l([e.color]))
				}
			}
			t.LineToolRotatedRectangle = a
		},
		173758: (e, t, i) => {
			"use strict";
			var r = i(755827).LevelsProperty,
				n = i(119310).LineToolPitchfork;
			class s extends n {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				name() {
					return "Modified Schiff Pitchfork"
				}
				static createProperties(e) {
					var t = new r("linetoolschiffpitchfork", e, !1, {
						range: [0, 8]
					});
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					n._configureProperties(e)
				}
			}
			t.LineToolSchiffPitchfork = s
		},
		792621: (e, t, i) => {
			"use strict";
			var r = i(755827).LevelsProperty,
				n = i(119310).LineToolPitchfork;
			class s extends n {
				constructor(e, t, i, r) {
					super(e, t || s.createProperties(), i, r)
				}
				name() {
					return "Schiff Pitchfork"
				}
				static createProperties(e) {
					var t = new r("linetoolschiffpitchfork2", e, !1, {
						range: [0, 8]
					});
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					n._configureProperties(e)
				}
			}
			t.LineToolSchiffPitchfork2 = s
		},
		706029: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolSignpost: () => _
			});
			var r = i(575932),
				n = i(346090),
				s = i(724145),
				o = i(232567),
				l = i.n(o);
			class a extends(l()) {
				constructor(e) {
					super(), this._source = e, e.pointAdded().subscribe(this, (() => this.listeners().fire(this))), e.pointChanged().subscribe(this, (() => this.listeners().fire(this)))
				}
				value() {
					const e = this._source.properties().childs().position.value();
					return parseFloat(e.toFixed(2))
				}
				setValue(e) {
					this._source.properties().childs().position.setValue(e), this._source.model().updateSource(this._source), this.listeners().fire(this), this._source.syncMultichartState({
						pricesChanged: !1,
						indexesChanged: !1
					})
				}
			}
			var c = i(839916);
			class u extends c.LineDataSourcePointIndexProperty {
				constructor(e, t) {
					super(e, t), this._source = e
				}
				_setPointImpl(e) {
					this._source.setPointAndChangeIndex(this._pointIndex, e)
				}
			}
			var h = i(424146),
				d = i(674993),
				p = i(633156);
			class _ extends d.LineToolWithRelativePriceCoordinate {
				constructor(e, t, r, n) {
					super(e, null != t ? t : _.createProperties(), r, n), this._image = null, this._currentImageURL = null, this._imageReady = !1, this._updateImage(), this.properties().childs().emoji.subscribe(this, (() => this._updateImage())), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 50743)).then((t => {
						this._setPaneViews([new t.SignpostPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Signpost"
				}
				customEvent() {
					return {
						index: () => {
							var e, t;
							return null !== (t = null === (e = this.points()[0]) || void 0 === e ? void 0 : e.index) && void 0 !== t ? t : null
						},
						position: () => this.properties().childs().position.value()
					}
				}
				image() {
					return this._imageReady && this.properties().childs().showImage.value() ? this._image : null
				}
				showInObjectTree() {
					return !this.isPhantom() && super.showInObjectTree()
				}
				isPhantom() {
					return this._model.isPhantomLine(this)
				}
				clonePositionOffset() {
					return {
						barOffset: 1,
						xCoordOffset: 0,
						yCoordOffset: 0
					}
				}
				template() {
					const e = super.template(),
						t = this.properties().childs();
					return e.text = t.text.value(), e.position = t.position.value(), e
				}
				shouldBeRemovedOnDeselect() {
					const e = this._properties.childs();
					if (e.showImage.value()) return !1;
					return "" === e.text.value().trim()
				}
				static createProperties(e) {
					const t = new n.DefaultProperty("linetoolsignpost", e);
					return _._configureProperties(t), t.hasChild("text") || t.addChild("text", new(l())((0, r.t)("Text"))), t.hasChild("position") || t.addChild("position", new(l())(50)), t.addExclusion("text"), t.addExclusion("position"), t.addChild("backgroundsColors", new h.LineToolColorsProperty([t.childs().plateColor])), t
				}
				_createPointProperty(e) {
					super._createPointProperty(e);
					const t = this._pointsProperty.childs().points[e];
					t.removeProperty("price"), t.removeProperty("bar"), t.addChild("price", new a(this)), t.addChild("bar", new u(this, 0))
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text), this.properties().childs().position.setValue(e.position)
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 911951)).then((e => e.SignpostDefinitionsViewModel))
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e)
				}
				_updateImage() {
					const e = this._imageURL();
					if (this._currentImageURL !== e && (this._currentImageURL = e, this._image = null, this._imageReady = !1, null !== this._currentImageURL)) {
						const e = new Image;
						this._image = e, e.onload = () => {
							this._imageReady = !0, this._model.updateSource(this), e.onload = null
						}, e.crossOrigin = "anonymous", e.src = this._currentImageURL
					}
				}
				_imageURL() {
					const e = this.properties().childs().emoji.value();
					return (0, p.getTwemojiUrl)(e, "png") || null
				}
			}
			_.supportPhantomMode = !0
		},
		210646: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolSineLine: () => s
			});
			var r = i(346090),
				n = i(724145);
			class s extends n.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || s.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 410039)).then((e => {
						this._setPaneViews([new e.SineLinePaneView(this, this._model)])
					}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Sine Line"
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolsineline", e);
					return s._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 664500))).CyclicAndSineLinesPatternDefinitionsViewModel
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e)
				}
			}
		},
		491458: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolText: () => d,
				LineToolTextAbsolute: () => p
			});
			var r = i(588537),
				n = i(86441),
				s = i(575932),
				o = i(724145),
				l = i(232567),
				a = i.n(l),
				c = i(346090),
				u = i(424146),
				h = i(194459);
			class d extends o.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || d.createProperties();
					super(e, s, r, n), this._barSpacing = e.timeScale().barSpacing(), this._recalculatePointsOnCenter = !1, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 38710)).then((({
						TextPaneView: t
					}) => {
						const i = this._recalculatePointsOnCenter ? (e, t) => {
							this._recalculatePointsOnCenter && this._recalculateCenterPosition(e, t)
						} : void 0;
						this._setPaneViews([new t(this, e, void 0, void 0, void 0, void 0, void 0, i)])
					}))
				}
				centerPosition() {
					this._recalculatePointsOnCenter = !0
				}
				setPoint(e, t, i) {
					const r = this.properties().childs();
					let n;
					if (1 === e && r.wordWrapWidth.value()) {
						const e = this.model().timeScale();
						n = this.isFixed() ? this.fixedPoints()[0].x : e.indexToCoordinate(this.points()[0].index);
						const i = e.indexToCoordinate(t.index) - n - ~~(r.fontsize.value() / 6);
						if (!isFinite(i)) return;
						r.wordWrapWidth.setValue(Math.max(100, i))
					}
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Text"
				}
				setPriceScale(e) {
					super.setPriceScale(e), e && e.priceRange() && (this._priceDencity = e.height() / (0, r.ensureNotNull)(e.priceRange()).length(), this._isPriceDencityLog = e.isLog())
				}
				restoreSize() {
					const e = (0, r.ensureNotNull)(this.priceScale());
					this._barSpacing = this.model().timeScale().barSpacing(), this._priceDencity = e.height() / (0, r.ensureNotNull)(e.priceRange()).length(), this.redraw((0, h.dataSourceChangeEvent)(this.id()))
				}
				redraw(e) {
					this.updateAllViews(e), this._model.updateSource(this)
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				state(e) {
					const t = super.state(e);
					return e && (t.state.fixedSize = !1), t
				}
				barSpacing() {
					return this._barSpacing
				}
				priceDencity() {
					return this._priceDencity
				}
				isPriceDencityLog() {
					return this._isPriceDencityLog
				}
				hasEditableCoordinates() {
					return !1
				}
				shouldBeRemovedOnDeselect() {
					return "" === this._properties.childs().text.value().trim()
				}
				static createProperties(e) {
					const t = new c.DefaultProperty("linetooltext", e);
					return d._configureProperties(t), t
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text)
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 923603)).then((e => e.TextDefinitionsViewModel))
				}
				static _configureProperties(e) {
					o.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(a())((0, s.t)("Text"))), e.addChild("linesColors", new u.LineToolColorsProperty([e.childs().borderColor])), e.addChild("textsColors", new u.LineToolColorsProperty([e.childs().color])), e.addExclusion("text"), e.addExclusion("linesColors"), e.addExclusion("textsColors")
				}
				_recalculateCenterPosition(e, t) {
					const i = this.isFixed() ? this.fixedPoints()[0] : (0, r.ensureNotNull)(this.pointToScreenPoint(this._points[0])),
						s = new n.Point(i.x - e / 2, i.y - t / 2),
						o = (0, r.ensureNotNull)(this.screenPointToPoint(s));
					this.setPoints([o]), this.normalizePoints(), this.createServerPoints(), this.redraw((0, h.dataSourceChangeEvent)(this.id()))
				}
			}
			class p extends d {
				constructor(e, t) {
					super(e, t || p.createProperties())
				}
				name() {
					return "Anchored Text"
				}
				hasEditableCoordinates() {
					return !1
				}
				isFixed() {
					return !0
				}
				static createProperties(e) {
					const t = new c.DefaultProperty("linetooltextabsolute", e);
					return p._configureProperties(t), t
				}
				static _configureProperties(e) {
					d._configureProperties(e)
				}
			}
		},
		452078: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolThreeDrivers: () => o
			});
			var r = i(346090),
				n = i(724145),
				s = i(424146);
			class o extends n.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || o.createProperties();
					super(e, s, r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 755148)).then((t => {
						this._setPaneViews([new t.LineToolThreeDrivesPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 7
				}
				name() {
					return "Three Drives Pattern"
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolthreedrivers", e);
					return o._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 587412)).then((e => e.PatternWithoutBackgroundDefinitionsViewModel))
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e), e.addChild("linesColors", new s.LineToolColorsProperty([e.childs().color])), e.addChild("textsColors", new s.LineToolColorsProperty([e.childs().textcolor])), e.addChild("linesWidths", new s.LineToolWidthsProperty([e.childs().linewidth])), e.hasChild("backgroundsColors") && e.removeProperty("backgroundsColors")
				}
			}
		},
		124214: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(346090).DefaultProperty;
			class s extends r {
				constructor(e, t, r, n) {
					super(e, t || s.createProperties(), r, n),
						Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 64806, 19)).then((({
							TimeCyclesPaneView: e
						}) => {
							this._setPaneViews([new e(this, this._model)])
						}))
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Time Cycles"
				}
				setPoint(e, t, i) {
					var r = Object.assign({}, t),
						n = this._points[0],
						s = this._points[1];
					n.price = r.price, s.price = r.price, this._points[e] = r, this.normalizePoints()
				}
				addPoint(e, t, i) {
					var n = r.prototype.addPoint.call(this, e, t, !0);
					if (n) {
						var s = this._points[0];
						this._points[1].price = s.price, i || (this.normalizePoints(), this.createServerPoints())
					}
					return n
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 646423))).TimeCyclesPatternDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetooltimecycles", e);
					return s._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			t.LineToolTimeCycles = s
		},
		157759: (e, t, i) => {
			"use strict";
			const r = i(724145).LineDataSource,
				n = i(20006).alignToStep;
			class s extends r {
				constructor(e, t) {
					super(e, t), this.customization.forcePriceAxisLabel = !0, this.customization.disableErasing = !0, this.customization.showInObjectsTree = !1, this.setSelectionEnabled(!1)
				}
				isSynchronizable() {
					return !1
				}
				pointsCount() {
					return s.POINTS_COUNT
				}
				hasContextMenu() {
					return !1
				}
				state() {
					return null
				}
				startMoving() {
					r.prototype.startMoving.apply(this, arguments), this._cursorMoved = !1
				}
				endMoving() {
					r.prototype.endMoving.apply(this, arguments), this._cursorMoved = !1
				}
				_correctPoints(e, t) {
					this._currentMovingPoint && this._startMovingPoint ? this._currentMovingPoint.logical.price - this._startMovingPoint.logical.price && (this._cursorMoved = !0) : this._cursorMoved = !1;
					for (var i = 1 / this.priceScale().mainSource().base(), r = 0; r < e.length; r++) {
						var s = e[r];
						this._cursorMoved && (s.price = this._currentMovingPoint.logical.price), s.price = n(s.price, i), e[r] = s
					}
				}
				userEditEnabled() {
					return !0
				}
				movable() {
					return !1
				}
				canBeHidden() {
					return !1
				}
				isUserDeletable() {
					return !1
				}
				showInObjectTree() {
					return !1
				}
				doesMovingAffectsUndo() {
					return !1
				}
				isAvailableInFloatingWidget() {
					return !1
				}
				timeAxisViews() {
					return null
				}
				cloneable() {
					return !1
				}
				copiable() {
					return !1
				}
				static _configureProperties(e) {
					r._configureProperties(e)
				}
			}
			s.POINTS_COUNT = 1, e.exports.LineToolTrading = s
		},
		409304: (e, t, i) => {
			"use strict";
			var r = i(232567),
				n = i(86441).Point,
				s = i(724145).LineDataSource,
				o = i(346090).DefaultProperty;
			class l extends r {
				constructor(e) {
					super(), this._lineSource = e
				}
				value() {
					var e = 180 * this._lineSource._angle / Math.PI;
					return Math.round(e)
				}
				setValue(e) {
					var t = e * Math.PI / 180;
					this._lineSource._angle = t;
					var i = this._lineSource.pointToScreenPoint(this._lineSource.points()[0]),
						r = Math.cos(this._lineSource._angle),
						s = -Math.sin(this._lineSource._angle),
						o = new n(r, s),
						l = i.addScaled(o, this._lineSource._distance),
						a = this._lineSource.screenPointToPoint(l);
					this._lineSource._points[1] = a, this._lineSource._model.updateSource(this._lineSource), this._lineSource.updateAllViews(), this._lineSource._model.updateSource(this._lineSource)
				}
			}
			class a extends s {
				constructor(e, t, r, n) {
					super(e, t || a.createProperties(), r, n), this._properties.addChild("angle", new l(this)),
						Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 288878, 19)).then((({
							TrendAnglePaneView: e
						}) => {
							this._setPaneViews([new e(this, this._model)])
						}))
				}
				isSynchronizable() {
					return !1
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Trend Angle"
				}
				_calculateAngle() {
					var e = this.pointToScreenPoint(this.points()[0]),
						t = this.pointToScreenPoint(this.points()[1]),
						i = t.subtract(e);
					i.length() > 0 ? (i = i.normalized(), this._angle = Math.acos(i.x), i.y > 0 && (this._angle = -this._angle), this._distance = t.subtract(e).length()) : delete this._angle, this.properties().hasOwnProperty("angle") && this.properties().angle.listeners().fire(this.properties().angle)
				}
				addPoint(e, t) {
					var i = s.prototype.addPoint.call(this, e, t);
					return i && this._calculateAngle(), i
				}
				setLastPoint(e, t) {
					var i = super.setLastPoint(e, t);
					return this.points().length > 1 && this._calculateAngle(), i
				}
				axisPoints() {
					if (this.points().length < 2) return [];
					var e = [this.points()[0]],
						t = this.pointToScreenPoint(this.points()[0]),
						i = Math.cos(this._angle) * this._distance,
						r = -Math.sin(this._angle) * this._distance,
						s = t.add(new n(i, r)),
						o = this.screenPointToPoint(s);
					return e.push(o), e
				}
				setPoint(e, t, i) {
					super.setPoint(e, t, i), this.points().length > 1 && 1 === e && this._calculateAngle()
				}
				restoreData(e) {
					this._angle = e.angle, this._distance = e.distance
				}
				state(e) {
					var t = s.prototype.state.call(this, e);
					return t.angle = this._angle, t.distance = this._distance, t
				}
				cloneData(e) {
					this._angle = e._angle, this._distance = e._distance
				}
				canHasAlert() {
					return !0
				}
				_getAlertPlots() {
					return [this._linePointsToAlertPlot(this._points, null, this.properties().extendLeft.value(), this.properties().extendRight.value())]
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 669598))).TrendAngleDefinitionsViewModel
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				static createProperties(e) {
					var t = new o("linetooltrendangle", e);
					return a._configureProperties(t), t
				}
				static _configureProperties(e) {
					s._configureProperties(e)
				}
			}
			t.LineToolTrendAngle = a
		},
		451848: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolTrendBasedFibExtension: () => c
			});
			var r = i(575932),
				n = i(277036),
				s = i(755827),
				o = i(424146),
				l = i(724145);
			const a = new n.TranslatedString("erase level line", (0, r.t)("erase level line"));
			class c extends l.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), this.version = 2, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 160063)).then((({
						TrendBasedFibExtensionPaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return 24
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Trend-Based Fib Extension"
				}
				migrateVersion(e, t) {
					1 === e && this.properties().childs().extendLines.setValue(!0)
				}
				processErase(e, t) {
					const i = "level" + t,
						r = this.properties().childs()[i].childs().visible;
					e.setProperty(r, !1, a)
				}
				fibLevelsBasedOnLogScale() {
					var e;
					return this.properties().childs().fibLevelsBasedOnLogScale.value() && Boolean(null === (e = this.priceScale()) || void 0 === e ? void 0 : e.isLog())
				}
				static createProperties(e) {
					const t = new s.LevelsProperty("linetooltrendbasedfibextension", e, !1, {
						range: [0, 8]
					});
					return c._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 726457))).FibDrawingsWith24LevelsDefinitionsViewModel
				}
				static _configureProperties(e) {
					const t = e.childs();
					l.LineDataSource._configureProperties(e);
					const i = [t.trendline.childs().color];
					for (let e = 1; e <= 24; e++) {
						const r = t["level" + e].childs().color;
						i.push(r)
					}
					e.addChild("linesColors", new o.LineToolColorsProperty(i));
					const r = [t.trendline.childs().linewidth, t.levelsStyle.childs().linewidth];
					e.addChild("linesWidths", new o.LineToolWidthsProperty(r))
				}
			}
		},
		821564: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolTrendBasedFibTime: () => c
			});
			var r = i(575932),
				n = i(277036),
				s = i(724145),
				o = i(755827),
				l = i(424146);
			const a = new n.TranslatedString("erase level line", (0, r.t)("erase level line"));
			class c extends s.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || c.createProperties(), r, n), this.version = 1, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 794836)).then((({
						TrendBasedFibTimePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				levelsCount() {
					return 11
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Trend-Based Fib Time"
				}
				processErase(e, t) {
					const i = "level" + t,
						r = this.properties().childs()[i].childs().visible;
					e.setProperty(r, !1, a)
				}
				static createProperties(e) {
					const t = new o.LevelsProperty("linetooltrendbasedfibtime", e, !1, {
						range: [1, 11]
					});
					return c._configureProperties(t), t
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 493955))).TrendBasedFibTimeDefinitionsViewModel
				}
				static _configureProperties(e) {
					s.LineDataSource._configureProperties(e);
					const t = e.childs(),
						i = [t.trendline.childs().linewidth],
						r = [t.trendline.childs().color];
					for (let e = 1; e <= 11; e++) i.push(t["level" + e].childs().linewidth), r.push(t["level" + e].childs().color);
					e.addChild("linesColors", new l.LineToolColorsProperty(r)), e.addChild("linesWidths", new l.LineToolWidthsProperty(i))
				}
			}
		},
		439195: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolTrendLine: () => a
			});
			var r = i(346090),
				n = i(724145),
				s = i(171073),
				o = i(232567),
				l = i.n(o);
			class a extends n.LineDataSource {
				constructor(e, t, r, n) {
					super(e, t || a.createProperties(), r, n), this._trendLinePaneView = null, Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 106320)).then((({
						TrendLinePaneView: e
					}) => {
						this._trendLinePaneView = new e(this, this._model), this._setPaneViews([this._trendLinePaneView])
					}))
				}
				dataAndViewsReady() {
					return super.dataAndViewsReady() && null !== this._trendLinePaneView && this._trendLinePaneView.iconsReady()
				}
				pointsCount() {
					return 2
				}
				name() {
					return "Trend Line"
				}
				canHasAlert() {
					return !0
				}
				showPriceLabels() {
					return this._properties.childs().showPriceLabels.value()
				}
				createPriceAxisView(e) {
					return new s.LineToolPriceAxisView(this, {
						pointIndex: e,
						backgroundPropertyGetter: () => this.showPriceLabels() ? this._properties.childs().linecolor.value() : null
					})
				}
				isForcedDrawPriceAxisLabel() {
					return this.showPriceLabels()
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetooltrendline", e);
					return a._configureProperties(t), t
				}
				_getAlertPlots() {
					return [this._linePointsToAlertPlot(this._points, null, this._properties.childs().extendLeft.value(), this._properties.childs().extendRight.value())]
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 561354))).TrendLineDefinitionsViewModel
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text || "")
				}
				_snapTo45DegreesAvailable() {
					return !0
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(l())("")), e.addExclusion("text")
				}
			}
		},
		679963: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolTrianglePattern: () => o
			});
			var r = i(346090),
				n = i(724145),
				s = i(424146);
			class o extends n.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || o.createProperties();
					super(e, s, r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 35336)).then((t => {
						this._setPaneViews([new t.LineToolTrianglePatternPaneView(this, e)])
					}))
				}
				pointsCount() {
					return 4
				}
				name() {
					return "Triangle Pattern"
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetooltrianglepattern", e);
					return o._configureProperties(t), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 949902)).then((e => e.PatternWithBackgroundDefinitionViewModel))
				}
				static _configureProperties(e) {
					n.LineDataSource._configureProperties(e), e.addChild("linesColors", new s.LineToolColorsProperty([e.childs().color])), e.addChild("textsColors", new s.LineToolColorsProperty([e.childs().textcolor])), e.addChild("backgroundsColors", new s.LineToolColorsProperty([e.childs().backgroundColor]))
				}
			}
		},
		953077: (e, t, i) => {
			"use strict";
			var r = i(724145).LineDataSource,
				n = i(346090).DefaultProperty,
				s = i(424146).LineToolColorsProperty;
			class o extends r {
				constructor(e, t, r, n) {
					super(e, t || o.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.t.bind(i, 773528, 19)).then((({
						TrianglePaneView: e
					}) => {
						this._setPaneViews([new e(this, this._model)])
					}))
				}
				pointsCount() {
					return 3
				}
				name() {
					return "Triangle"
				}
				async _getPropertyDefinitionsViewModelClass() {
					return (await Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 880717))).GeneralFiguresDefinitionsViewModel
				}
				static createProperties(e) {
					var t = new n("linetooltriangle", e);
					return o._configureProperties(t), t
				}
				static _configureProperties(e) {
					r._configureProperties(e), e.addChild("linesColors", new s([e.childs().color]))
				}
			}
			t.LineToolTriangle = o
		},
		54013: (e, t, i) => {
			"use strict";
			i.d(t, {
				isTwitterUrl: () => a,
				isTwitterProfileImageUrl: () => c,
				createTweetLineToolByUrl: () => u
			});
			var r = i(588537),
				n = i(62802),
				s = i(95935),
				o = i(694755),
				l = i(104129);

			function a(e) {
				try {
					const t = new URL(e);
					return ("twitter.com" === t.hostname || t.hostname.endsWith(".twitter.com")) && "https:" === t.protocol
				} catch (e) {
					return !1
				}
			}

			function c(e) {
				try {
					const t = new URL(e);
					return "pbs.twimg.com" === t.hostname && "https:" === t.protocol && t.pathname.startsWith("/profile_images/")
				} catch (e) {
					return !1
				}
			}

			function u(e, t, i = !1) {
				return async function(e) {
					const t = new URL("/api/v1/get-tweet-data/", location.href);
					return t.searchParams.append("tweet_url", e),
						fetch(t.toString()).then((e => {
							if (!e.ok) throw new Error(`Error processing tweet: ${e.statusText}`);
							return e.json()
						}))
				}(e).then((a => {
					const c = function(e, t) {
							var i;
							return {
								id: e.id,
								createdAt: e.created_at,
								text: (0, o.clean)(e.text, !0),
								username: `@${e.username}`,
								user: e.user,
								profileImageUrl: e.profile_image_url,
								hashtags: e.hashtags.join(" "),
								tweetUrl: null !== (i = e.tweet_url) && void 0 !== i ? i : t
							}
						}(a, e),
						u = {
							price: 0,
							time_t: c.createdAt,
							offset: 0
						},
						h = t.mainSeries(),
						d = (0, r.ensureNotNull)(t.model().paneForSource(h)),
						p = d.newLineToolZOrder(!0),
						_ = {
							type: "drawing",
							source: {
								id: (0, s.randomHashN)(6),
								zorder: p,
								type: "LineToolTweet",
								position: 50,
								state: {
									interval: "1",
									...l.LineToolTweet.createProperties().state()
								},
								tweetData: c,
								symbol: h.symbol(),
								ownerSource: h.id(),
								points: [u]
							},
							geometry: [],
							modelId: t.model().id()
						},
						P = t.pasteLineTool(d, _, !0, !0);
					return i && n.setValue("hint.pasteTweet", !0, {
						forceFlush: !0
					}), P.pointAdded().subscribe(null, (() => t.scrollToLineTool(P)), !0), P
				}))
			}
		},
		104129: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolTweet: () => S
			});
			var r = i(346090),
				n = i(575932),
				s = i(62802),
				o = i(345848),
				l = i(911905),
				a = i(846778),
				c = i(63208),
				u = i(308170),
				h = i(676553),
				d = i(54013);
			const p = (0, l.getLogger)("Chart.TweetDialog"),
				_ = (0, n.t)("Tweet"),
				P = (0, n.t)("Insert a link to the tweet");
			let f = null;

			function g(e) {
				"LineToolTweet" === e ? (window.is_authenticated || (0, u.resetToCursor)(!0), window.runOrSignIn((() => {
					u.tool.setValue("LineToolTweet"), f = (0, h.showCustomUrlEventDialog)({
						onConfirm: v,
						onClose: () => {
							f = null, "LineToolTweet" === u.tool.value() && (0, u.resetToCursor)(!0)
						},
						title: _,
						placeholderText: P
					}), (0, o.trackEvent)("Tweet", "Open tweet dialog")
				}), {
					source: "Change drawing tool state"
				})) : null !== f && f.then((e => e()))
			}

			function v(e) {
				const t = (0, c.chartWidgetCollectionService)();
				if (null === t) return;
				if (!(0, d.isTwitterUrl)(e)) return void p.logWarn(`Invalid tweet url: ${e}`);
				const i = !Boolean(s.getBool("hint.pasteTweet")),
					r = t.activeChartWidget.value();
				(0, d.createTweetLineToolByUrl)(e, r.model()).then((() => {
					i && (0, a.showPasteLineToolHint)(t.getContainer(), "hint.pasteTweet")
				}))
			}
			var m = i(232567),
				C = i.n(m),
				y = i(513647);
			class T extends y.CustomEventItem {
				constructor(e, t) {
					super(t), this._data = e
				}
				tweetData() {
					return this._data
				}
				index() {
					return this._source.eventTimePointIndex()
				}
				time() {
					return this._data.createdAt
				}
				avatar() {
					return this._data.profileImageUrl
				}
			}
			class S extends y.LineToolCustomUrlEvent {
				constructor(e, t, r, n) {
					super(e, t || S.createProperties(), r, n), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 945513)).then((t => {
						this._setPaneViews([new t.TweetPaneView(this, e)])
					}))
				}
				name() {
					return "Tweet"
				}
				state(e) {
					const t = super.state(e);
					return this._item && (t.tweetData = this._item.tweetData()), e && (t.eventTimePointIndex = this._eventTimePointIndex), t
				}
				restoreData(e) {
					if (e.tweetData) {
						if (!(0, d.isTwitterUrl)(e.tweetData.tweetUrl)) throw new Error(`Invalid url for tweet line tool: ${e.tweetData.tweetUrl}`);
						this._item = new T(e.tweetData, this)
					}
					void 0 !== e.eventTimePointIndex && (this._eventTimePointIndex = e.eventTimePointIndex)
				}
				static createProperties(e) {
					const t = new r.DefaultProperty("linetoolTweet", e);
					return S._configureProperties(t),
						t.hasChild("position") || t.addChild("position", new(C())(50)), t.addExclusion("position"), t
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 940072)).then((e => e.TweetDefinitionsViewModel))
				}
			}(0, u.runOnDrawingStateReady)((() => {
				u.tool.subscribe(g)
			}))
		},
		444234: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolVertLineTimeAxisView: () => n
			});
			var r = i(652778);
			class n extends r.LineDataSourceTimeAxisView {
				constructor(e) {
					super(e, 0)
				}
				_getBgColor() {
					return this._source.properties().linecolor.value()
				}
				_getAlwaysInViewPort() {
					return !1
				}
				_getIndex() {
					const e = this._source.points();
					return 0 === e.length ? null : e[0].index
				}
			}
		},
		308374: (e, t, i) => {
			"use strict";
			i.d(t, {
				LineToolVertLine: () => u
			});
			var r = i(588537),
				n = i(86441),
				s = i(346090),
				o = i(232567),
				l = i.n(o),
				a = i(724145),
				c = i(444234);
			class u extends a.LineDataSource {
				constructor(e, t, r, n) {
					const s = t || u.createProperties();
					super(e, s, r, n), this._timeAxisView = new c.LineToolVertLineTimeAxisView(this), this._paneViewFactory = null, this.properties().childs().extendLine.subscribe(this, (() => e.lightUpdate())), Promise.all([i.e(93987), i.e(44572), i.e(51583)]).then(i.bind(i, 398954)).then((t => {
						this._paneViewFactory = i => new t.VertLinePaneView(this, e, i), this._model.lightUpdate()
					}))
				}
				destroy() {
					this.properties().childs().extendLine.unsubscribeAll(this), super.destroy()
				}
				pointsCount() {
					return 1
				}
				name() {
					return "Vertical Line"
				}
				timeAxisViews() {
					return this.isSourceHidden() ? null : this.properties().childs().showTime.value() ? [this._timeAxisView] : null
				}
				updateAllViews(e) {
					super.updateAllViews(e), this._timeAxisView.update(e)
				}
				canHasAlert() {
					return !0
				}
				template() {
					const e = super.template();
					return e.text = this.properties().childs().text.value(), e
				}
				isMultiPaneAvailable() {
					return !0
				}
				isMultiPaneEnabled() {
					return this.properties().childs().extendLine.value()
				}
				paneViews(e) {
					return e = (0, r.ensureDefined)(e), this.isMultiPaneEnabled() || this._model.paneForSource(this) === e ? (null === this._getPaneViews(e) && null !== this._paneViewFactory && this._setPaneViews([this._paneViewFactory(e)], e, !0), super.paneViews(e)) : null
				}
				priceAxisViews() {
					return null
				}
				priceAxisPoints() {
					return []
				}
				pointToScreenPoint(e) {
					const t = this._model.timeScale();
					if (t.isEmpty()) return null;
					const i = t.indexToCoordinate(e.index);
					return new n.Point(i, 0)
				}
				convertYCoordinateToPriceForMoving(e) {
					return 0
				}
				static createProperties(e) {
					null != e && (void 0 === e.textOrientation && (e.textOrientation = "horizontal"), void 0 === e.extendLine && (e.extendLine = !1));
					const t = new s.DefaultProperty("linetoolvertline", e);
					return u._configureProperties(t), t
				}
				_getAlertPlots() {
					const e = this._points[0],
						t = {
							index: e.index,
							price: e.price + 1
						};
					return [this._linePointsToAlertPlot([e, t], null, !0, !0)]
				}
				_getPropertyDefinitionsViewModelClass() {
					return Promise.all([i.e(39509), i.e(39261), i.e(18537)]).then(i.bind(i, 7022)).then((e => e.VerticalLineDefinitionsViewModel))
				}
				_applyTemplateImpl(e) {
					super._applyTemplateImpl(e), this.properties().childs().text.setValue(e.text || "")
				}
				static _configureProperties(e) {
					a.LineDataSource._configureProperties(e), e.hasChild("text") || e.addChild("text", new(l())("")), e.addExclusion("text")
				}
			}
		},
		194459: (e, t, i) => {
			"use strict";

			function r(e, t, i) {
				return {
					type: "data-source-change",
					dataSourceId: e,
					firstUpdatedTimePointIndex: t,
					clearData: i
				}
			}
			i.r(t), i.d(t, {
				dataSourceChangeEvent: () => r,
				globalChangeEvent: () => s,
				viewportChangeEvent: () => l,
				selectionChangeEvent: () => c
			});
			const n = {
				type: "global-change"
			};

			function s() {
				return n
			}
			const o = {
				type: "viewport-change"
			};

			function l() {
				return o
			}
			const a = {
				type: "selection-change"
			};

			function c() {
				return a
			}
		},
		87511: (e, t, i) => {
			"use strict";
			var r;
			i.d(t, {
					PaneCursorType: () => r
				}),
				function(e) {
					e[e.Default = 0] = "Default", e[e.Pointer = 1] = "Pointer", e[e.Eraser = 2] = "Eraser", e[e.Dot = 3] = "Dot", e[e.Grabbing = 4] = "Grabbing", e[e.ZoomIn = 5] = "ZoomIn", e[e.VerticalResize = 6] = "VerticalResize", e[e.HorizontalResize = 7] = "HorizontalResize", e[e.DiagonalNeSwResize = 8] = "DiagonalNeSwResize", e[e.DiagonalNwSeResize = 9] = "DiagonalNwSeResize"
				}(r || (r = {}))
		},
		164149: (e, t, i) => {
			"use strict";
			i.d(t, {
				clearRectWithGradient: () => o,
				fillRectInnerBorder: () => l,
				drawHorizontalLine: () => a,
				drawVerticalLine: () => c,
				drawRoundRect: () => h,
				drawRoundRectWithInnerBorder: () => d,
				fillRectWithBorder: () => p,
				createCircle: () => _
			});
			var r = i(86441),
				n = i(72461),
				s = i(831825);

			function o(e, t, i, r, n, s, o) {
				e.save(), e.globalCompositeOperation = "copy";
				const l = e.createLinearGradient(0, 0, 0, n);
				l.addColorStop(0, s), l.addColorStop(1, o), e.fillStyle = l, e.fillRect(t, i, r, n), e.restore()
			}

			function l(e, t, i, r, n, s) {
				e.fillRect(t + s, i, r - 2 * s, s), e.fillRect(t + s, i + n - s, r - 2 * s, s), e.fillRect(t, i, s, n), e.fillRect(t + r - s, i, s, n)
			}

			function a(e, t, i, r) {
				e.beginPath();
				const n = e.lineWidth % 2 ? .5 : 0;
				e.moveTo(i, t + n), e.lineTo(r, t + n), e.stroke()
			}

			function c(e, t, i, r) {
				e.beginPath();
				const n = e.lineWidth % 2 ? .5 : 0;
				e.moveTo(t + n, i), e.lineTo(t + n, r), e.stroke()
			}

			function u(e, t) {
				return Array.isArray(e) ? e.map((e => 0 === e ? e : e + t)) : e + t
			}

			function h(e, t, i, r, n, s, o) {
				let l, a, c, u;
				if (Array.isArray(s))
					if (2 === s.length) {
						const e = Math.max(0, s[0]),
							t = Math.max(0, s[1]);
						l = e, a = e, c = t, u = t
					} else {
						if (4 !== s.length) throw new Error("Wrong border radius - it should be like css border radius");
						l = Math.max(0, s[0]), a = Math.max(0, s[1]), c = Math.max(0, s[2]), u = Math.max(0, s[3])
					}
				else {
					const e = Math.max(0, s);
					l = e, a = e, c = e, u = e
				}
				o || e.beginPath(), e.moveTo(t + l, i), e.lineTo(t + r - a, i), 0 !== a && e.arcTo(t + r, i, t + r, i + a, a), e.lineTo(t + r, i + n - c), 0 !== c && e.arcTo(t + r, i + n, t + r - c, i + n, c), e.lineTo(t + u, i + n), 0 !== u && e.arcTo(t, i + n, t, i + n - u, u), e.lineTo(t, i + l), 0 !== l && e.arcTo(t, i, t + l, i, l)
			}

			function d(e, t, i, r, o, l, a = 0, c = 0, d = "", p = s.LineStyle.Solid) {
				if (e.save(), !c || !d || d === l) return h(e, t, i, r, o, a), e.fillStyle = l, e.fill(), void e.restore();
				const _ = c / 2;
				if ("transparent" !== l) {
					const n = "transparent" !== d && p !== s.LineStyle.Solid;
					h(e, n ? t : t + c, n ? i : i + c, n ? r : r - 2 * c, n ? o : o - 2 * c, n ? a : u(a, -c)), e.fillStyle = l, e.fill()
				}
				if ("transparent" !== d) {
					h(e, t + _, i + _, r - c, o - c, u(a, -_)), e.lineWidth = c, e.strokeStyle = d, (0, n.setLineStyle)(e, p), e.closePath(), e.stroke()
				}
				e.restore()
			}

			function p(e, t, i, s, o, l, a, c, u, h, d, p, _, P, f) {
				const g = h ? 0 : t,
					v = d ? _ : s;
				if (void 0 !== l && (e.fillStyle = l, e.fillRect(g, i, v - g + P, o - i)), void 0 !== a && c > 0) {
					if (e.beginPath(), (0, n.setLineStyle)(e, u), void 0 !== f) {
						const t = f.map((e => e * c));
						(0, n.setLineDash)(e, t)
					}
					let l = (0, r.point)(0, 0),
						h = (0, r.point)(0, 0),
						d = (0, r.point)(0, 0),
						_ = (0, r.point)(0, 0);
					switch (p) {
						case "outer": {
							const e = .5 * c;
							d = (0,
								r.point)(0, e), _ = (0, r.point)(0, e), l = (0, r.point)(e, -c), h = (0, r.point)(e, -c);
							break
						}
						case "center": {
							const e = c % 2 ? .5 : 0,
								t = c % 2 ? .5 : P;
							d = (0, r.point)(.5 * c - e, -e), _ = (0, r.point)(t + .5 * c, -e), l = (0, r.point)(-e, e + .5 * c), h = (0, r.point)(t, e + .5 * c);
							break
						}
						case "inner": {
							const e = .5 * c;
							d = (0, r.point)(0, -e), _ = (0, r.point)(1, -e), l = (0, r.point)(-e, c), h = (0, r.point)(1 - e, c);
							break
						}
					}
					e.lineWidth = c, e.strokeStyle = a, e.moveTo(g - d.x, i - d.y), e.lineTo(v + _.x, i - _.y), e.moveTo(s + h.x, i + h.y), e.lineTo(s + h.x, o - h.y), e.moveTo(g - d.x, o + d.y), e.lineTo(v + _.x, o + _.y), e.moveTo(t - l.x, i + l.y), e.lineTo(t - l.x, o - l.y), e.stroke()
				}
			}

			function _(e, t, i, r) {
				e.beginPath(), e.arc(t, i, r, 0, 2 * Math.PI, !1), e.closePath()
			}
		},
		601132: (e, t, i) => {
			"use strict";
			i.d(t, {
				extendAndClipLineSegment: () => u,
				getArrowPoints: () => h,
				optimalBarWidth: () => d,
				optimalCandlestickWidth: () => p,
				optimalHiLoWidth: () => _,
				interactionTolerance: () => P,
				coordinateIsValid: () => f,
				setValidLineStyle: () => g,
				fillScaledRadius: () => v,
				strokeScaledRadius: () => m
			});
			var r = i(86441),
				n = i(5531),
				s = i(420808),
				o = i(270617),
				l = i(72461);
			const a = {
					line: 13,
					minDistanceBetweenPoints: 10,
					series: 14,
					curve: 10,
					anchor: 13,
					esd: 4
				},
				c = {
					line: 3,
					minDistanceBetweenPoints: 5,
					series: 2,
					curve: 3,
					anchor: 2,
					esd: 0
				};

			function u(e, t, i, s, o, l) {
				if ((0, r.equalPoints)(e, t)) return null;
				const a = new r.Point(0, 0),
					c = new r.Point(i, s);
				if (o) {
					if (l) {
						const i = (0, n.intersectLineAndBox)((0, r.lineThroughPoints)(e, t), (0, r.box)(a, c));
						return Array.isArray(i) ? i : null
					} {
						const i = (0, n.intersectRayAndBox)(t, e, (0, r.box)(a, c));
						return null === i || (0, r.equalPoints)(t, i) ? null : (0, r.lineSegment)(t, i)
					}
				}
				if (l) {
					const i = (0, n.intersectRayAndBox)(e, t, (0, r.box)(a, c));
					return null === i || (0, r.equalPoints)(e, i) ? null : (0, r.lineSegment)(e, i)
				} {
					const i = (0, n.intersectLineSegmentAndBox)((0, r.lineSegment)(e, t), (0, r.box)(a, c));
					return Array.isArray(i) ? i : null
				}
			}

			function h(e, t, i, r) {
				const n = .5 * i,
					s = Math.sqrt(2),
					o = t.subtract(e),
					l = o.normalized();
				let a = 5 * i;
				r && (a = Math.min(a, .35 * o.length()));
				const c = 1 * n;
				if (a * s * .2 <= c) return [];
				const u = l.scaled(a),
					h = t.subtract(u),
					d = l.transposed(),
					p = 1 * a,
					_ = d.scaled(p),
					P = h.add(_),
					f = h.subtract(_),
					g = P.subtract(t).normalized().scaled(c),
					v = f.subtract(t).normalized().scaled(c),
					m = t.add(g),
					C = t.add(v),
					y = n * (s - 1),
					T = d.scaled(y),
					S = Math.min(a - 1 * n / s, n * s * 1),
					w = l.scaled(S),
					b = t.subtract(T),
					x = t.add(T),
					L = t.subtract(w);
				return [
					[P, m],
					[f, C],
					[b, L.subtract(T)],
					[x, L.add(T)]
				]
			}

			function d(e, t) {
				return t = t || 1, Math.floor(.3 * e * t)
			}

			function p(e, t) {
				if (e >= 2.5 && e <= 4) return Math.floor(3 * t);
				const i = 1 - .2 * Math.atan(Math.max(4, e) - 4) / (.5 * Math.PI),
					r = Math.floor(e * i * t),
					n = Math.floor(e * t),
					s = Math.min(r, n);
				return Math.max(Math.floor(t), s)
			}

			function _(e) {
				return .4 * e
			}

			function P() {
				return (0, s.lastMouseOrTouchEventInfo)().isTouch ? a : c
			}

			function f(e) {
				return null != e && !(0, o.isNaN)(e)
			}

			function g(e, t) {
				void 0 !== t && (0, l.setLineStyle)(e, t)
			}

			function v(e, t) {
				const i = Math.max(1, Math.floor(t)) % 2 ? .5 : 0;
				return Math.round(e * t) + i
			}

			function m(e, t, i) {
				const r = Math.max(1, Math.floor(t)) % 2 ? .5 : 0;
				return Math.round(e * t) + (r !== i % 2 ? .5 : 0)
			}
		},
		534953: (e, t, i) => {
			"use strict";
			i.d(t, {
				sortSourcesPreOrdered: () => r,
				sortSources: () => n
			});
			const r = {
				ChartEventsSource: 10000001,
				Dividends: 10000002,
				Splits: 10000003,
				Earnings: 10000004,
				RollDates: 10000005,
				LineToolOrder: 10000006,
				LineToolPosition: 10000007,
				LineToolExecution: 10000008,
				AlertLabel: 10000009
			};

			function n(e) {
				return [...e].sort(((e, t) => e.zorder() - t.zorder()))
			}
		},
		498424: (e, t, i) => {
			"use strict";
			i.d(t, {
				PriceAxisView: () => p
			});
			var r = i(86441),
				n = i(934026),
				s = i(420808),
				o = i(721386),
				l = i(143498),
				a = i(824112),
				c = i(218718),
				u = i(164149),
				h = i(87511);
			class d {
				constructor(e, t) {
					this.setData(e, t)
				}
				setData(e, t) {
					this._data = e, this._commonData = t
				}
				draw(e, t, i, r, n, s, c) {
					var h, d, p;
					const _ = this._data;
					if (!_.visible || this._isOutOfScreen(t, n)) return;
					const P = this._commonData,
						f = void 0 !== _.labelIcon,
						g = _.ignoreOffset ? 0 : t.offsetSize,
						v = t.borderSize,
						m = t.paddingTop + P.additionalPaddingTop,
						C = t.paddingBottom + P.additionalPaddingBottom,
						y = t.paddingInner,
						T = t.paddingOuter,
						S = t.fontSize;
					let w = _.text,
						b = _.textColor || P.textColor,
						x = _.secondLine || "",
						L = P.secondLineTextColor || b,
						A = _.thirdLine || "";
					const D = P.thirdLineTextColor || b;
					0 === x.length && (x = A, L = D, A = ""), 0 === w.length && (w = x, b = L, x = A, L = D, A = ""), e.save(), e.font = t.font;
					const V = i.yMidCorrection(e, w) * c,
						I = Math.ceil(i.measureText(e, w)),
						M = S + m + C,
						R = Boolean(x),
						B = Boolean(A),
						E = R ? Math.ceil(i.measureText(e, x)) : 0,
						k = B ? Math.ceil(i.measureText(e, A)) : 0,
						N = v + y + T + I + g,
						F = E > 0 ? v + y + T + E + g : 0,
						O = k > 0 ? v + y + T + k + g : 0,
						U = Math.max(N, F, O),
						z = Math.max(1, Math.floor(c));
					let W = Math.round(M * c);
					W % 2 != z % 2 && (W += 1);
					const H = Math.round((S + t.lineSpacing) * c),
						q = Math.round(2 * (S + t.lineSpacing) * c),
						j = Math.max(1, Math.floor(v * c)),
						G = _.separatorVisible ? j : 0,
						K = _.borderVisible ? j : 0,
						Q = f ? W : Math.round(U * c),
						Y = Math.round(g * c),
						$ = Math.ceil(r * c),
						X = Math.ceil(y * c),
						Z = Math.round((null !== (h = P.fixedCoordinate) && void 0 !== h ? h : P.coordinate) * c) - Math.floor(.5 * c),
						J = Math.floor(Z + z / 2 - W / 2),
						ee = J + W,
						te = "right" === s,
						ie = te ? $ - G : G,
						re = $;
					let ne, se = ie;
					const oe = (0, o.resetTransparency)(null !== (d = _.backgroung) && void 0 !== d ? d : P.background);
					e.fillStyle = oe;
					const le = 2 * c;
					if (e.textAlign = te ? "right" : "left", e.textBaseline = "middle", te ? (se = ie - Q, ne = ie - Y - X - 1) : (se = ie + Q, ne = ie + Y + X), w || f) {
						const i = B ? W + q : R ? W + H : W;
						if (((t, r, n) => {
								te ? (0, u.drawRoundRectWithInnerBorder)(e, se, J, Q, i, t, [le, 0, 0, le], K, r, n) : (0, u.drawRoundRectWithInnerBorder)(e, ie, J, Q, i, t, [0, le, le, 0], K, r, n)
							})(oe, null !== (p = P.borderColor) && void 0 !== p ? p : oe, P.borderStyle), _.separatorVisible && (e.fillStyle = t.paneBackgroundColor, e.fillRect(te ? re - G : 0, J, G, ee - J)), f) {
							switch (_.labelIcon) {
								case 0:
									this._drawPlusIcon(e, ie, se, J, Z, ee, z);
									break;
								case 1:
									this._drawClockIcon(e, ie, se, Z, z, c)
							}
							return void e.restore()
						}
						e.save(), e.translate(ne, (J + ee) / 2 + V), (0, a.drawScaled)(e, c, (() => {
							e.fillStyle = b, e.fillText(w, 0, 0)
						})), e.restore()
					}
					R && (e.fillStyle = L, e.save(), e.translate(ne, (J + ee) / 2 + V + H), (0, a.drawScaled)(e, c, (() => {
						e.fillText((0, l.startWithLTR)(x), 0, 0)
					})), e.restore()), B && (e.fillStyle = D, e.save(), e.translate(ne, (J + ee) / 2 + V + q), (0, a.drawScaled)(e, c, (() => {
						e.fillText((0, l.startWithLTR)(A), 0, 0)
					})), e.restore()), e.restore()
				}
				height(e) {
					const t = this._lines();
					return this._data.visible && 0 !== t ? t * e.fontSize + (t - 1) * e.lineSpacing + e.paddingTop + this._commonData.additionalPaddingTop + e.paddingBottom + this._commonData.additionalPaddingBottom : 0
				}
				hitTest(e) {
					const t = this._data.hitTestData;
					if (void 0 === t || !this._data.visible) return null;
					const i = (0,
							s.lastMouseOrTouchEventInfo)().isTouch ? 10 : 0,
						o = (0, r.box)(new r.Point(t.xl - i, t.y - i), new r.Point(t.xl + t.containerWidth + i, t.y + t.containerHeight + i)),
						l = t.left && (0, n.pointInBox)(e, o),
						a = (0, r.box)(new r.Point(t.xr - i, t.y - i), new r.Point(t.xr + t.containerWidth + i, t.y + t.containerHeight + i)),
						u = t.right && (0, n.pointInBox)(e, a);
					if (l || u) {
						const i = l ? "left" : "right";
						return new c.HitTestResult(c.HitTestResult.CUSTOM, {
							cursorType: h.PaneCursorType.Default,
							clickHandler: void 0 === t.clickHandler ? void 0 : t.clickHandler.bind(this, e, i),
							tapHandler: void 0 === t.clickHandler ? void 0 : t.clickHandler.bind(this, e, i),
							tooltip: t.tooltip
						})
					}
					return null
				}
				_drawPlusIcon(e, t, i, r, n, s, o) {
					e.fillStyle = this._commonData.textColor, e.strokeStyle = this._commonData.textColor, e.lineWidth = o;
					const l = Math.abs(t - i);
					let a = Math.round(.35 * l);
					a % 2 != o % 2 && (a += 1);
					let c = Math.round(.65 * l);
					c % 2 != o % 2 && (c += 1);
					const u = Math.floor((l - a) / 2),
						h = Math.min(t, i),
						d = h + Math.floor(l / 2 - o / 2);
					e.fillRect(h + u, n, a, o), e.fillRect(d, r + u, o, a), e.beginPath(), e.arc(d + o / 2, n + o / 2, c / 2, 0, 2 * Math.PI, !1), e.stroke()
				}
				_drawClockIcon(e, t, i, r, n, s) {
					e.fillStyle = this._commonData.textColor, e.lineWidth = n;
					const o = Math.abs(t - i);
					let l = Math.round(.35 * o);
					l % 2 != n % 2 && (l += 1);
					let a = Math.round(.65 * o);
					a % 2 != n % 2 && (a += 1);
					const c = Math.min(t, i) + Math.floor(o / 2 - n / 2);
					e.save(), e.translate(c + n / 2 - a / 2, r + n / 2 - a / 2), e.scale(s, s);
					const u = new Path2D("M7.5 0.8a1 1 0 0 0 0 13.4 1 1 0 0 0 0-13.4zm0 1a1 1 0 0 1 0 11 1 1 0 0 1 0-11zm-.97-.25A3.5 3.5 0 0 0 3.5 0 3.5 3.5 0 0 0 0 3.5a3.5 3.5 0 0 0 1.75 3.03l.5-.86A2.5 2.5 0 0 1 1 3.5 2.5 2.5 0 0 1 3.5 1a2.5 2.5 0 0 1 2.17 1.25zm6.72 4.78A3.5 3.5 0 0 0 15 3.5 3.5 3.5 0 0 0 11.5 0a3.5 3.5 0 0 0-3.03 1.75l.86.5A2.5 2.5 0 0 1 11.5 1 2.5 2.5 0 0 1 14 3.5a2.5 2.5 0 0 1-1.25 2.17zM7 5h1v5H7zm3 2v1H5V7z");
					e.fill(u), e.restore()
				}
				_lines() {
					const e = this._data;
					return (e.text ? 1 : 0) + (e.secondLine ? 1 : 0) + (e.thirdLine ? 1 : 0)
				}
				_isOutOfScreen(e, t) {
					var i;
					const r = this._commonData,
						n = null !== (i = r.fixedCoordinate) && void 0 !== i ? i : r.coordinate,
						s = this.height(e),
						o = s / this._lines();
					return n - o / 2 - 3 > t || n + (s - o / 2) + 3 < 0
				}
			}
			class p {
				constructor(e) {
					this._commonRendererData = {
						coordinate: 0,
						textColor: "#FFF",
						background: "#000",
						additionalPaddingBottom: 0,
						additionalPaddingTop: 0
					}, this._axisRendererData = {
						text: "",
						visible: !1,
						separatorVisible: !1,
						borderVisible: !1,
						ignoreOffset: !1
					}, this._paneRendererData = {
						text: "",
						visible: !1,
						separatorVisible: !0,
						borderVisible: !1,
						ignoreOffset: !0
					}, this._invalidated = !0, this._axisRenderer = new(e || d)(this._axisRendererData, this._commonRendererData), this._paneRenderer = new(e || d)(this._paneRendererData, this._commonRendererData)
				}
				text() {
					return this._updateRendererDataIfNeeded(), this._axisRendererData.text
				}
				secondLineText() {
					return this._updateRendererDataIfNeeded(), this._axisRendererData.secondLine
				}
				thirdLineText() {
					return this._updateRendererDataIfNeeded(), this._axisRendererData.thirdLine
				}
				background() {
					return this._updateRendererDataIfNeeded(), this._commonRendererData.background
				}
				color() {
					return this._updateRendererDataIfNeeded(), this.generateTextColor(this.background())
				}
				generateTextColor(e) {
					return (0, o.colorFromBackground)(e)
				}
				coordinate() {
					return this._updateRendererDataIfNeeded(),
						this._commonRendererData.coordinate
				}
				floatCoordinate() {
					var e;
					return this._updateRendererDataIfNeeded(), null !== (e = this._commonRendererData.floatCoordinate) && void 0 !== e ? e : this._commonRendererData.coordinate
				}
				update(e) {
					this._invalidated = !0
				}
				height(e) {
					return this._updateRendererDataIfNeeded(), Math.max(this._axisRenderer.height(e), this._paneRenderer.height(e))
				}
				getFixedCoordinate() {
					return this._commonRendererData.fixedCoordinate || 0
				}
				setFixedCoordinate(e) {
					this._commonRendererData.fixedCoordinate = e
				}
				isVisible() {
					return this._updateRendererDataIfNeeded(), this._axisRendererData.visible || this._paneRendererData.visible
				}
				isAxisLabelVisible() {
					return this._updateRendererDataIfNeeded(), this._axisRendererData.visible
				}
				isPaneLabelVisible() {
					return this._updateRendererDataIfNeeded(), this._paneRendererData.visible
				}
				renderer() {
					return this._updateRendererDataIfNeeded(), this._axisRenderer
				}
				paneRenderer() {
					return this._updateRendererDataIfNeeded(), this._paneRenderer
				}
				setPaneRendererLabelIcon(e) {
					this._paneRendererData.labelIcon = e
				}
				setPaneLabelVisible(e) {
					this._paneRendererData.visible = e, this._invalidated = !0
				}
				ignoreAlignment() {
					return !1
				}
				_updateRendererDataIfNeeded() {
					this._invalidated && (this._commonRendererData.fixedCoordinate = void 0, this._updateRendererData(this._axisRendererData, this._paneRendererData, this._commonRendererData), this._invalidated = !1)
				}
			}
		},
		559270: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				PriceRange: () => s
			});
			var r = i(270617);
			const n = (0, i(911905).getLogger)("Chart.PriceRange");
			class s {
				constructor(e, t) {
					if (null !== e && "object" == typeof e) {
						const t = e;
						this._minValue = t.m_minValue, this._maxValue = t.m_maxValue
					} else {
						const i = e;
						this._minValue = i, void 0 !== t && (this._maxValue = t)
					}
				}
				equals(e) {
					return this._minValue === e._minValue && this._maxValue === e._maxValue
				}
				clone() {
					return new s(this._minValue, this._maxValue)
				}
				minValue() {
					return this._minValue
				}
				setMinValue(e) {
					this._minValue = e
				}
				maxValue() {
					return this._maxValue
				}
				setMaxValue(e) {
					this._maxValue = e
				}
				length() {
					return this._maxValue - this._minValue
				}
				isEmpty() {
					return this._maxValue === this._minValue || this._maxValue != this._maxValue || this._minValue != this._minValue
				}
				serialize() {
					return {
						m_maxValue: this._maxValue,
						m_minValue: this._minValue
					}
				}
				state() {
					return {
						max: this._maxValue,
						min: this._minValue
					}
				}
				merge(e) {
					return new s(Math.min(this.minValue(), e.minValue()), Math.max(this.maxValue(), e.maxValue()))
				}
				apply(e, t) {
					this._minValue = Math.min(this._minValue, e), this._maxValue = Math.max(this._maxValue, t)
				}
				set(e, t) {
					this._minValue = e, this._maxValue = t
				}
				scaleAroundCenter(e) {
					if (!(0, r.isNumber)(e)) return void n.logDebug("PriceRange.scaleAroundCenter: invalid coeff");
					if (0 === this._maxValue - this._minValue) return;
					const t = .5 * (this._maxValue + this._minValue);
					let i = this._maxValue - t,
						s = this._minValue - t;
					i *= e, s *= e, this._maxValue = t + i, this._minValue = t + s
				}
				shift(e) {
					(0, r.isNumber)(e) ? (this._maxValue += e, this._minValue += e) : n.logDebug("PriceRange.shift: invalid coeff")
				}
				containsStrictly(e) {
					return e.minValue() > this._minValue && e.maxValue() < this._maxValue
				}
				static compare(e, t) {
					return null === e || null === t ? e === t : e.equals(t)
				}
			}
		},
		326505: (e, t, i) => {
			"use strict";
			i.d(t, {
				extractAllPropertiesKeys: () => v,
				factoryDefaultsForCurrentTheme: () => C,
				ThemedDefaultProperty: () => T
			});
			var r = i(754061),
				n = i(700077),
				s = i(316230),
				o = i(598279),
				l = i(138651),
				a = i(588537),
				c = i(62802),
				u = i(746511),
				h = i(909740),
				d = i(919346),
				p = i(232567),
				_ = i.n(p),
				P = i(385518),
				f = i(97639),
				g = i.n(f);

			function v(e) {
				return new Set(Object.keys(e))
			}

			function m(e, t) {
				const i = {};
				for (const r of Object.keys(e)) t.has(r) && (i[r] = e[r]);
				return i
			}

			function C(e, t) {
				var i;
				const n = null !== (i = h.watchedTheme.value()) && void 0 !== i ? i : d.StdTheme.Light,
					s = (0, u.deepCopy)(e);
				return (0, r.default)(s, (0, a.ensureDefined)(t.get(n))), s
			}

			function y(e, t) {
				const i = (0, n.default)(e, ((e, i, r) => {
					if (void 0 === t[r]) return e;
					if (!(0, s.default)(i, t[r]))
						if ((0, o.default)(i) && (0, o.default)(t[r])) {
							const n = y(i, t[r]);
							void 0 !== n && (e[r] = n)
						} else e[r] = i;
					return e
				}), {});
				return (0, l.default)(i) ? void 0 : i
			}
			class T extends(_()) {
				constructor(e, t, i, n, s) {
					super(function(e, t, i) {
						var n;
						const s = t(),
							o = (0, u.deepCopy)(null !== (n = c.getJSON(e, null)) && void 0 !== n ? n : {});
						return (0, r.default)(s, o), (0, r.default)(s, null != i ? i : {}), s
					}(e, t, s)), this._applyingThemeInProcess = !1, this._restoreFactoryDefaultsEvent = new(g()), this._defaultName = e, this._defaultsSupplier = t, this._notThemedDefaultsKeys = i, this._themedDefaultsKeys = n
				}
				restoreFactoryDefaults() {
					const e = this._defaultsSupplier();
					this.mergeAndFire(e), this.saveDefaults(), this._restoreFactoryDefaultsEvent.fire()
				}
				addExclusion() {}
				preferences() {
					const e = new Set([...this._themedDefaultsKeys, ...this._notThemedDefaultsKeys]);
					return m(this.state(), e)
				}
				mergePreferences(e) {
					const t = new Set([...this._themedDefaultsKeys, ...this._notThemedDefaultsKeys]);
					this.mergeAndFire(m(e, t))
				}
				childChanged(e) {
					super.childChanged(e), this._applyingThemeInProcess || this.saveDefaults()
				}
				saveDefaults() {
					const e = this.state(),
						t = this._defaultsSupplier();
					let i = y(m(e, this._notThemedDefaultsKeys), m(t, this._notThemedDefaultsKeys));
					const n = m(t, this._themedDefaultsKeys),
						s = m(e, this._themedDefaultsKeys),
						o = y(s, n);
					(0, l.default)(o) || (i = null != i ? i : {}, (0, r.default)(i, s)), (0, P.saveDefaults)(this._defaultName, i)
				}
			}
		},
		364019: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				normalizeIntervalString: () => p,
				isAvailable: () => _,
				setLastUsedResolution: () => P,
				getRangeResolution: () => f,
				getTimeBasedResolution: () => g,
				getDefaultResolution: () => v,
				getResolutionByChartStyle: () => m,
				getServerInterval: () => C,
				isResolutionMultiplierValid: () => y,
				getMaxResolutionValue: () => S,
				getResolutionsFromSettings: () => w,
				convertResolutionsFromSettings: () => b,
				mergeResolutions: () => x,
				sortResolutions: () => L,
				getCustomResolutions: () => V,
				getTranslatedResolution: () => I,
				getTranslatedResolutionModel: () => M,
				isSecondsEnabled: () => B,
				isTicksEnabled: () => E
			});
			var r = i(575932),
				n = i(273044),
				s = i(749473),
				o = i(62802),
				l = i(583912),
				a = i(977809),
				c = i(270617);
			i(611688);
			const u = {
					[n.ResolutionKind.Ticks]: 1,
					[n.ResolutionKind.Seconds]: 60,
					[n.ResolutionKind.Minutes]: 1440,
					[n.SpecialResolutionKind.Hours]: 24,
					[n.ResolutionKind.Days]: 365,
					[n.ResolutionKind.Weeks]: 52,
					[n.ResolutionKind.Months]: 12,
					[n.ResolutionKind.Range]: 1e6,
					[n.ResolutionKind.Invalid]: NaN
				},
				h = {
					[n.ResolutionKind.Ticks]: 0,
					[n.ResolutionKind.Seconds]: 1,
					[n.ResolutionKind.Minutes]: 2,
					[n.SpecialResolutionKind.Hours]: 3,
					[n.ResolutionKind.Days]: 4,
					[n.ResolutionKind.Weeks]: 5,
					[n.ResolutionKind.Months]: 6,
					[n.ResolutionKind.Range]: 7,
					[n.ResolutionKind.Invalid]: 8
				},
				d = {
					[n.ResolutionKind.Invalid]: "",
					[n.ResolutionKind.Ticks]: (0, r.t)("T", {
						context: "interval_short"
					}),
					[n.ResolutionKind.Seconds]: (0, r.t)("s", {
						context: "interval_short"
					}),
					[n.ResolutionKind.Minutes]: (0, r.t)("m", {
						context: "interval_short"
					}),
					[n.SpecialResolutionKind.Hours]: (0, r.t)("h", {
						context: "interval_short"
					}),
					[n.ResolutionKind.Days]: (0, r.t)("D", {
						context: "interval_short"
					}),
					[n.ResolutionKind.Weeks]: (0, r.t)("W", {
						context: "interval_short"
					}),
					[n.ResolutionKind.Months]: (0, r.t)("M", {
						context: "interval_short"
					}),
					[n.ResolutionKind.Range]: (0, r.t)("R", {
						context: "interval_short"
					})
				};

			function p(e) {
				return n.Interval.parse(e).value()
			}

			function _(e) {
				const t = n.Interval.parse(e);
				if (t.isRange()) return l.linking.range.value();
				const i = t.value(),
					r = l.linking.supportedResolutions.value();
				return void 0 !== r ? void 0 !== r.find((e => p(e) === i)) : t.isIntraday() ? Boolean(l.linking.intraday.value()) : t.isDWM()
			}

			function P(e) {
				n.Interval.isValid(e) && (n.Interval.isRange(e) ? o.setValue("chart.lastUsedRangeResolution", e) : o.setValue("chart.lastUsedTimeBasedResolution", e))
			}

			function f(e) {
				const t = o.getValue("chart.lastUsedRangeResolution");
				if (void 0 !== t && n.Interval.isRange(t)) return t;
				let i = "100R";
				for (const t of e) {
					const e = n.Interval.parse(t);
					if (e.isRange()) {
						const t = e.value();
						if ("100R" === t) return t;
						i = t
					}
				}
				return i
			}

			function g(e) {
				const t = o.getValue("chart.lastUsedTimeBasedResolution");
				if (void 0 !== t && n.Interval.isTimeBased(t)) return t;
				let i = "1D";
				for (const t of e) {
					const e = n.Interval.parse(t);
					if (e.isTimeBased()) {
						const t = e.value();
						if ("1D" === t) return t;
						i = t
					}
				}
				return i
			}

			function v(e) {
				return e ? "100R" : "1D"
			}

			function m(e, t, i) {
				const r = s.isRangeStyle(e),
					o = n.Interval.isRange(t);
				return !r && o ? g(i) : r && !o ? f(i) : t
			}

			function C(e) {
				return n.Interval.isRange(e) ? "1" : e
			}

			function y(e) {
				const {
					interval: t,
					guiResolutionKind: i
				} = n.Interval.parseExt(e);
				if (!t.isValid()) return !1;
				return (i === n.SpecialResolutionKind.Hours ? t.multiplier() / 60 : t.multiplier()) <= T(i)
			}

			function T(e) {
				const t = u[e];
				return Number.isNaN(t) ? 1 : t
			}

			function S(e) {
				return T(n.Interval.parseExt(e).guiResolutionKind)
			}

			function w(e) {
				const t = b(o.getJSON(e, []));
				return (0, a.uniq)(t.filter(y).map(p))
			}

			function b(e) {
				return Array.isArray(e) ? e : Object.keys(e).map(n.Interval.normalize).filter(c.notNull)
			}

			function x(...e) {
				let t = [].concat(...e);
				return t = (0, a.uniq)(t.filter(y).map(p)), L(t)
			}

			function L(e) {
				return e.sort(D)
			}

			function A(e) {
				const t = n.Interval.parse(e),
					i = t.multiplier() || 1;
				return t.isMinuteHours() ? [n.SpecialResolutionKind.Hours, i / 60] : [t.kind(), i]
			}

			function D(e, t) {
				const [i, r] = A(e), [n, s] = A(t);
				return i !== n ? h[i] - h[n] : r - s
			}

			function V() {
				let e = [];
				return window.user.is_pro && (e = w("IntervalWidget.intervals")), e
			}

			function I(e) {
				const {
					multiplier: t,
					shortKind: i
				} = M(e);
				return `${t}${i}`
			}

			function M(e, t) {
				const i = n.Interval.parse(e);
				let r = i.multiplier(),
					s = i.kind();
				if (!i.isValid()) {
					if (t) return null;
					throw new TypeError("Can't translate invalid interval")
				}
				return i.isMinuteHours() && (r = Math.floor(r / 60), s = n.SpecialResolutionKind.Hours), {
					multiplier: r.toString(),
					shortKind: R(s),
					hint: `${r} ${R(s,r)}`,
					mayOmitMultiplier: i.isDWM() && 1 === r,
					mayOmitShortKind: i.isMinutes() && !i.isMinuteHours()
				}
			}

			function R(e, t) {
				if (!t) return d[e];
				switch (e) {
					case n.ResolutionKind.Ticks:
						return (0, r.t)("tick", {
							plural: "ticks",
							count: t
						});
					case n.ResolutionKind.Days:
						return (0, r.t)("day", {
							plural: "days",
							count: t
						});
					case n.ResolutionKind.Weeks:
						return (0, r.t)("week", {
							plural: "weeks",
							count: t
						});
					case n.ResolutionKind.Months:
						return (0, r.t)("month", {
							plural: "months",
							count: t
						});
					case n.ResolutionKind.Seconds:
						return (0, r.t)("second", {
							plural: "seconds",
							count: t
						});
					case n.ResolutionKind.Minutes:
						return (0, r.t)("minute", {
							plural: "minutes",
							count: t
						});
					case n.SpecialResolutionKind.Hours:
						return (0, r.t)("hour", {
							plural: "hours",
							count: t
						});
					case n.ResolutionKind.Range:
						return (0, r.t)("range", {
							plural: "ranges",
							count: t
						});
					default:
						return e
				}
			}

			function B() {
				return !0
			}

			function E() {
				return !1
			}
		},
		510196: (e, t, i) => {
			"use strict";
			i.d(t, {
				scaleRatio: () => n,
				priceRangeByScaleRatio: () => s,
				barSpacingByScaleRatio: () => o
			});
			var r = i(559270);

			function n(e, t) {
				if (t.isLog() || e.isEmpty() || t.isEmpty()) return null;
				const i = function(e) {
					if (e.isEmpty()) return null;
					const t = e.priceRange();
					if (null === t) return null;
					const i = t.length();
					return e.internalHeight() / i
				}(t);
				if (null === i) return null;
				return e.getValidBarSpacing() / Math.max(1e-10, i)
			}

			function s(e, t, i) {
				if (e.isLog() || null === i || e.isEmpty()) return null;
				const n = e.priceRange();
				if (null === n || n.isEmpty()) return null;
				const s = e.internalHeight() / (t / i),
					o = n.length();
				if (s === o) return n;
				const l = (s - o) / 2;
				return new r.PriceRange(n.minValue() - l, n.maxValue() + l)
			}

			function o(e, t) {
				if (e.isLog() || null === t || e.isEmpty()) return null;
				const i = e.priceRange();
				if (null === i) return null;
				const r = i.length();
				return e.internalHeight() / r * t
			}
		},
		366156: (e, t, i) => {
			"use strict";
			var r = i(97639),
				n = i(823127),
				s = i(575932).t,
				o = i(588537).assert,
				l = i(345848).trackEvent,
				a = i(226722).TVXWindowEvents,
				c = i(911905).getLogger("Pine.ScriptLib"),
				u = i(175203).telemetry,
				h = i(251954),
				d = {
					fast: ["delete", "get", "is_auth_to_get", "is_auth_to_write", "parse_title", "rename", "lib_list"],
					medium: ["list", "eval_pine_ex", "translate_light"],
					slow: ["process_legacy", "publish", "save", "translate", "translate_source", "gen_alert"]
				};
			var p = {};

			function _() {
				p._cache = {}
			}
			p._isAuthCache = new _, p._pineDeleted = new r, a.on("TVScriptModified", (function(e) {
				p.clearSavedScriptsCache(), p.scriptUpdater() && p.scriptUpdater().onTVScriptModified(JSON.parse(e))
			})), a.on("TVScriptDeleted", (function(e) {
				p.clearAllCaches(), p.scriptUpdater() && p.scriptUpdater().onTVScriptDeleted(JSON.parse(e))
			})), a.on("TVScriptRenamed", (function(e) {
				p.clearSavedScriptsCache(), p.scriptUpdater() && p.scriptUpdater().onTVScriptRenamed(JSON.parse(e))
			})), a.on("TVScriptLegacyPineProcessed", (function(e) {
				p.clearSavedScriptsCache(), p.scriptUpdater() && p.scriptUpdater().onTVScriptLegacyPineProcessed(JSON.parse(e))
			})), p.getPineFacadeUrl = function() {
				return window.PINE_URL
			}, p.PINE_FACADE_URL = function() {
				return window.PINE_URL
			}, p.onPineDeleted = function() {
				return p._pineDeleted
			}, p._pineFacadeAjax = function(e, t, i, r) {
				c.logNormal("Requesting pine facade scripts, url: " + t);
				var s = function(e, t) {
						for (var i = Object.keys(d), r = 0; r < i.length; r++) {
							var n = d[i[r]].filter((function(t) {
								return -1 !== e.indexOf(t)
							}));
							if (Boolean(n.length)) return i[r]
						}
						return !1
					}(t),
					o = Date.now(),
					l = r ? void 0 : {
						withCredentials: !0
					};
				return n.ajax({
					url: p.PINE_FACADE_URL() + t,
					type: e,
					data: i || {},
					dataType: "json",
					xhrFields: l
				}).done((function() {
					var e = Date.now() - o;
					u.sendReport("pine", s + "_group_time_frame", {
						value: e
					}), u.sendReport("pine", s + "_group_ok"), c.logNormal("Requesting pine facade scripts finished, url: " + t)
				})).fail((function() {
					var e = Date.now() - o;
					u.sendReport("pine", s + "_group_time_frame", {
						value: e
					}), u.sendReport("pine", s + "_group_error"), c.logError("Requesting pine facade scripts failed, url: " + t)
				}))
			}, p.convertScript = function(e, t) {
				var i = n.Deferred(),
					r = {
						source: e,
						version_to: t
					};
				return p._pineFacadeAjax("POST", "/convert/", r).done((function(e, t, r) {
					e.error ? i.reject(p._readableError(e.error)) : i.resolve(e)
				})).fail((function(e, t, r) {
					p._anyRequestAsyncFail(i, e)
				})), i.promise()
			}, p.translateScriptAsync = function(e, t, i, r) {
				l("Pine", "ScriptLib.translateScript"), r = !!r;
				var s = n.Deferred(),
					o = "/translate_source/" + encodeURIComponent(t) + "/?is_pine_ex=" + r,
					a = {
						user_name: window.user && window.user.username,
						source: e,
						inputs: JSON.stringify(i || {})
					};
				return p._pineFacadeAjax("POST", o, a).done((function(e, t, i) {
					p._translateScriptAsyncDone(s, e)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(s, e)
				})), s.promise()
			}, p.translateScriptAsync2 = function(e, t) {
				c.logNormal("translateScriptAsync2, pineId=" + e + " pineVersion=" + t), l("Pine", "ScriptLib.translateScript");
				var i = n.Deferred(),
					r = 0 !== e.indexOf("USER"),
					s = window.user && window.user.username,
					o = "?user_name=" + encodeURIComponent(s),
					u = "/translate/" + encodeURIComponent(e) + "/" + t + "/";
				return r || null == s || (u += o), p._pineFacadeAjax("GET", u, void 0, r).done((function(e, r, n) {
					if (p._translateScriptAsyncDone(i, e), t < 0) {
						p.clearSavedScriptsCache();
						var s = {
							scriptMetaInfo: e.result.metaInfo
						};
						a.emit("TVScriptLegacyPineProcessed", JSON.stringify(s)), h.emit("TVScriptLegacyPineProcessed", s), setTimeout((function() {
							s.isSelfCall = !0, null != p.scriptUpdater() && p.scriptUpdater().onTVScriptLegacyPineProcessed(s)
						}), 0)
					}
				})).fail((function(e, t, r) {
					p._anyRequestAsyncFail(i, e)
				})), i.promise()
			}, p._translateScriptAsyncDone = function(e, t) {
				if (t.error) e.reject(p._readableError(t.error));
				else if (t.success) e.resolve(t.result.metaInfo, t.result.IL);
				else {
					var i = t.result ? t.result.metaInfo : null;
					e.reject(t.reason, i)
				}
			}, p._saveScriptAsyncDone = function(e, t) {
				if (t.error) e.reject(p._readableError(t.error));
				else if (t.success) e.resolve(t.result.metaInfo);
				else {
					var i = t.result ? t.result.metaInfo : null;
					e.resolve(i, t.reason)
				}
			}, p._generateAlertAsyncDone = function(e, t) {
				if (t.error) e.reject(p._readableError(t.error));
				else if (t.success) e.resolve(t.result.metaInfo, t.result.IL, t.result.inputs || null, t.result.gen_alert_data || null);
				else {
					var i = t.result ? t.result.metaInfo : null;
					e.reject(t.reason, i)
				}
			}, p._readableError = function(e, t) {
				return t
			}, p._anyRequestAsyncFail = function(e, t) {
				0 === p.PINE_FACADE_URL().indexOf("http") && c.logError(t.responseText), e.reject(p._readableError(t.status, t.statusText))
			}, p.isAuthToWritePineScript = function(e) {
				var t = "write_" + e,
					i = p._isAuthCache.getPromise(t);
				if (null !== i) return i;
				l("Pine", "ScriptLib.isAuthToWritePineScript");
				var r = n.Deferred(),
					s = "/is_auth_to_write/" + encodeURIComponent(e);
				return p._pineFacadeAjax("GET", s).done((function(e, t, i) {
					r.resolve(e)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(r, e)
				})), p._isAuthCache.setPromise(t, r.promise())
			}, p.isAuthToGetPineSourceCode = function(e, t) {
				var i = "get_" + e + "_" + t,
					r = p._isAuthCache.getPromise(i);
				if (null !== r) return r;
				l("Pine", "ScriptLib.isAuthToGetPineSourceCode");
				var s = n.Deferred(),
					o = "/is_auth_to_get/" + encodeURIComponent(e) + "/" + t;
				return p._pineFacadeAjax("GET", o).done((function(e, t, i) {
					s.resolve(e)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(s, e)
				})), p._isAuthCache.setPromise(i, s.promise())
			}, _.prototype.getPromise = function(e) {
				var t = p._cache[e];
				return void 0 === t ? null : void 0 !== t.value ? n.Deferred().resolve(t.value) : void 0 !== t.promise ? t.promise : null
			}, _.prototype.setPromise = function(e, t) {
				return p._cache[e] = {
					promise: t
				}, t.done((function(t) {
					p._cache[e] = {
						value: t
					}
				})).fail((function(t) {
					delete p._cache[e]
				})), t
			}, p.getPineSourceCode = function(e, t, i) {
				l("Pine", "ScriptLib.getPineSourceCode");
				var r = n.Deferred(),
					s = "?no_4xx=" + !!i,
					o = "/get/" + encodeURIComponent(e) + "/" + t + s;
				return p._pineFacadeAjax("GET", o).done((function(e, t, i) {
					!1 === e.success ? r.reject(e.reason) : r.resolve(e)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(r, e)
				})), r.promise()
			}, p.saveNewDraft = function(e) {
				l("Pine", "ScriptLib.saveNewDraft");
				var t = n.Deferred();
				if (null == e || "" === e) return t.reject(s("Cannot save empty source code"));
				var i = window.user && window.user.username,
					r = "/save/new_draft/?user_name=" + encodeURIComponent(i) + "&allow_use_existing_draft=true",
					o = {
						source: e
					};
				return p._pineFacadeAjax("POST", r, o).done((function(e, i, r) {
					p._translateScriptAsyncDone(t, e)
				})).fail((function(e, i, r) {
					p._anyRequestAsyncFail(t, e)
				})), t.promise()
			}, p.saveNextDraft = function(e, t, i) {
				l("Pine", "ScriptLib.saveNextDraft");
				var r = n.Deferred();
				if (null == t || "" === t) return r.reject(s("Cannot save empty source code"));
				var o = window.user && window.user.username,
					a = (i = !!i, "/save/next_draft/" + encodeURIComponent(e) + "/?user_name=" + encodeURIComponent(o) + "&allow_create_new=" + i),
					c = {
						source: t
					};
				return p._pineFacadeAjax("POST", a, c).done((function(e, t, i) {
					p._translateScriptAsyncDone(r, e)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(r, e)
				})), r.promise()
			}, p.processLegacy = function(e, t) {
				l("Pine", "ScriptLib.processLegacy");
				var i = n.Deferred(),
					r = window.user && window.user.username,
					s = "/process_legacy/" + encodeURIComponent(e) + "/?user_name=" + encodeURIComponent(r),
					o = {};
				return null != t && "" !== t && (o.source = t), p._pineFacadeAjax("POST", s, o).done((function(e, t, r) {
					p._translateScriptAsyncDone(i, e)
				})).fail((function(e, t, r) {
					p._anyRequestAsyncFail(i, e)
				})), i.promise()
			}, p.generateAlert = function(e) {
				l("Pine", "ScriptLib.generateAlert");
				var t = n.Deferred(),
					i = window.user && window.user.username,
					r = "/gen_alert/?user_name=" + encodeURIComponent(i),
					s = {
						alert_info: e
					},
					o = Date.now();
				return p._pineFacadeAjax("POST", r, s).done((function(e, i, r) {
					u.sendReport("alerts", "compilation_ok"), p._generateAlertAsyncDone(t, e)
				})).fail((function(e, i, r) {
					u.sendReport("alerts", "compilation_error"), p._anyRequestAsyncFail(t, e)
				})).always((function() {
					var e = Date.now() - o;
					u.sendReport("alerts", "compilation_time_frame", {
						value: e
					})
				})), t.promise()
			}, p.parseScriptTitleAsync = function(e) {
				l("Pine", "ScriptLib.parseScriptTitle");
				var t = n.Deferred();
				if (null == e || "" === e) return t.reject(s("Cannot save empty source code"));
				var i = {
					user_name: window.user && window.user.username,
					source: e
				};
				return p._pineFacadeAjax("POST", "/parse_title/", i).done((function(e, i, r) {
					e.error ? t.reject(p._readableError(e.error)) : e.success ? t.resolve(e.result) : t.reject(e.reason)
				})).fail((function(e) {
					p._anyRequestAsyncFail(t, e)
				})), t.promise()
			}, p.evalMetaInfoExprsAsync = function(e, t) {
				l("Pine", "ScriptLib.evalMetaInfoExprs");
				var i = n.Deferred(),
					r = {
						username: window.user && window.user.username,
						source: e,
						inputs: JSON.stringify(t || {})
					};
				return p._pineFacadeAjax("POST", "/eval_pine_ex/", r).done((function(e, t, r) {
					e.error ? i.reject(p._readableError(e.error)) : e.success ? i.resolve(e.result) : i.reject(e.reason)
				})).fail((function(e) {
					p._anyRequestAsyncFail(i, e)
				})), i.promise()
			}, p.patchPropertiesAsync = function(e, t, i) {
				return c.logNormal("patchPropertiesAsync"), new Promise((function(r, n) {
					if (t.TVScriptMetaInfoExprs) {
						var s = t.TVScriptMetaInfoExprs.tree,
							l = t.TVScriptMetaInfoExprs.patchMap;
						p.evalMetaInfoExprsAsync(s, i).done((function(t) {
							for (var i = t.rootValues, n = Object.keys(l), s = 0; s < n.length; s++) {
								var a = n[s],
									c = i[l[a]],
									u = a.split(".");
								"defaults" === u[0] && u.splice(0, 1), o(u.length > 1, "Unexpectedly short json path");
								for (var h = e, d = 0; d < u.length - 1; ++d) h = h[u[d]];
								h[u[u.length - 1]].setValue(c)
							}
							r(e)
						})).fail((function(e) {
							n(e)
						}))
					} else r(e)
				}))
			}, p.scriptUpdater = function() {
				return window.scriptUpdater
			}, p.clearAllCaches = function() {
				p.clearIsAuthToCaches(), p.clearSavedScriptsCache()
			}, p.clearIsAuthToCaches = function(e) {
				e ? Object.keys(p._cache).filter((function(t) {
					return t.indexOf(e) >= 0
				})).forEach((function(e) {
					delete p._cache[e]
				})) : p._isAuthCache = new _
			}, p.clearSavedScriptsCache = function(e) {
				delete p._userScriptsDfd
			}, p.requestUserScripts = function(e) {
				if (l("Pine", "ScriptLib.requestUserScripts"), window.is_authenticated) {
					if (!p._userScriptsDfd) {
						p._userScriptsDfd = n.Deferred();
						var t = p._userScriptsDfd;
						p._pineFacadeAjax("GET", "/list?filter=saved").done((function(e, i, r) {
							t.resolve(e)
						})).fail((function(e) {
							p._anyRequestAsyncFail(t, e)
						}))
					}
					t = p._userScriptsDfd
				} else t = n.Deferred().resolve([]);
				return "function" == typeof e && t.done(e), t.promise()
			}, p.setUserScripts = function(e) {
				p._userScriptsDfd || (p._userScriptsDfd = n.Deferred().resolve(e))
			}, p.requestUserPublishedScripts = function(e, t) {
				if (l("Pine", "ScriptLib.requestUserPublishedScripts"), window.is_authenticated) {
					if (t || !p._userPublishedScriptsDfd) {
						p._userPublishedScriptsDfd = n.Deferred();
						var i = p._userPublishedScriptsDfd;
						p._pineFacadeAjax("GET", "/list?filter=published").done((function(e, t, r) {
							i.resolve(e)
						})).fail((function(e) {
							p._anyRequestAsyncFail(i, e)
						}))
					}
					i = p._userPublishedScriptsDfd
				} else i = n.Deferred().resolve([]);
				return "function" == typeof e && i.done(e), i.promise()
			}, p.requestPineEditorNewTemplateScripts = function(e) {
				l("Pine", "ScriptLib.requestPineEditorNewTemplateScripts");
				var t = n.Deferred();
				return p._pineFacadeAjax("GET", "/list/?filter=template", void 0, !0).done((function(e, i, r) {
					t.resolve(e)
				})).fail((function(e) {
					p._anyRequestAsyncFail(t, e)
				})), "function" == typeof e && t.done(e), t.promise()
			}, p.requestInfoForScripts = function(e) {
				return Promise.all([p._pineFacadeAjax("GET", "/list?filter=saved"), p._pineFacadeAjax("GET", "/list?filter=addon", void 0, !0)]).then((function(t) {
					var i = t[0],
						r = t[1];
					return i.concat(r).filter((function(t) {
						return e.includes(t.scriptIdPart)
					}))
				}))
			}, p.requestBuiltinScripts = function() {
				l("Pine", "ScriptLib.requestBuiltinScripts"), c.logNormal("Request built-in scripts");
				var e = n.Deferred();
				return p._pineFacadeAjax("GET", "/list/?filter=standard", void 0, !0).done((function(t, i, r) {
					c.logNormal("Request built-in scripts finished"), e.resolve(t)
				})).fail((function(t) {
					c.logWarn("Request built-in scripts finished with fail"), p._anyRequestAsyncFail(e, t)
				})), e.promise()
			}, p.requestBuiltinAndUserScripts = function() {
				l("Pine", "ScriptLib.requestBuiltinAndUserScripts"), c.logNormal("Request built-in and user scripts");
				var e, t = window.user && window.user.username,
					i = {},
					r = new Promise((function(t, r) {
						e = t, i.reject = r
					}));
				return Promise.all([p._pineFacadeAjax("GET", "/list?filter=saved&user_name=" + encodeURIComponent(t), void 0, !1), p._pineFacadeAjax("GET", "/list?filter=standard", void 0, !0)]).then((function(t) {
					c.logNormal("Request built-in and user scripts finished");
					var i = t[0],
						r = t[1];
					e(i.concat(r))
				})).catch((function(e) {
					c.logWarn("Request built-in and user scripts finished with fail"), p._anyRequestAsyncFail(i, e)
				})), r
			}, p.requestCandlestickScripts = function() {
				var e;
				l("Pine", "ScriptLib.requestCandlestickScripts"), c.logNormal("Request candlestick scripts");
				var t = {},
					i = new Promise((function(i, r) {
						e = i, t.reject = r
					}));
				return p._pineFacadeAjax("GET", "/list?filter=candlestick", void 0, !0).done((function(t) {
					c.logNormal("Request candlestick scripts finished"), e(t)
				})).fail((function(e) {
					c.logWarn("Request candlestick scripts finished with fail"), p._anyRequestAsyncFail(t, e)
				})), i
			};
			var P = {
				time: -1 / 0,
				request: null
			};
			p.requestFundamentalScripts = function() {
				if (P.time + 6e5 > Date.now() && null !== P.request) return c.logNormal("Return fundamentals from cache"), P.request;
				c.logNormal("Request fundamental scripts");
				var e = p._pineFacadeAjax("GET", "/list?filter=fundamental", void 0, !1);
				return e.then((function(e) {
					c.logNormal("Request fundamental scripts finished")
				})), e.fail((function(e) {
					c.logWarn("Request fundamental scripts finished with fail, resetting cache"), P.request = null
				})), P.time = Date.now(), P.request = Promise.resolve(e.promise()), P.request
			}, p.requestPineAddons = function(e) {
				l("Pine", "ScriptLib.requestPineAddons");
				var t = n.Deferred();
				return p._pineFacadeAjax("GET", "/list?filter=addon&pine_id_prefix=" + e).done((function(e) {
					t.resolve(e)
				})).fail((function(e) {
					p._anyRequestAsyncFail(t, e)
				})), t
			}, p._updateAliveScriptInstances = function(e, t) {
				var i = {};
				i.scriptMetaInfo = e.result.metaInfo, i.scriptVersionToUpdate = t, a.emit("TVScriptModified", JSON.stringify(i)), h.emit("TVScriptModified", i), setTimeout((function() {
					i.isSelfCall = !0,
						null != p.scriptUpdater() && p.scriptUpdater().onTVScriptModified(i)
				}), 0)
			}, p.saveNew = function(e, t, i, r) {
				l("Pine", "ScriptLib.saveNew");
				var o = n.Deferred();
				if (null == e || "" === e) return o.reject(s("Cannot save empty source code"));
				var a = window.user && window.user.username,
					c = i ? "&allow_overwrite=true" : "",
					u = "/save/new/?name=" + encodeURIComponent(t) + "&user_name=" + encodeURIComponent(a) + c,
					h = {
						source: e
					};
				return p._pineFacadeAjax("POST", u, h).done((function(e, t, i) {
					p.clearSavedScriptsCache(), p._updateAliveScriptInstances(e, r), p._saveScriptAsyncDone(o, e)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(o, e)
				})), o.promise()
			}, p.saveNext = function(e, t, i, r, o) {
				l("Pine", "ScriptLib.saveNext");
				var a = null != i ? "&name=" + encodeURIComponent(i) : "",
					c = n.Deferred();
				if (null == t || "" === t) return c.reject(s("Cannot save empty source code"));
				var u = window.user && window.user.username,
					h = "/save/next/" + encodeURIComponent(e) + "/?user_name=" + encodeURIComponent(u) + "&allow_create_new=" + !!o + a,
					d = {
						source: t
					};
				return p._pineFacadeAjax("POST", h, d).done((function(e, t, i) {
					p.clearSavedScriptsCache(), p._updateAliveScriptInstances(e, r), p._saveScriptAsyncDone(c, e)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(c, e)
				})), c.promise()
			}, p.deletePine = function(e) {
				l("Pine", "ScriptLib.deletePine");
				var t = n.Deferred(),
					i = window.user && window.user.username,
					r = "/delete/" + encodeURIComponent(e) + "/?user_name=" + encodeURIComponent(i);
				return p._pineFacadeAjax("POST", r).done((function(i, r, n) {
					p.clearIsAuthToCaches(e), p.clearSavedScriptsCache(), t.resolve(i);
					var s = {
						scriptIdPart: e
					};
					a.emit("TVScriptDeleted", JSON.stringify(s)), h.emit("TVScriptDeleted", s), setTimeout((function() {
						s.isSelfCall = !0, null != p.scriptUpdater() && p.scriptUpdater().onTVScriptDeleted(s), p._pineDeleted.fire(e)
					}), 0)
				})).fail((function(e, i, r) {
					p._anyRequestAsyncFail(t, e)
				})), t.promise()
			}, p.renamePine = function(e, t, i) {
				l("Pine", "ScriptLib.renamePine");
				var r = n.Deferred(),
					s = window.user && window.user.username,
					o = "/rename/" + encodeURIComponent(e) + "/?name=" + encodeURIComponent(t) + "&user_name=" + encodeURIComponent(s) + "&force=" + encodeURIComponent(!!i);
				return p._pineFacadeAjax("POST", o).done((function(i, n, s) {
					p.clearSavedScriptsCache();
					var o = {
						scriptIdPart: e,
						scriptName: t
					};
					a.emit("TVScriptRenamed", JSON.stringify(o)), h.emit("TVScriptRenamed", o), setTimeout((function() {
						o.isSelfCall = !0, null != p.scriptUpdater() && p.scriptUpdater().onTVScriptRenamed(o)
					}), 0), r.resolve(i)
				})).fail((function(e, t, i) {
					p._anyRequestAsyncFail(r, e)
				})), r.promise()
			}, p.publishNew = function(e, t) {
				l("Pine", "ScriptLib.publishNew");
				var i = n.Deferred(),
					r = window.user && window.user.username,
					s = "/publish/new/?access=" + encodeURIComponent(t) + "&user_name=" + encodeURIComponent(r),
					o = {
						source: e
					};
				return p._pineFacadeAjax("POST", s, o).done((function(e, t, r) {
					e.success ? (p.clearSavedScriptsCache(), i.resolve(e)) : i.reject(e.reason)
				})).fail((function(e, t, r) {
					p._anyRequestAsyncFail(i, e)
				})), i.promise()
			}, p.publishNext = function(e, t) {
				c.logNormal("ScriptLib.publishNext", "pine"), l("Pine", "ScriptLib.publishNext");
				var i = n.Deferred(),
					r = window.user && window.user.username,
					s = "/publish/next/" + encodeURIComponent(t) + "?user_name=" + encodeURIComponent(r),
					o = {
						source: e
					};
				return p._pineFacadeAjax("POST", s, o).done((function(e, t, r) {
					p.clearSavedScriptsCache(), e.success || i.reject(e.reason), i.resolve(e)
				})).fail((function(e, t, r) {
					p._anyRequestAsyncFail(i, e)
				})), i.promise()
			}, p.lightTranslate = function(e, t) {
				return c.logNormal("ScriptLib.lightTranslate", "pine"), l("Pine", "ScriptLib.lightTranslate"), new Promise((function(i, r) {
					var n = window.user && window.user.username,
						s = `/translate_light/?user_name=${encodeURIComponent(n)}`;
					t && (s += `&pine_id=${encodeURIComponent(t)}`);
					var o = {
						source: e
					};
					p._pineFacadeAjax("POST", s, o).done((function(e, t, n) {
						if (e.success) i(e.result);
						else {
							var s = e.result && e.result.reason || e.reason;
							r(s)
						}
					})).fail((function(e, t, i) {
						p._anyRequestAsyncFail({
							reject: r
						}, e)
					}))
				}))
			}, p.getLibList = function(e, t, i) {
				return c.logNormal("ScriptLib.getLibList", "pine"), l("Pine", "ScriptLib.getLibList"), new Promise((function(r, n) {
					var s = "/lib_list?lib_id_prefix=" + encodeURIComponent(e);
					t && (s += "&ignore_cache=true"), i && (s += "&ignore_case=true"), p._pineFacadeAjax("GET", s).done((function(e, t, i) {
						r(e)
					})).fail((function(e, t, i) {
						p._anyRequestAsyncFail({
							reject: n
						}, e)
					}))
				}))
			}, p.getExistingLibraryInfo = async function(e) {
				try {
					const t = await p.getLibList(e + "/last", !0, !0);
					if (!t.length) return null;
					const i = t[0];
					return {
						scriptIdPart: i.scriptIdPart,
						chartId: i.chartId,
						version: i.version
					}
				} catch (e) {
					return null
				}
			}, loginStateChange.subscribe(p, p.clearAllCaches), e.exports = p
		},
		262203: (e, t, i) => {
			"use strict";
			i.d(t, {
				SeriesTimeRangeVolumeCalculator: () => r
			});
			class r {
				constructor(e) {
					this._value = null, this._series = e, this._series.dataEvents().dataUpdated().subscribe(this, this._onSeriesUpdated)
				}
				destroy() {
					this._series.dataEvents().dataUpdated().unsubscribeAll(this)
				}
				volume(e, t) {
					if (null !== this._value && this._value.from === e && this._value.to === t) return this._value.value;
					let i = 0;
					const r = this._series.data().bars(),
						n = r.firstIndex(),
						s = r.lastIndex();
					if (null !== n && e < n && t < n || null !== s && e > s && t > s) i = NaN;
					else {
						const r = this._series.data().bars().rangeIterator(Math.min(e, t), Math.max(e, t));
						for (; r.hasNext();) {
							const e = r.next().value[5];
							if (void 0 === e) {
								i = NaN;
								break
							}
							i += e
						}
					}
					return this._value = {
						from: e,
						to: t,
						value: i
					}, i
				}
				_onSeriesUpdated(e, t) {
					if (null === this._value) return;
					if (t) return void(this._value = null);
					const i = this._series.data().bars().lastIndex();
					(null === i || i <= this._value.to) && (this._value = null)
				}
			}
		},
		499452: (e, t, i) => {
			"use strict";
			i.d(t, {
				seriesPrice: () => s,
				positionVisualDirection: () => l,
				positionToCoordinate: () => a,
				noDataBasePosition: () => c,
				seriesBasePosition: () => u,
				getNoDataPosition: () => h,
				getSeriesPosition: () => d
			});
			var r = i(588537),
				n = i(752280);

			function s(e, t, i) {
				const r = e.barFunction();
				switch (e.style()) {
					case 3:
					case 10:
					case 2:
						return r(t.value);
					default:
						return t.value[-1 === i ? 3 : 2]
				}
			}

			function o(e) {
				return e >= 0 ? 1 : -1
			}

			function l(e, t) {
				return -1 === o(e) !== t ? -1 : 1
			}

			function a(e, t, i, r) {
				const n = Math.min(t, Math.max(0, 1 === r ? i : t - i));
				return i - r * Math.abs(n * e / 100)
			}

			function c(e, t, i) {
				const r = e.index();
				return null === r ? null : {
					index: r,
					price: t.coordinateToPrice(t.height() / 2, i)
				}
			}

			function u(e, t) {
				const i = e.data().bars(),
					r = i.first(),
					l = i.last();
				if (null === r || null === l) return null;
				let a;
				const c = t.index();
				if (null === c) {
					if (void 0 === t.time) return null;
					const e = t.time(),
						s = r.value[0],
						o = l.value[0];
					if (e < s - 86400 || e > o) return null;
					a = i.searchByTime(e, n.PlotRowSearchMode.NearestRight, 4)
				} else a = i.search(c);
				return null === a ? null : {
					index: a.index,
					price: s(e, a, o(t.position()))
				}
			}

			function h(e, t, i) {
				const r = c(e, t, i);
				if (null === r) return null;
				const n = l(e.position(), t.isInverted());
				return {
					index: r.index,
					price: r.price,
					poleStartY: t.height(),
					visualDirection: 1,
					positionPointDirection: n,
					startsOnSeriesData: !1
				}
			}

			function d(e, t, i = !0) {
				const n = u(e, t),
					s = e.priceScale(),
					o = (0, r.ensureNotNull)(e.firstValue());
				if (null === n) return h(t, s, o);
				let a = 0;
				const c = e.properties().childs(),
					d = e.model().timeScale(),
					p = s.priceToCoordinate(n.price, o);
				if (i) switch (e.style()) {
					case 3:
						a = c.areaStyle.childs().linewidth.value() / 2;
						break;
					case 2:
						a = c.lineStyle.childs().linewidth.value() / 2;
						break;
					case 10:
						const e = Math.abs(100 - c.baselineStyle.childs().baseLevelPercentage.value());
						a = s.height() * e / 100 > p ? c.baselineStyle.childs().topLineWidth.value() / 2 : c.baselineStyle.childs().bottomLineWidth.value() / 2;
						break;
					case 1:
					case 9:
					case 8:
					case 12:
					case 4:
					case 7:
						a = 3;
						break;
					case 0:
						a = c.barStyle.childs().thinBars.value() ? 3 : Math.max(3, .25 * d.barSpacing());
						break;
					case 11:
						a = c.rangeStyle.childs().thinBars.value() ? 3 : Math.max(3, .25 * d.barSpacing());
						break;
					case 5:
						a = Math.max(4, .25 * d.barSpacing());
						break;
					case 6:
						a = Math.max(5, .25 * d.barSpacing())
				}
				const _ = l(t.position(), s.isInverted()),
					P = p - _ * a;
				return {
					index: n.index,
					price: n.price,
					poleStartY: P,
					visualDirection: _,
					positionPointDirection: _,
					startsOnSeriesData: !0
				}
			}
		},
		831825: (e, t, i) => {
			"use strict";
			var r, n, s, o;
			i.d(t, {
					MarkLocation: () => r,
					HAlign: () => n,
					LineStyle: () => o
				}),
				function(e) {
					e.AboveBar = "AboveBar", e.BelowBar = "BelowBar", e.Top = "Top", e.Bottom = "Bottom", e.Right = "Right", e.Left = "Left", e.Absolute = "Absolute", e.AbsoluteUp = "AbsoluteUp", e.AbsoluteDown = "AbsoluteDown"
				}(r || (r = {})),
				function(e) {
					e.Left = "left", e.Center = "center", e.Right = "right"
				}(n || (n = {})),
				function(e) {
					e.Top = "top", e.Middle = "middle", e.Bottom = "bottom"
				}(s || (s = {})),
				function(e) {
					e[e.Solid = 0] = "Solid", e[e.Dotted = 1] = "Dotted", e[e.Dashed = 2] = "Dashed"
				}(o || (o = {}))
		},
		706342: (e, t, i) => {
			"use strict";
			i.d(t, {
				areEqualSymbols: () => n,
				symbolSameAsCurrent: () => o
			});
			const r = i(611688).enabled("uppercase_instrument_names");

			function n(e, t) {
				return void 0 === e ? void 0 === t : void 0 !== t && (r ? e.toUpperCase() === t.toUpperCase() : e === t)
			}

			function s(e, t) {
				return e.some((e => n(t, e)))
			}

			function o(e, t, i) {
				if (n(t, e)) return !0;
				if (i) {
					if (n(i.full_name, e) || n(i.pro_name, e)) return !0;
					if (n(i.ticker, e)) return !0;
					if (i.aliases && s(i.aliases, e)) return !0;
					if (i.alternatives && s(i.alternatives, e)) return !0;
					if (0 === e.indexOf("FRA:") && n(i.pro_name, e.replace("FRA:", "FWB:"))) return !0
				}
				return !1
			}
		},
		642053: (e, t, i) => {
			"use strict";
			i.d(t, {
				TimeAxisView: () => o
			});
			var r = i(721386),
				n = i(824112);
			class s {
				constructor() {
					this._data = null
				}
				setData(e) {
					this._data = e
				}
				draw(e, t, i) {
					if (null === this._data || !this._data.visible || 0 === this._data.text.length) return;
					const r = this._data;
					e.font = t.font;
					const s = Math.round(t.widthCache.measureText(e, r.text));
					if (s <= 0) return;
					e.save();
					const o = t.paddingHorizontal,
						l = s + 2 * o,
						a = l / 2;
					let c = r.coordinate,
						u = Math.floor(c - a) + .5;
					if (r.alwaysInViewPort) {
						const e = r.width;
						u < 0 ? (c += Math.abs(0 - u), u = Math.floor(c - a) + .5) : u + l > e && (c -= Math.abs(e - (u + l)), u = Math.floor(c - a) + .5)
					}
					const h = u + l,
						d = Math.ceil(0 + t.borderSize + t.offsetSize + t.paddingTop + t.fontSize + t.paddingBottom);
					e.fillStyle = r.background;
					const p = Math.round(u * i),
						_ = Math.round(0 * i),
						P = Math.round(h * i),
						f = Math.round(d * i),
						g = Math.round(2 * i);
					e.beginPath(), e.moveTo(p, _), e.lineTo(p, f - g), e.arcTo(p, f, p + g, f, g), e.lineTo(P - g, f), e.arcTo(P, f, P, f - g, g), e.lineTo(P, _), e.fill();
					const v = 0 + t.borderSize + t.offsetSize + t.paddingTop + t.fontSize / 2;
					e.textAlign = "left", e.textBaseline = "middle", e.fillStyle = r.color;
					const m = t.widthCache.yMidCorrection(e, "Apr0");
					e.translate((u + o) * i, (v + m) * i), (0, n.drawScaled)(e, i, (() => e.fillText(r.text, 0, 0))), e.restore()
				}
			}
			class o {
				constructor(e) {
					this._renderer = new s, this._rendererData = {
						background: "",
						color: "",
						coordinate: 0,
						text: "",
						visible: !1,
						width: 0,
						alwaysInViewPort: !0
					}, this._invalidated = !0, this._model = e, this._renderer.setData(this._rendererData)
				}
				update() {
					this._invalidated = !0
				}
				renderer() {
					return this._invalidated && (this._updateImpl(), this._invalidated = !1), this._renderer
				}
				coordinate() {
					return this._rendererData.coordinate
				}
				_getAlwaysInViewPort() {
					return !0
				}
				_getText(e) {
					const t = this._model.timeScale().indexToUserTime(e);
					return null !== t ? this._model.dateTimeFormatter().format(t) : ""
				}
				_updateImpl() {
					const e = this._rendererData;
					if (e.visible = !1, this._model.timeScale().isEmpty() || !this._isVisible()) return;
					const t = this._getIndex();
					null !== t && (e.visible = !0, e.width = this._model.timeScale().width(), e.background = this._getBgColor(), e.color = (0, r.colorFromBackground)(e.background), e.coordinate = this._model.timeScale().indexToCoordinate(t), e.alwaysInViewPort = this._getAlwaysInViewPort(), e.text = this._getText(t), this._invalidated = !1)
				}
			}
		},
		281640: (e, t, i) => {
			var r;
			e = i.nmd(e), "undefined" != typeof window && (r = window.TVScript = window.TVScript || {}), (r = r || {}).Access = {}, r.Access.ACCESS_OPEN_NO_AUTH = "open_no_auth", r.Access.ACCESS_CLOSED_NO_AUTH = "closed_no_auth", r.Access.ACCESS_CLOSED_NEEDS_AUTH = "closed_needs_auth", r.Access.MAP_ID_TO_NAME = {
					1: r.Access.ACCESS_OPEN_NO_AUTH,
					2: r.Access.ACCESS_CLOSED_NO_AUTH,
					3: r.Access.ACCESS_CLOSED_NEEDS_AUTH
				}, r.Access.MAP_NAME_TO_ID = {}, Object.keys(r.Access.MAP_ID_TO_NAME).forEach((function(e) {
					r.Access.MAP_NAME_TO_ID[r.Access.MAP_ID_TO_NAME[e]] = e
				})), r.PinePrefix = {}, r.PinePrefix.USER = "USER;", r.PinePrefix.PUB = "PUB;", r.PinePrefix.STD = "STD;", r.PinePrefix.TV = "TV_", r.PinePrefix.EDGR = "EDGR_", r.PineType = {}, r.PineType.UserSaved = "PineType_UserSaved", r.PineType.UserPublished = "PineType_UserPublished", r.PineType.BuiltIn = "PineType_BuiltIn", r.PineType.Addon = "PineType_Addon", r.Type = r.Type || function() {}, r.Type.VOID = "void", r.Type.INTEGER = "integer", r.Type.FLOAT = "float", r.Type.STRING = "string", r.Type.BOOL = "bool", r.Type.COLOR = "color", r.Type.SERIES = "series", r.Type.PLOT = "plot", r.Type.HLINE = "hline", r.Type.BARCOLOR = "barcolor", r.Type.BGCOLOR = "bgcolor", r.Type.PLOTSHAPES = "plotshape", r.Type.PLOTCHARS = "plotchar", r.Type.PLOTARROWS = "plotarrow", r.Type.NA = "na", r.Type.ARRAY = "array", r.TranslatorDefaultVersion = 1, r.TranslatorReferenceVersioningIntroduced = 4, r.TranslatorLastVersion = 5,
				r.pineType = function(e) {
					return e.startsWith(r.PinePrefix.USER) ? r.PineType.UserSaved : e.startsWith(r.PinePrefix.PUB) ? r.PineType.UserPublished : e.startsWith(r.PinePrefix.STD) || e.startsWith(r.PinePrefix.TV) || e.startsWith(r.PinePrefix.EDGR) ? r.PineType.BuiltIn : r.PineType.Addon
				}, r.patchILTemplate = function(e, t, i) {
					var n = i || {};
					return r._patchTemplate(/<(in_\d+)>/g, e, t, n)
				}, r.decorateQuotes = function(e) {
					if (!e) return e;
					var t = /([^\\']+?)(')[^']*?/g,
						i = "$1\\$2",
						r = e;
					return "'" == r.charAt(0) && "'" == r.charAt(r.length - 1) ? "'" + (r = r.substr(1, r.length - 2)).replace(t, i) + "'" : r.replace(t, i)
				}, r.patchInputs = function(e, t) {
					var i = {};
					for (var r in e)
						if (e.hasOwnProperty(r)) {
							var n, s = e[r];
							n = s.isFake ? {
								v: t[s.id],
								f: !0,
								t: s.type
							} : t[s.id], i[s.id] = n
						} return i
				}, r._patchTemplate = function(e, t, i, n) {
					var s = n || {};
					return t.replace(e, (function(e, t) {
						for (var n = (t in s ? s[t] : i.defaults.inputs[t]), o = 0; o < i.inputs.length; ++o)
							if (i.inputs[o].id === t)
								if ("bool" === i.inputs[o].type) n = n ? "1.0" : "0.0";
								else if (["text", "symbol", "resolution", "session"].indexOf(i.inputs[o].type) >= 0) n = "'" + r.decorateQuotes(n) + "'";
						else if ("source" === i.inputs[o].type) {
							var l = n.split("$");
							l[0] = "'" + l[0] + "'", n = "source(" + l.join(",") + ")"
						}
						return n
					}))
				}, r.isStrategy = function(e) {
					return /^\s*strategy\s*\(/m.test(e)
				};
			var n = /^\s*\/\/\s*?@version\s*?=\s*?(\S*?)\s*?$/gm,
				s = /^[0-9]+$/;
			r.extractVersion = function(e) {
				n.lastIndex = 0;
				var t = n.exec(e);
				if (null === t) return 1;
				var i = t[1],
					o = s.test(i) ? Number(i) : NaN;
				return isNaN(o) ? 1 : Math.max(r.TranslatorDefaultVersion, Math.min(o, r.TranslatorLastVersion))
			}, r.canUpgradeVersion = function(e) {
				return e >= 3 && e < r.TranslatorLastVersion
			}, r.canDowngradeVersion = function(e) {
				return e >= 4 && e <= r.TranslatorLastVersion
			}, e && e.exports && (e.exports = r)
		},
		208214: (e, t, i) => {
			"use strict";

			function r(e, t, i, r) {
				return `${r?r+" ":""}${i?i+" ":""}${e}px ${t}`
			}
			i.d(t, {
				makeFont: () => r,
				parseFont: () => s
			});
			const n = /(bold )?(italic )?(\d+)(px|pt) (.*)$/;

			function s(e) {
				const t = n.exec(e);
				return null === t ? null : {
					family: t[5],
					size: parseInt(t[3]) * ("pt" === t[4] ? .75 : 1),
					bold: Boolean(t[1]),
					italic: Boolean(t[2])
				}
			}
		},
		844853: (e, t, i) => {
			"use strict";
			i.d(t, {
				showGoProAlertsOnSecondsDialog: () => n
			});
			var r = i(629588);

			function n() {
				(0, r.createGoProDialog)({
					feature: "alertsOnSeconds"
				})
			}
		},
		633156: (e, t, i) => {
			"use strict";
			i.d(t, {
				getTwemojiUrl: () => n
			});
			var r = i(818438);

			function n(e, t) {
				let i = "";
				return r.default.parse(e, (e => (i = r.default.base + ("svg" === t ? `svg/${e}.svg` : `72x72/${e}.png`), !1))), i
			}
		},
		520533: (e, t, i) => {
			"use strict";

			function r(e) {
				return "scriptTitle" in e && "modified" in e
			}

			function n(e) {
				return "userId" in e && "scriptAccess" in e
			}

			function s(e) {
				return "strategy" === e.kind
			}

			function o(e) {
				return "library" === e.kind
			}
			i.d(t, {
				isSavedPineInfo: () => r,
				isPubPineInfo: () => n,
				isScriptStrategy: () => s,
				isScriptLibrary: () => o
			})
		},
		919346: (e, t, i) => {
			"use strict";
			i.r(t), i.d(t, {
				StdTheme: () => l.StdTheme,
				getStdChartTheme: () => u,
				getStdThemeNames: () => c,
				getThemeNameIfStdTheme: () => p,
				isStdTheme: () => d,
				translateThemeName: () => h
			});
			var r = i(575932),
				n = i(724377);
			const s = JSON.parse('{"content":{"chartProperties":{"scalesProperties":{"textColor":"#131722","lineColor":"rgba(42, 46, 57, 0)","backgroundColor":"#ffffff"},"paneProperties":{"vertGridProperties":{"color":"rgba(42, 46, 57, 0.06)"},"horzGridProperties":{"color":"rgba(42, 46, 57, 0.06)"},"crossHairProperties":{"color":"#9598A1"},"background":"#ffffff","backgroundGradientStartColor":"#ffffff","backgroundGradientEndColor":"#ffffff","separatorColor":"#E0E3EB"}},"sessions":{"graphics":{"backgrounds":{"outOfSession":{"color":"#2962FF","transparency":92},"preMarket":{"color":"#FF9800","transparency":92},"postMarket":{"color":"#2962FF","transparency":92}},"vertlines":{"sessBreaks":{"color":"#4985e7","style":2,"width":1}}}},"mainSourceProperties":{"baseLineColor":"#B2B5BE","candleStyle":{"borderColor":"#378658","upColor":"#089981","wickColor":"#737375","wickUpColor":"#089981","wickDownColor":"#F23645","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645"},"haStyle":{"borderColor":"#378658","upColor":"#089981","wickColor":"#737375","wickUpColor":"#089981","wickDownColor":"#F23645","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645"},"barStyle":{"downColor":"#F23645","upColor":"#089981"},"pnfStyle":{"downColor":"#F23645","upColor":"#089981","upColorProjection":"#a9dcc3","downColorProjection":"#f5a6ae"},"baselineStyle":{"baselineColor":"#758696","topFillColor1":"rgba(8, 153, 129, 0.28)","topFillColor2":"rgba(8, 153, 129, 0.05)","bottomFillColor1":"rgba(242, 54, 69, 0.05)","bottomFillColor2":"rgba(242, 54, 69, 0.28)","topLineColor":"#089981","bottomLineColor":"#F23645"},"areaStyle":{"transparency":100,"color1":"rgba(41, 98, 255, 0.28)","color2":"#2962FF","linecolor":"#2962FF","linewidth":2,"linestyle":0},"hiloStyle":{"color":"#2962FF","borderColor":"#2962FF","labelColor":"#2962FF"},"columnStyle":{"upColor":"rgba(8, 153, 129, 0.5)","downColor":"rgba(242, 54, 69, 0.5)","priceSource":"close"},"renkoStyle":{"upColor":"#089981","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645","upColorProjection":"#a9dcc3","downColorProjection":"#f5a6ae","borderUpColorProjection":"#a9dcc3","borderDownColorProjection":"#f5a6ae","wickUpColor":"#089981","wickDownColor":"#F23645"},"lineStyle":{"color":"#2962FF","linewidth":2,"linestyle":0},"kagiStyle":{"downColor":"#F23645","upColor":"#089981","upColorProjection":"#a9dcc3","downColorProjection":"#f5a6ae"},"pbStyle":{"upColor":"#089981","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645","upColorProjection":"#a9dcc3","downColorProjection":"#f5a6ae","borderUpColorProjection":"#a9dcc3","borderDownColorProjection":"#f5a6ae"},"rangeStyle":{"upColor":"#089981","downColor":"#F23645","upColorProjection":"#a9dcc3","downColorProjection":"#f5a6ae"}}}}'),
				o = JSON.parse('{"content":{"chartProperties":{"scalesProperties":{"textColor":"#B2B5BE","lineColor":"rgba(240, 243, 250, 0)","backgroundColor":"#ffffff"},"paneProperties":{"vertGridProperties":{"color":"rgba(240, 243, 250, 0.06)"},"horzGridProperties":{"color":"rgba(240, 243, 250, 0.06)"},"crossHairProperties":{"color":"#9598A1"},"background":"#131722","backgroundGradientStartColor":"#181C27","backgroundGradientEndColor":"#131722","backgroundType":"gradient","separatorColor":"#2A2E39"}},"sessions":{"graphics":{"backgrounds":{"outOfSession":{"color":"#2962FF","transparency":92},"preMarket":{"color":"#FF9800","transparency":92},"postMarket":{"color":"#2962FF","transparency":92}},"vertlines":{"sessBreaks":{"color":"#4985e7","style":2,"width":1}}}},"mainSourceProperties":{"baseLineColor":"#5d606b","candleStyle":{"borderColor":"#378658","upColor":"#089981","wickColor":"#B5B5B8","wickUpColor":"#089981","wickDownColor":"#F23645","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645"},"haStyle":{"borderColor":"#378658","upColor":"#089981","wickColor":"#B5B5B8","wickUpColor":"#089981","wickDownColor":"#F23645","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645"},"barStyle":{"downColor":"#F23645","upColor":"#089981"},"pnfStyle":{"downColor":"#F23645","upColor":"#089981","upColorProjection":"#336854","downColorProjection":"#7f323f"},"baselineStyle":{"baselineColor":"#758696","topFillColor1":"rgba(8, 153, 129, 0.28)","topFillColor2":"rgba(8, 153, 129, 0.05)","bottomFillColor1":"rgba(242, 54, 69, 0.05)","bottomFillColor2":"rgba(242, 54, 69, 0.28)","topLineColor":"#089981","bottomLineColor":"#F23645"},"areaStyle":{"transparency":100,"color1":"rgba(41, 98, 255, 0.28)","color2":"#2962FF","linecolor":"#2962FF","linewidth":2,"linestyle":0},"hiloStyle":{"color":"#2962FF","borderColor":"#2962FF","labelColor":"#2962FF"},"columnStyle":{"upColor":"rgba(8, 153, 129, 0.5)","downColor":"rgba(242, 54, 69, 0.5)","priceSource":"close"},"renkoStyle":{"upColor":"#089981","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645","upColorProjection":"#336854","downColorProjection":"#7f323f","borderUpColorProjection":"#336854","borderDownColorProjection":"#7f323f","wickUpColor":"#089981","wickDownColor":"#F23645"},"lineStyle":{"color":"#2962FF","linewidth":2,"linestyle":0},"kagiStyle":{"downColor":"#F23645","upColor":"#089981","upColorProjection":"#336854","downColorProjection":"#7f323f"},"pbStyle":{"upColor":"#089981","downColor":"#F23645","borderUpColor":"#089981","borderDownColor":"#F23645","upColorProjection":"#336854","downColorProjection":"#7f323f","borderUpColorProjection":"#336854","borderDownColorProjection":"#7f323f"},"rangeStyle":{"upColor":"#089981","downColor":"#F23645","upColorProjection":"#336854","downColorProjection":"#7f323f"}}}}');
			var l = i(61499);

			function a() {
				return {
					[l.StdTheme.Light]: JSON.parse(JSON.stringify(s)),
					[l.StdTheme.Dark]: JSON.parse(JSON.stringify(o))
				}
			}

			function c() {
				return [l.StdTheme.Light, l.StdTheme.Dark]
			}

			function u(e) {
				return a()[e]
			}

			function h(e) {
				return {
					[l.StdTheme.Light]: r.t("Light", {
						context: "colorThemeName"
					}),
					[l.StdTheme.Dark]: r.t("Dark", {
						context: "colorThemeName"
					})
				} [e] || e
			}

			function d(e) {
				const t = a();
				return c().some((i => _(t[i], e)))
			}

			function p(e) {
				const t = a(),
					i = c();
				for (const r of i)
					if (_(t[r], e)) return r;
				return null
			}

			function _(e, t) {
				let i = e.content === t.content;
				return function(e = {}, t) {
					try {
						P(e, [], t)
					} catch (e) {
						return
					}
				}(e.content, ((e, r) => {
					const s = function(e, t = {}) {
						let i = t;
						for (let t = 0; t < e.length; t++) {
							if (!i || "object" != typeof i) return;
							i = i[e[t]]
						}
						if ("string" == typeof i || "number" == typeof i) return i;
						return
					}(e, t.content);
					return i = function(e, t) {
						if (e === t) return !0;
						if ("string" != typeof e || "string" != typeof t) return !1;
						try {
							return function(e, t) {
								return Math.hypot(e[3] * e[0] - t[3] * t[0], e[3] * e[1] - t[3] * t[1], e[3] * e[2] - t[3] * t[2], 255 * e[3] - 255 * t[3]) < 48
							}((0, n.parseRgba)(e), (0, n.parseRgba)(t))
						} catch (e) {}
						return !1
					}(r, s), !i
				})), i
			}

			function P(e, t, i) {
				for (const r in e)
					if (e.hasOwnProperty(r)) {
						const n = t.concat(r);
						if ("object" == typeof e[r]) P(e[r], n, i);
						else if (i(n, e[r])) throw new Error("exit")
					}
			}
		}
	}
]);